<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 3.9.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>Enchanter</title>


    <meta property="og:type" content="website">
<meta property="og:title" content="Enchanter">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Enchanter">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/images/og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Enchanter">
<meta name="twitter:image" content="http://yoursite.com/images/og_image.png">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="Enchanter" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">Home</a>
                
                <a class="navbar-item"
                href="/categories">Categories</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="Search" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main">
    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:07:44.407Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    20 minutes read (About 3031 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/加餐 | 我看Facebook发币（下）：深入浅出理解 Libra 币/">加餐 | 我看Facebook发币（下）：深入浅出理解 Libra 币</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。今天我们接着聊由 Facebook 推动的 Libra 币。</p>
<p>听到一个陌生概念后，人们往往习惯于把它和自己熟悉的东西做一个类比，方便和他人沟通的时候，用以表达自己的理解。</p>
<p>那么，和 Libra 最像的东西是什么呢？</p>
<h2 id="货币储备"><a href="#货币储备" class="headerlink" title="货币储备"></a>货币储备</h2><p>有人说，Libra 不就是腾讯的 Q 币么？但是，这种理解仅仅停留在非常表面的层次。两者共同之处，仅仅是因为两者都是一种虚拟币（甚至不能说它们都是数字货币，因为 Q 币是不能称之为数字货币的）。</p>
<p>首先，Q 币可以用货币购买，但是没法反向兑换现金。最关键的是，腾讯可以自由发行 Q 币，它说有多少就可以有多少，不需要被监管。所以如果 Q 币可以以稳定的价格兑换现金的话，相当于腾讯可以自由印钞票，这显然不会被政府所允许。</p>
<p>但是 Libra 并不是这样。Libra 可以自由兑换，另外 Facebook 也不能够自由发行 Libra 币。发行新的 Libra 币时，有两大核心约束。</p>
<p><strong>其一，发行新的 Libra 币需要保值的资产做为抵押，我们称之为 “Libra 储备”。</strong>什么样的资产可以作为 Libra 储备？被 Libra 协会认可的，稳定且信誉良好的中央银行发行的货币，或者政府货币证券。也就是说，Libra 币锚定的是它认可的“一篮子货币”，而不是某一种货币。</p>
<p><strong>其二，由 Libra 协会来发行或销毁 Libra 币。</strong>目前 Libra 协会执行这个动作完全是被动的。Libra 生态中，会有一些被授权的经销商，他们负责 Libra 币的买卖。</p>
<p>这些授权经销商会按照一定的汇率，以某种被 Libra 协会认可的货币，向 Libra 协会买入 Libra 币。这时，这些用于买入的货币就会成为 Libra 储备。</p>
<p>当然授权经销商也可能卖出 Libra 币，换成他所期望的某种货币。在这种情况下，被卖出的 Libra 币就会被销毁，相应地， Libra 储备就会减少。</p>
<p>所以你可以看到，Libra 并没有自己的货币政策，总共有多少 Libra 币完全是由市场的供需决定的。</p>
<p>关于货币储备更详细的内容，请参阅 “<a href="https://libra.org/zh-CN/about-currency-reserve/#the_reserve" target="_blank" rel="noopener">Libra 储备</a>”。</p>
<h2 id="稳定币"><a href="#稳定币" class="headerlink" title="稳定币"></a>稳定币</h2><p>既然 Libra 不像 Q 币，那么它像什么？比特币吗？</p>
<p>相比 Q 币来说，Libra 与比特币的确更有比较意义，毕竟它们都是一种数字货币。但是我们在 “<a href="https://time.geekbang.org/column/article/102283" target="_blank" rel="noopener">我看Facebook发币（上）：区块链、比特币与 Libra 币</a>”  中，也已经谈到过两者一些根本上的不同。</p>
<p>如果我们忽略所有的技术细节，单从货币角度来看，比特币和 Libra 最大的区别是价格的波动性。</p>
<p>通过上面我们对 “Libra 储备” 的介绍，我们很容易知道 Libra 是一种稳定币，它看起来更像是由一些保值资产抵押所形成的 “债券”。而在币圈，大家可能都经常会听到一个词，叫做 “炒币”。</p>
<p>如果我们细想一下这背后的逻辑，就会知道这个词其实挺神奇的。</p>
<p>货币的核心价值是什么？</p>
<p>货币的价值显然不是增值，而是流通。而流通用的货币，最重要的是价格稳定。而币圈则不同，这些各式各样存在的币，现在它们的核心价值变成了 “炒”，这就完全被扭曲了。</p>
<p>我这么说当然不是认为比特币不好。只不过如果我们真的对比特币好，就应该把关注点放在比特币流通价值的构建上；而不是“喜看币涨”，涨了就奔走相告。</p>
<h2 id="世界货币"><a href="#世界货币" class="headerlink" title="世界货币"></a>世界货币</h2><p>那么，究竟 Libra 最像什么呢？</p>
<p>我个人认为，虽然目前的实现机制有所不同，但是 Libra 最像的是欧元。欧元的出现，对欧盟国家之间的自由贸易往来发挥了巨大的贡献。</p>
<p>欧元和 Libra 的初衷是一样的，都是为了构建跨国的自由经济贸易体系。两者不同之处在于，当前 Libra 还没有央行，不能凭空去发行货币。</p>
<p>凡事都有两面，“世界货币” 同样是有缺陷的。欧债危机导致欧元贬值，这个教训大家还记忆犹新。它告诉我们，一个国家经济出现问题，如果它采用的是独立的主权货币，那么只是导致本国的货币贬值。</p>
<p>但是 “世界货币” 意味着大锅饭，它会传导到整个经济体，连带整个经济体的货币贬值。</p>
<p>那么 Libra 会出现自己的央行么？短期当然不会，当前最重要的是流通，是地盘的扩张。但是长远看只要 Libra 成功了，就一定会有。毕竟，没有 Libra 央行，就没有机会解决 “大锅饭” 的问题。</p>
<p>所以站在更长远的未来看，今天的 Libra 协会，有可能就会是未来的 “Libra 央行”。</p>
<h2 id="Libra-协会"><a href="#Libra-协会" class="headerlink" title="Libra 协会"></a>Libra 协会</h2><p>Libra 协会总部位于瑞士日内瓦，协会成员包括分布在不同地理区域的各种企业、非营利组织、多边组织和学术机构。初始协会成员共有28家（如下图），未来计划达到100家。</p>
<p><img src="https://static001.geekbang.org/resource/image/f6/36/f609ac75b5fbff59d1cdef49990c6736.png" alt></p>
<p>加入 Libra 协会，需要支付不低于 1000 万美元来购买 Libra 投资代币，注意，它并不能简单理解为 Libra 币，两者有很大不同，它有很多特殊的权益。</p>
<p><strong>其一，整个 “Libra 储备” 的处置权。</strong>比如， Libra 储备到底放在哪里会比较安全靠谱？这是由Libra 协会决定的。但是每个成员是不是都是一票？并不是，票数是由这个成员持有的 Libra 投资代币数量决定的。具体规则，我在下面会讨论。</p>
<p><strong>其二，整个 “Libra 储备” 的利息，会被用来支撑 Libra 协会的日常运转。</strong>比如工资和奖金激励，也会用于派发分红。分红会按照持有的 Libra 投资代币的多少来分配。</p>
<p><strong>其三，各类事务决策的投票权。</strong>权重按持有的 Libra 投资代币来计算，每 1000 万美元有 1 个投票权，但是为了防止投票权过于集中，任何成员的投票权不能超过总票数的 1%。</p>
<p>超出部分的投票权将由 Libra 协会的董事会重新分配，比如授予具有社会影响力的合作伙伴（称为 SIP）或研究机构，前提是：他们有能力并致力于验证节点的运作，从而参与治理，并且确实无法作出最低 1000 万美元的投资。</p>
<p><strong>其四，运行验证节点。</strong>这一点可以被看作义务，但也可以看作权益。义务角度来说，显然这事是需要 IT 成本的，如果连这都做不到，就会被剔除出去。从权益角度来说，那么多的交易数据都被你拿到了，这是多么有价值的数据。</p>
<p>关于 Libra 协会储备更详细的内容，请参阅 “<a href="https://libra.org/zh-CN/association-council-principles/#overview" target="_blank" rel="noopener">Libra 协会</a>”。</p>
<h2 id="发展目标"><a href="#发展目标" class="headerlink" title="发展目标"></a>发展目标</h2><p>当前 Libra 的验证节点是有限制的，是许可型的，也就是所谓的 “联盟链”。但是，未来它会向非许可型治理和共识节点运营转变，降低参与的准入门槛，并减少对创始人的依赖。</p>
<p>Libra 将逐步进行网络的开放，变成所谓的 “公链”。这时，新成员也能够通过投资 1000万美元来自动获得验证节点的运行许可，并持有 Libra 投资代币，从而分享网络权益（但是我估计投票权之类是没有的，只有投资收益）。这部分的详细政策，或许未来才会逐步明朗。</p>
<p>Libra 协会致力于尽可能减少协会的干预权。比如完全通过市场机制来调节 Libra 币的供需。所以除了说服更多人加入 Libra 协会，协会最重要的工作是确定 Libra 的技术演进路线。</p>
<p>但这一点真实情况下显然并不会那么理想。货币互联网和互联网不同的是，它管的毕竟是钱。一旦 Libra 网络发展壮大，一些货币相关的治理问题就会暴露出来。</p>
<h2 id="降维打击"><a href="#降维打击" class="headerlink" title="降维打击"></a>降维打击</h2><p>Libra 的影响面绝对超乎大部分人的想象。我们先看看一些具备技术背景的知名互联网公司 CEO 是怎么看的。具体参见下面的截图。</p>
<p><img src="https://static001.geekbang.org/resource/image/78/aa/78b46d87ae9809f58ebe40fab3056faa.png" alt><img src="https://static001.geekbang.org/resource/image/ce/f4/ce25963fa9847dab74240a63c2967bf4.png" alt></p>
<p>显然无论王兴还是王小川，都高度重视并反复评估 Libra 带来的影响和自己应该采取的行动。</p>
<p>Libra 带来的打击是全方位的，某种程度上来说甚至是极难抵御的降维打击。我们不妨从以下这些维度看。</p>
<ul>
<li>弱小国家的货币主权会不会就此被取代？</li>
<li>中国的汇率管控会不会失效？就算没有失效，会不会变成闭关锁国？</li>
<li>Libra 是否会成为美国取代美元的新货币霸权？</li>
<li>从企业与企业竞争的角度，这会不会成为 Facebook 对微信、支付宝的降维打击？</li>
</ul>
<p>想完影响面想对策。从对策的角度来说无非两种，一是对抗，一是谋求对等权力下的协作。当然，这两条路都不会太容易。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天，我们从分析 Libra 的运行机制重新去理解 Libra 币。这里面的关键是：理解 Libra 协会究竟如何工作的。</p>
<p>我们没有分析 Libra 的技术细节，比如它怎么改变区块链的底层实现机制，又为什么要引入 Move 语言。如王兴所说，评判 Libra 的实现技术好不好，就好比评价美元钞票的印刷技术精细不精细。这事本身是有价值的，但不那么关键。</p>
<p>为什么我会写这两篇文章？</p>
<p>站在未来看现在，Libra 币将会是极其重大的一个历史节点。我倾向于这样来描绘它的影响：</p>
<blockquote>
<p>计算机 =&gt; 互联网 =&gt; Libra 币</p>
</blockquote>
<p>货币有着巨大的网络效应，留给后来者的时间窗口极短。我想，我们都应该思考怎么去面对这件事情了。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:07:42.520Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    28 minutes read (About 4225 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/加餐 | 我看Facebook发币（上）：区块链、比特币与Libra币/">加餐 | 我看Facebook发币（上）：区块链、比特币与Libra币</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>Facebook（脸书）于6月18日发布了其加密数字货币项目白皮书。该数字货币被命名为 Libra（天秤座），象征着平衡与公正。</p>
<p>此前，BBC 报道说这个数字货币叫 GlobalCoin（全球币），但后来被纠正说这只是Facebook员工在内部对其的昵称。</p>
<p>不管是叫 Libra，还是 GlobalCoin，其实都透露出了Facebook的雄心壮志。</p>
<p>今天的Facebook 坐拥 27 亿的活跃用户，相当于全球1/3的人都在用 Facebook，这是一个比微信大得多的数字社群（微信月活为 11 亿，差不多全中国人民都在用微信）。</p>
<p><strong>我之所以叫它“数字社群”，而不叫“数字王国”，是因为用科学的态度来谈，“国家” 这样的称呼没法随便用，“国家”得符合国家需要具备的特征。</strong></p>
<p>国家有哪些特征？</p>
<p>武装是大家能够很快想得到的，国家得有自己的军队，但是数字世界毕竟是个虚拟世界，军队似乎没啥意义。</p>
<p>发行货币是国家另一个至关重要的权力。现在，拥有 27 亿人口的 Facebook 要发币，这意味着它离真正意义上的 “数字王国” 又靠近了一步，至关重要的一步。</p>
<p>整个世界将因此发生翻天覆地的变化。</p>
<p>今天我想借此机会，谈谈区块链和数字货币背后的社会需求动因、逻辑以及它们将产生的巨大影响。</p>
<p>我们的内容将会分为上下两部分，如下：</p>
<ul>
<li>我看 FB 发币（上）：区块链、比特币与 Libra 币；</li>
<li>我看 FB 发币（下）：深入浅出理解 Libra 币。</li>
</ul>
<h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>我们先从区块链谈起。</p>
<p>介绍区块链技术的文章已经有很多了，我们今天不谈技术实现的细节。简单说，<strong>它是一个分散式防篡改的数字账本。</strong></p>
<p>但是，区块链到底有什么用？它想解决什么样的问题？</p>
<p>有人说，区块链是为了“去中心化”。</p>
<p>那么“去中心化”是趋势么？<strong>互联网的趋势是“中心化”，而不是“去中心化”。</strong></p>
<p>效率为先。如果一个事情可以两个人干更好，那么最终的结果就是应该两个人去干，而不会是十个人去干，这是最朴素的经济学原理。</p>
<p>而微信和 Facebook 的成功，也证明了中心化是趋势。人们之所以向往着去中心化，是因为人天然对垄断有抗拒之心，被人生杀予夺的感觉怎么想都不太美妙。</p>
<p><strong>人们因为效率而中心化，因为垄断而去中心化</strong>。所以是一个中心还是几个中心，这是自然平衡的结果。</p>
<p>历史告诉我们，<strong>它选择的“去中心化</strong>”是开辟疆土。前有哥伦布发现新大陆，今有“钢铁侠”马斯克寻求火星殖民。这才是真正的“去中心化”，找到全新的盐碱地去开拓。</p>
<p>地球相比于整个宇宙，只不过是一粒尘埃。这样的“中心化”，又算得了什么呢？</p>
<p>当然也有人说，区块链是为了“去中介”。</p>
<p>那么“去中介化”是互联网的趋势么？互联网会减少尽可能多的中间环节，但是不会“去中介”。</p>
<p>每个人有他自己的专长。把自己不擅长的事情交给中介，这是特别自然的一件事情，我们为中介的专业性买单。</p>
<p>互联网让中介可以 24 小时为你服务，远程为你服务。这些都是以前没法完成的。这会导致什么呢？一些中介会茁壮成长，变成行业中的关键节点。它也有可能会顺带合并掉上下游的一些分工，让服务链条更短。</p>
<p>那么，区块链价值到底是什么？</p>
<p><strong>我认为，区块链本质上是一种“共识机制”，或者说“契约机制”。</strong>分散式防篡改的数字账本，保障的核心是事实的不可抵赖。这对双方形成共识是极大的效率提升。在大部分情况下，没有共识往往是因为争议的双方对事实的认定不同。</p>
<p><strong>从这个认知来看，一些鼓吹“区块链是下一个互联网基础设施”的人们可以洗洗睡了。</strong></p>
<p>区块链不会重造一个新互联网底层，但它最有可能重塑金融与供应链。</p>
<h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><p>比特币，数字货币的鼻祖，区块链技术的第一个杀手级应用。</p>
<p>为什么会出现比特币？它希望解决什么样的需求？</p>
<p><strong>其一，希望能够解决政府动不动就发币，让你手头货币凭空贬值的问题。</strong></p>
<p>这应该是比特币创始人中本聪的本意。所以比特币发币的机制是挖矿，谁挖到就算谁的。成本是购买计算机的成本和运行计算机挖矿所消耗的电费。</p>
<p>从这个角度看，比特币不能类比法币，它没有法币的发行者，国家信用作为背书。它更像是黄金，基于资源本身的稀缺性作为背书。</p>
<p><strong>其二，希望能够解决经济全球化带来的货币跨境流通问题。</strong></p>
<p>这是数字货币的价值投资者们的共同期望。</p>
<p>随着互联网技术在全球范围的不断普及，越来越多的生意被放到了网上。旧的商业文明可以一言以蔽之：一手交钱，一手交货。而建立在互联网之上的新商业文明，我们一手下单付款，一手收钱发货，足不出户，货物就通过便捷的物流服务送到了你手上。</p>
<p>但建立在互联网之上的新商业文明，遭遇了国家与国家之间的边界挑战。这体现在以下两点。</p>
<p><strong>其一，汇率。</strong>我们都知道，法币与法币的兑换是有损的。你把钱从 A 币换成 B 币，再把 B 币换回 A 币，钱就少了。</p>
<p><strong>其二，关税。</strong>一个商品从一个国家买到另一个国家，成本就变高了。刨除物流成本带来的影响因素外，最大的额外代价就是关税。</p>
<p>物流成本是可以解决的。贸易全球化带来的结果是生产全球化。</p>
<p>以前国与国之间的贸易，主要成分在成品贸易，这个成品的原料和加工的零件都来自于同一个国家，我生产出成品后销往世界各地。</p>
<p>但是现在国与国之间的贸易，主要成分在原料与零部件的交易。这意味着供应链已经越来越全球化，成品的生产很可能就在销售地，或者靠近销售地。</p>
<p>这样的好处，一方面当然是产品品质的需要，可以全球寻求优质供应商。另一方面可以极大程度地降低物流成本。原材料的运输相比成品来说，更易于利用规模化效应降低单位运输成本。</p>
<p>关税问题，也是可以国家之间协调解决的。超低关税，乃至最终零关税是历史发展的必然。</p>
<p>那么汇率问题呢？</p>
<p>这个问题不好解决。提供兑换货币服务的金融机构不可能是免费服务，他们自身的成本也在那里。只要有跨境交易，就有“用什么结算货币”的问题，随之而来的就有结汇的问题。</p>
<p>除非，有一种世界货币，它能够流通于各个国家，被各个国家的市场所接受。</p>
<p>解决汇率问题最好的办法当然是不用换汇。</p>
<p>比特币能够满足这个需求么？</p>
<p>不能。比特币有这样一些软肋，我列在了下面。</p>
<p><strong>其一，没法按需增发，价格波动大。</strong>货币发行量最理想的情况是按市场需求来。如果市场对货币的需求量暴增，但是又没法增加货币发行量来调节，必然会导致货币增值。</p>
<p>比特币就属于这种情况，它只能靠挖矿来增加，而没有其他手段。那么一旦人们对它的需求增加速度超过挖矿速度，就会出现价格暴涨。</p>
<p>投机性的行为可能会助长这一点。但是从更长远的维度看，比特币的价值与“市场需求量/比特币流通量”成正比。</p>
<p><strong>其二，性能低。</strong>比特币基于区块链技术，参与的节点众多。节点多对比特币是有极强的正面价值的，因为参与的节点越多，其被人把控的概率也就越低。</p>
<p>但是，节点越多，比特币交易的性能也就越低。那么现实中，比特币交易到底有多慢？平均每秒2-3笔交易。</p>
<p>这意味着，比特币完全无法满足支持世界货币所需的交易频次。</p>
<h2 id="Libra-币"><a href="#Libra-币" class="headerlink" title="Libra 币"></a>Libra 币</h2><p>虽然比特币并不满足需求，但数字化的世界货币一定会诞生，只不过是谁的问题，这是贸易全球化决定的。</p>
<p>Libra 币就是冲着成为世界货币去的。在 Facebook 最近发布的《加密货币项目 Libra 白皮书》中提到：</p>
<blockquote>
<p>我们的世界真正需要一套可靠的数字货币和金融基础设施，两者结合起来必须能兑现“货币互联网”的承诺。</p>
</blockquote>
<p>可见，Libra 币其实不属于 Facebook，只不过是由Facebook 发起的。就像互联网一样，它期望的是一种开放式的架构。</p>
<p>“互联网”连接了世界上的所有人，但是国与国之间边界导致的“汇率”和“关税”问题，让贸易无法做到真正意义的全球化。</p>
<p>Libra 币旨在构建“货币互联网”，让贸易真正无国界，它如何做到？我们将在《我看 FB 发币（下）：深入浅出理解 Libra 币》这篇文章中进行详细的介绍。</p>
<p>今天我们重点聊的是 Libra 币将带来什么。</p>
<p><strong>第一个问题：Libra 币会不会成功？</strong></p>
<p>我认为它会成功。唯一阻碍它成功的因素是美国政府。毕竟它给世界上任何一个国家的人们都带来了一个巨大的变化：</p>
<ul>
<li>除了本国的法币，还有一个货币能够用于人们之间的日常交易。</li>
</ul>
<p>虽然此前已经有比特币也能够做到这一点，但是比特币的低吞吐能力决定了它必然无法成为世界货币。</p>
<p>Libra 币最直接挑战的是美元的地位。某种意义上来说，在它之前，美元在承担着世界货币的作用。</p>
<p>但是我认为美国政府会支持 Libra 币。有两个重要的理由支持他们这样做。</p>
<p><strong>其一，世界货币一定会产生。</strong>与其让它发生在其他国家，不如发生在美国，由美国人来主导这件事情的发生。</p>
<p><strong>其二，美元的物理属性，决定了美元对交易的渗透在非美元区（法币不是美元的地区）只能在线下，无法支持线上交易。</strong></p>
<p>但线上交易的比重越来越大，意味着美国需要一个数字货币能够渗透到其他国家。Libra 币刚好满足了这个需求，所以，Libra 币很容易与美元达成结盟。</p>
<p>一旦美国支持 Libra 币，这件事情就成功了一半。欧洲本来就有欧元，相当于已经有一个自己小范围的世界货币了，货币发行本来就已经和国家政权解绑了。改用 Libra 币带来的冲击并不大。</p>
<p>搞定了欧美，Libra 币基本上就算成功了。其他地区的国家很难真正去反抗这一潮流。</p>
<p>为什么？</p>
<p>不拥抱 Libra 币，意味着放弃由“互联网+Libra币”共同构建的世界自由贸易体系。这对任何一个国家来说，都意味着闭关锁国，放弃经济增长。</p>
<p>另外搞一个世界货币与之对抗？</p>
<p>难。货币有很强的网络效应。如果一个国家或地区已经被 Libra 币渗透，另一个货币进来就难了。</p>
<p>所以如果非要干，最佳的时机是现在。</p>
<p>假设，另一个世界货币干起来了，全球被分成了两半，一东一西。</p>
<p>它们之间没有贸易么？贸易用哪个世界币？这带来了新的汇率问题。</p>
<p>如果可以让企业自由选择，那么这会是大鱼吃小鱼的故事。因此，第二个世界货币很难真正干起来。</p>
<p><strong>第二个问题：如果 Libra 币成功的话，它会带来什么影响？</strong></p>
<p>最大的变化，是货币的大一统。就像欧洲已经发生的那样，国家政权和货币脱钩，政府再也无法用货币杠杆来宏观调控市场。</p>
<p>第二个大变化，是交易的透明化。链上的支撑节点都可以看到全球所有的交易往来。虽然 Libra 币是匿名的身份，但是开通 Libra 账户过程在很多国家很可能是实名的。所以某种意义上来说，交易还是会和现实身份对应起来。</p>
<p><strong>第三个问题：中国应该怎么应对？</strong></p>
<p>这个问题，有点像是中国该不该加入世贸组织（WTO）一样。我的答案是：应该认认真真考虑下如何加入，什么时候加入，加入前应该做好哪些准备。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总结一下我对 Facebook 发币这件事情的看法。</p>
<ul>
<li>世界货币一定会诞生，只不过是谁的问题。这是贸易全球化决定的。</li>
<li>以前大家看好比特币，但是比特币有软肋。其一是波动大，其二是性能低。</li>
<li>Libra 币不属于 Facebook，只不过是由 Facebook 发起而已。它就像互联网一样，是开放式的架构。这也是其他巨头一拍即合，毫不犹豫地去支持的原因。</li>
<li>Libra 币会得到美国政府的支持，并逐步渗透到世界各个地区。它不只是流行于 Facebook 的 27 亿活跃用户，也会流行于其他如 PayPal、Booking 等主流服务。</li>
<li>“互联网 + Libra 币” 将共同构建全新的世界自由贸易体系。</li>
</ul>
<p>站在未来看现在，Libra 币将会是极其重大的一个历史节点。我倾向于这样来描绘它的影响：</p>
<blockquote>
<p>计算机 =&gt; 互联网 =&gt; Libra 币</p>
</blockquote>
<p>货币有着巨大的网络效应，留给后来者的时间窗口极短。我想，我们都应该思考怎么面对这件事情了。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:07:40.615Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    21 minutes read (About 3219 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/19 | 基础平台篇：回顾与总结/">19 | 基础平台篇：回顾与总结</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>到今天为止，我们第一章 “基础平台篇” 就要结束了。今天，让我们对整章的内容做一个回顾与总结。</p>
<h2 id="抽象信息世界的骨架"><a href="#抽象信息世界的骨架" class="headerlink" title="抽象信息世界的骨架"></a>抽象信息世界的骨架</h2><p>基础平台篇主要涉及的内容如下。</p>
<p><img src="https://static001.geekbang.org/resource/image/68/e6/68f2c948ff8c329ceb8b5fe76e34eee6.png" alt></p>
<p>这些内容如果展开来讲，每一系统（或模块）都会是很厚的一本书。我们的目的，当然不是为了取代这里每一个领域知识相关的专业书籍。</p>
<p>我们的核心目标是以架构为导向，抽象出系统的骨架，融会贯通，把这些领域知识串起来，拼出完整的信息世界的版图。</p>
<p>抽象出系统骨架的过程时信息必然是有损的，怎么才能做到忽略掉众多的实现细节，把系统以简洁易于理解的方式呈现出来？</p>
<p>这很大程度取决于你对系统的理解程度和抽象能力。如果我们把系统想象成一个人，大部分情况下我们比较容易对其进行详尽而具体的描述，好比下图。</p>
<p><img src="https://static001.geekbang.org/resource/image/7d/57/7d0bf49d1cc2a1bc20964d694b67b257.png" alt></p>
<p>这相对容易。因为你只需要陈述你看到的事实，而不必拷问背后的原因。但实际上为了在最短的时间里让别人理解你的想法，你也许应该这样来描述它，见下图。</p>
<p><img src="https://static001.geekbang.org/resource/image/d4/b3/d4557d1a21a2a017ce317ab8e6d465b3.png" alt></p>
<p>当你不是在描述这个系统本身，而是描述它与其他系统的相互关系时，你可能需要进一步简化它，变成如下图这样。</p>
<p><img src="https://static001.geekbang.org/resource/image/11/bc/111cbf1adcb5effdb836979c7e44a3bc.png" alt></p>
<p><strong>抽象有助于记忆，因为骨架需要逻辑的自洽。</strong></p>
<p>这种抽象能力之所以重要，是因为它是融会贯通、疏通整个信息世界的知识脉络的关键。当你做到对世界的认知可宏观、可微观，自然一切皆在掌握。</p>
<p>比如，本章我们首先介绍的是冯·诺依曼体系结构，我们把它抽象为“<strong>中央处理器（CPU）+ 存储 + 一系列的输入输出设备</strong>”，并给出了系统的示意图如下。</p>
<p><img src="https://static001.geekbang.org/resource/image/28/a9/28ef9c0241c5c34abb85148453379fa9.png" alt></p>
<p>这个图相当笼统，并没有涉及中央处理器（CPU）指令设计的真正细节。比如，我们没有介绍栈（stack）这个概念，虽然它实际上也非常关键。</p>
<p>为什么需要引入栈？它在中央处理器中起到了什么样的作用？</p>
<p>要了解这个问题，你就需要深入到中央处理器的架构设计中去。如果你对梳理中央处理器的架构设计感兴趣，可以尝试写一篇介绍它的文字。</p>
<p>做这样的事情会对你非常的锻炼。<strong>“你自己理解一个事物”和“把你的理解表述成文，去引导其他人也能够理解它”</strong>，是完全不同难度的事情。</p>
<p>如果你对中央处理器的设计细节感兴趣，可以进一步查阅相关的参考资料。也欢迎与我分享你的心得体会。</p>
<h2 id="基础平台篇的内容回顾"><a href="#基础平台篇的内容回顾" class="headerlink" title="基础平台篇的内容回顾"></a>基础平台篇的内容回顾</h2><p>这一章前面我们讲了些什么？为了让大家对第一章内容有个宏观的了解，我画了一幅图，如下。</p>
<p><img src="https://static001.geekbang.org/resource/image/2c/32/2c8357bd303f229ac98b67bec6e31932.png" alt></p>
<p><strong>首先，我们介绍了冯·诺依曼体系结构。</strong>从需求演进角度看，虽然我们信息科技发展日新月异，但是底层设计并没有发生过变化，非常稳定。从这一点来说，我们不能不佩服他们的远见。</p>
<p><strong>随后，我们介绍了编程语言的演进。</strong>从汇编语言的诞生，出现了程序员这个新职业开始，此后编程语言的演进便进入高速发展期。</p>
<p>然而，尽管语言很多，但是编程范式的演进却并不剧烈。大家熟知的过程式、函数式、面向对象基本上能够把几乎所有的语言都囊括其中。Go 语言独树一帜地宣称自己是面向连接的语言，<strong>我们着重对比了面向对象与面向连接思想上的差异。</strong></p>
<p>编程语言本身与业务架构的设计关联性不大，虽然模块规格的描述会借助语言的文法。<strong>但是语言长期演进所沉淀下来的社区资源，是我们架构设计所依赖的重要基础。</strong>充分利用好这些资源可以大大降低系统的研发成本。</p>
<p><strong>最后，我们开始聊操作系统。</strong>从 UNIX =&gt; DOS =&gt; Windows/Mac/Linux =&gt; iOS/Android，从用户交互、进程管理、安全管理等角度看，操作系统的需求演变非常剧烈。</p>
<p>传统操作系统主要包含五个子系统：设备管理（包括存储设备、输入/输出设备、网络设备）、进程管理和安全管理。</p>
<p>输入/输出设备主要和交互有关，我们概要描述，基本上一笔带过。我会在后面 “桌面软件开发” 这一章再详加讨论。而服务端的交互比较简单，命令行基本上就满足需求，所以 “服务端开发” 一章我们不会再特意去展开。</p>
<p><strong>另外，操作系统的商业模式也发生了剧烈的变化。</strong></p>
<p>早期操作系统的营收模式以软件销售收入为主。但是从苹果的 iOS 开始，操作系统都无一例外地增加了以下三个模块：</p>
<ul>
<li>账号（Account）；</li>
<li>支付（Pay）；</li>
<li>应用市场（AppStore）。</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/d6/b7/d608db3b28f247ccb2886cc4e8cd99b7.jpg" alt></p>
<p>注意，这里我们说的账号是指互联网账号。传统操作系统虽然也有账号概念，但是，它是本地账号，属于多用户权限隔离所需。</p>
<p>而互联网账号的价值完全不同，它是支付和应用商店的基础。没有账号，就没有支付系统，也没有办法判断用户是否在应用市场上购买过软件。</p>
<p>实现了“<strong>帐号-支付-应用市场</strong>”这样的商业闭环，意味着操作系统的商业模式，从软件销售转向了收税模式。这类操作系统，我们称之为现代操作系统。所有现代操作系统，所凭借的都是自己拥有巨大的流量红利。</p>
<h2 id="基础平台篇的参考资料"><a href="#基础平台篇的参考资料" class="headerlink" title="基础平台篇的参考资料"></a>基础平台篇的参考资料</h2><p>概要回顾了我们 “基础平台篇” 的内容后，我们这里补充一下有助于理解我们内容的相关资料，如下。</p>
<p><img src="https://static001.geekbang.org/resource/image/b2/22/b26278cc56017617fac8572b88224b22.png" alt></p>
<p>有了本专栏梳理的骨架，相信对你学习和理解以上这些材料会一定的指引意义。</p>
<p>如果你有什么推荐的优秀参考资料，也欢迎在留言区分享，我补充到这个表格中来，我们一起来完善它。</p>
<h2 id="架构之美在于悟"><a href="#架构之美在于悟" class="headerlink" title="架构之美在于悟"></a>架构之美在于悟</h2><p>信息世界是无中生有创造出来的，我们不需要去记忆，而是要找到创造背后的骨架和逻辑。</p>
<p><strong>架构即创造。</strong></p>
<p>学架构在于匠心和悟心。它靠的是悟，不是记忆。<strong>用思考的方式去记忆，而不是用记忆的方式去思考。</strong></p>
<p>我们日常所依赖的基础平台，随处可见的架构之美，<strong>看到了，悟到了，就学到了。</strong>如果你只能从你自己写业务代码中感受架构之道，那么你可能就要多留些心思了。</p>
<p>比如，如果你日常用的是 Go 语言，那么你可以做一个作业：“谈谈 Go 语言之美”。你从Go语言的设计中感悟到了什么样的架构思维？当然如果你不常接触 Go 语言，可以给自己换一个题目，比如 “Java 语言之美”。</p>
<p><strong>作为架构师，如何构建需求分析能力，尤其是需求的预判能力？</strong></p>
<p><strong>首先，归纳总结能力很重要。</strong>分析现象背后的原因，并对未来可能性进行推测。判断错了并不要紧，分析一下你的推测哪些地方漏判了，哪些重要信息没有考虑到。</p>
<p><strong>另外，批判精神也同样至关重要。</strong>批判不是无中生有的批评，而是切实找到技术中存在的效率瓶颈和心智负担。尤其在你看经典书籍的时候，要善于找出现状与书的历史背景差异，总结技术演进的螺旋上升之路，培养科学的批判方法论。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天我们对本章内容做了概要的回顾，并借此对整个基础平台的骨架进行了一次梳理。</p>
<p>我们最为依赖，也最为强调的，是抽象能力。它对于构建信息世界的骨架至关重要。为此我们需要不断改造自己的抽象体系。例如，前面 “<a href="https://time.geekbang.org/column/article/91007" target="_blank" rel="noopener">02 | 大厦基石：无生有，有生万物</a>” 这一讲中提到过：</p>
<blockquote>
<p>引入了输入输出设备的电脑，不再只能做狭义上的“计算”（也就是数学意义上的计算），如果我们把交互能力也看做一种计算能力的话，电脑理论上能够解决的“计算”问题变得无所不包。</p>
</blockquote>
<p>有同学留言问：输入/输出设备提供的明明是一种 IO 能力，怎么能够算得上是“计算”？</p>
<p>但是实际上，我们人类其实就是在这种“否定自己，不断延展自己的抽象体系”，补全自己的想象力。我们以数学中最为基础的 “数” 为例子。数的演化大概经历了：</p>
<blockquote>
<p>自然数 =&gt; 整数 =&gt; 有理数 =&gt; 实数 =&gt; 复数</p>
</blockquote>
<p><strong>输入/输出能力算不算是“计算”？我们不妨以广义的“计算”角度来看。</strong></p>
<p>输入（Input），无非是采集物理世界的信息，将其数字化，所以一个输入设备其实可以看作是一个模数转换的“算子”。只不过这个算子非 CPU 的指令可以表达。</p>
<p>输出（Output），无非是将数字内容反作用于物理世界，一个输出设备其实可以看作是一个数模转换的“算子”。同样，这个算子非 CPU 的指令可以表达。</p>
<p>计算机 CPU 自身只能做数数转换，输入是比特信息，输出还是比特信息。结合了输入/输出设备提供的数模和模数转换的 “算子”，连接了数字世界和物理世界的计算机，在数学上也就完备了。</p>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。本章到此结束，我们将开始第二章：桌面开发的宏观视角。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>
<h3 id="限时放送"><a href="#限时放送" class="headerlink" title="限时放送"></a>限时放送</h3><p>推荐阅读专栏《Go语言核心36讲》正在拼团中，限时特惠79元，点击<a href="https://time.geekbang.org/column/intro/112" target="_blank" rel="noopener">链接</a>订阅专栏。</p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:07:38.688Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    33 minutes read (About 4927 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/18 | 架构：需求分析 (下) · 实战案例/">18 | 架构：需求分析 (下) · 实战案例</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>今天，我们继续上一讲关于架构第一步 “需求分析” 的讨论。为了能够获得更加具体的观感，我们选了两个实战的案例，如下：</p>
<ul>
<li>打造 “互联网”；</li>
<li>存储新兵 “对象存储”。</li>
</ul>
<h2 id="案例-打造-“互联网”"><a href="#案例-打造-“互联网”" class="headerlink" title="案例: 打造 “互联网”"></a>案例: 打造 “互联网”</h2><p>从对信息科技的影响面来说，最为标志性的两个事件，一个是计算机的诞生，另一个是互联网的诞生。</p>
<p>我们前面在 “<a href="https://time.geekbang.org/column/article/93130" target="_blank" rel="noopener">05 | 思考题解读: 如何实现可自我迭代的计算机？</a>”这一讲中，已经剖析过一个 MVP 版本的计算机是什么样的。</p>
<p>今天，我们就以 “互联网” 这个产品为题，看看应该怎么去做需求分析。</p>
<p>我们想象一下，把我们自己置身于互联网诞生之前。互联网并不是第一张网。在此之前的信息世界中，更多的是某个企业专用的局域网。不同的企业会选择不同公司所提供的网络方案。这些网络方案缺乏统一的规划，彼此并不兼容。</p>
<p>那么，怎么才能打造一个连接人与人、企业与企业，甚至是物与物，能够 “连接一切” 的 “互联网”？</p>
<p>首先，从根源需求来说，我们期望这不是某个巨头公司的网，也不是政府的网。这是需求的原点，这一点上的不同，产生的结果可能就很不一样。</p>
<p>如果我们忽略这一点，就有可能会把它做成微信网（WechatNet），或者中国网（ChinaNet）。它们可能会是一张巨大的网，但都不是 “互联网”。</p>
<p><strong>所谓 “互联网” 首先应该是一张开放的网。它应该可以让很多国家很多公司参与其中，形成合力。它不应该存在 “造物主”，一个可以在这张网络中主宰一切的人。</strong></p>
<p>开放，最基础的层次来说，意味着需要定义网络协议标准，尤其是跨网的数据交换标准。这里的跨网，指的是跨不同的网络设备，不同的网络运营商。</p>
<p>开放，从另一个角度来说，是对应用程序软件的开放。想要 “互联网” 真正能够连接一切，只是把物理的网络连接在一起是不够的，还要有能够丰富的 “连接一切” 的应用。</p>
<p>为了能够让更多应用可以更便捷地连接网络，我们需要提供方便应用接入的高层协议。这个协议需要屏蔽掉网络连接的复杂性（丢包重传等）。</p>
<p>但这还不够。“互联网” 这样的基础设施，启动阶段没有应用去吸引用户是不行的。所以我们需要 “吃自己的狗粮”，开发若干互联网应用的典型代表。</p>
<p>有一些需求可能非常非常重要，但是我们需要阶段性放弃，例如安全。加密传输并没有作为互联网的内建特性，这极大降低了互联网的实施难度。</p>
<p>从另一个角度考虑，为什么不把安全放在最底层，也要考虑方案的可持续性。一个安全方案是否能够长期有效，这非常存疑。</p>
<p>但是物理网络一旦存在，就很难做出改变（想想我们从 IPv4 过渡到 IPv6 需要多少年吧）。所以从这个角度来说，我们也不希望安全是一个网络的底层设施。</p>
<p>这并不意味着安全问题可以不解决，只是把这事儿留给了软件层，留给操作系统和应用程序。这是一个极其明智的选择。相比物理网络而言，软件层更加能够经受得起变更。</p>
<p><strong>总结来说，要想把 “互联网” 这个项目做成，需要考虑这样一些事情。</strong></p>
<ul>
<li>一个能够连接所有既有网络的协议标准，我们不妨叫它互联网协议（Internet Protocol），简称 IP 协议。</li>
<li>一张连接城市的骨干网络，至少有两个城市互联的试点。</li>
<li>打通骨干网络和主流企业专用网络的路由器。</li>
<li>一套方便应用开发的高阶网络协议，工作在 IP 协议之上。</li>
<li>一份支撑互联网应用程序的基础网络协议栈源代码或包（package），方便主流操作系统厂商、网络设备厂商集成。</li>
<li>若干典型互联网应用，如电子邮件（Email）、万维网（WWW）等。</li>
<li>一份安全传输的网络协议方案（远期），及其源代码或包（package）。</li>
</ul>
<p>让我们先来看下物理网络的构建。</p>
<p>首先，构建骨干网络。不同城市可以由若干个骨干网路由器相连。骨干路由器可以看做是由一个负责路由算法的计算机，和若干网络端口构成，如下图所示。</p>
<p><img src="https://static001.geekbang.org/resource/image/41/bb/41355201ff809e671b599ddd7a43aabb.png" alt></p>
<p>每个端口可能和其他城市相连，也可能和该城市内的某些大型局域网相连。一个局域网和城际网络从抽象视角看，没有非常本质的不同，只不过是采用的网络技术有异，使用的网络协议有异。</p>
<p>一个局域网可以简化理解为由若干台交换机连接所有的计算机设备。而交换机同样也可以看做是由一个负责路由算法的计算机，和若干网络端口构成，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/1f/d0/1f778f97797e6b94f806fb6a3daaedd0.png" alt></p>
<p>剩下的问题是怎么对接骨干网络和局域网。这需要有人负责进行网络协议转换，它就是路由器。一台路由器上有两类端口，一类端口为本地端口，连接局域网内的设备，比如交换机，或者直接连普通的计算机。另一类端口为远程端口，负责接入互联网。</p>
<p><img src="https://static001.geekbang.org/resource/image/53/b2/53211a8ff21d73d403a3b4dbd97cd5b2.png" alt></p>
<p>理清楚了物理网络后，我们再来看应用构建。我们打算打造两个杀手级应用（Killer Application）：电子邮件（Email）和万维网（WWW）。</p>
<p>在考虑应用的用户交互体验时，我们发现，物理网络能够处理的 IP 地址，和人类方便记忆的地址非常不同，故而我们决定引入域名（domain）作为人与人交流用途的地址。为此，我们引入了 DNS 地址簿协议，用于将域名解析为物理网络可理解的 IP 地址。</p>
<p>综上分析，最终我们得到 MVP 版本的 Internet 项目的各子系统如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/6c/4c/6c7bac541039e535deb6679c8c2b684c.png" alt></p>
<h2 id="案例-存储新兵-“对象存储”"><a href="#案例-存储新兵-“对象存储”" class="headerlink" title="案例: 存储新兵 “对象存储”"></a>案例: 存储新兵 “对象存储”</h2><p>对象存储是非常新兴的一种存储系统。是什么样的需求满足方式的变化，导致人们要创造一种新的存储呢？</p>
<p>对象存储是伴随互联网的兴起，尤其是移动互联网的兴起而产生的。</p>
<p><strong>首先，互联网应用兴起，软件不再是单机软件，用户在使用应用软件的过程中产生的数据，并不是跟随设备，而是跟随账号。</strong>这样，用户可以随心所欲地切换设备，不必考虑数据要在设备间倒来倒去的问题。</p>
<p>数据跟随账号，这是互联网应用的第一大特征，区别于单机软件的关键所在。</p>
<p><strong>其次，用户交互方式的变化。</strong>用户不再打字用纯文本沟通，而是用照片、视频、语音等多媒体内容来表达自己的想法。</p>
<p>移动化加剧了这一趋势，在手机上打字是非常痛苦的事情。拍拍照、拍拍视频、说说话（语音输入）更加符合人的天性，尤其是手机用户覆盖面越来越宽，大部分用户属于没有经过专业培训的普通用户，这些手段是最低准入门槛的交互方式。</p>
<p><strong>最后，用户体验诉求的提升。</strong>计算机显示器早年是黑白的，后来有了256色，有了真彩色（TrueColor）；显示器的屏幕分辨率，也从320x240，到640x480，到今天我们再也不关心具体分辨率是多大。随之发生变化的，是一张照片从100K，到几兆，到几十兆。</p>
<p>这些趋势，对存储系统带来的挑战是什么？</p>
<p><strong>其一，规模。</strong>那么多用户的数据，一台机器显然放不下了，要很多很多台机器一起来保存。</p>
<p><strong>其二，可靠。</strong>用户单机对存储的要求并不高，机器硬盘出问题了，不会想着找操作系统厂商或者软件应用厂商去投诉。但是，用户数据在服务端，数据丢了那就是软件厂商的责任，要投诉。</p>
<p><strong>其三，成本。</strong>从软件厂商来说，那么多的用户数据，怎么做才能让成本更低一些。</p>
<p><strong>其四，并发吞吐能力。</strong>大量的用户同时操作，有读有写，怎么保证系统是高效的。</p>
<p>另外，从存储系统的操作接口来说，我们分为关系型存储（数据库，结构化数据）和文件型存储（非结构化数据）。我们今天的关注点在文件型存储上。</p>
<p>对于文件型存储来说，相关的备选解决方案有很多，我们简单罗列如下。</p>
<p><img src="https://static001.geekbang.org/resource/image/08/11/085ecbe7df53531f8af9cf7fec20de11.png" alt><br><strong>第一类是大家最熟悉的、最古老的存储系统：本地文件系统。</strong>虽然有很多种具体的实现方案，但是它们的使用接口大同小异，实现方案也只是在有限的几种选择中平衡。我们在 “<a href="https://time.geekbang.org/column/article/94991" target="_blank" rel="noopener">09 | 外存管理与文件系统</a>” 这一讲中已经有过详细的介绍，这里不提。</p>
<p><strong>第二类是网络文件系统</strong>，可以统称为 NAS，如上面的 NFS、FTP、Samba（CIFS）、WebDAV，都只是 NAS 存储不同的访问接口。</p>
<p><strong>第三类是数据库</strong>，它通常用于存储结构化数据，比较少作为文件型存储。但也有人在这么做，如果单个文件太大，会切成多个块放到多行。</p>
<p><strong>第四类是 SAN</strong>，它是块存储。块存储和关系型存储、文件型存储都不同，它模拟的是硬盘，是非常底层的存储接口。很少会有应用直接基于块存储，更多的是 mount 到虚拟机或物理机上，然后供应用软件需要的存储系统使用。</p>
<p><strong>第五类是分布式文件系统 GFS/HDFS</strong>。GFS 最早是为搜索引擎网页库的存储而设计，通常单个文件比较大，非常适合用于日志类数据的存储。这也是为什么 Hadoop最后从大数据领域跑出来，原因就是因为大数据处理的就是日志。</p>
<p>你可以看到，除了数据库和 SAN，我们不用细分析就知道它们不是文件型存储的最佳选择，其他几类包括本地文件系统、NAS、GFS/HDFS 有一个共同特征，就是它们的使用接口都是文件系统（FileSystem）。</p>
<p>那么，我们就来看下文件系统（FileSystem）对于大规模的文件型存储来说有什么问题。</p>
<p>最大的问题，是文件系统是一棵树（Tree）。除了对单个文件的操作只需要锁住该文件外，所有对树节点的修改操作，比如把 A 节点移到 B 处，都是一次事务操作，需要锁住整棵树。</p>
<p>这对规模和并发吞吐能力都是伤害。从规模来说，分布式事务是很难的（这也是为什么分布式数据库很难做的原因），做出来性能也往往好不到哪里去。从并发吞吐能力来说，如果系统存在大锁，即在锁里面执行费时的操作，就会大幅降低系统的并发吞吐能力。</p>
<p>传统的 NAS 出现比较早，所以它没有考虑“大规模条件下存储会有什么样的挑战”是非常正常的。</p>
<p>GFS/HDFS 为什么没有考虑大规模问题？这是 Google 设计 GFS 的背景导致的，网页库存储，或者日志型存储的共同特征是单个文件很大，可以到几个 G 级别，这样的话文件系统的元数据就会减少到单台机器就可以存储的级别。</p>
<p>所以对象存储出现了。它打破了文件型存储访问接口一定是文件系统（FileSystem）的惯例。它用的是键值存储（Key-Value Storage）。</p>
<p>从使用接口来说，首先选择文件所在的桶（Bucket），它类似于数据库的表（Table），只是一个逻辑划分的手段；然后选择文件的键（Key），就可以存取文件了。</p>
<p>这意味着文件之间并不存在关联（树型结构是文件之间的一种关联），可以通过某种算法将文件元信息分散到不同的机器上。</p>
<p>那么为什么文件型存储，不必考虑文件之间的关联？因为关系都在数据库里面，文件型存储只需要负责文件内容的存储，有个键（Key）能够找到文件内容即可。</p>
<p>从本质上来说，这是因为服务端和桌面软件面临的用户场景是完全不同的。文件系统是在桌面软件下的产物，桌面系统是单用户使用的，没有那么高的并发访问需求。</p>
<p>服务端一上来就面临着并发访问的问题，所以很早就出现了数据库这样的存储中间件。数据库的出现，其实已经证明文件系统并不适合服务端。只不过因为文件型存储在早期的服务端开发的比重并不大，所以没有被重视。</p>
<p>但是，互联网的发展极大地加速了文件型存储的发展。互联网增加的 90% 以上的数据，都是非结构化数据，包括图片、音频、视频、日志。</p>
<p>对象存储能够支撑的文件数量规模上非常非常大。比如七牛云存储，我们已经支持万亿级别的文件。</p>
<p>这在传统 NAS 这种基于文件系统访问接口的存储是难以想象的，我们看到的 NAS 存储 POC 测试要求基本上都是要能够支持 1-2 亿级别的文件存储规模。</p>
<p>另外，对象存储的高速发展，很大程度上会逐步侵蚀 Hadoop 生态的市场。因为 HDFS 这种日志型存储，其实只是对象存储里面的一个特例。在人们习惯了对象存储后，他们并不希望需要学习太多的存储系统；所以大数据的整个生态会逐步过渡到以对象存储为基石。</p>
<p>这已经发生了。这两年你可能也能够听到，Hadoop 生态的公司活得挺不好的，几家公司合并了也没有解决掉没落的问题。这和大数据生态向对象存储迁徙是分不开的，只不过这方面我们国内还处在相对比较落后的阶段。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>通过对打造“互联网”和存储新兵“对象存储”这两个案例的分析，我们可以看出不同市场差异还是很大的。“互联网” 这个产品它并不是替换某种既有的方案，而是把既有的方案连接在一起。所以 “互联网” 的历史包袱很少，基本上不太需要考虑历史问题。</p>
<p>“对象存储” 产品则不同。在对象存储之前，存储已经经历了很长时间的发展。只不过因为文件型的数据爆发式的增长，带来了存储系统的新挑战，从而给对象存储这样的新技术一个市场机会。</p>
<p>当然，另外一个原因是云服务的诞生，让存储有了新的交付形态。我们不再需要拿着硬件往用户家里搬，这就出现了一个新的空白市场。</p>
<p>但是解决了空白市场的需求后，对象存储还是要面临 “既有市场中用户采用的老存储方案怎么搬迁” 的问题。所以存储网关这样的产品就出现了。存储网关做什么？简单说，就是把对象存储包装成 NAS，提供 NFS、FTP、Samba（CIFS）、WebDAV 这些访问接口给用户使用。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>需求分析相关的讨论就到此结束了。不同市场差异非常大，并不存在大一统的产品定义和市场策略，需要具体问题具体分析。</p>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲将是我们第一章的回顾与总结。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:07:36.705Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    30 minutes read (About 4552 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/17 | 架构：需求分析 (上)/">17 | 架构：需求分析 (上)</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>前面我们多次提到过，架构的第一步是需求分析。那么，为什么要做需求分析？如何做好需求分析？</p>
<p>今天让我们一起聊一聊需求分析这个话题。</p>
<h2 id="关于需求分析的那些事"><a href="#关于需求分析的那些事" class="headerlink" title="关于需求分析的那些事"></a>关于需求分析的那些事</h2><p>为何要做需求分析？</p>
<p><strong>首先</strong>，当然是因为我们做软件本身就是为了满足用户需求。那么，用户需求到底为何，我们需要清楚定义。</p>
<p><strong>其次</strong>，需求边界定义的需要。用户需求理清楚了，不代表产品理清楚了。用户需求的满足一定会有行业分工，我们做什么，合作伙伴做什么，需要厘清大家的边界。</p>
<p><strong>最后</strong>，架构设计的需要。架构需要切分子系统，需要我们梳理并对用户需求进行归纳与抽象。架构还需要防止过度设计，把简单的事情复杂化。</p>
<p>但什么是过度设计？不会发生的事情你考虑了并且为它做足了准备，就是过度设计。所以判断是不是过度设计是很困难的，需要对需求未来演化有很强的判断力。</p>
<p>从这几个维度来看，需求分析过程必然会涉及以下这些内容。</p>
<ul>
<li>我们要面向的核心用户人群是谁？</li>
<li>用户原始需求是什么？最核心问题是哪几个？</li>
<li>已经有哪些玩家在里面？上下游有哪些类型的公司，在我们之前，用户是怎么解决他们的问题的？我们的替换方案又是怎样的？</li>
<li>进而，我们的产品创造的价值点是什么？用户最关注的核心指标是什么？</li>
<li>用户需求潜在的变化在哪些地方？区分出需求的变化点和稳定点。</li>
</ul>
<p>当然，我并不是说，我们应该在需求分析的文档中完整地回答这些问题。需求分析文档目的并不是回答这些问题。但是在我们梳理需求的过程中，我们无法回避对这些问题的思考。</p>
<p>可能有人会认为，这些问题是 CEO 或产品经理这样的角色需要回答的，而不是架构师需要回答的。</p>
<p>某种意义上来说这句话没错。回答这些问题的首要责任方是 CEO 或产品经理。他们有责任让团队中的每一个人理解我们的产品逻辑。</p>
<p>但是，如果架构师只是被动地接受产品需求，以按图索骥的方式来做架构设计，是不足以成为顶级架构师的。原因在于两点。</p>
<p><strong>一方面，用户需求的深层理解是很难传递的。</strong>你看到的产品文档，是产品经理和用户沟通交流后的二次理解，是需求的提炼和二次加工，很难原汁原味地传递用户的述求。</p>
<p>所以架构师自己亲身近距离地接触用户，和用户沟通，去体会用户的述求是非常有必要的。</p>
<p>况且，大部分人并不会那么仔仔细细地阅读别人写的文档。当然这不完全是看文档的人单方面的原因，如果团队文档平均质量不高的话，也会影响到阅读者的心态。</p>
<p><strong>另一方面，产品设计过程需要架构师的深度参与，而不是单向的信息传递。</strong>产品经理非常需要来自架构师的建设性意见。</p>
<p>为什么我会有这样的看法呢？这涉及我对产品的理解。产品本身是运用先进的技术来满足用户需求过程的产物。</p>
<p>用户需求的变化是缓慢的，真正改变的是需求的满足方式。而需求满足方式的变化，深层次来说，其背后往往由技术迭代所驱动。</p>
<p>从这个角度来说，<strong>产品是桥，它一端连接了用户需求，一端连接了先进的技术。</strong>产品经理是需要有技术高度的，他不一定要深刻了解技术的原理，但是一定要深刻理解新技术的边界。</p>
<p>某项技术能够做什么，不能做到什么，顶级产品经理甚至比实现这项技术的开发人员还要清楚。</p>
<p>认为产品经理不需要理解技术，这可能是我们普遍存在的社会现象，但很可能并不符合这个岗位的内在诉求。</p>
<p><strong>回到架构师这个角色。</strong></p>
<p>我经常说一个观点，<strong>产品经理和架构师其实是一体两面。两者都需要关心用户需求与产品定义。</strong></p>
<p>只不过产品经理更多从用户需求出发，而架构师更多从技术实现出发，两者是在产品这座桥的两端相向而行，最终必然殊途同归。</p>
<p>这也是我为什么说架构师需要深度参与产品设计的原因。产品经理很可能会缺乏他应该有的技术广度，这就需要架构师去补位。产品定义过程需要反复推敲琢磨，并最终成型。</p>
<p>需求分析并不是纯技术的东西，和编程这件事情无关。它关乎的是用户需求的梳理、产品的清晰定义、可能的演变方向。</p>
<p>需求分析的重要性怎么形容都不过分。准确的需求分析是做出良好架构设计的基础。</p>
<p>前面我也说过，我个人认为架构师在整个架构设计的过程中，至少应该花费三分之一的精力在需求分析上。</p>
<p>这也是为什么很多非常优秀的架构师换到一个新领域后，一上来并不能保证一定能够设计出良好的架构，而是往往需要经过几次迭代才趋于稳定。</p>
<p>原因就在于：领域的需求理解是需要一个过程的，对客户需求的理解不可能一蹴而就。</p>
<h2 id="怎么做需求分析"><a href="#怎么做需求分析" class="headerlink" title="怎么做需求分析"></a>怎么做需求分析</h2><p>那么怎么才能做好需求分析？</p>
<p><strong>首先，心态第一，心里得装着用户。</strong>除了需要 “在心里对需求反复推敲” 的严谨态度外，对用户反馈的尊重之心也至关重要。</p>
<p><strong>其次，对问题刨根究底，找到根源需求。</strong>有很多用户反馈需求的时候，往往已经带着他自己给出的解决方案。</p>
<p>这种需求反馈已经属于二次加工的需求，而非原始需求。这个时候我们要多问多推敲，把它还原到不带任何技术实现假设的根源需求。</p>
<p><img src="https://static001.geekbang.org/resource/image/c9/0f/c9895fc36b9493576ae3a1bce763f60f.png" alt></p>
<p>如上图所示，根源需求可能会有非常非常多的技术方案可以满足它。我们上面示意图中的小圆点是一个个用户反馈的需求。在用户提这些需求的时候，往往可能会带着他熟悉的技术方案的烙印。</p>
<p>对于那些我们明显不关心的需求，如上图的小红点，相对容易排除在外。毕竟产品的边界意识大家还是会有的，产品不可能无限制膨胀下去。</p>
<p>但是对于上面的小绿点，决策上就比较难了。不做？可能会丢了这个客户。做？如果我们手放宽一点，最后产品需求就会被放大（如上图中蓝色的圆圈），做出一个四不像的产品。</p>
<p><strong>最后，在理清楚需求后，要对需求进行归纳整理。</strong>一方面，将需求分别归类到不同的子类别中。另一方面，形成需求的变化点和稳定点的基本判断。</p>
<p>前面我们也强调过：在需求分析时，要区分需求的变化点和稳定点。稳定点往往是系统的核心能力，而变化点则需要对应地去考虑扩展性上的设计。</p>
<p>要注意的是，在讨论需求的变化点和稳定点的时候，我们需要有明确参考的坐标系。在不同视角下，稳定点和变化点的判断是完全不同的。</p>
<p>所以<strong>需要明确的一点是，当我们说需求的变化点和稳定点时，这是站在我们要设计的产品角度来说的。</strong></p>
<p>比如我们要设计一台计算机，那么多样化的外部设备是一个变化点。但是如果我们今天是在设计一台显示器，问题域就完全变了，需求的变化点和稳定点也就完全发生了变化。</p>
<p>本质上来说，对变化点的梳理，是一次产品边界的确立过程。所谓的开放性设计，就是说我把这个功能交给了合作伙伴，但是我得考虑怎么和合作伙伴配合的问题。</p>
<p>开放性设计并不是一个纯粹的用户需求问题，它通常涉及技术方案的探讨。因此，产品边界的确立不是一个纯需求，也不是一个纯技术，而是两者合而为一的过程。</p>
<p>对变化点的梳理至关重要。产品功能必须是收敛的，必须是可完成的。</p>
<p>如果某个子类别的需求呈现出发散而无法收敛的趋势，这个事情，团队一定要坐下来一起去反复推敲。不断拷问，不断明确响应需求的正确姿势到底为何。</p>
<h2 id="产品定义"><a href="#产品定义" class="headerlink" title="产品定义"></a>产品定义</h2><p>需求分析的目标和最终结果，都是要最终形成清晰的产品定义。产品定义并不是简单的产品需求的归类。</p>
<p><img src="https://static001.geekbang.org/resource/image/6f/14/6fdb28f9c90127d772e65e8388bd8214.png" alt></p>
<p>上面我也说过，产品是桥，它一端连接了用户需求，一端连接了先进的技术。所以产品定义不可能做到和技术方案完全没关系。</p>
<p><strong>首先，需要明确产品中有哪些元素，或者叫资源，以及这些资源的各类操作方式。</strong>如果我们从技术的视角来理解，这就是定义对象和方法。当然这仅仅是这么理解，实际上一个我们技术上的对象方法，从产品需求角度会有多条路径的操作方式来达到相同的目的。</p>
<p><strong>其次，需要对产品如何满足用户需求进行确认。</strong>用户的使用场景未必全部是我们的产品所能直接满足的，面向特定的行业，有可能需要相应的行业解决方案，把我们的产品整合进去。<br><img src="https://static001.geekbang.org/resource/image/75/52/75e4c17d083da8459468ada25d593752.jpg" alt></p>
<p>我们要避免把行业方案视作产品的一部分。更多的情况下，需要我们更加开放的心态来看待这件事情，优先寻找合作伙伴来一起完成这类行业的需求覆盖。</p>
<p><strong>最后，产品定义还需要考虑市场策略，我们的产品如何进入市场，和既有市场格局中的其他主流解决方案的关系是什么样的。</strong></p>
<p><img src="https://static001.geekbang.org/resource/image/4c/61/4c23a1f778f1d78ce379702cc8df0161.png" alt></p>
<p>我们希望获取的用户，可能大部分都已经有一个既有的产品和技术方案，在满足他的需求。在考虑如何让客户从既有方案迁移到我们的产品后，我们确定产品的边界时又会复杂很多。</p>
<p>在一些极其关键的市场，我们有可能会把迁移需求视作产品需求的一部分。但更多的情况下，我们产品上只为这些市场上的主流方案提供迁移路径，而不是完整的迁移方案。</p>
<h2 id="为何架构课从基础平台开始？"><a href="#为何架构课从基础平台开始？" class="headerlink" title="为何架构课从基础平台开始？"></a>为何架构课从基础平台开始？</h2><p>很抱歉我说得很抽象，但是总结需求分析的方法论的确是一件很难的事情。</p>
<p><strong>为什么我们谈架构会从 “基础平台” 讲起？为什么从硬件架构，到编程语言，再到操作系统，我们似乎绕了一大圈，还没有谈到架构？</strong></p>
<p>有两个原因。</p>
<p><strong>最直接的原因是 “基础平台” 是我们所依赖的环境，是我们应用的业务架构的一部分。越了解我们所处的环境，我们就越能够运用自如。</strong></p>
<p><strong>但还有一个重要的原因是架构的探讨容易过度抽象。</strong>所以我并没有先长篇大论谈架构方法论，谈需求应该怎么怎么去分析，而是围绕着基础平台的演进过程来谈需求分析。</p>
<p>信息世界的构建过程，本身就是一个最宏大的架构实践。我们通过对信息世界的骨架构成的参悟，自然能够感悟到架构思维的要点。</p>
<p>学内功需要悟心，学架构也需要悟心。怎么准确研判需求，对需求演进进行预测，这并不是靠技术技能，而是靠谦和求取的心态。</p>
<p>所以我们第一章 “基础平台”  篇整体来说，内容介绍以产品的需求分析为主、核心技术原理为辅。我们尝试把整个基础平台融为一个整体，宏观上不留任何疑惑。</p>
<p>实际上这一章的内容很难做到只看一遍就可以，可能要时时看，反复看。还需要查阅一些资料，也可以与人一起探讨。当然，我们也欢迎留言一起交流。</p>
<p>这一章我们介绍的内容，大部分内容都有一些对应的经典书籍，在后面 “基础平台篇: 回顾与总结” 一讲中，我也会给大家推荐一些经典的图书。</p>
<p>但我们并不是要重复这些书籍中的内容。<strong>我们的关注点在于：一是构建信息世界的宏观骨架，二是需求演进。</strong></p>
<p>经典书籍虽然好，但是它们写作时候的历史背景和今天有很大不同。从架构视角来说，结合我们今天的现实情况来看，一方面我们可以总结今天区别于当初的所有变化，另一方面主动去思考为什么发生了这样的变化。以这样的视角去读经典书籍，会别有一番滋味。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在我们介绍完第一章 “基础平台” 篇的所有内容后，今天我们终于正式开始谈架构思维。我们探讨的是架构的第一步：需求分析。</p>
<p>需求分析并不是纯技术的东西，和编程这件事情无关。它关乎的是用户需求的梳理、产品的清晰定义、可能的演变方向。</p>
<p><strong>怎么提升需求分析能力，尤其是预判能力？</strong></p>
<p><strong>首先</strong>，心态第一，心里得装着用户。除了需要 “在心里对需求反复推敲” 的严谨态度外，对用户反馈的尊重之心也至关重要。</p>
<p><strong>其次</strong>，对问题刨根究底，找到根源需求。</p>
<p><strong>最后</strong>，对需求进行归纳整理。一方面，将需求分别归类到不同的子类别中。另一方面，形成需求的变化点和稳定点的基本判断。</p>
<p>需求分析的目标和最终结果，都是要最终形成清晰的产品定义。产品定义将明确产品的元素，明确产品的边界，与产业上下游、合作伙伴的分工。</p>
<p>为什么我们的架构课从日常最平常之处，我们日日接触的基础平台讲起？</p>
<p>你真了解它们吗？你真感悟到它们的不凡之处了吗？</p>
<p>学习架构，关键在于匠心与悟心。</p>
<p><strong>用思考的方式去记忆，而不是用记忆的方式去思考。</strong></p>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲将是 “架构: 需求分析（下）· 实战案例”。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:07:34.692Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    38 minutes read (About 5669 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/16 | 安全管理：数字世界的守护/">16 | 安全管理：数字世界的守护</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。今天我们要聊的话题是操作系统的最后一个子系统：安全管理。</p>
<p>数字世界是高效的，但数字世界也是脆弱的。在越来越多的日常生活被数字化的今天，安全问题也越来越凸显出了它的重要性。</p>
<p>有经验的安全工程师都知道，做好安全的基本逻辑是：不要开太多的门和窗，最好所有人都在同一道门进出，安全检查工作就可以非常便利地进行。</p>
<p>要想构建一个安全可靠的环境，从最底层就开始设计显然是最好的。所以安全管理是一个基础架构问题。现代操作系统必然会越来越关注安全性相关的问题。因为一旦安全问题严重到触及人们的心里防线，整个数字世界都有可能随之崩塌。</p>
<p>让我们从头回顾一下操作系统安全能力的演进。</p>
<h2 id="病毒与木马"><a href="#病毒与木马" class="headerlink" title="病毒与木马"></a>病毒与木马</h2><p>首先是实模式的操作系统，以微软的 DOS 系统为代表。实模式的操作系统进程都运行在物理地址空间下。</p>
<p>这意味着，每个软件进程都可以访问到其它软件进程（包括操作系统）的内存数据，也可以随意地修改它。所以这个时期的计算机是非常脆弱的，它选择的是信任模式：我相信你不会搞破坏。</p>
<p>不过，好在这个时期网络还并不发达，所以一个单机版本的恶意软件，能够干的真正恶意的事情也很有限。这一时期恶意软件以计算机病毒为主，其特征主要是繁衍自己（复制自己），对计算机系统本身做某种程度的破坏。</p>
<p>现代操作系统基本上都是保护模式的操作系统。保护模式就是让软件运行的内存地址空间隔离，进程之间相互不能访问（除非基于共享内存技术，那也是进程自己主动选择，与被动无感知的情况下被人窥视不同）。</p>
<p>这从安全角度来说，是很重要的进步。不管怎么说，内存数据是最为敏感的，因为它无所不包。况且，从 Windows 开始，互联网逐步进入人们的视野。计算机的联网，一下子让安全问题变得严峻起来。</p>
<p>恶意软件目的开始变得不单纯。它不再只是黑客的技术炫耀，而是切切实实的黑色产业链的关键依赖。</p>
<p>这一时期恶意软件开始以木马为主。木马和病毒一样会去繁衍自己（复制自己），但是它较少以破坏计算机的运行为目的，相反它默默隐藏起来，窃取着你的隐私。然后，它再通过互联网把窃取的信息默默地传递出去（比如通过电子邮件）。</p>
<p><strong>哪些信息是木马感兴趣的？有很多。比如以下这些信息：</strong></p>
<ul>
<li>键盘按键；</li>
<li>剪贴板的内容；</li>
<li>内存数据；</li>
<li>文件系统中关键文件的内容；</li>
<li>……</li>
</ul>
<p>你可能奇怪，前面不是说保护模式已经把内存数据隔离了么，为什么木马还是能够取到内存数据？</p>
<p>其实这一点不难想明白，虽然跨进程已经无法取得数据了，但是木马本来就是靠复制自己，把自己伪装成正常软件的一部分。这样，木马程序和正常的软件代码同属于一个进程内，所有信息对其仍然一览无余。</p>
<p>为了彻底阻止木马程序篡改正常的应用程序，聪明的操作系统创造者们想到了好方法：数字签名。</p>
<p>这本质上是白名单技术。所有正常发布的软件都到操作系统厂商那里登记一下。这样，一旦木马去修改软件，把自己附加上去，这个软件的签名验证就通不过，也就直接暴露了。</p>
<p>其实 Windows 操作系统已经引入了数字签名的概念，可以用以鉴别软件的可信度。但是考虑到从开放转向封闭有极大的历史负担，所以无论是 Windows 还是 Mac，都没有完全杜绝无签名的软件，最多当你运行无数字签名的软件时，会给个不可信的警告。</p>
<p><strong>第一个大规模把软件发布变成一个封闭环境的是苹果的 iOS 操作系统。</strong>苹果通过引入 App Store，要求所有应用发布都必须通过 App Store 进行。今天无论是 Android 还是 iOS 操作系统都基于应用市场这样的封闭软件发布的形态。</p>
<p>这样一来，软件无法被非法修改，木马基本上就无所遁形了。当然，这并不代表木马在这些平台上就消失了。虽然不容易，但是通过感染开发人员的软件开发环境，还是可以在软件编译或其它环节中把木马注入到要发布的软件中。</p>
<p>要发现这种异常，iOS 和 Android 系统的厂商对软件进行数字签名前，往往会对其进行安全扫描，以发现各种潜在的安全风险。一旦某个软件被鉴定为恶意软件，就无法通过数字签名，也无法发布到应用市场上。</p>
<p>通过这些机制，木马很难再有机会得到传播。</p>
<h2 id="软件的信息安全"><a href="#软件的信息安全" class="headerlink" title="软件的信息安全"></a>软件的信息安全</h2><p>但是，这意味着我们没有安全风险了么？当然不是。在移动设备上，安全问题的大环境发生了巨大的变化。</p>
<p>首先，移动时代随着我们数字世界对现实生活影响的加深，我们越来越多的敏感信息更加容易被软件触及。有很多新增的敏感信息是PC时代所不具备的，例如：</p>
<ul>
<li>通讯录和通话记录；</li>
<li>短信；</li>
<li>个人照片和视频；</li>
<li>个人地理位置（GPS）信息；</li>
<li>移动支付的支付密码、支付验证码；</li>
<li>录像和录音权限；</li>
<li>通话权限；</li>
<li>.……</li>
</ul>
<p>正因为如此，尽管操作系统正变得越来越安全，但我们面临的安全威胁却也在日趋严重。</p>
<p><strong>其实， iOS 操作系统在安全管理上的考虑不可谓不周全。</strong></p>
<p><strong>首先</strong>，在软件隔离机制上，除了基于 CPU 的保护模式，确保软件之间的内存隔离外，iOS 还引入了沙盒系统（Sandbox），确保软件之间文件系统隔离，相互之间不能访问对方保存在磁盘上的文件。</p>
<p><strong>其次</strong>，通过上面我们已经提及的数字签名机制，防止了软件被恶意篡改，让病毒和木马无法传播繁衍。</p>
<p><strong>最后</strong>，对涉及敏感信息的系统权限进行管控。各类敏感信息的授予均是在应用程序使用的过程中进行提示，提醒用户注意潜在的安全风险。</p>
<p>在这一点上，Android 操作系统往往则是在安装软件时索要权限。这两者看似只是时机不同，但是从安全管理角度来说， iOS 强很多。</p>
<p>还没有见到软件真身就让用户判断要不要给权限，用户往往只能无脑选择接受。而如果是在软件运行到特定场景时再索要权限，那么权限给不给就有合理的场景支持决策。</p>
<p>但是，在利益面前，软件厂商们是很难抵御住诱惑的。所以不仅仅是恶意软件会去过度索要系统权限，很多我们耳熟能详的常规软件也会索要运行该软件所不需要的权限。</p>
<p>移动时代，恶意软件的形态已经再一次发生变化。它既不是病毒也不是木马，而是“具备实用功能，但背地却通过获取用户的敏感信息来获利”的应用软件。</p>
<p>它通过诱导用户下载，然后在软件安装或者使用时索要敏感信息的获取权限。</p>
<p><strong>一个软件到底是正常的还是恶意的？边界已经越来越模糊了。</strong></p>
<p>以前病毒和木马都有复制和繁衍自己，这样一个显著的特征，但如今病毒和木马的复制繁衍能力已经被操作系统的安全机制所阻止，所以恶意软件和普通软件一样，都是通过某种手段吸引用户下载安装。</p>
<p>怎么保护好用户的隐私信息？道高一尺，魔高一丈。攻防之间的斗争仍将继续下去。</p>
<h2 id="网络环境的信息安全"><a href="#网络环境的信息安全" class="headerlink" title="网络环境的信息安全"></a>网络环境的信息安全</h2><p>如果我们不轻易尝试不可信的软件，就可以一切安全无虞？并不然，我们还要考虑我们的计算机所处的网络环境安全问题。</p>
<p>我们上网过程需要经过一系列的中间节点，有交换机，有路由器。我们的上网产生的所有数据包，都经由这些中间节点，<strong>这意味着我们有以下三个级别的安全风险。</strong></p>
<ul>
<li>被窃听的风险。可能会有人在这些节点上监听你访问和提交的内容。</li>
<li>被篡改的风险。可能会有人在这些节点上截获并修改你访问的内容。</li>
<li>被钓鱼的风险。可能会有人冒充你要访问的服务提供方和你通讯。</li>
</ul>
<p>虽然大部分的中间节点由网络运营商提供，我们刨除这些节点被黑客所黑的情形，基本上认为可信。但这并不绝对，至少在中国，运营商修改中转的数据包这样的事情是干得出来的，常见的手法有：</p>
<ul>
<li>在正常的 HTML 页面插入广告；</li>
<li>修改用户下载的 apk 文件，替换成自己想分发的 apk 文件；</li>
<li>修改 404 类型的 HTML 页面，替换成自己的搜索引擎的搜索页；</li>
<li>.……</li>
</ul>
<p>其次是 WiFi 路由器。WiFi 路由器因为其提供方鱼龙混杂，天生是安全问题的大户。运营商能够干的事情它全都可以干，甚至可以更加肆无忌惮，以李鬼替换李逵，钓鱼的风险并不低。</p>
<p>比如你以为登录的是交通银行官网，它可能给你一个一模一样外观的网站，但是一旦你输入用户名和密码就会被它偷偷记录下来。</p>
<p>怎么解决中间人问题？</p>
<p>首先是怎么防篡改。应用场景是电子合同/公章、网络请求授权（例如你要用七牛的云服务，需要确认这个请求的确是你，而不是别人发出的）等。这类场景的特征是不在乎内容是否有人看到，在乎的是内容是不是真的是某个人写的。</p>
<p>解决方法是数字签名技术。一般来说，一个受数字签名保护的文档可示意如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/c1/3f/c191e43d0959abf907754286ed926f3f.png" alt></p>
<blockquote>
<p>其中，“要防篡改的内容” 是信息原文。“密钥提示” 是在数字签名的 “密钥” 有多个的情况下，通过 “密钥提示” 找到对应的 “密钥”。如果用于保护信息的 “密钥” 只有一个，那么可以没有 “密钥提示”。“指纹” 则是对信息使用特定 “密钥” 和信息摘要算法生成的信息摘要。</p>
</blockquote>
<p>大部分情况下，数字签名的信息摘要算法会选择 HMAC MD5 或者 HMAC SHA1。在 Go 语言中，使用上示意如下：</p>
<pre><code>import &quot;crypto/hmac&quot;
import &quot;crypto/sha1&quot;
import &quot;encoding/base64&quot;

textToProtected := &quot;要防篡改的内容&quot;
keyHint := &quot;123&quot;
key := findKey(keyHint) // 根据 keyHint 查找到 key []byte

h := hmac.New(sha1.New, key) // 这里用sha1，也可以改成别的
h.Write([]byte(textToProtected))
textDigest := base64.URLEncoding.EncodeToString(h.Sum(nil))
textResult := textToProtected + &quot;:&quot; + keyHint + &quot;:&quot; + textDigest</code></pre><p>得到的 textResult 就是我们期望的不可篡改信息。验证信息是否被篡改和以上这个过程相反。</p>
<p>首先根据 textResult 分解得到 textToProtected、keyHint、textDigest，然后根据 keyHint 查找到 key；再根据 textToProtected 和 key 算一次我们期望的信息摘要 textDigestExp。</p>
<p>如果 textDigestExp 和 textDigest 相同，表示没被篡改，否则则表示信息不可信，应丢弃。</p>
<p>如果我们希望更彻底的隐私保护，避免被窃听、被篡改、被钓鱼，那么数字签名就不顶用了，而需要对内容进行加密。</p>
<p>加密算法上，一般分为对称加密和非对称加密。对称加密是指用什么样的密钥（key）加密，就用什么样的密钥解密，这比较符合大家惯常的思维。</p>
<p>非对称加密非常有趣。它有一对钥匙，分私钥（private key）和公钥（public key）。私钥自己拿着，永远不要给别人知道。公钥顾名思义是可以公开的，任何人都允许拿。</p>
<p>那么公私钥怎么配合？首先，通过公钥加密的文本，只有私钥才能解得开。这就解决了定向发送的问题。网络中间人看到加密后的信息是没有用的，因为没有私钥解不开。</p>
<p>另外，私钥拥有人可以用私钥对信息进行数字签名（防止篡改），所有有公钥的人都可以验证签名，以确认信息的确来自私钥的拥有者，这就解决了请求来源验证的问题。</p>
<p>那么 A、B 两个人怎么才能进行安全通讯呢？首先A、B两人都要有自己的公私钥，并把公钥发给对方。这样 A 就有 A-private-key、B-public-key，B 就有 B-private-key、A-public-key。通讯过程如下所示。</p>
<ul>
<li>A 向 B 发信息 R。具体来说，A 首先用 A-private-key 对 R 进行签名，得到（R，R-digest）；然后用 B-public-key 对（R，R-digest）加密，得到 encoded（R，R-digest）；然后把最终的加密信息发出去。</li>
<li>B 收到 encoded（R，R-digest），用 B-private-key 解密得到（R，R-digest），然后再用 A-public-key 验证信息的确来自 A。</li>
<li>B 理解了 R 后，回复信息给 A。这时两人的角色互换，其他同上。</li>
</ul>
<p>非对称加密机制非常有效地解决了在不可信的网络环境下的安全通讯问题。但是它也有一个缺点，那就是慢。相比之下，它的速度比对称加密慢很多。</p>
<p>所以，一个改善思路是结合两者。非对称加密仅用于传输关键信息，比如对称加密所需的密码。完整的通讯过程如下所示。</p>
<ul>
<li>A 生成一个临时用的随机密码 random-key。</li>
<li>A 向 B 发送 random-key，机制用的就是上面的非对称加密，基于 B-public-key。</li>
<li>B 收到 A 发送的 random-key，把它记录下来，并回复 A 成功。回复的信息可以基于 random-key 做对称加密。</li>
<li>此后，A 向 B 发、B 向 A 发信息，都用 random-key 作对称加密，直到本次会话结束。</li>
</ul>
<p>你可能发现，整个过程中 A 自己已经不再需要非对称的公私钥对了。只要 A 事先有 B 的公钥（B-public-key）就可以。</p>
<p>当然，上面我们的讨论，没有涉及 B 如何把自己的 B-public-key 交给对方的。在假设网络不可信的前提下，这似乎是个难题。</p>
<p>我觉得有两个可能性。一个是 A 和 B 很熟悉，平常都经常一起玩。那么他们交换 public-key 完全可以不依赖任何现代通讯设备，包括电话和互联网，而是写在一张纸上，某天聚会的时候交换给对方。</p>
<p>另一个是更为常见的互联网世界场景：我要访问一个网站。我怎么才能避免被窃听、被篡改、被钓鱼？</p>
<p><strong>通常我们用 HTTPS 协议。</strong></p>
<p>在 HTTPS 协议中，第一步是 A 作为客户端（Client）去获取 B 作为网站的公钥（B-public-key）。</p>
<p>怎么获取？如果我们认为网络不可信，那么我们就需要找一个可信的中间人，第三方权威机构 G，由它来证明，我们网站 B 返回客户端 A 的公钥（B-public-key），的确来自于 B，中间没有被其他人篡改。</p>
<p>这意味着网站 B 不能直接返回自己的公钥（B-public-key）给客户端 A，而是需要返回由权威机构 G 做了数字签名的公证书（简称数字证书），里面记录了网站 B 的域名（domain），和对应的公钥（B-public-key），还有证书的颁发人 G 的代号。</p>
<p>这张数字证书的作用是什么？最重要的并不是它怎么在网络上传递的。而是它记录了这样一个事实：域名 domain 对应的公钥是 B-public-key，它是由权威机构 G 做出的公证，因为上面有 G 的数字签名。</p>
<p>所以这张数字证书并不需要临时生成，而是提前在网站部署时就已经生成好了，而且也可以随意传递给任何人，因为它是完全公开的信息。</p>
<p>当然这里还有一个前提，我们客户端 A 已经提前拥有第三方权威机构 G 的公钥（G-public-key）了。整个过程如下：</p>
<ul>
<li>客户端 A 向 网站 B 请求网站的数字证书。</li>
<li>网站 B 返回它的数字证书。</li>
<li>客户端 A 收到数字证书，用 G-public-key 验证该数字证书的确由权威机构 G 认证，于是选择相信证书里面的 (domain, public-key) 信息。</li>
<li>客户端 A 检查证书中的 domain，和我们要访问的网站 B 域名是否一致。如果不一致，那么说明数字证书虽然是真的，但是是别人找权威机构 G 认证的其他域名的证书，于是结束会话；如果一致，于是相信证书中的 public-key 就是网站 B 的公钥（B-public-key）。</li>
</ul>
<p>有了 B-public-key，客户端 A 就可以愉快地上网，不必担心网络通讯的安全了。</p>
<p>但是，HTTPS 并不能完全解决钓鱼问题。它假设用户对要访问的网站域名（domain）可靠性有自己的判断力。</p>
<p>这当然并不全是事实。所以，高级一点的浏览器（例如 Google Chrome），它会建立不靠谱网站域名的数据库，在用户访问这些网站时进行风险提示。</p>
<h2 id="更多的信息安全话题"><a href="#更多的信息安全话题" class="headerlink" title="更多的信息安全话题"></a>更多的信息安全话题</h2><p>上面我们更多从服务终端用户角度，操作系统和浏览器以及我们的应用程序需要考虑的信息安全问题。有以下这些信息安全问题没有涉及：</p>
<ul>
<li>服务器的安全问题（DDOS 攻击、漏洞与入侵）；</li>
<li>企业信息安全；</li>
<li>社会工程学的安全问题；</li>
<li>……</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总结一下，我们今天聊了软件安全态势的演变过程，从最早的病毒和木马，演化到今天敏感信息如通讯录等内容的窃取，正常软件与恶意软件的判断边界越来越模糊。</p>
<p>我们也聊了网络环境带来的安全问题。今天主流的假设是网络链路是不可信的，在不可信的网络之上如何去做安全的通讯，可以做到防窃听、防篡改、防钓鱼。这也是苹果前几年强制要求 iOS App 必须走 HTTPS 协议的原因。</p>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。本章关于操作系统的话题到此就结束了。下一讲我们结合前面的内容，讨论并实战架构第一步，怎么做需求分析。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:07:32.653Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    37 minutes read (About 5596 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/15 | 可编程的互联网世界/">15 | 可编程的互联网世界</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>前面我们讨论架构思维的时候说过，架构的第一步是做需求分析。需求分析之后呢？是概要设计。概要设计做什么？是做子系统的划分。它包括这样一些内容：</p>
<ul>
<li>子系统职责范围的定义；</li>
<li>子系统的规格（接口），子系统与子系统之间的边界；</li>
<li>需求分解与组合的过程，系统如何满足需求、需求适用性（变化点）的应对策略。</li>
</ul>
<p>对于我们理解这个精彩的互联网世界来说，理解它的子系统的划分思路是非常非常重要的。</p>
<h2 id="网络应用程序的全视图"><a href="#网络应用程序的全视图" class="headerlink" title="网络应用程序的全视图"></a>网络应用程序的全视图</h2><p>在上一讲 “<a href="https://time.geekbang.org/column/article/98406" target="_blank" rel="noopener">14 | IP 网络：连接世界的桥梁</a>” 中我们介绍了 IP 网络的工作原理。我们还画了一幅与数据传输这件事本身有关的网络协议图，如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/8d/23/8d3d2147685359357e78c8715e5edf23.png" alt></p>
<p>那么，从一个典型的网络应用程序角度来说，它的完整视图又是什么样子的呢？</p>
<p><img src="https://static001.geekbang.org/resource/image/27/35/272a1a5319c226fc6472bb4f5f256c35.png" alt></p>
<p>上图是我给出的答案。当然，它并不代表所有的网络应用程序，但这不影响我们借它的结构来解释网络世界是怎么划分子系统的，每个子系统都负责了些什么。</p>
<p><strong>第一层是物理层。</strong>你可以理解为网络设备的原生能力，它定义了硬件层次来看的基础网络协议。</p>
<p><strong>第二层是数据链路层。</strong>它负责解决的是局部网络世界的数据传输能力。网络数据传输技术会层出不穷，今天主流有固网、WiFi、3G/4G，明天有 5G/6G，未来也必然还会出现更快速的网络新技术。</p>
<p>这些网络技术虽然都有自己独特的链路层协议，但都可以很自然融入整个互联网世界。原因在于什么？在于 IP 网络。</p>
<p><strong>所以第三层是 IP 网络层，它负责的是互联网世界的一体化，彼此包容与协作。</strong>如果拿单机的应用程序的全视图来类比的话，IP 网络类似于单机体系中的操作系统。</p>
<p>在单机体系，操作系统是一台计算机真正可编程的开始。同样地，互联网世界的体系中，IP 网络是互联网 “操作系统” 的核心，是互联网世界可编程的开始。</p>
<p><strong>第四层是 TCP/UDP 传输层。</strong>它也是互联网 “操作系统” 的重要组成部分，和 IP 网络一起构成互联网 “操作系统” 的内核。IP 网络解决的是网如何通的问题，而传输层解决的是如何让互联网通讯可信赖的问题，从而大幅降低互联网应用程序开发的负担。</p>
<p>互联网并不是世界上的第一张网。但是只有拥有了 TCP/IP 这一层 “操作系统”，这才真正实现了网络价值的最大化：连接一切。</p>
<p>有了操作系统，应用软件才得以蓬勃发展。上图我们列出的应用层协议，仅仅只是沧海一粟。但是，要说当前最主流的应用层协议，无疑当属 HTTP 协议（超文本传输协议，HyperText Transfer Protocol）和 SMTP/POP3 协议了。</p>
<p>HTTP 协议是因为万维网（World Wide Web，简称 WWW）这个应用场景而诞生，冲着传输静态网页而去的。但是由于设计上的开放性，几经演进到今天，已经俨然成为一个通用传输协议了。</p>
<p>通用到什么程度？DNS 地址簿这样的基础协议，也搞出来一个新的 HTTP DNS。当然今天 HTTP DNS 还只是传统 DNS 协议的补充，使用还并不广泛。但由此可知人们对 HTTP 协议的喜爱。</p>
<p>除了呈现网页之外，HTTP 协议也经常被用来作为业务开放协议 RESTful API 的承载。另外，一些通用 RPC 框架也基于 HTTP 协议，比如 Google 的 gRPC 框架。</p>
<p>SMTP/POP3 协议是电子邮件（Email）应用所采用的，它们没有像 HTTP 协议那么被广泛借用，只是局限于电子邮件应用领域。但 SMTP/POP3 协议使用仍然极为广泛，原因是因为电子邮件是最通用的连接协议，它连接了人和人，连接了企业和企业。</p>
<p>我们都很佩服微信的成功，因为它连接了几乎所有的中国人。但是相比电子邮件，微信仍然只是小巫见大巫，因为电子邮件连接了世界上的每一个人和企业。</p>
<p>这是怎么做到的？因为开放的力量。如果说有谁能够打败微信，那么我个人一个基本的思考是：用微信的方式打败微信恐怕很难，但微信是封闭协议，开放也许是一个打败微信的机会？</p>
<p>还有其他很多应用层协议上图没有列出来，比如 FTP、NFS、Telnet 等等。它们大都应用范围相对小，甚至有一些渐渐有被 HTTP 协议替代的趋势。</p>
<p>对于一个网络应用程序来说，它往往还依赖存储和数据库（DB/Storage）。目前存储和数据库这块使用 HTTP 的还不多，除了对象存储（Object Storage），大部分还是直接基于 TCP 协议为主。</p>
<p>对象存储作为一种最新颖的存储类型，现在主流都是基于 HTTP 协议来提供 RESTful API，比如七牛云的对象存储服务。</p>
<p>所以你可以看到，网络应用程序所基于的基础平台，比单机软件要庞大得多。前面我们介绍的单机软件所依赖的 CPU + 编程语言 + 操作系统就不说了，它一样要依赖。</p>
<p>上图所示的网络世界所构建的庞大基础平台，从物理层 -&gt; 数据链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用平台层，也都是我们业务架构的依赖点。选择自定义网络协议，基于 gRPC，还是基于 HTTP 提供 RESTful API ？这是架构师需要做出的决策之一。</p>
<h2 id="应用层协议与网关"><a href="#应用层协议与网关" class="headerlink" title="应用层协议与网关"></a>应用层协议与网关</h2><p>上一讲 “<a href="https://time.geekbang.org/column/article/98406" target="_blank" rel="noopener">14 | IP 网络：连接世界的桥梁</a>” 中我们谈到两台主机是如何通讯时，我们介绍了让局域网主机能够上网的 NAT 技术。NAT 网关本质上是一个透明代理（中间人），工作在网络协议的第四层，即传输层，基于 TCP/UDP 协议。</p>
<p>如果我们限定传输的数据包一定是某种应用层协议时，就会出现所谓的应用层网关，工作在网络协议的第七层，所以有时候我们也叫七层网关。</p>
<p>我们熟知的 Nginx、Apache 都可以用作应用层网关。应用层协议通常我们采用的是 HTTP/HTTPS 协议。</p>
<p>为什么 HTTP 协议这么受欢迎，甚至获得了传输层协议才有的待遇，出现专用的网关？</p>
<p>这得益于 HTTP 协议的良好设计。</p>
<p>我们一起来看一看 HTTP 协议长什么样。先看获取资源的 GET 请求（Request）：</p>
<pre><code>GET /abc/example?id=123 HTTP/1.1
Host: api.qiniu.com
User-Agent: curl/7.54.0
Accept: */*</code></pre><p>HTTP 协议的请求（Request）分协议头和正文两部分，中间以空行分隔。GET 请求一般正文为空。</p>
<p>协议头的第一行是请求的命令行，具体分为三部分，以空格分隔。第一部分为命令，常见有 GET、HEAD、PUT、POST、DELETE 等。第二部分是请求的资源路径。第三部分为协议版本。</p>
<p>协议头从第二行开始，每行均为请求的上下文环境或参数，我们不妨统一叫字段（Field）。格式为：</p>
<pre><code>字段名: 字段值</code></pre><p>HTTP 服务器收到一个请求后，往往会返回这样一个回复（Response）：</p>
<pre><code>HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 68
ETag: W/&quot;fb751fe2cb812eb5d466ed9e3c3cd519&quot;

&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;qiniu.com&lt;/body&gt;&lt;/html&gt;</code></pre><p>HTTP 请求（Request）和回复（Response）格式上只有第一行不同。回复的第一行也分为三部分，以空格分割。</p>
<p>第一部分为协议版本。</p>
<p>第二部分是状态码（Status Code），用来表征请求的结果，200 表示成功，4xx 通常表示请求（Request）本身不合法，5xx 则通常表示 HTTP 服务器有异常。</p>
<p>第三部分是状态文本（Status Text），方便接收方看到回复后可以立刻判断问题，而不用去查状态码对应的文档。</p>
<p>当协议正文非空的时候，往往还需要用 Content-Type 字段来指示协议正文的格式。例如这里我们用 text/html 表征返回的协议正文是一个 html 文档。Content-Length 字段则用来指示协议正文的长度。</p>
<p>我们再来看一下修改资源的 POST 请求：</p>
<pre><code>POST /abc/example HTTP/1.1
Host: api.qiniu.com
User-Agent: curl/7.54.0
Authorization: Qiniu dXNlcj14dXNoaXdlaSZwYXNzd2Q9MTIzCg
Content-Type: application/x-www-form-urlencoded;charset=utf-8
Content-Length: 18

id=123&amp;title=Hello</code></pre><p>和 GET 不一样，修改资源往往需要授权，所以往往会有 Authorization 字段。另外这里我们用 Content-Type 字段表示我们协议正文用了表单（form）格式。</p>
<p>最后我们看下删除资源的 DELETE 请求：</p>
<pre><code>DELETE /abc/example HTTP/1.1
Host: api.qiniu.com
User-Agent: curl/7.54.0
Authorization: Qiniu dXNlcj14dXNoaXdlaSZwYXNzd2Q9MTIzCg
Content-Type: application/json
Content-Length: 11

{&quot;id&quot;: 123}</code></pre><p>删除和修改完全类似。除了我这里刻意换了一种 Content-Type，协议正文用 json 格式了。实际业务中当然不是这样，通常会选择一致的表达方法。</p>
<p>大致了解了 HTTP 协议的样子，我们一起来分析一下它到底好在哪里？</p>
<p>毫无疑问，最关键的是它的协议头设计。具体表现在如下这些方面。</p>
<ul>
<li>极其开放的协议头设计。虽然 HTTP 定义了很多标准的协议头字段（Field），但是用户还是可以加自己的字段，惯例上以 X- 开头。例如，七牛引入了 X-Reqid 作为请求的内部调用过程的跟踪线索。关于 X-Reqid 本专栏后续我们还会继续谈到。</li>
<li>规范了业务的表达范式。虽然业务有千千万万种可能，但是实质上不外乎有什么资源，以及对资源的 CURD（创建-修改-读取-删除）。相对应地，在HTTP 协议中以 “资源路径” 表达资源，以 PUT-POST-GET-DELETE 表达 CURD 操作（也有一些服务以 POST 而不是用 PUT 请求来创建资源）。</li>
<li>规范了应用层的路由方式。我们知道，在传输层网络的路由基于 IP 地址，但是对于应用而言，IP 地址是一个无意义的字段，在 HTTP 协议头中，有一个字段是强制的，那就是 Host 字段，它用来表征请求的目标主机。通常，在正式生产环境下它是个域名，比如 api.qiniu.com 。以域名来表征目标主机，无疑更加能够体现业务特性。故而，对应用层而言，“域名+资源路径” 是更好的路由依据，方便进行业务的切分。</li>
</ul>
<p>正因为 HTTP 协议的这些好处，逐渐地它成为了网络应用层协议的模板。无论业务具体是什么样子的，都可以基于 HTTP 协议表达自己的业务逻辑。</p>
<h2 id="TCP-IP-层编程接口"><a href="#TCP-IP-层编程接口" class="headerlink" title="TCP/IP 层编程接口"></a>TCP/IP 层编程接口</h2><p>理解清楚了我们网络应用程序的结构，也理解了我们最主流的应用层协议 HTTP 协议，那么我们就可以考虑去实现一个互联网软件了。</p>
<p>从编程接口来说，网络的可编程性是从网络层 IP 协议开始。这是最底层的网络 “操作系统” 的能力体现。</p>
<p>从基于 IP 协议的网络视角来看，数据是并不是源源不断的流（stream），而是一个个大小有明确限制的 IP 数据包。IP 协议是无连接的，它可以在不连接对方的情况下向其发送数据。规格示意如下：</p>
<pre><code>package net

type IPAddr struct {
    IP   IP
    Zone string // IPv6 scoped addressing zone
}

func DialIP(network string, laddr, raddr *IPAddr) (*IPConn, error)
func ListenIP(network string, laddr *IPAddr) (*IPConn, error)

func (c *IPConn) Read(b []byte) (int, error)
func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)
func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)
func (c *IPConn) Write(b []byte) (int, error)
func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)
func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)
func (c *IPConn) Close() error</code></pre><p>IP 协议本身只定义了数据的目标 IP，那么这个 IP 地址对应的计算机收到数据后，究竟应该交给哪个软件应用程序来处理收到的数据呢？</p>
<p>为了解决这个问题，在 IP 协议的基础上定义了两套传输层的协议：UDP 和 TCP 协议。它们都引入了端口（port）的概念。</p>
<p>端口很好地解决了软件间的冲突问题。一个IP地址+端口，我们通常记为 ip:port，代表了软件层面上来说唯一定位的通讯地址。每个软件只处理自己所使用的 ip:port 的数据。</p>
<p>当然，既然 IP 和端口被传输层一起作为唯一地址，端口上一定程度上缓解了 IPv4 地址空间紧张的问题。</p>
<p>虽然从设计者的角度来说，最初端口的设计意图，更多是作为应用层协议的区分。例如 port = 80 表示 HTTP 协议，port = 25 表示 SMTP 协议。</p>
<p>应用协议的多样化很容易理解，这是应用的多样化决定的。尽管从架构的角度，我们并不太建议轻易去选择创造新的协议，我们会优先选择 HTTP 这样成熟的应用层协议。但是随着时间的沉淀，还是会不断诞生新的优秀的应用层协议。</p>
<p>但是，<strong>为什么需要有多套传输层的协议（TCP 和 UDP）呢？</strong></p>
<p>还是因为应用需求是多样的。底层的 IP 协议不保证数据是否到达目标，也不保证数据到达的次序。出于编程便捷性的考虑，TCP 协议就产生了。</p>
<p>TCP 协议包含了 IP 数据包的序号、重传次数等信息，它可以解决丢包重传，纠正乱序，确保了数据传输的可靠性。</p>
<p>但是 TCP 协议对传输协议的可靠性保证，对某些应用场景来说并不是一个好特性。最典型的就是音视频的传输。在网络比较差的情况下，我们往往希望丢掉一些帧，但是由于 TCP 重传机制的存在，可能会反而加剧了网络拥塞的情况。</p>
<p>这种情况下，UDP 协议就比较理想，它在 IP 协议基础上的额外开销非常小，基本上可以认为除了引入端口（port）外并没有额外做什么，非常适合音视频的传输需求。</p>
<p>编程接口来说，TCP 的编程接口看起来是这样的：</p>
<pre><code>package net

type TCPAddr struct {
    IP   IP
    Port int
    Zone string // IPv6 scoped addressing zone
}

func DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error)
func ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error)

func (c *TCPConn) Read(b []byte) (int, error)
func (c *TCPConn) Write(b []byte) (int, error)
func (c *TCPConn) Close() error

func (l *TCPListener) Accept() (Conn, error)
func (l *TCPListener) AcceptTCP() (*TCPConn, error)
func (l *TCPListener) Close() error</code></pre><p>UDP 的编程接口看起来是这样的：</p>
<pre><code>package net

type UDPAddr struct {
    IP   IP
    Port int
    Zone string // IPv6 scoped addressing zone
}

func DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error)
func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error)

func (c *UDPConn) Read(b []byte) (int, error)
func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)
func (c *UDPConn) ReadFromUDP(b []byte) (int, *UDPAddr, error)
func (c *UDPConn) Write(b []byte) (int, error)
func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)
func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)
func (c *UDPConn) Close() error</code></pre><p>对比看，IP 和 UDP 的区别非常小，都是无连接的协议，唯一差别就是 UDPAddr 在 IPAddr 基础上增加了一个端口。也正因为如此，我们很少有应用程序会直接基于 IP 协议来编程。</p>
<p>客户端来说，无论 TCP 还是 UDP，使用方式都很像，其示意代码如下：</p>
<pre><code>c, err := net.Dial(&quot;tcp&quot;, addrServer)
c.Write(...)
c.Read(...)
c.Close()</code></pre><p>net.Dial 背后会根据 network 字段选择调用 DialTCP 还是 DialUDP。然后我们就像操作一个文件一样来操作就行，理解上非常简单，只是 UDP 的读写在应用层面需要考虑可能会丢包。</p>
<p>但是服务端不太一样。服务端并不知道谁会给自己发信息，它只能监听自己的 “邮箱”，不时看看是不是有人来信了。</p>
<p>对于 TCP 协议，服务端示意代码如下：</p>
<pre><code>l, err := net.Listen(&quot;tcp&quot;, addrServer)
for {
  c, err := l.Accept()
  if err != nil {
    错误处理
    continue
  }
  go handleConnection(c)
}</code></pre><p>对于 UDP 协议，服务端示意代码如下：</p>
<pre><code>c, err := net.ListenUDP(&quot;udp&quot;, addrServer)
for {
  n, srcAddr, err := c.ReadFromUDP(...)
  if err != nil {
    错误处理
    continue
  }
  // 根据 srcAddr.IP+port 确定是谁发过来的包，怎么处理
}</code></pre><p>由于 TCP 基于连接（connection），所以每 Accept 一个连接后，我们可以有一个独立的执行体（goroutine）去处理它。但是 UDP 是无连接的，需要我们手工根据请求的来源 IP+port 来判断如何分派。</p>
<h2 id="HTTP-层编程接口"><a href="#HTTP-层编程接口" class="headerlink" title="HTTP 层编程接口"></a>HTTP 层编程接口</h2><p>尽管基于 TCP/IP 层编程是一个选择，但是在当前如果没有特殊的理由，架构师做业务架构的时候，往往还是优先选择基于 HTTP 协议。</p>
<p>我们简单来看一下 HTTP 层的编程接口：</p>
<pre><code>package http

func Get(url string) (*Response, error)
func Post(url, contentType string, body io.Reader) (*Response, error)
func PostForm(url string, data url.Values) (*Response, error)

func NewRequest(method, url string, body io.Reader) (*Request, error)

var DefaultClient = new(Client)
func (c *Client) Do(req *Request) (*Response, error)

func NewServeMux() *ServeMux
func (mux *ServeMux) Handle(pattern string, handler Handler)
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))
func ListenAndServe(addr string, handler Handler) error
func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error</code></pre><p>对于 HTTP 客户端，使用上要比 TCP/UDP 简单得多，常见情况下直接调用 Get、Post 这些函数调用就满足业务需求。</p>
<p>在需要在 HTTP 协议头写一些额外字段的，会略微麻烦一点，需要先 NewRequest 生成一个请求，并添加一些字段（Field），然后再调用 Client.Do 去发起请求。整体上比调用 Read/Write 这样的基础 IO 函数要简便得多。</p>
<p>对于 HTTP 服务端，使用上的示意代码如下：</p>
<pre><code>mux := http.NewServeMux()
mux.HandleFunc(&quot;/abc/example&quot;, handleAbcExampe)
mux.HandleFunc(&quot;/abc/hello/&quot;, handleAbcHello)

http.ListenAndServe(addServer, mux)</code></pre><p>简单解释一下，一个 HTTP 服务器最基础的就是需要有根据 “资源路径” 的路由能力，这依赖 ServeMux 对象来完成。</p>
<p>简单对比可以看出，基于 HTTP 协议的编程接口，和基于 TCP/IP 协议裸写业务，其复杂程度完全不可同日而语。前者一个程序的架子已经呈现，基本上只需要填写业务逻辑就好。这也是采纳通用的应用层协议的威力所在。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这一讲我们希望给大家呈现的是应用程序的全貌。当然，我们现在看到的仍然是非常高维的样子，后面在 “服务端开发” 一章，我们将进一步展开所有的细节。</p>
<p>在应用层协议介绍上，我们很难有全面的介绍，因而我们把侧重点放在 HTTP 协议的概要介绍上。同样，后面我们在 “服务端开发” 一章会进一步介绍 HTTP 协议。</p>
<p>最后，我们整理了基于 TCP/UDP 协议编程和基于 HTTP 协议编程的主体逻辑。虽然介绍非常简要，但通过对比我们仍然可以感受到业务架构基于成熟的应用层协议的优势所在。</p>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。网络编程本章就到此结束，后面我们有专门的章节来进一步展开。下一讲，我们将探讨操作系统的最后一个子系统：安全管理。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:07:30.594Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    an hour read (About 6757 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/14 | IP 网络：连接世界的桥梁/">14 | IP 网络：连接世界的桥梁</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>到目前为止，我们介绍了操作系统的六大子系统中的四项：进程、存储、输入、输出。当你理解了这些东西背后的道理，基本上做一款单机软件就游刃有余了。</p>
<p>但是，如果仅仅局限于单机，一台计算机并不见得比计算器高明太多。网络对整个信息科技的重要性不言而喻。它让计算机连接在了一起，这一连接就发生了巨大的变化。</p>
<p>没有了网络，我们只能用用 Office 软件，玩玩扫雷。没有网络，就没有 QQ 和微信，不会有淘宝和支付宝，也不会有 BAT。</p>
<p>网络连接一切。它连接了人（个人和企业）、服务（由软件系统构建的服务接口）和物（大自然产物和智能终端），构建了多姿多彩的互联网。</p>
<p>它让地球上的任何两个人都可以随时随地进行沟通，远程做生意。在互联网出现之前，旧的商业文明我们可以一言以蔽之：一手交钱，一手交货。而建立在互联网之上的新商业文明，我们一手下单付款，一手收钱发货，足不出户，货物就通过便捷的物流服务送到了你手上。</p>
<p>这是多么巨大的效率变革，但这一切是怎么做到的呢？</p>
<h2 id="数据的封包过程"><a href="#数据的封包过程" class="headerlink" title="数据的封包过程"></a>数据的封包过程</h2><p>网络和其他所有的输入输出设备一样，只能交换数据。无论你要对方做什么，你首先需要发送对方理解得了的数据给它。所以双方要就沟通的语言达成共识，这就是网络协议。</p>
<p>网络协议是计算机与计算机远程沟通的数据格式。它包含很多信息。这些信息不同部分的内容，有不同的职责，关心它的人也各有不同。</p>
<p>网络是传递数据的，是数字内容的物流。作为类比，我们可以看看实物快递的物流协议是什么样的。下面这张快递面单大家应该都很熟悉：</p>
<p><img src="https://static001.geekbang.org/resource/image/d2/18/d2206dbdaf528ef1f1fcb26869b05018.png" alt></p>
<p>这个快递面单包含很多内容，其中最重要的当然是寄件人信息和收件人信息。有了收件人信息，物流系统才能够知道怎么把要邮寄的物品进行一站站中转，并最终到达目的地。</p>
<p>有了寄件人信息，收件人收到信息才知道是谁寄过来的，如果回复的话应该邮寄往何方。而在物流过程如果出错的话，物流系统也知道如何与寄件人沟通协调错误的处置方法。</p>
<p>寄件人关心什么？他很可能关心物流订单号。这是他掌握物流状态的唯一凭据。另外，为了传输过程的便捷，物流系统可能还会给我们要邮寄的物品用信封袋或者包装箱进行封装。</p>
<p>所有这些寄件人信息、收件人信息、物流订单号、信封袋、包装箱，都不是寄件人要邮寄的内容，而是物流系统对物流协议所产生的需求。</p>
<p>为了支持整个物流系统的不间断运转，我们会有很多不同的部门。有负责最后一公里的快递员，也有负责骨干线路的航空运输部门，或者火车货运部门等等。</p>
<p>同样的，数字物流系统也有很多不同的部门，有的部门负责局域网（LAN）内最后一公里的，也有人负责广域网（WAN）骨干线路的运输的。网络协议作为数字物流的载体，会收到来自这些不同部门的需求。</p>
<p>我们平常可能经常听人提及，网络协议有 OSI 模型，它把网络协议分成了七层结构，从上到下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。但这样描述有点过于抽象，我们不妨用下图来理解网络协议的分层结构。</p>
<p><img src="https://static001.geekbang.org/resource/image/60/2a/6059e45af9f2ff757fa64df2ec48212a.png" alt></p>
<p>让我们设想：我们要传输一部电影，它就是我们的 “物品”，或者用技术术语叫 “应用层数据”，怎么传？</p>
<p><strong>第一步，分批次。</strong>数字物流系统单次能够传递的数据大小是有限的。如果数据太大，就必须分开多次来传输。从物理网络视角看，数据是并不是流（stream），而是一个个大小有明确限制的数据包。</p>
<p><strong>第二步，套上信封，写好寄件单位的部门（源端口号）、收件单位的部门（目标端口号）、批次编号。</strong>为什么要写部门（端口号）？方便知道由谁（哪个应用程序软件）来负责收件。为什么要写批次编号？是为了防止寄丢了，寄丢了就得重新传一份该批次编号的东西。</p>
<p>这层我们叫传输层。它主要是为了解决传输可靠性的问题。当然传输层有两套协议（两种信封），一套是 TCP 协议，另一套是 UDP 协议。UDP 协议不保证对方一定收到，信封上就没写批次编号。</p>
<p><strong>第三步，再套上一层信封，上面写上寄件单位地址（源 IP 地址）、收件单位地址（目标 IP 地址）。</strong>有了地址，这封信在广域网（WAN）上流转，就知道自己应该去往何方了。这一层叫做网络层，它定义的信封格式，叫 IP 协议。</p>
<p>互联网的复杂性是在于，它不是一家数字物流公司的事。信寄到某处，可能就换一家物流公司了。它是所有的数字物流公司通力协作的结果。</p>
<p>所以 IP 协议最核心的意义是标准化，解决跨物流公司传输的问题。为什么我们要这样一层信封套一层信封？因为越往外层的信封，内容越和具体的物流公司相关。但无论你外层套的信封如何各有不同，拆到这一层，信的格式就是标准化的。</p>
<p><strong>第四步，再套上一层信封，这层我们叫它数据链路层。</strong>具体信封上写什么，完全是具体负责这段路程的物流公司说了算。当信件从一个物流公司转到另一个物流公司做交接的时候，这一层信封拆掉，重新换上新的信封。</p>
<p>数据链路层的信封格式（网络协议）非常多样化。局域网（LAN）现在最流行的是以太网（Ethernet）协议，广域网（WAN）现在常见的有 HDLC、PPP、Frame-Relay 等网络协议。</p>
<p>无论如何，写完了特定物流公司所需要的信息，信件就可以进入数字物流系统（物理层）去流转了。</p>
<h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>上面那一层套一层的信件（网络协议）放的是用户要邮寄的东西，比如一部电影。但为了支持整个邮寄过程的顺利进行，获得更好的用户体验，还会有一些辅助用途的信件（网络协议）在网络上传递，有的是面向用户的，有的是面向数字网络系统内部的。</p>
<p>完整来说，在整个数字物流系统中，与数据传输这件事本身有关的网络协议，我们整理如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/8d/23/8d3d2147685359357e78c8715e5edf23.png" alt></p>
<p>在这个图中，链路层协议最为复杂，MAC+LLC、PPP、HDLC、Frame-Replay，这些是目前最为常见的。未来也必然会出来很多新的网络通讯技术，用的是全新的协议。链路层之上，IP -&gt; TCP/UDP，这些协议我们最为耳熟能详，上面我们也已经介绍过了。</p>
<p>其他都还有些什么？除了 ICMP 和 IGMP 协议，这些协议都和网络地址的解析有关。所以，在谈协议用途前，我们先聊一聊网络地址。</p>
<p>要通讯，首先要有地址。数字物流世界的地址有三层。最底下的是链路层地址。不同链路层协议的地址表示非常不同。</p>
<p>比如，局域网所采纳的以太网（Ethernet）协议用的是 MAC 地址。一台计算机有一个或多个网卡，每个网卡会有自己的唯一标识即 MAC 地址。这个标识跟随网卡设备存在，和网络环境无关。你把计算机从北京搬到上海，MAC 地址保持不变。</p>
<p>链路层的网络地址我们平常接触并不多，常规我们理解的网络地址是位于第二层的 IP 地址。</p>
<p>IP 地址类似于门牌号：你家住在哪个城市哪条路几号。它决定了网络路由怎么走，信息如何到达你的计算机网卡。IP 地址已经发展了两代，分别为 IPv4 和 IPv6。升级的原因是 IPv4 地址空间太小，只有 4G（即40多亿）个地址。</p>
<p>就像我们通常会更喜欢用 “我要去金茂大厦” 而不是 “我要去上海市浦东新区世纪大道88号” 一样，IP地址并不容易记忆，所以就有了第三层的网络地址：域名。</p>
<p>比如，我们会用 <a href="http://www.qiniu.com" target="_blank" rel="noopener">www.qiniu.com</a> 这个地址来找到七牛云的官网，而不是记住枯燥的 IP 地址。</p>
<p>理解了这三类网络地址，我们一一介绍下这些协议的用途。</p>
<p><strong>首先是 DNS 协议。</strong>这个协议就像是个地址簿，主要负责 “域名” =&gt; “IP地址” 的查询。每次我们要邮寄信件之前都要拿出来查一查。</p>
<p><strong>其次是 DHCP 协议。</strong>DHCP 全称叫动态主机配置协议（Dynamic Host Configuration Protocol），主要负责计算机接入网络时的初始化。计算机刚开始就只有网卡的 MAC 地址，通过 DHCP 可以给它分配 IP 地址，并得到默认网关地址（这很重要，不知道网关就上不了网）和 DNS 服务器的地址。有了这些东西，这台计算机就可以和外界通讯了。</p>
<p><strong>然后是 ARP 协议。</strong>ARP 全称叫地址解析协议（Address Resolution Protocol），它服务于现在局域网中最流行的以太网协议。在以太网中，ARP 协议负责解析远程主机 IP 地址对应的 MAC 地址。之所以需要 ARP 协议，是因为我们平常应用程序连接目标计算机进行网络通讯时，都是提供了域名或 IP 地址。但对以太网来说，要想发信件出去，它要的是对方的 MAC 地址。</p>
<p><strong>然后是 RARP 协议。</strong>RARP 全称叫反向地址转换协议（Reverse Address Resolution Protocol）。顾名思义，它和 ARP 协议相反，负责的是 MAC 地址到 IP 地址的转换。RARP 协议已经被上面的 DHCP 协议所取代，平常用不太到了。</p>
<p><strong>然后是 ICMP 协议。</strong>ICMP 全称叫互联网控制报文协议（Internet Control Message Protocol），它能够检测网路的连线状况，以保证连线的有效性。基于这个协议实现的常见程序有两个：ping 和 traceroute，它们可以用来判断和定位网络问题。</p>
<p><strong>最后是 IGMP 协议。</strong>IGMP 全称叫互联网组管理协议（Internet Group Management Protocol），它负责 IP 组播（Multicast）成员管理。本文略过这块的内容。</p>
<h2 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h2><p>了解了数据包的结构，也了解了数据传输相关的网络协议，接下来我们聊一聊数据传输的过程。为了方便理解，我们画了一幅数据传输的示意图：</p>
<p><img src="https://static001.geekbang.org/resource/image/b6/d5/b6dd426fa5fffa0c38b69118c20732d5.png" alt></p>
<p>简化理解来说，我们可以认为，在需要传输数据的源主机和目标主机之间，它们通过若干路由器或交换机连接。我们分以下几种情况来分析：</p>
<p><strong>情形一，源主机和目标主机在同一个局域网内，中间通过交换机连接，采用了最常见的以太网协议。</strong></p>
<p>通讯开始的时候，源主机只有目标主机的 IP 地址，并没有 MAC 地址。但以太网通讯要的是 MAC 地址，所以源主机会发起一个 ARP 请求去获得目标 IP 对应的 MAC 地址。</p>
<p>当然，源主机会缓存这个对应关系。第二次继续给相同 IP 发信息的时候，就不需要重新发起 ARP 请求了。</p>
<p>无论是 ARP 请求，还是普通的数据包，都会先到达交换机。ARP 是一个广播请求，所以交换机会转发给所有其他主机，目标主机发现这个 IP 地址是自己的，于是返回自己的 MAC 地址。</p>
<p>有了目标主机的 MAC 地址，源主机就可以发数据了。同样的，所有数据包都发给了交换机。</p>
<p>交换机是性能极高的网络数据交换设备。它通常工作在网络协议的第二层，也就是数据链路层。这一层只认 MAC 地址，不认 IP 地址。MAC 地址本身是个唯一身份标识，就像我们的身份证号，并没有可寻址的作用。那么交换机怎么做到这么高的数据传输的效率？</p>
<p>交换机在工作的过程中，会不断地收集资料去创建一个地址映射表：MAC 地址 =&gt; 交换机端口。这个表很简单，它记录了某个MAC 地址是在哪个端口上被发现的。</p>
<p>交换机收到一个数据包后，首先会进行学习，把源 MAC 地址和收到数据包的交换机端口对应起来。然后交换机查看数据包的目标 MAC 地址，并在地址映射表中找，如果找到对应的端口，那么就往这个端口转发数据包。</p>
<p>如果没找到，交换机可能会把这个数据包 “扩散” 出去，就好像收到广播数据包一样。这时如果目标主机收到广播过来的数据包后，回复了这个数据包，那么它的 MAC 地址和交换机端口的映射关系就也会被学习到。</p>
<p>当交换机初次加入网络时，由于地址映射表是空的，所以，所有的数据包将发往局域网内的全部端口，直到交换机 “学习” 到各个MAC 地址为止。这样看来，交换机刚刚启动时与传统的共享式集线器类似，直到地址映射表比较完整地建立起来后，它才真正发挥它的高性能。</p>
<p>我们总结一下，当一台交换机安装配置好之后，其工作过程如下。</p>
<ul>
<li>收到某端口（设为A）MAC 地址为 X 的计算机发给 MAC 地址为 Y 的计算机的数据包。交换机从而记下了 MAC 地址 X 在端口 A。这称为学习（learning）。</li>
<li>交换机还不知道 MAC 地址 Y 在哪个端口上，于是向除了 A 以外的所有端口转发该数据包。这称为泛洪（flooding）。</li>
<li>MAC 地址 Y 的计算机收到该数据包，向 MAC 地址 X 发出确认包。交换机收到该包后，从而记录下 MAC 地址 Y 所在的端口。</li>
<li>交换机向 MAC 地址 X 转发确认包。这称为转发（forwarding）。</li>
<li>交换机收到一个数据包，查表后发现该数据包的来源地址与目的地址属于同一端口。交换机将不处理该数据包。这称为过滤（filtering）。</li>
<li>交换机内部的 “MAC 地址 =&gt; 端口” 查询表的每条记录采用时间戳记录最后一次访问的时间。早于某个阈值（用户可配置）的记录被清除。这称为老化（aging）。</li>
</ul>
<p><strong>情形二，源主机和目标主机都有公网 IP 地址，它们中间经过若干交换机和路由器相连。</strong></p>
<p>路由器和交换机不太一样，交换机因为没有门牌号，通讯基本靠吼。好的一点是，圈子比较小，吼上一段时间后，路都记住了，闭着眼睛都不会走错。</p>
<p>但广域网太大了，靠吼没几个人听得见。所以路由器工作在网络协议的第三层，也就是网络层。网络层看到的是 IP 协议，能够知道数据传输的源 IP 地址和目标 IP 地址。</p>
<p>有了 IP 地址，就相当于有了门牌号，开启导航按图索骥就可以把东西带过去了。这也是路由器为什么叫路由器的原因，它有导航（路由）功能，知道哪些目标 IP 地址的数据包应该往哪条路走的。</p>
<p>路由器可以拥有一部分交换机的能力，比如，如果发现请求是局域网内的话，也可以引入类似交换机那样的基于 MAC 地址的映射表实现高速通讯。但总体来说，路由器要考虑的问题复杂很多，因为涉及 “最佳路由路径” 的问题。</p>
<p>简单说，所谓 “最佳路由路径” 是指，到达目标主机的路有很多种可能性，我应该选择哪一条。大家在大学可能都学过带权的有向图，路由器面临的正是这种情况。而且情况可能更复杂的是，每一小段路径的权重都是动态的，因为网络状况一直在变。</p>
<p>如果你对路由算法感兴趣，可以在维基百科查找 “<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">路由</a>” ，进一步研究。</p>
<p>路由器除了解决路由问题，它往往还要解决异构网络的封包转换问题。作为局域网的接入方，它可能走的是固网或 WiFi 网络。</p>
<p>作为 Internet 的接入方，它可能走的是光纤宽带。所以它需要把局域网的数据链路层的封包解开并重组，以适应广域网数据链路协议的需求。</p>
<p>理解了以上两点，我们回到话题：广域网的两台具备公网 IP 的主机之间如何完成数据传输？</p>
<p>大体来说，整个过程如下。</p>
<ul>
<li>首先，源主机发送的数据包，经由交换机（可选），到达本局域网的公网网关（路由器）。这个过程属于局域网内通讯，同情形一。</li>
<li>路由器收到了数据包，发现目标主机是 Internet 上的某个远端的目标主机，于是对数据包进行拆包重组，形成新的数据包。</li>
<li>循着自身的路由表，把这个新数据包层层转发，最后到达目标主机对应的公网网关（路由器）上。</li>
<li>路由器发现是发给本局域网内的目标主机，于是再拆包重组，形成新的数据包。</li>
<li>新数据包转到局域网内，经由交换机（可选），并最终到达目标主机。如此，整个数据传输过程就结束了。</li>
</ul>
<p><strong>情形三，源主机和目标主机至少有一方在局域网内且只有私有 IP 地址，它们中间经过若干交换机和路由器相连。</strong></p>
<p>解释一下私有 IP 地址。在 IPv4 地址区间中，有一些区段比如 10.0.0.0 ~ 10.255.255.255、172.16.0.0 ~ 172.31.255.255、192.168.0.0 ~ 192.168.255.255 这几个 IP 地址区间都是私有 IP 地址，只用于局域网内通讯。</p>
<p>常规来说，只有私有 IP 而没有公网 IP 的主机只能和局域网内的主机通讯，而无法和 Internet 上的其他主机相互通讯。</p>
<p>但这一点又和我们日常的感受不符：比如家庭用户往往网络结构是一个 WiFi 路由器连接公网，所有的家庭设备如手机、平板、笔记本，都以 WiFi 路由器为网关构成一个局域网。那么我们的这些设备是怎么上网的呢？</p>
<p>答案是 NAT（Network Address Translation，网络地址转换）技术。它的原理比较简单，假设我们现在源主机用的IP+端口为 iAddr:port1，经过 NAT 网关后，NAT 将源主机的 IP 换成自己的公网 IP，比如 eAddr，端口随机分配一个，比如 port2。</p>
<p>也就是从目标主机看来，这个数据包看起来是来自于 eAddr:port2。然后，目标主机把数据包回复到 eAddr:port2，NAT 网关再把它转发给 iAddr:port1。</p>
<p>也就是说，NAT 网关临时建立了一个双向的映射表 iAddr:port1 &lt;=&gt; eAddr:port2，一旦完成映射关系的建立，在映射关系删除前，eAddr:port2 就变成了 iAddr:port1 的 “替身”。这样，内网主机也就能够上网了。</p>
<p>NAT 网关并不一定是公网网关（路由器），它可以由局域网内任何一台有公网 IP 的主机担当。但显然如果公网网关担当 NAT 网关，链路的效率会高一点。</p>
<p>我们家用的 WiFi 路由器，就充当了 NAT 网关的作用，这也是我们能够上网的原因。</p>
<p>那么，最极端的情形，源主机和目标主机在不同的局域网内，且都没有公网 IP，它们是否可以通讯呢？</p>
<p>答案是不确定。</p>
<p>首先，在这种情况下，源主机和目标主机没法直接通讯，需要中间人去帮忙搭建通讯的链路。怎么做呢？找一个有公网 IP 的主机作为中间人服务器，目标主机向它发包，这样，在目标主机的 NAT 网关就形成了一对双向的映射表：</p>
<ul>
<li>iDestAddr:portDest1 &lt;=&gt; eDestAddr:portDest2</li>
</ul>
<p>然后，中间人服务器再把 eDestAddr:portDest2 告诉源主机。这样源主机就可以通过向 eDestAddr:portDest2 发送数据包来和目标主机 iDestAddr:portDest1 通讯了。</p>
<p>我们不少 P2P 软件就利用了这个技术实现 NAT 穿透，让两台不同内网的计算机相互能够直接通讯。</p>
<p>那么，答案为什么是不确定？因为上面这个机制只有在目标主机的 NAT 网关是 Full cone NAT，即一对一（one-to-one）NAT 网关时才成立。</p>
<p>什么是 Full cone NAT？它是指 NAT 网关临时建立了 iAddr:port1 &lt;=&gt; eAddr:port2 双向映射后，任何主机给 eAddr:port2 发送数据包，都会被转给 iAddr:port1，并不局限于构建这个映射时数据包发送的目标主机是谁。</p>
<p>但在其他类型的 NAT 网关下，一般都对回包的主机 IP 地址有约束。也就是说，NAT 网关形成的双向映射表是因为哪个目标主机建立的，那么回包也必须来自哪台主机。</p>
<p>这种情况下，中间人服务器就没办法来搭桥让它们直接通讯了，数据包需要由中间人服务器来中转。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总结一下，今天我们介绍了数据封包过程、与 IP 数据包传输相关的网络协议，并对数据传输过程做了整体的描述。</p>
<p>我们主要介绍的重点是 IP 协议之下的网络工作过程。我们不讨论如何进行数据重传，更不关心数据到达应用层我们收到数据包后，如何去处理它们。</p>
<p>互联网背后的世界，和互联网一样精彩。精妙之处，值得细细体会。</p>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将进一步来探讨一下网络世界的编程接口。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:07:28.549Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    27 minutes read (About 4080 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/13 | 进程间的同步互斥、资源共享与通讯/">13 | 进程间的同步互斥、资源共享与通讯</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>在上一讲，我们介绍了进程内执行体之间的协同机制。今天我们接着聊进程与进程之间的协同。</p>
<p>这些协同机制大体可分为：互斥、同步、资源共享以及通讯等原语。对于这些协同机制，我们对比了 Linux、Windows、iOS 这三大操作系统的支持情况，整理内容如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/27/e5/276e3874bc64364c10c52371f6b11ce5.png" alt></p>
<p>在逐一详细分析它们之前，我们先讨论一个问题：从需求角度来讲，进程内协同与进程间协同有何不同？</p>
<p>在早期，操作系统还只有进程这个唯一的执行体。而今天，进程内的执行体（线程与协程）被发明出来并蓬勃发展，事情发生了怎样的变化？</p>
<p>请先思考一下这个问题。我们在这一讲最后总结的时候一起聊聊。</p>
<h2 id="启动进程"><a href="#启动进程" class="headerlink" title="启动进程"></a>启动进程</h2><p>在讨论进程间的协同前，我们先看下怎么在一个进程中启动另一个进程。这通常有两种方法：</p>
<ul>
<li>创建子进程；</li>
<li>让Shell配合执行某个动作。</li>
</ul>
<p>前面在 “<a href="https://time.geekbang.org/column/article/96324" target="_blank" rel="noopener">11 | 多任务：进程、线程与协程</a>” 一讲中我们已经提到过，创建子进程 UNIX 系的操作系统都用了 fork API，它使用上很简洁，但是从架构角度来说是一个糟糕的设计。Windows 中我们用 CreateProcess，这个函数有很多的参数。</p>
<p>iOS 很有意思，它并不支持创建子进程。在进程启动这件事情上，它做了两个很重要的变化：</p>
<ul>
<li>软件不再创建多个进程实例，永远是单例的；</li>
<li>一个进程要调用另一个进程的能力，不是去创建它，而是基于 URL Scheme 去打开它。</li>
</ul>
<p>什么是 URL Scheme ？我们平常看到一个 URL 地址。比如：</p>
<ul>
<li><a href="https://www.qiniu.com/" target="_blank" rel="noopener">https://www.qiniu.com/</a></li>
<li><a href="ftp://example.com/hello.doc" target="_blank" rel="noopener">ftp://example.com/hello.doc</a></li>
</ul>
<p>这里面的 https 和 ftp 就是 URL Scheme，它代表了某种协议规范。在 iOS 下，一个软件可以声明自己实现了某种 URL Scheme，比如微信可能注册了“weixin”这个 URL Scheme，那么调用</p>
<pre><code>UIApplication.openURL(&quot;weixin://...&quot;) </code></pre><p>都会跳转到微信。通过这个机制，我们实现了支付宝和微信支付能力的对接。</p>
<p>URL Scheme 机制并不是 iOS 的发明，它应该是浏览器出现后形成的一种扩展机制。Windows 和 Linux 的桌面也支持类似的能力，在 Windows 下调用的是 ShellExecute 函数。</p>
<h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><p>聊完进程的启动，我们正式开始谈进程间的协同。</p>
<p>首先我们来看一下同步和互斥体。从上一讲 “<a href="https://time.geekbang.org/column/article/96994" target="_blank" rel="noopener">12 | 进程内协同：同步、互斥与通讯</a>”看，同步互斥相关的内容有：</p>
<ul>
<li>锁（Mutex）；</li>
<li>读写锁（RWMutex）；</li>
<li>信号量（Semaphore）；</li>
<li>等待组（WaitGroup）；</li>
<li>条件变量（Cond）。</li>
</ul>
<p>进程间协同来说，主流操作系统支持了锁（Mutex）和信号量（Semaphore）。Windows 还额外支持了事件（Event）同步原语，这里我们略过不提。</p>
<p>进程间的锁（Mutex），语义上和进程内没有什么区别，只不过标识互斥资源的方法不同。Windows 最简单，用名称（Name）标识资源，iOS 用路径（Path），Linux 则用共享内存。</p>
<p>从使用接口看，Windows 和 iOS 更为合理，虽然大家背后实现上可能都是基于共享内存（对用户进程来说，操作系统内核对象都是共享的），但是没必要把实现机理暴露给用户。</p>
<p>我们再看信号量。</p>
<p>信号量（Semaphore）概念是 Dijkstra（学过数据结构可能会立刻回忆起图的最短路径算法，对的，就是他发明的）提出来的。信号量本身是一个整型数值，代表着某种共享资源的数量（简记为 S）。信号量的操作界面为 PV 操作。</p>
<p>P 操作意味着请求或等待资源。执行 P 操作 P(S) 时，S 的值减 1，如果 S &lt; 0，说明没有资源可用，等待其他执行体释放资源。</p>
<p>V 操作意味着释放资源并唤醒执行体。执行 V 操作 V(S) 时，S 的值加 1，如果 S &lt;= 0，则意味着有其他执行体在等待中，唤醒其中的一个。</p>
<p>看到这里，你可能敏锐地意识到，条件变量的设计灵感实际上是从信号量的 PV 操作进一步抽象而来，只不过信号量中的变量是确定的，条件也是确定的。</p>
<p>进程间的同步与互斥原语并没有进程内那么丰富（比如没有 WaitGroup，也没有 Cond），甚至没那么牢靠。</p>
<p>为什么？因为进程可能会异常挂掉，这会导致同步和互斥的状态发生异常。比如，进程获得了锁，但是在做任务的时候异常挂掉，这会导致锁没有得到正常的释放，那么另一个等待该锁的进程可能就会永远饥饿。</p>
<p>信号量同样有类似的问题，甚至更麻烦。对锁来说，进程挂掉还可能可以把释放锁的责任交给操作系统内核。但是信号量做不到这一点，操作系统并不清楚信号量的值（S）应该是多少才是合理的。</p>
<h2 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h2><p>两个进程再怎么被隔离，只要有共同的中间人，就可以相互对话（通讯）。中间人可以是谁？共享资源。进程之间都有哪些共享的存储型资源？比较典型的是：</p>
<ul>
<li>文件系统；</li>
<li>剪贴板。</li>
</ul>
<p>文件系统本身是因存储设备的管理而来。但因为存储设备本身天然是共享资源，某个进程在存储设备上创建一个文件或目录，其他进程自然可以访问到。</p>
<p>因此，文件系统天然是一个进程间通讯的中间人。而且，在很多操作系统里面，文件的概念被抽象化，“一切皆文件”。比如，命名管道就只是一种特殊的 “文件” 而已。</p>
<p>和文件系统相关的进程间协同机制有：</p>
<ul>
<li>文件；</li>
<li>文件锁；</li>
<li>管道（包括匿名管道和命名管道）；</li>
<li>共享内存。</li>
</ul>
<p>这里我们重点介绍一下共享内存。</p>
<p>共享内存其实是虚拟内存机制的自然结果。关于虚拟内存的详细介绍，可以参阅 “<a href="https://time.geekbang.org/column/article/93802" target="_blank" rel="noopener">07 | 软件运行机制及内存管理</a>” 一讲。虚拟内存本来就需要在内存页与磁盘文件之间进行数据的保存与恢复。</p>
<p>将虚拟内存的内存页和磁盘文件的内容建立映射关系，在虚拟内存管理机制中原本就存在。</p>
<p>只需要让两个进程的内存页关联到同一个文件句柄，即可完成进程间的数据共享。这可能是性能最高的进程间数据通讯手段了。</p>
<p>Linux 的共享内存的使用界面大体是这样的：</p>
<pre><code>func Map(addr unsafe.Pointer, len int64, prot, flags int, fd int, off int64) unsafe.Pointer
func Unmap(addr unsafe.Pointer, len int64)</code></pre><p>其中，Map 是将文件 fd 中的<code>[off, off+len)</code>区间的数据，映射到<code>[addr, addr+len)</code> 这段虚拟内存地址上去。</p>
<p>addr 可以传入 nil 表示选择一段空闲的虚拟内存地址空间来进行映射。Unmap 则是将<code>[addr, addr+len)</code>这段虚拟内存地址对应的内存页取消映射，此后如果代码中还对这段内存地址进行访问，就会发生缺页异常。</p>
<p>在 Windows 下共享内存的使用界面和 Linux 略有不同，但语义上大同小异，这里略过不提。</p>
<p>真正值得注意的是 iOS，你会发现基于文件系统的进程间通讯机制，一律不支持。为什么？因为 iOS 操作系统做了一个极大的改变：软件被装到了一个沙箱（Sandbox）里面，不同进程间的存储完全隔离。</p>
<p>存储分为内存和外存。内存通过虚拟内存机制实现跨进程的隔离，这个之前我们已经谈到过。现在 iOS 更进一步，外存的文件系统也相互独立。软件 A 创建的文件，软件 B 默认情况下并不能访问。在一个个软件进程看来，自己在独享着整个外存的文件系统。</p>
<p>文件系统之外，进程间共享的存储型资源，就剩下剪贴板了。</p>
<p>但剪贴板并不是一个常规的进程间通讯方式。从进程间通讯角度来说它有很大的限制：剪贴板只有一个，有人共享数据上去，就会把别人存放的数据覆盖掉。</p>
<p>实践中，剪贴板通常作为一种用户实现跨进程交互的手段，而不太会被用来作为进程间的通讯。相反它更可能被恶意程序所利用。比如，写个木马程序来监听剪贴板，以此来窃取其他程序使用过程中留下的痕迹。</p>
<h2 id="收发消息"><a href="#收发消息" class="headerlink" title="收发消息"></a>收发消息</h2><p>那么，不用文件系统和剪贴板这样的共享资源，还有其他的通讯机制么？</p>
<p><strong>有，基于网络。很重要的一个事实是：这些进程同在一台机器上，同在一个局域网中。</strong></p>
<p>套接字作为网络通讯的抽象，本身就是最强大的通讯方式，没有之一。进程间基于套接字来进行通讯，也是极其自然的一个选择。</p>
<p>况且，UNIX 还发明了一个专门用于本地通讯的套接字：UNIX 域。UNIX 域不同于常规套接字的是，它通过一个 name 来作为访问地址，而不是用<code>ip:port</code>来作为访问地址。</p>
<p>Windows 平台并不支持 UNIX 域。但是有趣的是，Windows 的命名管道（NamedPipe）也不是一个常规意义上的管道那么简单，它更像是一个管道服务器（PipeServer），一个客户端连上来可以分配一个独立的管道给服务器和客户端进行通讯。从这个事实看，Windows 的命名管道和 UNIX 域在能力上是等价的。</p>
<p>关于套接字更详细的内容，后文在讨论网络设备管理时我们会进一步介绍。</p>
<h2 id="架构思维上我们学习到什么？"><a href="#架构思维上我们学习到什么？" class="headerlink" title="架构思维上我们学习到什么？"></a>架构思维上我们学习到什么？</h2><p>对比不同操作系统的进程间协同机制，差异无疑是非常巨大的。</p>
<p>总结来说，进程间协同的机制真的很多了，五花八门，我们这里不见得就列全了。但是有趣的是，iOS 把其中绝大部分的协同机制给堵死了。</p>
<p>创新性的系统往往有其颠覆性，带着批判吸收的精神而来，做的是大大的减法。</p>
<p>iOS 就是这样的一个操作系统。它告诉我们：</p>
<ul>
<li>软件不需要启动多份实例。一个软件只需启动一个进程实例。</li>
<li>大部分进程间的协同机制都是多余的。你只需要能够调用其他软件的能力（URL Scheme）、能够互斥、能够收发消息就够了。</li>
</ul>
<p>这的确是一个让人五体投地的决策。虽然从进程间协同机制的角度，看起来 iOS 少了很多能力。但这恰恰也给了我们一个启示：这么多的进程通讯机制，是否都是必需的？</p>
<p>至少从桌面操作系统的视角看，进程间协同的机制，大部分都属于过度设计。当然，后面在 “服务端开发” 一章中，我们也会继续站在服务端开发视角来谈论这个话题。</p>
<p>并不是早期操作系统的设计者们喜欢过度设计。实际上这是因为有了线程和协程这样的进程内多任务设施之后，进程的边界已经发生了极大的变化。</p>
<p>前面我们讨论架构思维的时候说过，架构的第一步是做需求分析。那么需求分析之后呢？是概要设计。概要设计做什么？是做子系统的划分。它包括这样一些内容：</p>
<ul>
<li>子系统职责范围的定义；</li>
<li>子系统的规格（接口），子系统与子系统之间的边界；</li>
<li>需求分解与组合的过程，系统如何满足需求、需求适用性（变化点）的应对策略。</li>
</ul>
<p>从架构角度来看，进程至少应该是子系统级别的边界。子系统和子系统应该尽可能是规格级别的协同，而不是某种实现框架级别的协同。规格强调的是自然体现需求，所以规格是稳定的，是子系统的契约。而实现框架是技巧，是不稳定的，也许下次重构的时候实现框架就改变了。</p>
<p>所以站在架构视角，站在子系统的边界看进程边界，我们就很清楚，进程间协同只需要有另一个进程能力的调用，而无需有复杂的高频协作、高度耦合的配合需求。</p>
<p>不过，为什么 iOS 会如此大刀阔斧地做出改变，除了这些机制的确多余之外，还有一个极其核心的原因，那就是安全。关于这一点，我们在后面探讨操作系统的安全管理时，会进一步进行分析。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天我们从进程启动开始入手，介绍了同步与互斥、资源共享、收发消息等进程间的协同机制。通过对比不同操作系统，我们会发现以 “剧烈变动” 来形容进程间协同的需求演进一点也不过分。</p>
<p>我认为 iOS 是对的。大刀阔斧干掉很多惯例要支持的功能后，进程这个执行体，相比线程和协程就有了更为清晰的分工。</p>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。到这一讲为止，我们单机软件相关的内容就介绍完了。从下一讲开始我们将进入多姿多彩的互联网世界。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:07:26.496Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    27 minutes read (About 3977 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/12 | 进程内协同：同步、互斥与通讯/">12 | 进程内协同：同步、互斥与通讯</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>上一讲开始我们进入了多任务的世界，我们详细介绍了三类执行体：进程、线程和协程，并且介绍了每一种执行体的特点。</p>
<p>既然启动了多个执行体，它们就需要相互协同，今天我们先讨论进程内的执行体协同。</p>
<p>考虑到进程内的执行体有两类：用户态的协程（以 Go 语言的 goroutine 为代表）、操作系统的线程，我们对这两类执行体的协同机制做个概要。如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/57/1b/575d31c0ebf3f4a6148a211387bdae1b.jpg" alt></p>
<p>让我们逐一详细分析一下它们。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>首先让我们看一下原子操作。需要注意的是，原子操作是 CPU 提供的能力，与操作系统无关。这里列上只是为了让你能够看到进程内通讯的全貌。</p>
<p>顾名思义，原子操作的每一个操作都是原子的，不会中途被人打断，这个原子性是 CPU 保证的，与执行体的种类无关，无论 goroutine 还是操作系统线程都适用。</p>
<p>从语义上来说，原子操作可以用互斥体来实现，只不过原子操作要快得多。</p>
<p>例如：</p>
<pre><code>var val int32
...
newval = atomic.AddInt32(&amp;val, delta)</code></pre><p>等价于：</p>
<pre><code>var val int32
var mutex sync.Mutex
...
mutex.Lock()
val += delta
newval = val
mutex.Unlock()</code></pre><h2 id="执行体的互斥"><a href="#执行体的互斥" class="headerlink" title="执行体的互斥"></a>执行体的互斥</h2><p>互斥体也叫锁。锁用于多个执行体之间的互斥访问，避免多个执行体同时操作一组数据产生竞争。其使用界面上大概是这样的：</p>
<pre><code>func (m *Mutex) Lock()
func (m *Mutex) Unlock()</code></pre><p>锁的使用范式比较简单：在操作需要互斥的数据前，先调用 Lock，操作完成后就调用 Unlock。但总是存在一些不求甚解的人，对锁存在各种误解。</p>
<p>有的人会说锁很慢。甚至我曾看到有 Go 程序员用 channel 来模拟锁，理由就是锁太慢了，尽量不要用锁。产生“锁慢，channel 快”这种错觉的一个原因，可能是人们经常看到这样的忠告：</p>
<blockquote>
<p><strong>不要通过共享内存（锁）来通信，要通过通信（channel）来共享内存。</strong></p>
</blockquote>
<p>不明就里的人们看到这话后，可能就有了这样的印象：锁是坏的，锁是性能杀手，channel 是好的，是 Go 发明的先进武器，应该尽可能用 channel，而不要用锁。</p>
<p>快慢是相对而言的。锁的确会导致代码串行执行，所以在某段代码并发度非常高的情况下，串行执行的确会导致性能的显著降低。但平心而论，相比其他的进程内通讯的原语来说，锁并不慢。从进程内通讯来说，比锁快的东西，只有原子操作。</p>
<p>例如 channel，作为进程内执行体间传递数据的设施来说，它本身是共享变量，所以 channel 的每个操作必然是有锁的。事实上，channel 的每个操作都比较耗时。关于这一点，在下文解释 channel 背后的工作机理后，你就会清楚知道。</p>
<p>那么锁的问题在哪里？锁的最大问题在于不容易控制。锁 Lock 了但是忘记 Unlock 后是灾难性的，因为相当于服务器挂了，所有和该锁相关的代码都不能被执行。</p>
<p>比如：</p>
<pre><code>mutex.Lock()
doSth()
mutex.Unlock()</code></pre><p>在考虑异常的情况下，这段代码是不安全的，如果 doSth 抛出了异常，那么服务器就会出现问题。</p>
<p>为此 Go 语言还专门发明了一个 defer 语法来保证配对：</p>
<pre><code>mutex.Lock()
defer mutex.Unlock()
doSth()</code></pre><p>这样可以保证即使 doSth 发生异常，mutex.Unlock 仍然会被正确地执行。这类在异常情况下也能够正常工作的代码，我们称之为 “对异常安全的代码”。如果语言不支持 defer，而是支持 try … catch，那么代码可能是这样的：</p>
<pre><code>mutex.Lock()
try {
    doSth()
} catch (e Exception) {
    mutex.Unlock()
    throw e
}
mutex.Unlock()</code></pre><p>锁不容易控制的另一个表现是锁粒度的问题。例如上面 doSth 函数里面如果调用了网络 IO 请求，而网络 IO 请求在少数特殊情况下可能会出现慢请求，要好几秒才返回。那么这几秒对服务器来说就好像挂了，无法处理请求。</p>
<p>对服务器来说这是极为致命的。对后端程序员来说，有一句箴言要牢记：</p>
<blockquote>
<p><strong>不要在锁里面执行费时操作。</strong></p>
</blockquote>
<p>这里 “锁里面” 是指在<code>mutex.Lock</code>和<code>mutex.Unlock</code>之间的代码。</p>
<p>在锁的最佳编程实践中，如果明确一组数据的并发访问符合 “绝大部分情况下是读操作，少量情况有写操作” ，这种 “读多写少” 特征，那么应该用读写锁。</p>
<p>所谓读写锁，是把锁里面的操作分为读操作和写操作两种，对应调用不同的互斥操作。</p>
<p>如果是读操作，代码如下：</p>
<pre><code>mutex.RLock()
defer mutex.RUnlock()
doReadOnlyThings</code></pre><p>如果是锁里面是写操作，代码就和普通锁一样，如下：</p>
<pre><code>mutex.Lock()
defer mutex.Unlock()
doWriteThings</code></pre><p>为什么在 “读多写少” 的情况下，这样的使用范式能够优化性能？</p>
<p>因为从需求上来说，如果当前我们正在执行某个读操作，那么再来一个新的读操作，是不应该挡在外面的，大家都不修改数据，可以安全地并发执行。但如果来的是写操作，就应该挡在外面，等待读操作执行完。整体来说，读写锁的特性就是：</p>
<blockquote>
<p><strong>读操作不阻止读操作，阻止写操作；</strong><br><strong>写操作阻止一切，不管读操作还是写操作。</strong></p>
</blockquote>
<h2 id="执行体的同步"><a href="#执行体的同步" class="headerlink" title="执行体的同步"></a>执行体的同步</h2><p>聊完了执行体的互斥，我们再来看下执行体之间的同步。</p>
<p>同步的一个最常见的场景是：把一个大任务分解为n个小任务，分配给n个执行体并行去做，等待它们一起做完。这种同步机制我们叫 “等待组”。</p>
<p>其使用界面上大概是这样的：</p>
<pre><code>func (wg *WaitGroup) Add(n int)
func (wg *WaitGroup) Done()
func (wg *WaitGroup) Wait()</code></pre><p>用法上大概是这样的：</p>
<pre><code>var wg WaitGroup
...
wg.Add(n)
for 循环n次 {
    go func() {
        defer wg.Done()
        doTaski  // 执行第i个任务
    }()
}
wg.Wait()</code></pre><p>简而言之，在每个任务开始的时候调用 wg.Add(1)，结束的时候调用 wg.Done()，然后在主执行体调用 wg.Wait() 等待这些任务结束。</p>
<p>需要注意的是，wg.Add(1) 是要在任务的 goroutine 还没有开始就先调用，否则可能出现某个任务还没有开始执行就被认为结束了。</p>
<p>条件变量（Condition Variable）是一个更通用的同步原语，设计精巧又极为强大。强大到什么程度？像 channel 这样的通讯机制都可以用它来实现。</p>
<p>条件变量的使用界面上大概是这样的：</p>
<pre><code>func NewCond(l Locker) *Cond
func (c *Cond) Broadcast()
func (c *Cond) Signal()
func (c *Cond) Wait()</code></pre><p>那么，怎么用条件变量？</p>
<p>我们先看下初始化。条件变量初始化的时候需要传入一个互斥体，它可以是普通锁（Mutex)，也可以是读写锁（RWMutex）。如下：</p>
<pre><code>var mutex sync.Mutex  // 也可以是 sync.RWMutex
var cond = sync.NewCond(&amp;mutex)
...</code></pre><p>为什么创建条件变量需要传入锁？因为 cond.Wait() 的需要。Wait 内部实现逻辑是：</p>
<pre><code>把自己加入到挂起队列
mutex.Unlock()
等待被唤醒  // 挂起的执行体会被后续的 cond.Broadcast 或 cond.Signal() 唤醒
mutex.Lock()</code></pre><p>初始化了条件变量后，我们再来看看它的使用方式。条件变量的用法有一个标准化的模板，看起来大概是这样的：</p>
<pre><code>mutex.Lock()
defer mutex.Unlock()
for conditionNotMetToDo {
    cond.Wait()
}
doSomething
if conditionNeedNotify {
    cond.Broadcast()
    // 有时可以优化为 cond.Signal()
}</code></pre><p>看起来有些复杂，让我们来解释一下。加锁后，先用一个 for 循环判断当前是否能够做我们想做的事情，如果做不了就调用 cond.Wait() 进行等待。</p>
<p>这里很重要的一个细节是注意用的是 for 循环，而不是 if 语句。这是因为 cond.Wait() 得到了执行权后不代表我们想做的事情就一定能够干了，所以要再重新判断一次条件是否满足。</p>
<p>确定能够做事情了，于是 doSomething。在做的过程中间，如果我们判断可能挂起队列中的部分执行体满足了重新执行的条件，就用 cond.Broadcast 或 cond.Signal 唤醒它们。</p>
<p>cond.Broadcast 比较粗暴，它唤醒了所有在这个条件变量挂起的执行体，而 cond.Signal 则只唤醒其中的一个。</p>
<p>什么情况下应该用 cond.Broadcast，什么情况下应该用 cond.Signal？最偷懒的方式当然是不管三七二十一，用 cond.Broadcast 一定没问题。但是本着经济的角度，我们还是要交代清楚 cond.Signal 的适用范围：</p>
<ul>
<li>挂起在这个条件变量上的执行体，它们等待的条件是一致的；</li>
<li>本次 doSomething 操作完成后，所释放的资源只够一个执行体来做事情。</li>
</ul>
<p>Cond 原语虽然叫条件变量，但是实际上它既没有明白说变量具体是什么样的，也没有说条件具体是什么样的。变量是指 “一组要在多个执行体之间协同的数据”。条件是指做任务前 Wait 的 “前置条件”，和做任务时需要唤醒其它人的 “唤醒条件”。</p>
<p>这样的介绍相当的抽象。我们拿 Go 语言的 channel 开刀，自己实现一个。代码如下：</p>
<pre><code>type Channel struct {
    mutex sync.Mutex
    cond *sync.Cond
    queue *Queue
    n int
}

func NewChannel(n int) *Channel {
    if n &lt; 1 {
        panic(&quot;todo: support unbuffered channel&quot;)
    }
    c := new(Channel)
    c.cond = sync.NewCond(&amp;c.mutex)
    c.queue = NewQueue()
    // 这里 NewQueue 得到一个普通的队列
    // 代码从略
    c.n = n
    return c
}

func (c *Channel) Push(v interface{}) {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    for c.queue.Len() == c.n { // 等待队列不满
        c.cond.Wait()
    }
    if c.queue.Len() == 0 { // 原来队列是空的，可能有人等待数据，通知它们
        c.cond.Broadcast()
    }
    c.queue.Push(v)
}

func (c *Channel) Pop() (v interface{}) {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    for c.queue.Len() == 0 { // 等待队列不空
        c.cond.Wait()
    }
    if c.queue.Len() == c.n { // 原来队列是满的，可能有人等着写数据，通知它们
        c.cond.Broadcast()
    }
    return c.queue.Pop()
}

func (c *Channel) TryPop() (v interface{}, ok bool) {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    if c.queue.Len() == 0 { // 如果队列为空，直接返回
        return
    }
    if c.queue.Len() == c.n { // 原来队列是满的，可能有人等着写数据，通知它们
        c.cond.Broadcast()
    }
    return c.queue.Pop(), true
}

func (c *Channel) TryPush(v interface{}) (ok bool) {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    if c.queue.Len() == c.n { // 如果队列满，直接返回
        return
    }
    if c.queue.Len() == 0 { // 原来队列是空的，可能有人等待数据，通知它们
        c.cond.Broadcast()
    }
    c.queue.Push(v)
    return true
}</code></pre><p>对着这个 Channel 的实现，你是否对条件变量有感觉很多？顺便提醒一点，这个 Channel 的实现不支持无缓冲 channel，也就是不支持 NewChannel(0) 的情况。如果你感兴趣，可以改改这个问题。</p>
<h2 id="执行体的通讯"><a href="#执行体的通讯" class="headerlink" title="执行体的通讯"></a>执行体的通讯</h2><p>聊完同步与互斥，我们接着聊执行体的通讯：怎么在执行体间收发消息。</p>
<p>管道是大家都很熟知的执行体间的通讯机制。规格如下：</p>
<pre><code>func Pipe() (pr *PipeReader, pw PipeWriter)</code></pre><p>用法上，先调用<code>pr, pw := io.Pipe()</code>得到管道的写入端和读出端，分别传给两个并行执行的 goroutine（其他语言也类似），然后一个 goroutine 读，一个 goroutine 写就好了。</p>
<p>管道用处很多。一个比较常见的用法是做读写转换，例如，假设我手头有一个算法：</p>
<pre><code>func Foo(w io.Writer) error</code></pre><p>这个算法生成的数据流，需要作为另一个函数的输入，但是这个函数的输入是 io.Reader，原型如下：</p>
<pre><code>func Bar(r io.Reader)</code></pre><p>那么怎么把它们串起来呢？用管道我们很容易实现这样的变换：</p>
<pre><code>func FooReader() io.ReadCloser {
    pr, pw := io.Pipe()
    go func() {
        err := Foo(pw)
        pw.CloseWithError(err)
    }()
    return pr
}</code></pre><p>这个 FooReader 函数几句话就把 Foo 变成了一个符合 io.Reader 接口的对象，它就可以很方便的和 Bar 函数结合了。</p>
<p>其实 Go 语言中引入的 channel 也是管道，只不过它是类型安全的管道。具体用法如下：</p>
<pre><code>c := make(chan Type, n) // 创建一个能够传递 Type 类型数据的管道，缓冲大小为 n
...
go func() {
    val := &lt;-c // 从管道读入
}()
...
go func() {
    c &lt;- val // 向管道写入
}()</code></pre><p>我们后面在 “服务端开发” 一章，我们还会比较详细讨论 channel，今天先了解一个大体的语义。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总结一下，我们今天主要聊了执行体间的协同机制：原子操作、同步、互斥与通讯。我们重点聊了锁和同步原语 “条件变量”。</p>
<p>锁在一些人心中是有误解的，但实际上锁在服务端编程中的比重并不低，我们可能经常需要和它打交道，建议多花精力理解它们。</p>
<p>条件变量是最复杂的同步原语，功能强大。虽然平常我们直接使用条件变量的机会不是太多，大部分常见的场景往往有更高阶的原语（例如 channel）可以取代。但是它的设计精巧而高效，值得细细体会。</p>
<p>你会发现，操作系统课本上的信号量这样的同步原语，我们这里没有交代，这是因为它被更强大而且性能更好的同步原语 “条件变量” 所取代了。</p>
<p>上面我们为了介绍条件变量的用法，我们实作了一个 channel，你也可以考虑用信号量这样的东西来实现一遍，然后分析一下为什么我们说基于 “条件变量” 的版本是更优的。</p>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。在下期，我们将讨论进程与进程之间的协同：进程间的同步互斥、资源共享与通讯。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>









    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous">
            <a class="is-flex-grow has-text-black-ter" href="/page/2/">Préc</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/page/4/">Suiv</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link has-text-black-ter" href="/">1</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/2/">2</a></li>
            
            <li><a class="pagination-link is-current" href="/page/3/">3</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/4/">4</a></li>
            
            <li><span class="pagination-ellipsis has-text-black-ter">&hellip;</span></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/10/">10</a></li>
            
        </ul>
    </nav>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                        <figure class="image is-128x128 has-mb-6">
                            <img class="is-rounded" src="https://ws2.sinaimg.cn/large/0067tbKZgy1g6j281yfbqj30ox0oxq41.jpg" alt="xcool">
                        </figure>
                    
                    
                    <p class="is-size-4 is-block">
                        xcool
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        enchanter
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>http://www.enchanter.tech</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Articles
                    </p>
                    <p class="title has-text-weight-normal">
                        99
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Catégories
                    </p>
                    <p class="title has-text-weight-normal">
                        2
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Tags
                    </p>
                    <p class="title has-text-weight-normal">
                        0
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/zhangxiongxin/blog" target="_blank">
                SUIVRE</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Github" href="https://github.com/zhangxiongxin">
                
                <i class="fab fa-github"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
        


    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Catégories
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/许世伟的架构课/">
            <span class="level-start">
                <span class="level-item">许世伟的架构课</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">42</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/重学前端/">
            <span class="level-start">
                <span class="level-item">重学前端</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">57</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Nuage de tags
        </h3>
        
    </div>
</div>

    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Récents
        </h3>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/37 | 键值存储与数据库/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="37 | 键值存储与数据库">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:23.566Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/37 | 键值存储与数据库/" class="title has-link-black-ter is-size-6 has-text-weight-normal">37 | 键值存储与数据库</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/36 | 业务状态与存储中间件/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="36 | 业务状态与存储中间件">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:21.648Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/36 | 业务状态与存储中间件/" class="title has-link-black-ter is-size-6 has-text-weight-normal">36 | 业务状态与存储中间件</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/35 | 流量调度与负载均衡/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="35 | 流量调度与负载均衡">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:19.672Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/35 | 流量调度与负载均衡/" class="title has-link-black-ter is-size-6 has-text-weight-normal">35 | 流量调度与负载均衡</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/34 | 服务端开发的宏观视角/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="34 | 服务端开发的宏观视角">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:17.750Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/34 | 服务端开发的宏观视角/" class="title has-link-black-ter is-size-6 has-text-weight-normal">34 | 服务端开发的宏观视角</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/33 | 桌面开发篇：回顾与总结/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="33 | 桌面开发篇：回顾与总结">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:15.818Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/33 | 桌面开发篇：回顾与总结/" class="title has-link-black-ter is-size-6 has-text-weight-normal">33 | 桌面开发篇：回顾与总结</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">August 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">99</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
            </div>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Récents
        </h3>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/37 | 键值存储与数据库/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="37 | 键值存储与数据库">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:23.566Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/37 | 键值存储与数据库/" class="title has-link-black-ter is-size-6 has-text-weight-normal">37 | 键值存储与数据库</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/36 | 业务状态与存储中间件/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="36 | 业务状态与存储中间件">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:21.648Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/36 | 业务状态与存储中间件/" class="title has-link-black-ter is-size-6 has-text-weight-normal">36 | 业务状态与存储中间件</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/35 | 流量调度与负载均衡/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="35 | 流量调度与负载均衡">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:19.672Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/35 | 流量调度与负载均衡/" class="title has-link-black-ter is-size-6 has-text-weight-normal">35 | 流量调度与负载均衡</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/34 | 服务端开发的宏观视角/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="34 | 服务端开发的宏观视角">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:17.750Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/34 | 服务端开发的宏观视角/" class="title has-link-black-ter is-size-6 has-text-weight-normal">34 | 服务端开发的宏观视角</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/33 | 桌面开发篇：回顾与总结/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="33 | 桌面开发篇：回顾与总结">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:15.818Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/33 | 桌面开发篇：回顾与总结/" class="title has-link-black-ter is-size-6 has-text-weight-normal">33 | 桌面开发篇：回顾与总结</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">August 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">99</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="Enchanter" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2019 xcool&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("en");</script>

<script>
var IcarusThemeSettings = {
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>



    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Articles',
                PAGES: 'Pages',
                CATEGORIES: 'Catégories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>