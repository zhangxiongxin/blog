<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 3.9.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>Enchanter</title>


    <meta property="og:type" content="website">
<meta property="og:title" content="Enchanter">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Enchanter">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/images/og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Enchanter">
<meta name="twitter:image" content="http://yoursite.com/images/og_image.png">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="Enchanter" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">Home</a>
                
                <a class="navbar-item"
                href="/categories">Categories</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="Search" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main">
    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:03:00.818Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/重学前端/">重学前端</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    15 minutes read (About 2294 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/重学前端/JavaScript语法（预备篇）：到底要不要写分号呢？/">JavaScript语法（预备篇）：到底要不要写分号呢？</a>
            
        </h1>
        <div class="content">
            <p>你好，我是winter。</p>
<p>在我们介绍JavaScript语法的全局结构之前，我们先要探讨一个语言风格问题：究竟要不要写分号。</p>
<p>这是一个非常经典的口水问题，“加分号”党和“不写分号”党之间的战争，可谓是经久不息。</p>
<p>实际上，行尾使用分号的风格来自于Java，也来自于C语言和C++，这一设计最初是为了降低编译器的工作负担。</p>
<p>但是，从今天的角度来看，行尾使用分号其实是一种语法噪音，恰好JavaScript语言又提供了相对可用的分号自动补全规则，所以，很多JavaScript的程序员都是倾向于不写分号。</p>
<p>这里要特意说一点，在今天的文章中，我并不希望去售卖自己的观点（其实我是属于“加分号”党），而是希望比较中立地给你讲清楚相关的知识，让你具备足够的判断力。</p>
<p>我们首先来了解一下自动插入分号的规则。</p>
<h2 id="自动插入分号规则"><a href="#自动插入分号规则" class="headerlink" title="自动插入分号规则"></a>自动插入分号规则</h2><p>自动插入分号规则其实独立于所有的语法产生式定义，它的规则说起来非常简单，只有三条。</p>
<ul>
<li>要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。</li>
<li>有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。</li>
<li>源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。</li>
</ul>
<p>这样描述是比较难以理解的，我们一起看一些实际的例子进行分析：</p>
<pre><code>let a = 1
void function(a){
    console.log(a);
}(a);</code></pre><p>在这个例子中，第一行的结尾处有换行符，接下来void关键字接在1之后是不合法的，这命中了我们的第一条规则，因此会在void前插入换行符。</p>
<pre><code>var a = 1, b = 1, c = 1;
a
++
b
++
c</code></pre><p>这也是个著名的例子，我们看第二行的a之后，有换行符，后面遇到了++运算符，a后面跟++是合法的语法，但是我们看看JavaScript标准定义中，有[no LineTerminator here]这个字样，这是一个语法定义中的规则，你可以感受一下这个规则的内容（下一小节，我会给你详细介绍no LineTerminator here ）：</p>
<pre><code>UpdateExpression[Yield, Await]:
    LeftHandSideExpression[?Yield, ?Await]
    LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]++
    LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]--
    ++UnaryExpression[?Yield, ?Await]
    --UnaryExpression[?Yield, ?Await]</code></pre><p>于是，这里a的后面就要插入一个分号了。所以这段代码最终的结果，b和c都变成了2，而a还是1。</p>
<pre><code>(function(a){
    console.log(a);
})()
(function(a){
    console.log(a);
})()</code></pre><p>这个例子是比较有实际价值的例子，这里两个function调用的写法被称作IIFE（立即执行的函数表达式），是个常见技巧。</p>
<p>这段代码意图上显然是形成两个IIFE。</p>
<p>我们来看第三行结束的位置，JavaScript引擎会认为函数返回的可能是个函数，那么，在后面再跟括号形成函数调用就是合理的，因此这里不会自动插入分号。</p>
<p>这是一些鼓励不写分号的编码风格会要求大家写IIFE时必须在行首加分号的原因。</p>
<pre><code>function f(){
    return/*
        This is a return value.
    */1;
}
f();</code></pre><p>在这个例子中，return和1被用注释分隔开了。</p>
<p>根据JavaScript自动插入分号规则，<strong>带换行符的注释也被认为是有换行符</strong>，而恰好的是，return也有[no LineTerminator here]规则的要求。所以这里会自动插入分号，f执行的返回值是undefined。</p>
<h2 id="no-LineTerminator-here-规则"><a href="#no-LineTerminator-here-规则" class="headerlink" title="no LineTerminator here 规则"></a>no LineTerminator here 规则</h2><p>好了，到这里我们已经讲清楚了分号自动插入的规则，但是我们要想彻底掌握分号的奥秘，就必须要对JavaScript的语法定义做一些数据挖掘工作。</p>
<p>no LineTerminator here规则表示它所在的结构中的这一位置不能插入换行符。</p>
<p>自动插入分号规则的第二条：有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。跟no LineTerminator here规则强相关，那么我们就找出JavaScript语法定义中的这些规则。</p>
<p><img src="https://static001.geekbang.org/resource/image/c3/ad/c3ffbc89e049ad1901d4108c8ad88aad.jpg" alt></p>
<p>为了方便你理解，我把产生式换成了实际的代码。</p>
<p>下面一段代码展示了，带标签的continue语句，不能在continue后插入换行。</p>
<pre><code>outer:for(var j = 0; j &lt; 10; j++)
    for(var i = 0; i &lt; j; i++)
        continue /*no LineTerminator here*/ outter</code></pre><p>break跟continue是一样的，break后也不能插入换行：</p>
<pre><code>outer:for(var j = 0; j &lt; 10; j++)
    for(var i = 0; i &lt; j; i++)
        break /*no LineTerminator here*/ outter</code></pre><p>我们前面已经提到过return和后自增、后自减运算符。</p>
<pre><code>function f(){
    return /*no LineTerminator here*/1;
}


i/*no LineTerminator here*/++
i/*no LineTerminator here*/--</code></pre><p>以及，throw和Exception之间也不能插入换行符：</p>
<pre><code>throw/*no LineTerminator here*/new Exception(&quot;error&quot;)</code></pre><p>凡是async关键字，后面都不能插入换行符：</p>
<pre><code>async/*no LineTerminator here*/function f(){

}
const f = async/*no LineTerminator here*/x =&gt; x*x</code></pre><p>箭头函数的箭头前，也不能插入换行：</p>
<pre><code>const f = x/*no LineTerminator here*/=&gt; x*x</code></pre><p>yield之后，不能插入换行：</p>
<pre><code>function *g(){
    var i = 0;
    while(true)
        yield/*no LineTerminator here*/i++;
}</code></pre><p>到这里，我已经整理了所有标准中的no LineTerminator here规则，实际上，no LineTerminator here规则的存在，多数情况是为了保证自动插入分号行为是符合预期的，但是令人遗憾的是，JavaScript在设计的最初，遗漏了一些重要的情况，所以有一些不符合预期的情况出现，需要我们格外注意。</p>
<h2 id="不写分号需要注意的情况"><a href="#不写分号需要注意的情况" class="headerlink" title="不写分号需要注意的情况"></a>不写分号需要注意的情况</h2><p>下面我们来看几种不写分号容易造成错误的情况，你可以稍微注意一下，避免发生同样的问题。</p>
<h3 id="以括号开头的语句"><a href="#以括号开头的语句" class="headerlink" title="以括号开头的语句"></a>以括号开头的语句</h3><p>我们在前面的案例中，已经展示了一种情况，那就是以括号开头的语句：</p>
<pre><code>(function(a){
    console.log(a);
})()/*这里没有被自动插入分号*/
(function(a){
    console.log(a);
})()</code></pre><p>这段代码看似两个独立执行的函数表达式，但是其实第三组括号被理解为传参，导致抛出错误。</p>
<h3 id="以数组开头的语句"><a href="#以数组开头的语句" class="headerlink" title="以数组开头的语句"></a>以数组开头的语句</h3><p>除了括号，以数组开头的语句也十分危险：</p>
<pre><code>var a = [[]]/*这里没有被自动插入分号*/
[3, 2, 1, 0].forEach(e =&gt; console.log(e))</code></pre><p>这段代码本意是一个变量a赋值，然后对一个数组执行forEach，但是因为没有自动插入分号，被理解为下标运算符和逗号表达式，我这个例子展示的情况，甚至不会抛出错误，这对于代码排查问题是个噩梦。</p>
<h3 id="以正则表达式开头的语句"><a href="#以正则表达式开头的语句" class="headerlink" title="以正则表达式开头的语句"></a>以正则表达式开头的语句</h3><p>正则表达式开头的语句也值得你去多注意一下。我们来看这个例子。</p>
<pre><code>var x = 1, g = {test:()=&gt;0}, b = 1/*这里没有被自动插入分号*/
/(a)/g.test(&quot;abc&quot;)
console.log(RegExp.$1)</code></pre><p>这段代码本意是声明三个变量，然后测试一个字符串中是否含有字母a，但是因为没有自动插入分号，正则的第一个斜杠被理解成了除号，后面的意思就都变了。</p>
<p>注意，我构造的这个例子跟上面的例子一样，同样不会抛错，凡是这一类情况，都非常致命。</p>
<h3 id="以Template开头的语句"><a href="#以Template开头的语句" class="headerlink" title="以Template开头的语句"></a>以Template开头的语句</h3><p>以Template开头的语句比较少见，但是跟正则配合时，仍然不是不可能出现：</p>
<pre><code>var f = function(){
  return &quot;&quot;;
}
var g = f/*这里没有被自动插入分号*/
`Template`.match(/(a)/);
console.log(RegExp.$1)</code></pre><p>这段代码本意是声明函数f，然后赋值给g，再测试Template中是否含有字母a。但是因为没有自动插入分号，函数f被认为跟Template一体的，进而被莫名其妙地执行了一次。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一节课，我们讨论了要不要加分号的问题。</p>
<p>首先我们介绍了自动插入分号机制，又对JavaScript语法中的no line terminator规则做了个整理，最后，我挑选了几种情况，为你介绍了不写分号需要注意的一些常见的错误。</p>
<p>最后留给你一个问题，请找一些开源项目，看看它们的编码规范是否要求加分号，欢迎留言讨论。</p>
<p><img src="https://static001.geekbang.org/resource/image/7c/b1/7ca7c24e92d25bde2e8609ed5386b5b1.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:02:58.910Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/重学前端/">重学前端</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    14 minutes read (About 2043 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/重学前端/（小实验）理解编译原理：一个四则运算的解释器/">（小实验）理解编译原理：一个四则运算的解释器</a>
            
        </h1>
        <div class="content">
            <p>你好，我是winter。</p>
<p>在前面的课程中，我在JavaScript和CSS的部分，多次提到了编译原理相关的知识。这一部分的知识，如果我们从编译原理“龙书”等正规的资料中学习，就会耗费掉不少的时间，所以我在这里设计了一个小实验，帮助你快速理解编译原理相关的知识。</p>
<p>今天的内容比较特殊，我们来做一段详细的代码实验，详细的代码我放在了文章里，如果你正在收听音频，可以点击文章查看详情。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>按照编译原理相关的知识，我们来设计一下工作，这里我们分成几个步骤。</p>
<ul>
<li>定义四则运算：产出四则运算的词法定义和语法定义。</li>
<li>词法分析：把输入的字符串流变成token。</li>
<li>语法分析：把token变成抽象语法树AST。</li>
<li>解释执行：后序遍历AST，执行得出结果。</li>
</ul>
<h2 id="定义四则运算"><a href="#定义四则运算" class="headerlink" title="定义四则运算"></a>定义四则运算</h2><p>四则运算就是加减乘除四种运算，例如：</p>
<pre><code>1 + 2 * 3</code></pre><p>首先我们来定义词法，四则运算里面只有数字和运算符，所以定义很简单，但是我们还要注意空格和换行符，所以词法定义大概是下面这样的。</p>
<ul>
<li><p>Token</p>
</li>
<li><p>Number: <code>1``2``3``4``5``6``7``8``9``0</code> 的组合</p>
</li>
<li><p>Operator: <code>+</code> 、<code>-</code>、 <code>*</code>、 <code>/</code> 之一</p>
</li>
<li><p>Whitespace: <code>&lt;sp&gt;</code></p>
</li>
<li><p>LineTerminator：<code>&lt;LF&gt;``&lt;CR&gt;</code></p>
</li>
</ul>
<p>这里我们对空白和换行符没有任何的处理，所以词法分析阶段会直接丢弃。</p>
<p>接下来我们来定义语法，语法定义多数采用BNF，但是其实大家写起来都是乱写的，比如JavaScript标准里面就是一种跟BNF类似的自创语法。</p>
<p>不过语法定义的核心思想不会变，都是几种结构的组合产生一个新的结构，所以语法定义也叫语法产生式。</p>
<p>因为加减乘除有优先级，所以我们可以认为加法是由若干个乘法再由加号或者减号连接成的：</p>
<pre><code>&lt;Expression&gt; ::= 
    &lt;AdditiveExpression&gt;&lt;EOF&gt;

&lt;AdditiveExpression&gt; ::= 
    &lt;MultiplicativeExpression&gt;
    |&lt;AdditiveExpression&gt;&lt;+&gt;&lt;MultiplicativeExpression&gt;
    |&lt;AdditiveExpression&gt;&lt;-&gt;&lt;MultiplicativeExpression&gt;</code></pre><p>这种BNF的写法类似递归的原理，你可以理解一下，它表示一个列表。为了方便，我们把普通数字也得当成乘法的一种特例了。</p>
<pre><code>&lt;MultiplicativeExpression&gt; ::= 
    &lt;Number&gt;
    |&lt;MultiplicativeExpression&gt;&lt;*&gt;&lt;Number&gt;
    |&lt;MultiplicativeExpression&gt;&lt;/&gt;&lt;Number&gt;</code></pre><p>好了，这就是四则运算的定义了。</p>
<h2 id="词法分析：状态机"><a href="#词法分析：状态机" class="headerlink" title="词法分析：状态机"></a>词法分析：状态机</h2><p>词法分析部分，我们把字符流变成token流。词法分析有两种方案，一种是状态机，一种是正则表达式，它们是等效的，选择你喜欢的就好，这里我都会你介绍一下状态机。</p>
<p>根据分析，我们可能产生四种输入元素，其中只有两种token，我们状态机的第一个状态就是根据第一个输入字符来判断进入了哪种状态：</p>
<pre><code>var token = [];
const start = char =&gt; {
    if(char === &apos;1&apos; 
        || char === &apos;2&apos;
        || char === &apos;3&apos;
        || char === &apos;4&apos;
        || char === &apos;5&apos;
        || char === &apos;6&apos;
        || char === &apos;7&apos;
        || char === &apos;8&apos;
        || char === &apos;9&apos;
        || char === &apos;0&apos;
    ) {
        token.push(char);
        return inNumber;   
    }
    if(char === &apos;+&apos; 
        || char === &apos;-&apos;
        || char === &apos;*&apos;
        || char === &apos;/&apos;
    ) {
        emmitToken(char, char);
        return start
    }
    if(char === &apos; &apos;) {
        return start;
    }
    if(char === &apos;\r&apos; 
        || char === &apos;\n&apos;
    ) {
        return start;
    }
}
const inNumber = char =&gt; {
    if(char === &apos;1&apos; 
        || char === &apos;2&apos;
        || char === &apos;3&apos;
        || char === &apos;4&apos;
        || char === &apos;5&apos;
        || char === &apos;6&apos;
        || char === &apos;7&apos;
        || char === &apos;8&apos;
        || char === &apos;9&apos;
        || char === &apos;0&apos;
    ) {
        token.push(char);
        return inNumber;
    } else {
        emmitToken(&quot;Number&quot;, token.join(&quot;&quot;));
        token = [];
        return start(char); // put back char
    }
}</code></pre><p>这个状态机非常简单，它只有两个状态，因为我们只有Number不是单字符的token。</p>
<p>这里我的状态机实现是非常经典的方式：用函数表示状态，用if表示状态的迁移关系，用return值表示下一个状态。</p>
<p>下面我们来运行一下这个状态机试试看：</p>
<pre><code>function emmitToken(type, value) {
    console.log(value);
}

var input = &quot;1024 + 2 * 256&quot;

var state = start;

for(var c of input.split(&apos;&apos;))
    state = state(c);

state(Symbol(&apos;EOF&apos;))</code></pre><p>运行后我们发现输出如下：</p>
<pre><code>1024
+
2
*
256</code></pre><p>这是我们想要的答案。</p>
<h2 id="语法分析：LL"><a href="#语法分析：LL" class="headerlink" title="语法分析：LL"></a>语法分析：LL</h2><p>做完了词法分析，我们开始进行语法分析，LL语法分析根据每一个产生式来写一个函数，首先我们来写好函数名：</p>
<pre><code>function AdditiveExpression( ){


}
function MultiplicativeExpression(){


}</code></pre><p>为了便于理解，我们就不做流式处理了，实际上一般编译代码都应该支持流式处理。</p>
<p>所以我们假设token已经都拿到了：</p>
<pre><code>var tokens = [{
    type:&quot;Number&quot;,
    value: &quot;1024&quot;
}, {
    type:&quot;+&quot;
    value: &quot;+&quot;
}, {
    type:&quot;Number&quot;,
    value: &quot;2&quot;
}, {
    type:&quot;*&quot;
    value: &quot;*&quot;
}, {
    type:&quot;Number&quot;,
    value: &quot;256&quot;
}, {
    type:&quot;EOF&quot;
}];</code></pre><p>每个产生式对应着一个函数，例如：根据产生式，我们的AdditiveExpression需要处理三种情况：</p>
<pre><code>&lt;AdditiveExpression&gt; ::= 
    &lt;MultiplicativeExpression&gt;
    |&lt;AdditiveExpression&gt;&lt;+&gt;&lt;MultiplicativeExpression&gt;
    |&lt;AdditiveExpression&gt;&lt;-&gt;&lt;MultiplicativeExpression&gt;</code></pre><p>那么AddititveExpression中就要写三个if分支，来处理三种情况。</p>
<p>AdditiveExpression的写法是根传入的节点，利用产生式合成新的节点</p>
<pre><code>function AdditiveExpression(source){
    if(source[0].type === &quot;MultiplicativeExpression&quot;) {
        let node = {
            type:&quot;AdditiveExpression&quot;,
            children:[source[0]]
        }
        source[0] = node;
        return node;
    } 
    if(source[0].type === &quot;AdditiveExpression&quot; &amp;&amp; source[1].type === &quot;+&quot;) {
        let node = {
            type:&quot;AdditiveExpression&quot;,
            operator:&quot;+&quot;,
            children:[source.shift(), source.shift(), MultiplicativeExpression(source)]
        }
        source.unshift(node);
    }
    if(source[0].type === &quot;AdditiveExpression&quot; &amp;&amp; source[1].type === &quot;-&quot;) {
        let node = {
            type:&quot;AdditiveExpression&quot;,
            operator:&quot;-&quot;,
            children:[source.shift(), source.shift(), MultiplicativeExpression(source)]
        }
        source.unshift(node);
    }
}</code></pre><p>那么下一步我们就把解析好的token传给我们的顶层处理函数Expression。</p>
<pre><code>Expression(tokens);</code></pre><p>接下来，我们看Expression该怎么处理它。</p>
<p>我们Expression收到第一个token，是个Number，这个时候，Expression就傻了，这是因为产生式只告诉我们，收到了 AdditiveExpression 怎么办。</p>
<p>这个时候，我们就需要对产生式的首项层层展开，根据所有可能性调用相应的处理函数，这个过程在编译原理中称为求“closure”。</p>
<pre><code>function Expression(source){
    if(source[0].type === &quot;AdditiveExpression&quot; &amp;&amp; source[1] &amp;&amp; source[1].type === &quot;EOF&quot; ) {
        let node = {
            type:&quot;Expression&quot;,
            children:[source.shift(), source.shift()]
        }
        source.unshift(node);
        return node;
    }
    AdditiveExpression(source);
    return Expression(source);
}
function AdditiveExpression(source){
    if(source[0].type === &quot;MultiplicativeExpression&quot;) {
        let node = {
            type:&quot;AdditiveExpression&quot;,
            children:[source[0]]
        }
        source[0] = node;
        return AdditiveExpression(source);
    } 
    if(source[0].type === &quot;AdditiveExpression&quot; &amp;&amp; source[1] &amp;&amp; source[1].type === &quot;+&quot;) {
        let node = {
            type:&quot;AdditiveExpression&quot;,
            operator:&quot;+&quot;,
            children:[]
        }
        node.children.push(source.shift());
        node.children.push(source.shift());
        MultiplicativeExpression(source);
        node.children.push(source.shift());
        source.unshift(node);
        return AdditiveExpression(source);
    }
    if(source[0].type === &quot;AdditiveExpression&quot; &amp;&amp; source[1] &amp;&amp; source[1].type === &quot;-&quot;) {
        let node = {
            type:&quot;AdditiveExpression&quot;,
            operator:&quot;-&quot;,
            children:[]
        }
        node.children.push(source.shift());
        node.children.push(source.shift());
        MultiplicativeExpression(source);
        node.children.push(source.shift());
        source.unshift(node);
        return AdditiveExpression(source);
    }
    if(source[0].type === &quot;AdditiveExpression&quot;)
        return source[0];
    MultiplicativeExpression(source);
    return AdditiveExpression(source);
}
function MultiplicativeExpression(source){
    if(source[0].type === &quot;Number&quot;) {
        let node = {
            type:&quot;MultiplicativeExpression&quot;,
            children:[source[0]]
        }
        source[0] = node;
        return MultiplicativeExpression(source);
    } 
    if(source[0].type === &quot;MultiplicativeExpression&quot; &amp;&amp; source[1] &amp;&amp; source[1].type === &quot;*&quot;) {
        let node = {
            type:&quot;MultiplicativeExpression&quot;,
            operator:&quot;*&quot;,
            children:[]
        }
        node.children.push(source.shift());
        node.children.push(source.shift());
        node.children.push(source.shift());
        source.unshift(node);
        return MultiplicativeExpression(source);
    }
    if(source[0].type === &quot;MultiplicativeExpression&quot;&amp;&amp; source[1] &amp;&amp; source[1].type === &quot;/&quot;) {
        let node = {
            type:&quot;MultiplicativeExpression&quot;,
            operator:&quot;/&quot;,
            children:[]
        }
        node.children.push(source.shift());
        node.children.push(source.shift());
        node.children.push(source.shift());
        source.unshift(node);
        return MultiplicativeExpression(source);
    }
    if(source[0].type === &quot;MultiplicativeExpression&quot;)
        return source[0];

    return MultiplicativeExpression(source);
};

var source = [{
    type:&quot;Number&quot;,
    value: &quot;3&quot;
}, {
    type:&quot;*&quot;,
    value: &quot;*&quot;
}, {
    type:&quot;Number&quot;,
    value: &quot;300&quot;
}, {
    type:&quot;+&quot;,
    value: &quot;+&quot;
}, {
    type:&quot;Number&quot;,
    value: &quot;2&quot;
}, {
    type:&quot;*&quot;,
    value: &quot;*&quot;
}, {
    type:&quot;Number&quot;,
    value: &quot;256&quot;
}, {
    type:&quot;EOF&quot;
}];
var ast = Expression(source);

console.log(ast);</code></pre><h2 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h2><p>得到了AST之后，最困难的一步我们已经解决了。这里我们就不对这颗树做任何的优化和精简了，那么接下来，直接进入执行阶段。我们只需要对这个树做遍历操作执行即可。</p>
<p>我们根据不同的节点类型和其它信息，写if分别处理即可：</p>
<pre><code>function evaluate(node) {
    if(node.type === &quot;Expression&quot;) {
        return evaluate(node.children[0])
    }
    if(node.type === &quot;AdditiveExpression&quot;) {
        if(node.operator === &apos;-&apos;) {
            return evaluate(node.children[0]) - evaluate(node.children[2]);
        }
        if(node.operator === &apos;+&apos;) {
            return evaluate(node.children[0]) + evaluate(node.children[2]);
        }
        return evaluate(node.children[0])
    }
    if(node.type === &quot;MultiplicativeExpression&quot;) {
        if(node.operator === &apos;*&apos;) {
            return evaluate(node.children[0]) * evaluate(node.children[2]);
        }
        if(node.operator === &apos;/&apos;) {
            return evaluate(node.children[0]) / evaluate(node.children[2]);
        }
        return evaluate(node.children[0])
    }
    if(node.type === &quot;Number&quot;) {
        return Number(node.value);
    }
}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这个小实验中，我们通过一个小实验学习了编译原理的基本知识，小实验的目的是帮助你理解JavaScript课程中涉及到的编译原理基本概念，它离真正的编译原理学习还有很大的差距。</p>
<p>通过实验，我们了解了产生式、词法分析、语法分析和解释执行的过程。</p>
<p>最后留给你一些挑战，你可以根据自己的水平选择：</p>
<ul>
<li>补全emmitToken，使得我们的代码能完整工作起来。</li>
<li>为四则运算加入小数。</li>
<li>引入负数。</li>
<li>添加括号功能。</li>
</ul>
<p>欢迎写好的同学留言给我。</p>
<p><img src="https://static001.geekbang.org/resource/image/7c/b1/7ca7c24e92d25bde2e8609ed5386b5b1.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:02:56.969Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/重学前端/">重学前端</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    23 minutes read (About 3461 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/重学前端/JavaScript词法：为什么12.toString会报错？/">JavaScript词法：为什么12.toString会报错？</a>
            
        </h1>
        <div class="content">
            <p>你好，我是winter。</p>
<p>在前面的文章中，我们已经从运行时的角度了解过JavaScript的知识内容，在接下来的几节课，我们来了解一下JavaScript的文法部分。</p>
<p>文法是编译原理中对语言的写法的一种规定，一般来说，文法分成词法和语法两种。</p>
<p>词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”，在我的专栏文章中，我统一把token翻译成词。</p>
<p>从字符到词的整个过程是没有结构的，只要符合词的规则，就构成词，一般来说，词法设计不会包含冲突。词法分析技术上可以使用状态机或者正则表达式来进行，我们的课程主要是学习词法，关于它们实现的细节就不多谈了。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们先来看一看JavaScript的词法定义。JavaScript源代码中的输入可以这样分类：</p>
<ul>
<li><p>WhiteSpace 空白字符</p>
</li>
<li><p>LineTerminator 换行符</p>
</li>
<li><p>Comment 注释</p>
</li>
<li><p>Token 词</p>
</li>
<li><p>IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了。</p>
</li>
<li><p>Punctuator 符号，我们使用的运算符和大括号等符号。</p>
</li>
<li><p>NumericLiteral 数字直接量，就是我们写的数字。</p>
</li>
<li><p>StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量。</p>
</li>
<li><p>Template 字符串模板，用反引号``` 括起来的直接量。</p>
</li>
</ul>
<p>这个设计符合比较通用的编程语言设计方式，不过，JavaScript中有一些特别之处，我下面就来讲讲特别在哪里。</p>
<p>首先是除法和正则表达式冲突问题。我们都知道，JavaScript不但支持除法运算符“ / ”和“ /= ”，还支持用斜杠括起来的正则表达式“ /abc/ ”。</p>
<p>但是，这时候对词法分析来说，其实是没有办法处理的，所以JavaScript的解决方案是定义两组词法，然后靠语法分析传一个标志给词法分析器，让它来决定使用哪一套词法。</p>
<p>JavaScript词法的另一个特别设计是字符串模板，模板语法大概是这样的：</p>
<pre><code>`Hello, ${name}`</code></pre><p>理论上，“ ${ } ”内部可以放任何JavaScript表达式代码，而这些代码是以“ } ” 结尾的，也就是说，这部分词法不允许出现“ } ”运算符。</p>
<p>是否允许“ } ”的两种情况，与除法和正则表达式的两种情况相乘就是四种词法定义，所以你在JavaScript标准中，可以看到四种定义：</p>
<ul>
<li>InputElementDiv；</li>
<li>InputElementRegExp；</li>
<li>InputElementRegExpOrTemplateTail；</li>
<li>InputElementTemplateTail。</li>
</ul>
<p>为了解决这两个问题，标准中还不得不把除法、正则表达式直接量和“ } ”从token中单独抽出来，用词上，也把原本的 Token 改为 CommonToken。</p>
<p>但是我认为，从理解的角度上出发，我们不应该受到影响，所以在本课，我们依然把它们归类到token来理解。</p>
<p>对一般的语言的词法分析过程来说，都会丢弃除了token之外的输入，但是对JavaScript来说，不太一样，换行符和注释还会影响语法分析过程，这个我们将会在语法部分给你详细讲解（所以要实现JavaScript的解释器，词法分析和语法分析非常麻烦，需要来回传递信息）。</p>
<p>接下来我来给你详细介绍一下。</p>
<h3 id="空白符号-Whitespace"><a href="#空白符号-Whitespace" class="headerlink" title="空白符号 Whitespace"></a>空白符号 Whitespace</h3><p>说起空白符号，想必给大家留下的印象就是空格，但是实际上，JavaScript可以支持更多空白符号。</p>
<ul>
<li><p><code>&lt;HT&gt;</code>(或称<code>&lt;TAB&gt;</code>)是U+0009，是缩进TAB符，也就是字符串中写的 \t 。</p>
</li>
<li><p><code>&lt;VT&gt;</code>是U+000B，也就是垂直方向的TAB符 \v，这个字符在键盘上很难打出来，所以很少用到。</p>
</li>
<li><p><code>&lt;FF&gt;</code>是U+000C，Form Feed，分页符，字符串直接量中写作 \f ，现代已经很少有打印源程序的事情发生了，所以这个字符在JavaScript源代码中很少用到。</p>
</li>
<li><p><code>&lt;SP&gt;</code>是U+0020，就是最普通的空格了。</p>
</li>
<li><p><code>&lt;NBSP&gt;</code>是U+00A0，非断行空格，它是SP的一个变体，在文字排版中，可以避免因为空格在此处发生断行，其它方面和普通空格完全一样。多数的JavaScript编辑环境都会把它当做普通空格（因为一般源代码编辑环境根本就不会自动折行……）。HTML中，很多人喜欢用的 <code>&amp;nbsp;</code> 最后生成的就是它了。</p>
</li>
<li><p><code>&lt;ZWNBSP&gt;</code>(旧称<code>&lt;BOM&gt;</code>)是U+FEFF，这是ES5新加入的空白符，是Unicode中的零宽非断行空格，在以UTF格式编码的文件中，常常在文件首插入一个额外的U+FEFF，解析UTF文件的程序可以根据U+FEFF的表示方法猜测文件采用哪种UTF编码方式。这个字符也叫做“bit order mark”。</p>
</li>
</ul>
<p>此外，JavaScript支持所有的Unicode中的空格分类下的空格，我们可以看下表：</p>
<p><img src="https://static001.geekbang.org/resource/image/dd/60/dd26aa9599b61d26e7de807dee2c6360.png" alt></p>
<p>很多公司的编码规范要求JavaScript源代码控制在ASCII范围内，那么，就只有<code>&lt;TAB&gt;``&lt;VT&gt;``&lt;FF&gt;``&lt;SP&gt;``&lt;NBSP&gt;</code>五种空白可用了。</p>
<h3 id="换行符-LineTerminator"><a href="#换行符-LineTerminator" class="headerlink" title="换行符 LineTerminator"></a>换行符 LineTerminator</h3><p>接下来我们来看看换行符，JavaScript中只提供了4种字符作为换行符。</p>
<ul>
<li><code>&lt;LF&gt;</code></li>
<li><code>&lt;CR&gt;</code></li>
<li><code>&lt;LS&gt;</code></li>
<li><code>&lt;PS&gt;</code></li>
</ul>
<p>其中，<code>&lt;LF&gt;</code>是U+000A，就是最正常换行符，在字符串中的<code>\n</code>。</p>
<p><code>&lt;CR&gt;</code>是U+000D，这个字符真正意义上的“回车”，在字符串中是<code>\r</code>，在一部分Windows风格文本编辑器中，换行是两个字符<code>\r\n</code>。</p>
<p><code>&lt;LS&gt;</code>是U+2028，是Unicode中的行分隔符。<code>&lt;PS&gt;</code>是U+2029，是Unicode中的段落分隔符。</p>
<p>大部分LineTerminator在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响JavaScript的两个重要语法特性：自动插入分号和“no line terminator”规则。</p>
<h3 id="注释-Comment"><a href="#注释-Comment" class="headerlink" title="注释 Comment"></a>注释 Comment</h3><p>JavaScript的注释分为单行注释和多行注释两种：</p>
<pre><code>/* MultiLineCommentChars */ 
// SingleLineCommentChars</code></pre><p>多行注释中允许自由地出现<code>MultiLineNotAsteriskChar</code>，也就是除了<code>*</code>之外的所有字符。而每一个<code>*</code>之后，不能出现正斜杠符<code>/</code>。</p>
<p>除了四种LineTerminator之外，所有字符都可以作为单行注释。</p>
<p>我们需要注意，多行注释中是否包含换行符号，会对JavaScript语法产生影响，对于“no line terminator”规则来说，带换行的多行注释与换行符是等效的。</p>
<h2 id="标识符名称-IdentifierName"><a href="#标识符名称-IdentifierName" class="headerlink" title="标识符名称 IdentifierName"></a>标识符名称 IdentifierName</h2><p><code>IdentifierName</code>可以以美元符“<code>$</code>”、下划线“<code>_</code>”或者Unicode字母开始，除了开始字符以外，<code>IdentifierName</code>中还可以使用Unicode中的连接标记、数字、以及连接符号。</p>
<p><code>IdentifierName</code>的任意字符可以使用JavaScript的Unicode转义写法，使用Unicode转义写法时，没有任何字符限制。</p>
<p><code>IdentifierName</code>可以是<code>Identifier</code>、<code>NullLiteral</code>、<code>BooleanLiteral</code>或者<code>keyword</code>，在<code>ObjectLiteral</code>中，<code>IdentifierName</code>还可以被直接当做属性名称使用。</p>
<p>仅当不是保留字的时候，<code>IdentifierName</code>会被解析为<code>Identifier</code>。</p>
<p>注意<code>&lt;ZWNJ&gt;</code>和<code>&lt;ZWJ&gt;</code>是ES5新加入的两个格式控制字符，它们都是0宽的。</p>
<p>我在前面提到了，关键字也属于这个部分，在JavaScript中，关键字有:</p>
<pre><code>await break case catch class const continue debugger default delete do else export extends finally for function if import ininstance of new return super switch this throw try typeof var void while with yield</code></pre><p>除了上述的内容之外，还有1个为了未来使用而保留的关键字:</p>
<pre><code>enum</code></pre><p>在严格模式下,有一些额外的为未来使用而保留的关键字:</p>
<pre><code>implements package protected interface private public</code></pre><p>除了这些之外，<code>NullLiteral</code>（<code>null</code>）和<code>BooleanLiteral</code>（<code>true false</code>）也是保留字，不能用于<code>Identifier</code>。</p>
<h3 id="符号-Punctuator"><a href="#符号-Punctuator" class="headerlink" title="符号 Punctuator"></a>符号 Punctuator</h3><p>因为前面提到的除法和正则问题, /和/=两个运算符被拆分为DivPunctuator，因为前面提到的字符串模板问题，<code>}</code>也被独立拆分。加在一起，所有符号为：</p>
<pre><code>{ ( ) [ ] . ... ; , &lt; &gt; &lt;= &gt;= == != === !== + - * % ** ++ -- &lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^ ! ~ &amp;&amp; || ? : = += -= *= %= **= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= |= ^= =&gt; / /= }</code></pre><h3 id="数字直接量-NumericLiteral"><a href="#数字直接量-NumericLiteral" class="headerlink" title="数字直接量 NumericLiteral"></a>数字直接量 NumericLiteral</h3><p>我们来看看今天标题提出的问题，JavaScript规范中规定的数字直接量可以支持四种写法：十进制数、二进制整数、八进制整数和十六进制整数。</p>
<p>十进制的Number可以带小数，小数点前后部分都可以省略，但是不能同时省略，我们看几个例子：</p>
<pre><code>.01
12.
12.01</code></pre><p>这都是合法的数字直接量。这里就有一个问题，也是我们标题提出的问题，我们看一段代码：</p>
<pre><code>12.toString()</code></pre><p>这时候<code>12.</code> 会被当做省略了小数点后面部分的数字而看成一个整体，所以我们要想让点单独成为一个token，就要加入空格，这样写：</p>
<pre><code>12 .toString()</code></pre><p>数字直接量还支持科学计数法，例如：</p>
<pre><code>10.24E+2
10.24e-2
10.24e2</code></pre><p>这里e后面的部分，只允许使用整数。当以<code>0x``0b</code> 或者<code>0o</code> 开头时，表示特定进制的整数：</p>
<pre><code>0xFA
0o73
0b10000</code></pre><p>上面这几种进制都不支持小数，也不支持科学计数法。</p>
<h3 id="字符串直接量-StringLiteral"><a href="#字符串直接量-StringLiteral" class="headerlink" title="字符串直接量 StringLiteral"></a>字符串直接量 StringLiteral</h3><p>JavaScript中的StringLiteral支持单引号和双引号两种写法。</p>
<pre><code>&quot; DoubleStringCharacters &quot;
&apos; SingleStringCharacters &apos;</code></pre><p>单双引号的区别仅仅在于写法，在双引号字符串直接量中，双引号必须转义，在单引号字符串直接量中，单引号必须转义。字符串中其他必须转义的字符是<code>\</code>和所有换行符。</p>
<p>JavaScript中支持四种转义形式，还有一种虽然标准没有定义，但是大部分实现都支持的八进制转义。</p>
<p>第一种是单字符转义。 即一个反斜杠<code>\</code>后面跟一个字符这种形式。</p>
<p>有特别意义的字符包括有<code>SingleEscapeCharacter</code>所定义的9种，见下表：</p>
<p><img src="https://static001.geekbang.org/resource/image/02/75/022c2c77d0a3c846ad0d61b48c4e0e75.png" alt></p>
<p>除了这9种字符、数字、x和u以及所有的换行符之外，其它字符经过<code>\</code>转义后都是自身。</p>
<h3 id="正则表达式直接量-RegularExpressionLiteral"><a href="#正则表达式直接量-RegularExpressionLiteral" class="headerlink" title="正则表达式直接量 RegularExpressionLiteral"></a>正则表达式直接量 RegularExpressionLiteral</h3><p>正则表达式由Body和Flags两部分组成，例如：</p>
<pre><code>/RegularExpressionBody/g</code></pre><p>其中Body部分至少有一个字符，第一个字符不能是<em>（因为/</em>跟多行注释有词法冲突）。</p>
<p>正则表达式有自己的语法规则，在词法阶段，仅会对它做简单解析。</p>
<p>正则表达式并非机械地见到<code>/</code>就停止，在正则表达式<code>[ ]</code>中的<code>/</code>就会被认为是普通字符。我们可以看一个例子：</p>
<pre><code>/[/]/.test(&quot;/&quot;);</code></pre><p>除了<code>\</code>、<code>/</code> 和<code>[</code> 三个字符之外，JavaScript正则表达式中的字符都是普通字符。</p>
<p>用\和一个非换行符可以组成一个转义，<code>[ ]</code>中也支持转义。正则表达式中的flag在词法阶段不会限制字符。</p>
<p>虽然只有ig几个是有效的，但是任何IdentifierPart（Identifier中合法的字符）序列在词法阶段都会被认为是合法的。</p>
<h3 id="字符串模板-Template"><a href="#字符串模板-Template" class="headerlink" title="字符串模板 Template"></a>字符串模板 Template</h3><p>从语法结构上，Template是个整体，其中的 <code>${ }</code> 是并列关系。</p>
<p>但是实际上，在JavaScript词法中，包含 <code>${ }</code> 的 Template，是被拆开分析的，如：</p>
<pre><code>`a${b}c${d}e`</code></pre><p>它在JavaScript中被认为是：</p>
<pre><code>`a${
b
}c${
d
}e`</code></pre><p>它被拆成了五个部分：</p>
<ul>
<li>``a${` 这个被称为模板头</li>
<li><code>}c${</code> 被称为模板中段</li>
<li>`}e`` 被称为模板尾</li>
<li><code>b</code> 和 <code>d</code> 都是普通标识符</li>
</ul>
<p>实际上，这里的词法分析过程已经跟语法分析深度耦合了。</p>
<p>不过我们学习的时候，大可不必按照标准和引擎工程师这样去理解，可以认为模板就是一个由反引号括起来的、可以在中间插入代码的字符串。</p>
<p>模板支持添加处理函数的写法，这时模板的各段会被拆开，传递给函数当参数：</p>
<pre><code>function f(){
    console.log(arguments);
}

var a = &quot;world&quot;
f`Hello ${a}!`; // [[&quot;Hello&quot;, &quot;!&quot;], world]</code></pre><p>模板字符串不需要关心大多数字符的转义，但是至少 <code>${</code> 和 ``` 还是需要处理的。</p>
<p>模板中的转义跟字符串几乎完全一样，都是使用 <code>\</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们一起学习JavaScript的词法部分，这部分的内容包括了空白符号、换行符、注释、标识符名称、符号、数字直接量、字符串直接量、正则表达式直接量、字符串模板。掌握词法对我们平时调试代码至关重要。</p>
<p>最后，给你留一个问题：用零宽空格和零宽连接符、零宽非连接符，写一段好玩的代码。你可以给我留言，我们一起讨论。</p>
<h1 id="猜你喜欢"><a href="#猜你喜欢" class="headerlink" title="猜你喜欢"></a>猜你喜欢</h1><p><a href="https://time.geekbang.org/course/intro/163?utm_term=zeusMTA7L&amp;utm_source=app&amp;utm_medium=chongxueqianduan&amp;utm_campaign=163-presell" target="_blank" rel="noopener"><img src="https://static001.geekbang.org/resource/image/1a/08/1a49758821bdbdf6f0a8a1dc5bf39f08.jpg" alt="unpreview"></a></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:02:54.983Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/重学前端/">重学前端</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    23 minutes read (About 3475 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/重学前端/浏览器CSSOM：如何获取一个元素的准确位置/">浏览器CSSOM：如何获取一个元素的准确位置</a>
            
        </h1>
        <div class="content">
            <p>你好，我是winter。</p>
<p>在前面的课程中，我们已经学习了DOM相关的API，狭义的DOM API仅仅包含DOM树形结构相关的内容。今天，我们再来学习一类新的API：CSSOM。</p>
<p>我想，你在最初接触浏览器API的时候，应该都有跟我类似的想法：“好想要element.width、element.height这样的API啊”。</p>
<p>这样的API可以直接获取元素的显示相关信息，它们是非常符合人的第一印象直觉的设计，但是，偏偏 DOM API 中没有这样的内容。</p>
<p>随着学习的深入，我才知道，这样的设计是有背后的逻辑的，正如HTML和CSS分别承担了语义和表现的分工，DOM和CSSOM也有语义和表现的分工。</p>
<p>DOM中的所有的属性都是用来表现语义的属性，CSSOM的则都是表现的属性，width和height这类显示相关的属性，都属于我们今天要讲的CSSOM。</p>
<p>顾名思义，CSSOM是CSS的对象模型，在W3C标准中，它包含两个部分：描述样式表和规则等CSS的模型部分（CSSOM），和跟元素视图相关的View部分（CSSOM View）。</p>
<p>在实际使用中，CSSOM View比CSSOM更常用一些，因为我们很少需要用代码去动态地管理样式表。</p>
<p>在今天的文章中，我来分别为你介绍这两部分的API。</p>
<h2 id="CSSOM"><a href="#CSSOM" class="headerlink" title="CSSOM"></a>CSSOM</h2><p>首先我们来介绍下CSS中样式表的模型，也就是CSSOM的本体。</p>
<p>我们通常创建样式表也都是使用HTML标签来做到的，我们用style标签和link标签创建样式表，例如：</p>
<pre><code>&lt;style title=&quot;Hello&quot;&gt;
a {
  color:red;
}
&lt;/style&gt;
&lt;link rel=&quot;stylesheet&quot; title=&quot;x&quot; href=&quot;data:text/css,p%7Bcolor:blue%7D&quot;&gt;</code></pre><p>我们创建好样式表后，还有可能要对它进行一些操作。如果我们以DOM的角度去理解的话，这些标签在DOM中是一个节点，它们有节点的内容、属性，这两个标签中，CSS代码有的在属性、有的在子节点。这两个标签也遵循DOM节点的操作规则，所以可以使用DOM API去访问。</p>
<p>但是，这样做的后果是我们需要去写很多分支逻辑，并且，要想解析CSS代码结构也不是一件简单的事情，所以，这种情况下，我们直接使用CSSOM API去操作它们生成的样式表，这是一个更好的选择。</p>
<p>我们首先了解一下CSSOM API的基本用法，一般来说，我们需要先获取文档中所有的样式表：</p>
<pre><code>document.styleSheets</code></pre><p>document的styleSheets属性表示文档中的所有样式表，这是一个只读的列表，我们可以用方括号运算符下标访问样式表，也可以使用item方法来访问，它有length属性表示文档中的样式表数量。</p>
<p>样式表只能使用style标签或者link标签创建（对XML来说，还可以使用，咱们暂且不表）。</p>
<p>我们虽然无法用CSSOM API来创建样式表，但是我们可以修改样式表中的内容。</p>
<pre><code>document.styleSheets[0].insertRule(&quot;p { color:pink; }&quot;, 0)
document.styleSheets[0].removeRule(0)</code></pre><p>更进一步，我们可以获取样式表中特定的规则（Rule），并且对它进行一定的操作，具体来说，就是使用它的cssRules属性来实现：</p>
<pre><code>document.styleSheets[0].cssRules</code></pre><p>这里取到的规则列表，同样是支持item、length和下标运算。</p>
<p>不过，这里的Rules可就没那么简单了，它可能是CSS的at-rule，也可能是普通的样式规则。不同的rule类型，具有不同的属性。</p>
<p>我们在CSS语法部分，已经为你整理过at-rule的完整列表，多数at-rule都对应着一个rule类型：</p>
<ul>
<li>CSSStyleRule</li>
<li>CSSCharsetRule</li>
<li>CSSImportRule</li>
<li>CSSMediaRule</li>
<li>CSSFontFaceRule</li>
<li>CSSPageRule</li>
<li>CSSNamespaceRule</li>
<li>CSSKeyframesRule</li>
<li>CSSKeyframeRule</li>
<li>CSSSupportsRule</li>
</ul>
<p>具体的规则支持的属性，建议你可以用到的时候，再去查阅MDN或者W3C的文档，在我们的文章中，仅为你详细介绍最常用的 CSSStyleRule。</p>
<p>CSSStyleRule有两个属性：selectorText 和 style，分别表示一个规则的选择器部分和样式部分。</p>
<p>selector部分是一个字符串，这里显然偷懒了没有设计进一步的选择器模型，我们按照选择器语法设置即可。</p>
<p>style部分是一个样式表，它跟我们元素的style属性是一样的类型，所以我们可以像修改内联样式一样，直接改变属性修改规则中的具体CSS属性定义，也可以使用cssText这样的工具属性。</p>
<p>此外，CSSOM还提供了一个非常重要的方法，来获取一个元素最终经过CSS计算得到的属性：</p>
<pre><code>window.getComputedStyle(elt, pseudoElt);</code></pre><p>其中第一个参数就是我们要获取属性的元素，第二个参数是可选的，用于选择伪元素。</p>
<p>好了，到此为止，我们可以使用CSSOM API自由地修改页面已经生效的样式表了。接下来，我们来一起关注一下视图的问题。</p>
<h2 id="CSSOM-View"><a href="#CSSOM-View" class="headerlink" title="CSSOM View"></a>CSSOM View</h2><p>CSSOM View 这一部分的API，可以视为DOM API的扩展，它在原本的Element接口上，添加了显示相关的功能，这些功能，又可以分成三个部分：窗口部分，滚动部分和布局部分，下面我来分别带你了解一下。</p>
<h2 id="窗口-API"><a href="#窗口-API" class="headerlink" title="窗口 API"></a>窗口 API</h2><p>窗口API用于操作浏览器窗口的位置、尺寸等。</p>
<ul>
<li>moveTo(x, y) 窗口移动到屏幕的特定坐标；</li>
<li>moveBy(x, y) 窗口移动特定距离；</li>
<li>resizeTo(x, y) 改变窗口大小到特定尺寸；</li>
<li>resizeBy(x, y) 改变窗口大小特定尺寸。</li>
</ul>
<p>此外，窗口API还规定了 window.open() 的第三个参数：</p>
<pre><code>window.open(&quot;about:blank&quot;, &quot;_blank&quot; ,&quot;width=100,height=100,left=100,right=100&quot; )</code></pre><p>一些浏览器出于安全考虑没有实现，也不适用于移动端浏览器，这部分你仅需简单了解即可。下面我们来了解一下滚动API。</p>
<h2 id="滚动-API"><a href="#滚动-API" class="headerlink" title="滚动 API"></a>滚动 API</h2><p>要想理解滚动，首先我们必须要建立一个概念，在PC时代，浏览器可视区域的滚动和内部元素的滚动关系是比较模糊的，但是在移动端越来越重要的今天，两者必须分开看待，两者的性能和行为都有区别。</p>
<h3 id="视口滚动API"><a href="#视口滚动API" class="headerlink" title="视口滚动API"></a>视口滚动API</h3><p>可视区域（视口）滚动行为由window对象上的一组API控制，我们先来了解一下：</p>
<ul>
<li>scrollX 是视口的属性，表示X方向上的当前滚动距离，有别名 pageXOffset；</li>
<li>scrollY 是视口的属性，表示Y方向上的当前滚动距离，有别名 pageYOffset；</li>
<li>scroll(x, y) 使得页面滚动到特定的位置，有别名scrollTo，支持传入配置型参数 {top, left}；</li>
<li>scrollBy(x, y) 使得页面滚动特定的距离，支持传入配置型参数 {top, left}。</li>
</ul>
<p>通过这些属性和方法，我们可以读取视口的滚动位置和操纵视口滚动。不过，要想监听视口滚动事件，我们需要在document对象上绑定事件监听函数：</p>
<pre><code>document.addEventListener(&quot;scroll&quot;, function(event){
  //......
})</code></pre><p>视口滚动API是页面的顶层容器的滚动，大部分移动端浏览器都会采用一些性能优化，它和元素滚动不完全一样，请大家一定建立这个区分的意识。</p>
<h3 id="元素滚动API"><a href="#元素滚动API" class="headerlink" title="元素滚动API"></a>元素滚动API</h3><p>接下来我们来认识一下元素滚动API，在Element类（参见DOM部分），为了支持滚动，加入了以下API。</p>
<ul>
<li>scrollTop 元素的属性，表示Y方向上的当前滚动距离。</li>
<li>scrollLeft 元素的属性，表示X方向上的当前滚动距离。</li>
<li>scrollWidth 元素的属性，表示元素内部的滚动内容的宽度，一般来说会大于等于元素宽度。</li>
<li>scrollHeight 元素的属性，表示元素内部的滚动内容的高度，一般来说会大于等于元素高度。</li>
<li>scroll(x, y) 使得元素滚动到特定的位置，有别名scrollTo，支持传入配置型参数 {top, left}。</li>
<li>scrollBy(x, y) 使得元素滚动到特定的位置，支持传入配置型参数 {top, left}。</li>
<li>scrollIntoView(arg) 滚动元素所在的父元素，使得元素滚动到可见区域，可以通过arg来指定滚到中间、开始或者就近。</li>
</ul>
<p>除此之外，可滚动的元素也支持scroll事件，我们在元素上监听它的事件即可：</p>
<pre><code>element.addEventListener(&quot;scroll&quot;, function(event){
  //......
})</code></pre><p>这里你需要注意一点，元素部分的API设计与视口滚动命名风格上略有差异，你在使用的时候不要记混。</p>
<h2 id="布局API"><a href="#布局API" class="headerlink" title="布局API"></a>布局API</h2><p>最后我们来介绍一下布局API，这是整个CSSOM中最常用到的部分，我们同样要分成全局API和元素上的API。</p>
<h3 id="全局尺寸信息"><a href="#全局尺寸信息" class="headerlink" title="全局尺寸信息"></a>全局尺寸信息</h3><p>window对象上提供了一些全局的尺寸信息，它是通过属性来提供的，我们一起来了解一下来这些属性。</p>
<p><img src="https://static001.geekbang.org/resource/image/b6/10/b6c7281d86eb7214edf17069f95ae610.png" alt></p>
<ul>
<li><p>window.innerHeight, window.innerWidth 这两个属性表示视口的大小。</p>
</li>
<li><p>window.outerWidth, window.outerHeight 这两个属性表示浏览器窗口占据的大小，很多浏览器没有实现，一般来说这两个属性无关紧要。</p>
</li>
<li><p>window.devicePixelRatio 这个属性非常重要，表示物理像素和CSS像素单位的倍率关系，Retina屏这个值是2，后来也出现了一些3倍的Android屏。</p>
</li>
<li><p>window.screen （屏幕尺寸相关的信息）</p>
</li>
<li><p>window.screen.width, window.screen.height 设备的屏幕尺寸。</p>
</li>
<li><p>window.screen.availWidth, window.screen.availHeight 设备屏幕的可渲染区域尺寸，一些Android机器会把屏幕的一部分预留做固定按钮，所以有这两个属性，实际上一般浏览器不会实现的这么细致。</p>
</li>
<li><p>window.screen.colorDepth, window.screen.pixelDepth 这两个属性是固定值24，应该是为了以后预留。</p>
</li>
</ul>
<p>虽然window有这么多相关信息，在我看来，我们主要使用的是innerHeight、innerWidth和devicePixelRatio三个属性，因为我们前端开发工作只需要跟视口打交道，其它信息大概了解即可。</p>
<h3 id="元素的布局信息"><a href="#元素的布局信息" class="headerlink" title="元素的布局信息"></a>元素的布局信息</h3><p>最后我们来到了本节课一开始提到的问题，我们是否能够取到一个元素的宽（width）和高（height）呢？</p>
<p>实际上，我们首先应该从脑中消除“元素有宽高”这样的概念，我们课程中已经多次提到了，有些元素可能产生多个盒，事实上，只有盒有宽和高，元素是没有的。</p>
<p>所以我们获取宽高的对象应该是“盒”，于是CSSOM View为Element类添加了两个方法：</p>
<ul>
<li>getClientRects();</li>
<li>getBoundingClientRect()。</li>
</ul>
<p>getClientRects 会返回一个列表，里面包含元素对应的每一个盒所占据的客户端矩形区域，这里每一个矩形区域可以用 x, y, width, height 来获取它的位置和尺寸。</p>
<p>getBoundingClientRect ，这个API的设计更接近我们脑海中的元素盒的概念，它返回元素对应的所有盒的包裹的矩形区域，需要注意，这个API获取的区域会包括当overflow为visible时的子元素区域。</p>
<p>根据实际的精确度需要，我们可以选择何时使用这两个API。</p>
<p>这两个API获取的矩形区域都是相对于视口的坐标，这意味着，这些区域都是受滚动影响的。</p>
<p>如果我们要获取相对坐标，或者包含滚动区域的坐标，需要一点小技巧：</p>
<pre><code>var offsetX = document.documentElement.getBoundingClientRect().x - element.getBoundingClientRect().x;</code></pre><p>如这段代码所示，我们只需要获取文档跟节点的位置，再相减即可得到它们的坐标。</p>
<p>这两个API的兼容性非常好，定义又非常清晰，建议你如果是用JavaScript实现视觉效果时，尽量使用这两个API。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天我们一起学习了CSSOM这一类型的API。我们首先就说到了，就像HTML和CSS分别承担了语义和表现的分工，DOM和CSSOM也有语义和表现的分工。</p>
<p>CSSOM是CSS的对象模型，在W3C标准中，它包含两个部分：描述样式表和规则等CSS的模型部分（CSSOM），和跟元素视图相关的View部分（CSSOM View）。</p>
<p>最后留给你一个问题，写好欢迎留言来讨论，请找一个网页，用我们今天讲的API，把页面上的所有盒的轮廓画到一个canvas元素上。</p>
<h1 id="猜你喜欢"><a href="#猜你喜欢" class="headerlink" title="猜你喜欢"></a>猜你喜欢</h1><p><a href="https://time.geekbang.org/course/intro/163?utm_term=zeusMTA7L&amp;utm_source=app&amp;utm_medium=chongxueqianduan&amp;utm_campaign=163-presell" target="_blank" rel="noopener"><img src="https://static001.geekbang.org/resource/image/1a/08/1a49758821bdbdf6f0a8a1dc5bf39f08.jpg" alt="unpreview"></a></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:02:53.034Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/重学前端/">重学前端</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    21 minutes read (About 3171 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/重学前端/CSS排版：从毕升开始，我们就开始用正常流了/">CSS排版：从毕升开始，我们就开始用正常流了</a>
            
        </h1>
        <div class="content">
            <p>你好，我是winter。今天我们来聊聊CSS的正常流。</p>
<p>我想，在CSS中，大家最讨厌的大概就是排版部分了。因为早年的CSS设计上不能够很好地支持软件排版需求，导致大家需要使用很多黑科技，让很多新人望而却步。</p>
<p>现在CSS提供了很多种排版方式，我们有很多选项可以选择自己适合的那一种，然而，正常流却是我们绕不开的一种排版。</p>
<p>我们能够在网上看到关于正常流的各种资料，比如：块级格式化上下文、margin折叠等等……这一系列的概念光是听起来就令人非常头痛。</p>
<p>所以我相信很多同学一定会奇怪：正常流到底正常在哪里。事实上，我认为正常流本身是简单和符合直觉的东西。</p>
<p>我们之所以会觉得它奇怪，是因为如果我们从严苛的CSS标准角度去理解正常流，规定排版的算法，就需要引入上述那些复杂的概念。但是，如果我们单纯地从感性认知的层面去理解正常流，它其实是简单的。</p>
<p>下面，就让我们先抛弃掉所有的已知概念，从感性认知的角度出发，一起去理解一下正常流。</p>
<h2 id="正常流的行为"><a href="#正常流的行为" class="headerlink" title="正常流的行为"></a>正常流的行为</h2><p>首先，我们先从词源来讲一讲排版这件事。</p>
<p>在毕昇发明活字印刷之前，排版这项工作是不存在的，相应的操作叫做“雕版”。人们要想印刷书籍，就需要依靠雕版工人去手工雕刻印版。</p>
<p>活字印刷的出现，将排版这个词引入进来，排版是活字印刷的15道工序之一，不论是古代的木质活字印刷，还是近代的铅质活字印刷，排版的过程是由排版工人一个字一个字从字架捡出，再排入版框中。实际上，这个过程就是一个流式处理的过程。</p>
<p>从古代活字印刷开始，到现代的出版行业，再到今天的Web，排版过程其实并没有什么本质的变化，只不过，今天在我们的CSS中，排版需要处理的内容，不再是简单的大小相同的木字或者铅字，而是有着不同字体和字号的富文本，以及插入在富文本中大小不等的盒。</p>
<p>并且，在这些过程中，都会有一个正常流的存在。那么，正常流是什么样的呢？</p>
<p><strong>我们可以用一句话来描述正常流的排版行为，那就是：依次排列，排不下了换行。</strong>这个操作很简单吧，我想，任何一个不懂排版的人都会将其作为排版时的第一反应。</p>
<p>理解了正常流的基本概念，剩下的功能只需要在它的基础上延伸一下就好。</p>
<p>在正常流基础上，我们有float相关规则，使得一些盒占据了正常流需要的空间，我们可以把float理解为“文字环绕”。</p>
<p><img src="https://static001.geekbang.org/resource/image/af/65/aff7250eac6064158021aea86dd4ac65.png" alt></p>
<p>我们还有vertical-align相关规则规定了如何在垂直方向对齐盒。vertical-align相关规则看起来复杂，但是实际上，基线、文字顶/底、行顶/底都是我们正常书写文字时需要用到的概念，只是我们平时不一定会总结它们。</p>
<p>下图展示了在不同的vertical-align设置时，盒与文字是如何混合排版的。为了方便你理解，我们用代码给大家标注了基线、文字顶/底、行顶/底等概念。</p>
<p><img src="https://static001.geekbang.org/resource/image/aa/e3/aa6611b00f71f606493f165294410ee3.png" alt></p>
<p>（点击大图查看）</p>
<p>除此之外，margin折叠是很多人非常不理解的一种设计，但是实际上我们可以把margin理解为“一个元素规定了自身周围至少需要的空间”，这样，我们就非常容易理解为什么margin需要折叠了。</p>
<h2 id="正常流的原理"><a href="#正常流的原理" class="headerlink" title="正常流的原理"></a>正常流的原理</h2><p>我们前面描述了正常流的行为，接下来我们要切换一下模式，用比较严谨的姿势来理解一下正常流。</p>
<p>在CSS标准中，规定了如何排布每一个文字或者盒的算法，这个算法依赖一个排版的“当前状态”，CSS把这个当前状态称为“格式化上下文（formatting context）”。</p>
<p>我们可以认为排版过程是这样的：</p>
<blockquote>
<p>格式化上下文 + 盒/文字 = 位置</p>
</blockquote>
<blockquote>
<p>formatting context + boxes/charater = positions</p>
</blockquote>
<p>我们需要排版的盒，是分为块级盒和行内级盒的，所以排版需要分别为它们规定了块级格式化上下文和行内级格式化上下文。</p>
<p>与正常流一样，如果我们单纯地看格式化上下文，规则其实是非常简单的。</p>
<p>块级格式化上下文顺次排列元素：</p>
<p><img src="https://static001.geekbang.org/resource/image/a5/e7/a5e1b9a77d9745499f96d25cf0a0dbe7.png" alt></p>
<p>行内级格式化上下文顺次排列元素：</p>
<p><img src="https://static001.geekbang.org/resource/image/1c/cf/1ced4fa809b30343df45e559cf0c08cf.png" alt></p>
<p>注意，块级和行内级元素的排版，受文字书写方向的影响，这里我们讲上下左右只是为了方便你直观理解。</p>
<p>当我们要把正常流中的一个盒或者文字排版，需要分成三种情况处理。</p>
<ul>
<li><strong>当遇到块级盒</strong>：排入块级格式化上下文。</li>
<li><strong>当遇到行内级盒或者文字</strong>：首先尝试排入行内级格式化上下文，如果排不下，那么创建一个行盒，先将行盒排版（行盒是块级，所以到第一种情况），行盒会创建一个行内级格式化上下文。</li>
<li><strong>遇到float盒</strong>：把盒的顶部跟当前行内级上下文上边缘对齐，然后根据float的方向把盒的对应边缘对到块级格式化上下文的边缘，之后重排当前行盒。</li>
</ul>
<p>我们以上讲的都是一个块级格式化上下文中的排版规则，实际上，页面中的布局没有那么简单，一些元素会在其内部创建新的块级格式化上下文，这些元素有：</p>
<ol>
<li>浮动元素；</li>
<li>绝对定位元素；</li>
<li>非块级但仍能包含块级元素的容器（如inline-blocks, table-cells, table-captions）；</li>
<li>块级的能包含块级元素的容器，且属性overflow不为visible。</li>
</ol>
<p>这里的最后一条比较绕，实际上，我个人喜欢用另一种思路去理解它：</p>
<p>自身为块级，且overflow为visible的块级元素容器，它的块级格式化上下文和外部的块级格式化上下文发生了融合，也就是说，如果不考虑盒模型相关的属性，这样的元素从排版的角度就好像根本不存在。</p>
<p>好了，到这里我们已经讲完了正常流的排版详细规则，但是理解规则仅仅是基础，我们还需要掌握一些技巧。</p>
<h2 id="正常流的使用技巧"><a href="#正常流的使用技巧" class="headerlink" title="正常流的使用技巧"></a>正常流的使用技巧</h2><p>现在，我们就一起来动手用实际的例子来研究一下。我们今天来看看等分布局和自适应宽，从这两种经典布局问题入手，一起来探索一下正常流的使用技巧。</p>
<h3 id="等分布局问题"><a href="#等分布局问题" class="headerlink" title="等分布局问题"></a>等分布局问题</h3><p>横向等分布局是一个很常见的需求，按照一般的思路，我们可以使用百分比宽度来解决，我们参考以下代码：</p>
<pre><code>&lt;div class=&quot;outer&quot;&gt;
    &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
.inner {
    width:33.33%;
    height:300px;
    display:inline-block;
    outline:solid 1px blue;
}</code></pre><p>在这段HTML代码中，我们放了三个div，用CSS给它们指定了百分比宽度，并且指定为inline-block。</p>
<p>但是这段代码执行之后，效果跟我们预期不同，我们可以发现，每个div并非紧挨，中间有空白，这是因为我们为了代码格式加入的换行和空格被HTML当作空格文本，跟inline盒混排了的缘故。</p>
<p>解决方案是修改HTML代码，去掉空格和换行：</p>
<pre><code>&lt;div class=&quot;outer&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>但是这样做影响了源代码的可读性，一个变通的方案是，改变outer中的字号为0。</p>
<pre><code>.inner {
    width:33.33%;
    height:300px;
    display:inline-block;
    outline:solid 1px blue;
    font-size:30px;
}
.outer {
    font-size:0;
}</code></pre><p>在某些浏览器中，因为像素计算精度问题，还是会出现换行，我们给outer添加一个特定宽度：</p>
<pre><code>.inner {
    width:33.33%;
    height:300px;
    display:inline-block;
    outline:solid 1px blue;
}
.outer {
    width:101px
}</code></pre><p>这个代码在某些旧版本浏览器中会出现换行。为了保险起见，我们给最后一个div加上一个负的右margin：</p>
<pre><code>.outer {
    width:101px
}

.inner {
    width:33.33%;
    height:300px;
    display:inline-block;
    outline:solid 1px blue;
}

.inner:last-child {
    margin-right:-5px;
}</code></pre><p>这样就可以解决旧版本浏览器的问题了。</p>
<p>除了使用inline-block，float也可以实现类似的效果，但是float元素只能做顶对齐，不如inline-block灵活。</p>
<h3 id="自适应宽"><a href="#自适应宽" class="headerlink" title="自适应宽"></a>自适应宽</h3><p>我们再来说说自适应宽。在IE6统治浏览器市场的旧时代，自适应宽（一个元素固定宽度，另一个元素填满父容器剩余宽度）是个经典的布局问题，我们现在就看一下如何使用正常流来解决。</p>
<p>我们首先来看一下问题。</p>
<pre><code>&lt;div class=&quot;outer&quot;&gt;
    &lt;div class=&quot;fixed&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;auto&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
.fixed {
    width:200px;
}
.fixed, .auto {
    height:300px;
    outline:solid 1px blue;
}</code></pre><p>这里fixed这个div宽度已经被指定好，我们需要添加css代码尝试让.auto填满剩余宽度。</p>
<p>使用正常流解决这个问题的思路是，利用负margin：</p>
<pre><code>.fixed {
    display:inline-block;
    vertical-align:top;
}
.auto {
    margin-left:-200px;
    width:100%;
    display:inline-block;
    vertical-align:top;
}</code></pre><p>但是，这样做会导致auto中的内容位置不对，所以我们还需要使用padding把内容挤出来，最终完整代码如下：</p>
<pre><code>.fixed {
    display:inline-block;
    vertical-align:top;
}
.auto {
    margin-left:-200px;
    padding-left:200px;
    box-sizing:border-box;
    width:100%;
    display:inline-block;
    vertical-align:top;
}</code></pre><p>这样就给auto添加了padding-left和box-sizing两个属性。</p>
<p>总的来说，正常流布局主要是使用inline-block来作为内容的容器，利用块级格式化上下文的纵向排布和行内级格式化上下文的横向排布来完成布局的，我们需要根据需求的横向和纵向排布要求，来选择元素的display属性。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次的文章中，我们一起学习了正常流，我们可以用一句话来描述正常流的排版行为，那就是：依次排列，排不下了换行。这也是理解它最简单最源头的方式。</p>
<p>我们将正常流的知识分成了三个部分。</p>
<ul>
<li><p>正常流的行为部分，我们从一些感性认知出发，帮助你从思路和源头上理解正常流的行为。</p>
</li>
<li><p>正常流的原理部分，我用更严格的描述方式，给你讲解了CSS标准中规定的正常流排版逻辑。</p>
</li>
<li><p>最后的正常流应用部分，我以两个经典布局问题等分布局和自适应宽为例，为你讲解了正常流实际使用的一些技巧。</p>
</li>
</ul>
<p>最后，留给你一个思考题：用JavaScript写一个仅包含inline-block的正常流布局算法。你写好的话，可以留言给我，我们一起讨论。</p>
<h1 id="猜你喜欢"><a href="#猜你喜欢" class="headerlink" title="猜你喜欢"></a>猜你喜欢</h1><p><a href="https://time.geekbang.org/course/intro/163?utm_term=zeusMTA7L&amp;utm_source=app&amp;utm_medium=chongxueqianduan&amp;utm_campaign=163-presell" target="_blank" rel="noopener"><img src="https://static001.geekbang.org/resource/image/1a/08/1a49758821bdbdf6f0a8a1dc5bf39f08.jpg" alt="unpreview"></a></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:02:51.094Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/重学前端/">重学前端</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    25 minutes read (About 3719 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/重学前端/HTML链接：除了a标签，还有哪些标签叫链接？/">HTML链接：除了a标签，还有哪些标签叫链接？</a>
            
        </h1>
        <div class="content">
            <p>你好，我是winter。</p>
<p>在前面的课程中，我讲到了HTML的语义和元信息标签，今天这一课，我们来讲另一类HTML元素：链接。</p>
<p>链接这种元素可以说是占据了整个互联网。也正是因为无处不在的超链接，才让我们的万维网如此繁荣。没有了超链接的HTML，最多可以称为富文本，没法称作超文本（hyper text）。</p>
<p>我想，作为互联网从业者，我们一定对链接都非常熟悉了。链接能够帮助我们从一个网页跳转到另一个网页。</p>
<p>不过，除了肉眼可见的这些链接，其实HTML里面还规定了一些不可见链接的类型，这节课，我就来给你介绍链接家族的全员，让你对它们有一个完整的认识。</p>
<p>链接是HTML中的一种机制，它是HTML文档和其它文档或者资源的连接关系，在HTML中，链接有两种类型。一种是超链接型标签，一种是外部资源链接。</p>
<p>链接的家族中有a标签、area标签和link标签。今天，我会逐一对它们进行介绍。</p>
<p><img src="https://static001.geekbang.org/resource/image/ca/51/caab7832c425b3af2b3adae747e6f551.png" alt></p>
<h2 id="link-标签"><a href="#link-标签" class="headerlink" title="link 标签"></a>link 标签</h2><p>提到链接，我们都知道a标签可以成为超链接，但是我们今天的内容，要从一个大家不太熟悉的标签开始，也就是link标签。</p>
<p>我们已经介绍过元信息类标签。实际上，我们并没有介绍完全，有些link标签也是元信息类标签的一种。</p>
<p>我们已经讲过，HTML标准并没有规定浏览器如何使用元信息，我们还讲到了元信息中有不少是被设计成“无需被浏览器识别，而是专门用于搜索引擎看的”。</p>
<p>link标签也是元信息的一种，在很多时候，它也是不会对浏览器产生任何效果的，这也是很多人会忽略link标签学习的原因。</p>
<p>link标签会生成一个链接，它可能生成超链接，也可能生成外部资源链接。</p>
<p>一些link标签会生成超链接，这些超链接又不会像a标签那样显示在网页中。这就是超链接型的link标签。</p>
<p>这意味着多数浏览器中，这些link标签不产生任何作用。但是，这些link标签能够被搜索引擎和一些浏览器插件识别，从而产生关键性作用。</p>
<p>比如，到页面RSS的link标签，能够被浏览器的RSS订阅插件识别，提示用户当前页面是可以RSS订阅的。</p>
<p>另外一些link标签则会把外部的资源链接到文档中，也就是说，会实际下载这些资源，并且做出一些处理，比如我们常见的用link标签引入样式表。</p>
<p>除了元信息的用法之外，多数外部资源型的link标签还能够被放在body中使用，从而起到把外部资源链接进文档的作用。</p>
<p>link标签的链接类型主要通过rel属性来区分，在本篇文章中，我们提到xx型link即表示属性rel为xx的link，其代码类似下面：</p>
<pre><code>&lt;link rel=&quot;xx&quot; ...&gt;</code></pre><p>下面我们先来看看超链接型link标签。</p>
<h2 id="超链接类link标签"><a href="#超链接类link标签" class="headerlink" title="超链接类link标签"></a>超链接类link标签</h2><p>超链接型link标签是一种被动型链接，在用户不操作的情况下，它们不会被主动下载。</p>
<p>link标签具有特定的rel属性，会成为特定类型的link标签。产生超链接的link标签包括：具有 rel=“canonical” 的link、具有 rel=”alternate”的link、具有rel=“prev” rel=”next”的link等等。</p>
<h3 id="canonical型link"><a href="#canonical型link" class="headerlink" title="canonical型link"></a>canonical型link</h3><p>这种link的代码写法是这样：</p>
<pre><code>&lt;link rel=&quot;canonical&quot; href=&quot;...&quot;&gt;</code></pre><p>这个标签提示页面它的主URL，在网站中常常有多个URL指向同一页面的情况，搜索引擎访问这类页面时会去掉重复的页面，这个link会提示搜索引擎保留哪一个URL。</p>
<h2 id="alternate型link"><a href="#alternate型link" class="headerlink" title="alternate型link"></a>alternate型link</h2><p>这种link的代码写法是这样：</p>
<pre><code>&lt;link rel=&quot;alternate&quot; href=&quot;...&quot;&gt;</code></pre><p>这个标签提示页面它的变形形式，这个所谓的变形可能是当前页面内容的不同格式、不同语言或者为不同的设备设计的版本，这种link通常也是提供给搜索引擎来使用的。</p>
<p>alternate型的link的一个典型应用场景是，页面提供rss订阅时，可以用这样的link来引入：</p>
<pre><code>&lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;...&quot;&gt;</code></pre><p>除了搜索引擎外，很多浏览器插件都能识别这样的link。</p>
<h3 id="prev型link和next型link"><a href="#prev型link和next型link" class="headerlink" title="prev型link和next型link"></a>prev型link和next型link</h3><p>在互联网应用中，很多网页都属于一个序列，比如分页浏览的场景，或者图片展示的场景，每个网页是序列中的一个项。</p>
<p>这种时候，就适合使用prev和next型的link标签，来告诉搜索引擎或者浏览器它的前一项和后一项，这有助于页面的批量展示。</p>
<p>因为next型link告诉浏览器“这是很可能访问的下一个页面”，HTML标准还建议对next型link做预处理，在本课后面的内容，我们会讲到预处理类的link。</p>
<h3 id="其它超链接类的link"><a href="#其它超链接类的link" class="headerlink" title="其它超链接类的link"></a>其它超链接类的link</h3><p>其它超链接类link标签都表示一个跟当前文档相关联的信息，可以把这样的link标签视为一种带链接功能的meta标签。</p>
<ul>
<li>rel=“author” 链接到本页面的作者，一般是 mailto:协议</li>
<li>rel=“help” 链接到本页面的帮助页</li>
<li>rel=“license” 链接到本页面的版权信息页</li>
<li>rel=“search” 链接到本页面的搜索页面（一般是站内提供搜索时使用）</li>
</ul>
<p>到这里，我们已经讲完了所有的超链接类的link标签用法了。接下来我们讲讲外部资源类link标签。</p>
<h2 id="外部资源类link标签"><a href="#外部资源类link标签" class="headerlink" title="外部资源类link标签"></a>外部资源类link标签</h2><p>外部资源型link标签会被主动下载，并且根据rel类型做不同的处理。外部资源型的标签包括：具有icon型的link、预处理类link、modulepreload型的link、stylesheet、pingback。下面我们来一一介绍它们。</p>
<h3 id="icon型link"><a href="#icon型link" class="headerlink" title="icon型link"></a>icon型link</h3><p>这类链接表示页面的icon。多数浏览器会读取icon型link，并且把页面的icon展示出来。</p>
<p>icon型link是唯一一个外部资源类的元信息link，其它元信息类link都是超链接，这意味着，icon型link中的图标地址默认会被浏览器下载和使用。</p>
<p>如果没有指定这样的link，多数浏览器会使用域名根目录下的favicon.ico，即使它并不存在，所以从性能的角度考虑，建议一定要保证页面中有icon型的link。</p>
<p>只有icon型link有有效的sizes属性，HTML标准允许一个页面出现多个icon型link，并且用sizes指定它适合的icon尺寸。</p>
<h3 id="预处理类link"><a href="#预处理类link" class="headerlink" title="预处理类link"></a>预处理类link</h3><p>我们都知道，导航到一个网站需要经过dns查询域名、建立连接、传输数据、加载进内存和渲染等一系列的步骤。</p>
<p>预处理类link标签就是允许我们控制浏览器，提前针对一些资源去做这些操作，以提高性能（当然如果你乱用的话，性能反而更差）。</p>
<p>下面我来列一下这些link类型：</p>
<ul>
<li>dns-prefetch型link 提前对一个域名做dns查询，这样的link里面的href实际上只有域名有意义。</li>
<li>preconnect型link 提前对一个服务器建立tcp连接。</li>
<li>prefetch型link 提前取href指定的url的内容。</li>
<li>preload型link 提前加载href指定的url。</li>
<li>prerender型link 提前渲染href指定的url。</li>
</ul>
<h3 id="modulepreload型的link"><a href="#modulepreload型的link" class="headerlink" title="modulepreload型的link"></a>modulepreload型的link</h3><p>modulepreload型link的作用是预先加载一个JavaScript的模块。这可以保证JS模块不必等到执行时才加载。</p>
<p>这里的所谓加载，是指完成下载并放入内存，并不会执行对应的JavaScript。</p>
<pre><code>&lt;link rel=&quot;modulepreload&quot; href=&quot;app.js&quot;&gt;
&lt;link rel=&quot;modulepreload&quot; href=&quot;helpers.js&quot;&gt;
&lt;link rel=&quot;modulepreload&quot; href=&quot;irc.js&quot;&gt;
&lt;link rel=&quot;modulepreload&quot; href=&quot;fog-machine.js&quot;&gt;
&lt;script type=&quot;module&quot; src=&quot;app.js&quot;&gt;</code></pre><p>这个例子来自HTML标准，我们假设app.js中有 import “irc” 和 import “fog-machine”, 而 irc.js中有 import “helpers”。这段代码使用moduleload型link来预加载了四个js模块。</p>
<p>尽管，单独使用script标签引用app.js也可以正常工作，但是我们通过加入对四个JS文件的link标签，使得四个JS文件有机会被并行地下载，这样提高了性能。</p>
<h3 id="stylesheet型link"><a href="#stylesheet型link" class="headerlink" title="stylesheet型link"></a>stylesheet型link</h3><p>样式表大概是所有人最熟悉的link标签用法了。它的样子是下面这样的。</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;xxx.css&quot; type=&quot;text/css&quot;&gt;</code></pre><p>基本用法是从一个CSS文件创建一个样式表。这里type属性可以没有，如果有，必须是”text/css”才会生效。</p>
<p>rel前可以加上alternate，成为rel=“alternate stylesheet”，此时必须再指定title属性。</p>
<p>这样可以为页面创建一份变体样式，一些浏览器，如 Firefox 3.0，支持从浏览器菜单中切换这些样式，当然了，大部分浏览器不支持这个功能，所以仅仅从语义的角度了解一下这种用法即可。</p>
<h3 id="pingback型link"><a href="#pingback型link" class="headerlink" title="pingback型link"></a>pingback型link</h3><p>这样的link表示本网页被引用时，应该使用的pingback地址，这个机制是一份独立的标准，遵守pingback协议的网站在引用本页面时，会向这个pingback url发送一个消息。</p>
<p>以上就是link标签的所有用法了。接下来我们来介绍一下最熟悉的 a 标签，当然了，也可能你学过了本节课以后，觉得自己其实也没那么熟悉。</p>
<h2 id="a-标签"><a href="#a-标签" class="headerlink" title="a 标签"></a>a 标签</h2><p>a标签是“anchor”的缩写，它是锚点的意思，所谓锚点，实际上也是一种比喻的用法，古代船舶用锚来固定自己的位置，避免停泊时被海浪冲走，所以anchor标签的意思也是标识文档中的特定位置。</p>
<p>a标签其实同时充当了链接和目标点的角色，当a标签有href属性时，它是链接，当它有name时，它是链接的目标。</p>
<p>具有href的a标签跟一些link一样，会产生超链接，也就是在用户不操作的情况下，它们不会被主动下载的被动型链接。</p>
<p>重点的内容是，a标签也可以有rel属性，我们来简单了解一下，首先是跟link相同的一些rel，包括下面的几种。</p>
<ul>
<li>alternate</li>
<li>author</li>
<li>help</li>
<li>license</li>
<li>next</li>
<li>prev</li>
<li>search</li>
</ul>
<p>这些跟link语义完全一致，不同的是，a标签产生的链接是会实际显示在网页中的，而link标签仅仅是元信息。</p>
<p>除了这些之外，a标签独有的rel类型：</p>
<ul>
<li>tag 表示本网页所属的标签；</li>
<li>bookmark 到上级章节的链接。</li>
</ul>
<p>a标签还有一些辅助的rel类型，用于提示浏览器或者搜索引擎做一些处理：</p>
<ul>
<li>nofollow 此链接不会被搜索引擎索引；</li>
<li>noopener 此链接打开的网页无法使用opener来获得当前页面的窗口；</li>
<li>noreferrer 此链接打开的网页无法使用referrer来获得当前页面的url；</li>
<li>opener 打开的网页可以使用window.opener来访问当前页面的window对象，这是a标签的默认行为。</li>
</ul>
<p>a标签基本解决了在页面中插入文字型和整张图片超链接的需要，但是如果我们想要在图片的某个区域产生超链接，那么就要用到另一种标签了——area标签。</p>
<h2 id="area-标签"><a href="#area-标签" class="headerlink" title="area 标签"></a>area 标签</h2><p>area标签与a标签非常相似，不同的是，它不是文本型的链接，而是区域型的链接。</p>
<p>area标签支持的rel与a完全一样，这里就不多说了。</p>
<p>area是整个html规则中唯一支持非矩形热区的标签，它的shape属性支持三种类型。</p>
<ul>
<li>圆形：circle或者circ，coords支持三个值，分别表示中心点的x,y坐标和圆形半径r。</li>
<li>矩形：rect或者rectangle，coords支持两个值，分别表示两个对角顶点x1，y1和x2，y2。</li>
<li>多边形：poly或者polygon，coords至少包括6个值，表示多边形的各个顶点。</li>
</ul>
<p>因为area设计的时间较早，所以不支持含有各种曲线的路径，但是它也是唯一一个支持了非矩形触发区域的元素，所以，对于一些效果而言，area是必不可少的。</p>
<p>area必须跟img和map标签配合使用。使用示例如下（例子来自html标准）。</p>
<pre><code>&lt;p&gt;
 Please select a shape:
 &lt;img src=&quot;shapes.png&quot; usemap=&quot;#shapes&quot;
      alt=&quot;Four shapes are available: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star.&quot;&gt;
 &lt;map name=&quot;shapes&quot;&gt;
  &lt;area shape=rect coords=&quot;50,50,100,100&quot;&gt; &lt;!-- the hole in the red box --&gt;
  &lt;area shape=rect coords=&quot;25,25,125,125&quot; href=&quot;red.html&quot; alt=&quot;Red box.&quot;&gt;
  &lt;area shape=circle coords=&quot;200,75,50&quot; href=&quot;green.html&quot; alt=&quot;Green circle.&quot;&gt;
  &lt;area shape=poly coords=&quot;325,25,262,125,388,125&quot; href=&quot;blue.html&quot; alt=&quot;Blue triangle.&quot;&gt;
  &lt;area shape=poly coords=&quot;450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60&quot;
        href=&quot;yellow.html&quot; alt=&quot;Yellow star.&quot;&gt;
 &lt;/map&gt;
&lt;/p&gt;</code></pre><p>这个例子展示了在一张图片上画热区并且产生链接，分别使用了矩形、圆形和多边形三种area。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本节课我们介绍了几种链接类型。在HTML中，链接有两种类型。一种是超链接型标签，一种是外部资源链接。</p>
<p>我们逐次讲到了link标签、a标签和area标签，link标签一般用于看不见的链接，它可能产生超链接或者外部资源链接，a和area一般用于页面上显示的链接，它们只能产生超链接。</p>
<p>最后，留给你一个思考问题，你的工作中，是使用过哪些类型的link标签的呢？</p>
<h1 id="猜你喜欢"><a href="#猜你喜欢" class="headerlink" title="猜你喜欢"></a>猜你喜欢</h1><p><a href="https://time.geekbang.org/course/intro/163?utm_term=zeusMTA7L&amp;utm_source=app&amp;utm_medium=chongxueqianduan&amp;utm_campaign=163-presell" target="_blank" rel="noopener"><img src="https://static001.geekbang.org/resource/image/1a/08/1a49758821bdbdf6f0a8a1dc5bf39f08.jpg" alt="unpreview"></a></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:02:49.120Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/重学前端/">重学前端</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    22 minutes read (About 3366 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/重学前端/浏览器DOM：你知道HTML的节点有哪几种吗？/">浏览器DOM：你知道HTML的节点有哪几种吗？</a>
            
        </h1>
        <div class="content">
            <p>你好，我是winter。</p>
<p>今天我们进入浏览器API的学习, 这一节课，我们来学习一下DOM API。</p>
<p>DOM API是最早被设计出来的一批API，也是用途最广的API，所以早年的技术社区，常常用DOM来泛指浏览器中所有的API。不过今天这里我们要介绍的DOM，指的就是狭义的文档对象模型。</p>
<h2 id="DOM-API介绍"><a href="#DOM-API介绍" class="headerlink" title="DOM API介绍"></a>DOM API介绍</h2><p>首先我们先来讲一讲什么叫做文档对象模型。</p>
<p>顾名思义，文档对象模型是用来描述文档，这里的文档，是特指HTML文档（也用于XML文档，但是本课不讨论XML）。同时它又是一个“对象模型”，这意味着它使用的是对象这样的概念来描述HTML文档。</p>
<p>说起HTML文档，这是大家最熟悉的东西了，我们都知道，HTML文档是一个由标签嵌套而成的树形结构，因此，DOM也是使用树形的对象模型来描述一个HTML文档。</p>
<p>DOM API大致会包含4个部分。</p>
<ul>
<li>节点：DOM树形结构中的节点相关API。</li>
<li>事件：触发和监听事件相关API。</li>
<li>Range：操作文字范围相关API。</li>
<li>遍历：遍历DOM需要的API。</li>
</ul>
<p>事件相关API和事件模型，我们会用单独的课程讲解，所以我们本篇文章重点会为你介绍节点和遍历相关API。</p>
<p>DOM API 数量很多，我希望给你提供一个理解DOM API设计的思路，避免单靠机械的方式去死记硬背。</p>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>DOM的树形结构所有的节点有统一的接口Node，我们按照继承关系，给你介绍一下节点的类型。</p>
<p><img src="https://static001.geekbang.org/resource/image/6e/f6/6e278e450d8cc7122da3616fd18b9cf6.png" alt></p>
<p>在这些节点中，除了Document和DocumentFrangment，都有与之对应的HTML写法，我们可以看一下。</p>
<pre><code>Element: &lt;tagname&gt;...&lt;/tagname&gt;
Text: text
Comment: &lt;!-- comments --&gt;
DocumentType: &lt;!Doctype html&gt;
ProcessingInstruction: &lt;?a 1?&gt;</code></pre><p>我们在编写HTML代码并且运行后，就会在内存中得到这样一棵DOM树，HTML的写法会被转化成对应的文档模型，而我们则可以通过JavaScript等语言去访问这个文档模型。</p>
<p>这里我们每天都需要用到，要重点掌握的是：Document、Element、Text节点。</p>
<p>DocumentFragment也非常有用，它常常被用来高性能地批量添加节点。因为Comment、DocumentType和ProcessingInstruction很少需要运行时去修改和操作，所以有所了解即可。</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node是DOM树继承关系的根节点，它定义了DOM节点在DOM树上的操作，首先，Node提供了一组属性，来表示它在DOM树中的关系，它们是：</p>
<ul>
<li>parentNode</li>
<li>childNodes</li>
<li>firstChild</li>
<li>lastChild</li>
<li>nextSibling</li>
<li>previousSibling</li>
</ul>
<p>从命名上，我们可以很清晰地看出，这一组属性提供了前、后、父、子关系，有了这几个属性，我们可以很方便地根据相对位置获取元素。当然，Node中也提供了操作DOM树的API，主要有下面几种。</p>
<ul>
<li>appendChild</li>
<li>insertBefore</li>
<li>removeChild</li>
<li>replaceChild</li>
</ul>
<p>这个命名跟上面一样，我们基本可以知道API的作用。这几个API的设计可以说是饱受诟病。其中最主要的批评是它不对称——只有before，没有after，而jQuery等框架都对其做了补充。</p>
<p>实际上，appendChild和insertBefore的这个设计，是一个“最小原则”的设计，这两个API是满足插入任意位置的必要API，而insertAfter，则可以由这两个API实现出来。</p>
<p>我个人其实不太喜欢这个设计，对我而言，insertAt(pos) 更符合审美一些。当然，不论喜不喜欢，这个标准已经确定，我们还是必须要掌握它。</p>
<p>这里从设计的角度还想要谈一点，那就是，所有这几个修改型的API，全都是在父元素上操作的，比如我们要想实现“删除一个元素的上一个元素”，必须要先用parentNode获取其父元素。</p>
<p>这样的设计是符合面向对象的基本原则的。还记得我们在JavaScript对象部分讲的对象基本特征吗？“拥有哪些子元素”是父元素的一种状态，所以修改状态，应该是父元素的行为。这个设计我认为是DOM API中好的部分。</p>
<p>到此为止，Node提供的API已经可以很方便（大概吧）地对树进行增、删、遍历等操作了。</p>
<p>除此之外，Node还提供了一些高级API，我们来认识一下它们。</p>
<ul>
<li>compareDocumentPosition 是一个用于比较两个节点中关系的函数。</li>
<li>contains 检查一个节点是否包含另一个节点的函数。</li>
<li>isEqualNode 检查两个节点是否完全相同。</li>
<li>isSameNode 检查两个节点是否是同一个节点，实际上在JavaScript中可以用“===”。</li>
<li>cloneNode 复制一个节点，如果传入参数true，则会连同子元素做深拷贝。</li>
</ul>
<p>DOM标准规定了节点必须从文档的create方法创建出来，不能够使用原生的JavaScript的new运算。于是document对象有这些方法。</p>
<ul>
<li>createElement</li>
<li>createTextNode</li>
<li>createCDATASection</li>
<li>createComment</li>
<li>createProcessingInstruction</li>
<li>createDocumentFragment</li>
<li>createDocumentType</li>
</ul>
<p>上面的这些方法都是用于创建对应的节点类型。你可以自己尝试一下。</p>
<h2 id="Element-与-Attribute"><a href="#Element-与-Attribute" class="headerlink" title="Element 与 Attribute"></a>Element 与 Attribute</h2><p>Node提供了树形结构上节点相关的操作。而大部分时候，我们比较关注的是元素。Element表示元素，它是Node的子类。</p>
<p>元素对应了HTML中的标签，它既有子节点，又有属性。所以Element子类中，有一系列操作属性的方法。</p>
<p>我们需要注意，对DOM而言，Attribute和Property是完全不同的含义，只有特性场景下，两者才会互相关联（这里在后面我会详细讲解，今天的文章里我就不展开了）。</p>
<p>首先，我们可以把元素的Attribute当作字符串来看待，这样就有以下的API：</p>
<ul>
<li>getAttribute</li>
<li>setAttribute</li>
<li>removeAttribute</li>
<li>hasAttribute</li>
</ul>
<p>如果你追求极致的性能，还可以把Attribute当作节点：</p>
<ul>
<li>getAttributeNode</li>
<li>setAttributeNode</li>
</ul>
<p>此外，如果你喜欢property一样的访问attribute，还可以使用 attributes 对象，比如 document.body.attributes.class = “a” 等效于 document.body.setAttribute(“class”, “a”)。</p>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>document节点提供了查找元素的能力。比如有下面的几种。</p>
<ul>
<li>querySelector</li>
<li>querySelectorAll</li>
<li>getElementById</li>
<li>getElementsByName</li>
<li>getElementsByTagName</li>
<li>getElementsByClassName</li>
</ul>
<p>我们需要注意，getElementById、getElementsByName、getElementsByTagName、getElementsByClassName，这几个API的性能高于querySelector。</p>
<p>而 getElementsByName、getElementsByTagName、getElementsByClassName 获取的集合并非数组，而是一个能够动态更新的集合。</p>
<p>我们看一个例子：</p>
<pre><code>var collection = document.getElementsByClassName(&apos;winter&apos;);
console.log(collection.length);
var winter = document.createElement(&apos;div&apos;);
winter.setAttribute(&apos;class&apos;, &apos;winter&apos;)
document.documentElement.appendChild(winter)
console.log(collection.length);</code></pre><p>在这段代码中，我们先获取了页面的className为winter的元素集合，不出意外的话，应该是空。</p>
<p>我们通过console.log可以看到集合的大小为0。之后我们添加了一个class为winter的div，这时候我们再看集合，可以发现，集合中出现了新添加的元素。</p>
<p>这说明浏览器内部是有高速的索引机制，来动态更新这样的集合的。所以，尽管querySelector系列的API非常强大，我们还是应该尽量使用getElement系列的API。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>前面已经提到过，通过Node的相关属性，我们可以用JavaScript遍历整个树。实际上，DOM API中还提供了NodeIterator 和 TreeWalker 来遍历树。</p>
<p>比起直接用属性来遍历，NodeIterator 和 TreeWalker 提供了过滤功能，还可以把属性节点也包含在遍历之内。</p>
<p>NodeIterator的基本用法示例如下：</p>
<pre><code>var iterator = document.createNodeIterator(document.body, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_COMMENT, null, false);
var node;
while(node = iterator.nextNode())
{
    console.log(node);
}</code></pre><p>这个API的设计非常老派，这么讲的原因主要有两点，一是循环并没有类似“hasNext”这样的方法，而是直接以nextNode返回null来标志结束，二是第二个参数是掩码，这两个设计都是传统C语言里比较常见的用法。</p>
<p>放到今天看，这个迭代器无法匹配JavaScript的迭代器语法，而且JavaScript位运算并不高效，掩码的设计就徒增复杂性了。</p>
<p>这里请你注意一下这个例子中的处理方法，通常掩码型参数，我们都是用按位或运算来叠加。而针对这种返回null表示结束的迭代器，我使用了在while循环条件中赋值，来保证循环次数和调用next次数严格一致（但这样写可能违反了某些编码规范）。</p>
<p>我们再来看一下TreeWalker的用法。</p>
<pre><code>var walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, null, false)
var node;
while(node = walker.nextNode())
{
    if(node.tagName === &quot;p&quot;)
        node.nextSibling();
    console.log(node);
}</code></pre><p>比起NodeIterator，TreeWalker多了在DOM树上自由移动当前节点的能力，一般来说，这种API用于“跳过”某些节点，或者重复遍历某些节点。</p>
<p>总的来说，我个人不太喜欢TreeWalker和NodeIterator这两个API，建议需要遍历DOM的时候，直接使用递归和Node的属性。</p>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p>Range API 是一个比较专业的领域，如果不做富文本编辑类的业务，不需要太深入。这里我们就仅介绍概念和给出基本用法的示例，你只要掌握即可。</p>
<p>Range API 表示一个HTML上的范围，这个范围是以文字为最小单位的，所以Range不一定包含完整的节点，它可能是Text节点中的一段，也可以是头尾两个Text的一部分加上中间的元素。</p>
<p>我们通过 Range API 可以比节点 API 更精确地操作 DOM 树，凡是 节点 API 能做到的，Range API都可以做到，而且可以做到更高性能，但是 Range API 使用起来比较麻烦，所以在实际项目中，并不常用，只有做底层框架和富文本编辑对它有强需求。</p>
<p>创建Range一般是通过设置它的起止来实现，我们可以看一个例子：</p>
<pre><code>var range = new Range(),
    firstText = p.childNodes[1],
    secondText = em.firstChild
range.setStart(firstText, 9) // do not forget the leading space
range.setEnd(secondText, 4)</code></pre><p>此外，通过 Range 也可以从用户选中区域创建，这样的Range用于处理用户选中区域:</p>
<pre><code>var range = document.getSelection().getRangeAt(0);</code></pre><p>更改 Range 选中区段内容的方式主要是取出和插入，分别由extractContents和insertNode来实现。</p>
<pre><code>var fragment = range.extractContents()
range.insertNode(document.createTextNode(&quot;aaaa&quot;))</code></pre><p>最后我们看一个完整的例子。</p>
<pre><code>var range = new Range(),
    firstText = p.childNodes[1],
    secondText = em.firstChild
range.setStart(firstText, 9) // do not forget the leading space
range.setEnd(secondText, 4)

var fragment = range.extractContents()
range.insertNode(document.createTextNode(&quot;aaaa&quot;))</code></pre><p>这个例子展示了如何使用range来取出元素和在特定位置添加新元素。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在今天的文章中，我们一起了解了DOM API的内容。DOM API大致会包含4个部分。</p>
<ul>
<li>节点：DOM树形结构中的节点相关API。</li>
<li>事件：触发和监听事件相关API。</li>
<li>Range：操作文字范围相关API。</li>
<li>遍历：遍历DOM需要的API。</li>
</ul>
<p>DOM API中还提供了NodeIterator 和 TreeWalker 来遍历树。比起直接用属性来遍历，NodeIterator 和 TreeWalker 提供了过滤功能，还可以把属性节点也包含在遍历之内。</p>
<p>除此之外，我们还谈到了Range的一些基础知识点，这里你掌握即可。</p>
<p>最后，我给你留了一个题目，请你用DOM API来实现遍历整个DOM树，把所有的元素的tagName打印出来。</p>
<hr>
<h3 id="补充阅读：命名空间"><a href="#补充阅读：命名空间" class="headerlink" title="补充阅读：命名空间"></a>补充阅读：命名空间</h3><p>我们本课介绍的所有API，特意忽略了命名空间。</p>
<p>在HTML场景中，需要考虑命名空间的场景不多。最主要的场景是SVG。创建元素和属性相关的API都有带命名空间的版本：</p>
<ul>
<li><p>document</p>
</li>
<li><p>createElementNS</p>
</li>
<li><p>createAttributeNS</p>
</li>
<li><p>Element</p>
</li>
<li><p>getAttributeNS</p>
</li>
<li><p>setAttributeNS</p>
</li>
<li><p>getAttributeNodeNS</p>
</li>
<li><p>setAttributeNodeNS</p>
</li>
<li><p>removeAttributeNS</p>
</li>
<li><p>hasAttributeNS</p>
</li>
<li><p>attributes.setNamedItemNS</p>
</li>
<li><p>attributes.getNamedItemNS</p>
</li>
<li><p>attributes.removeNamedItemNS</p>
</li>
</ul>
<p>若要创建Document或者Doctype，也必须要考虑命名空间问题。DOM要求从document.implementation来创建。</p>
<ul>
<li>document.implementation.createDocument</li>
<li>document.implementation.createDocumentType</li>
</ul>
<p>除此之外，还提供了一个快捷方式，你也可以动手尝试一下。</p>
<ul>
<li>document.implementation.createHTMLDocument</li>
</ul>
<h1 id="猜你喜欢"><a href="#猜你喜欢" class="headerlink" title="猜你喜欢"></a>猜你喜欢</h1><p><a href="https://time.geekbang.org/course/intro/163?utm_term=zeusMTA7L&amp;utm_source=app&amp;utm_medium=chongxueqianduan&amp;utm_campaign=163-presell" target="_blank" rel="noopener"><img src="https://static001.geekbang.org/resource/image/1a/08/1a49758821bdbdf6f0a8a1dc5bf39f08.jpg" alt="unpreview"></a></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:02:47.154Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/重学前端/">重学前端</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    21 minutes read (About 3160 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/重学前端/CSS选择器：伪元素是怎么回事儿？/">CSS选择器：伪元素是怎么回事儿？</a>
            
        </h1>
        <div class="content">
            <p>你好，我是winter。</p>
<p>在上一篇文章中，我已经给你介绍了一些简单选择器，这一节课我会继续给你介绍选择器的几个机制：选择器的组合、选择器的优先级和伪元素。</p>
<h2 id="选择器的组合"><a href="#选择器的组合" class="headerlink" title="选择器的组合"></a>选择器的组合</h2><p>在CSS规则中，选择器部分是一个选择器列表。</p>
<p>选择器列表是用逗号分隔的复杂选择器序列；复杂选择器则是用空格、大于号、波浪线等符号连接的复合选择器；复合选择器则是连写的简单选择器组合。</p>
<p>根据选择器列表的语法，选择器的连接方式可以理解为像四则运算一样有优先级。</p>
<ul>
<li><p>第一优先级</p>
</li>
<li><p>无连接符号</p>
</li>
<li><p>第二优先级</p>
</li>
<li><p>“空格”</p>
</li>
<li><p>“~”</p>
</li>
<li><p>“+”</p>
</li>
<li><p>“&gt;”</p>
</li>
<li><p>“||”</p>
</li>
<li><p>第三优先级</p>
</li>
<li><p>“,”</p>
</li>
</ul>
<p>例如以下选择器：</p>
<pre><code>.c,.a&gt;.b.d {
    /*......*/
}</code></pre><p>我们应该理解为这样的结构。</p>
<ul>
<li><p>.c,.a&gt;.b.d</p>
</li>
<li><p>.c</p>
</li>
<li><p>.a&gt;.b.d</p>
</li>
<li><p>.a</p>
</li>
<li><p>.b.d</p>
</li>
<li><p>.b</p>
</li>
<li><p>.d</p>
</li>
</ul>
<p>复合选择器表示简单选择器中“且”的关系，例如，例子中的“ .b.d ”，表示选中的元素必须同时具有b和d两个class。</p>
<p>复杂选择器是针对节点关系的选择，它规定了五种连接符号。</p>
<ul>
<li><strong>“空格”</strong>：后代，表示选中所有符合条件的后代节点， 例如“ .a .b ”表示选中所有具有class为a的后代节点中class为b的节点。</li>
<li><strong>“&gt;”</strong> ：子代，表示选中符合条件的子节点，例如“ .a&gt;.b ”表示：选中所有“具有class为a的子节点中，class为b的节点”。</li>
<li>*<em>“~” *</em>: 后继，表示选中所有符合条件的后继节点，后继节点即跟当前节点具有同一个父元素，并出现在它之后的节点，例如“ .a~.b ”表示选中所有具有class为a的后继中，class为b的节点。</li>
<li><strong>“+”</strong>：直接后继，表示选中符合条件的直接后继节点，直接后继节点即nextSlibling。例如 “.a+.b ”表示选中所有具有class为a的下一个class为b的节点。</li>
<li><strong>“||”</strong>：列选择器，表示选中对应列中符合条件的单元格。</li>
</ul>
<p>我们在实际使用时，比较常用的连接方式是“空格”和“&gt;”。</p>
<p>工程实践中一般会采用设置合理的class的方式，来避免过于复杂的选择器结构，这样更有利于维护和性能。</p>
<p>空格和子代选择器通常用于组件化场景，当组件是独立开发时，很难完全避免class重名的情况，如果为组件的最外层容器元素设置一个特别的class名，生成CSS规则时，则全部使用后代或者子代选择器，这样可以有效避免CSS规则的命名污染问题。</p>
<p>逗号表示“或”的关系，实际上，可以把它理解为“两条内容一样的CSS规则”的一种简写。如我们开头的例子，可以理解成与下面的代码等效：</p>
<pre><code>.c {
    /*......*/
}
.a&gt;.b.d {
    /*......*/
}</code></pre><p>到这里，我们就讲完了如何用简单选择器组合成复合选择器和复杂选择器，形成选择器列表，这能够帮助我们应对各种复杂的需求。</p>
<p>CSS选择器是基于规则生效的，同一个元素命中多条规则是非常常见的事情。不同规则指定同一个属性为不同值时，就需要一个机制来解决冲突。这个机制，就是接下来我们要讲的选择器优先级。</p>
<h2 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h2><p>CSS标准用一个三元组 (a, b, c) 来构成一个复杂选择器的优先级。</p>
<ul>
<li>id选择器的数目记为a；</li>
<li>伪类选择器和class选择器的数目记为b；</li>
<li>伪元素选择器和标签选择器数目记为c；</li>
<li>“*” 不影响优先级。</li>
</ul>
<p>CSS标准建议用一个足够大的进制，获取“ a-b-c ”来表示选择器优先级。</p>
<p>即：</p>
<pre><code>specificity = base * base * a + base * b + c</code></pre><p>其中，base是一个“足够大”的正整数。关于base，历史中有些趣闻，早年IE6采用256进制，于是就产生“256个class优先级等于一个id”这样的奇葩问题，后来扩大到65536，基本避免了类似的问题。</p>
<p>现代浏览器多采用了更大的数量，我们正常编写的CSS规则数量不太可能达到数万，因此我们可以认为这样的base就足够大了。</p>
<p>行内属性的优先级永远高于CSS规则，浏览器提供了一个“口子”，就是在选择器前加上“!import”。</p>
<p>这个用法非常危险，因为它相当于一个新的优先级，而且此优先级会高于行内属性。</p>
<p>同一优先级的选择器遵循“后面的覆盖前面的”原则，我们可以看一个例子：</p>
<pre><code>&lt;div id=&quot;my&quot; class=&quot;x y&quot;&gt;text&lt;div&gt;


.x {
    background-color:lightblue;
}
.y {
    background-color:lightgreen;
}</code></pre><p>调换“.x”和“.y”我们可以得到不同的显示效果。选择器的优先级是针对单条规则的，多条规则的选择器同时命中元素，优先级不会发生叠加。</p>
<pre><code>&lt;div id=&quot;my&quot; class=&quot;x y z&quot;&gt;text&lt;div&gt;


.x {
    background-color:lightblue;
}
.z {
    background-color:lightblue;
}
.y {
    background-color:lightgreen;
}</code></pre><p>在这个例子中，“.x ”和“.z ”都指定了背景色为浅蓝色，但是因为“.y ”规则在最后，所以最终显示结果为浅绿色。另外一个需要注意的是，选择器的优先级是针对复杂选择器的优先级，选择器列表不会合并计算优先级。</p>
<p>我们看一个例子：</p>
<pre><code>&lt;div id=&quot;my&quot; class=&quot;x y z&quot;&gt;text&lt;div&gt;


.x, .z {
    background-color:lightblue;
}
.y {
    background-color:lightgreen;
}</code></pre><p>这里选择器列表“ .x, .z”命中了div，但是它的两项分别计算优先级，所以最终优先级仍跟“ .y” 规则相同。</p>
<p>以上就是选择器优先级的相关规则了，虽然我们这里介绍了详细的计算方式，但是我认为选择器的使用上，如果产生复杂的优先级计算，代码的可读性一定是有问题的。</p>
<p>所以实践中，建议你“根据 id 选单个元素”“class和class的组合选成组元素”“tag选择器确定页面风格”这样的简单原则来使用选择器，不要搞出过于复杂的选择器。</p>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>在上一课，我们有意忽略了一种重要的简单选择器：伪元素。</p>
<p>我之所以没有把它放在简单选择器中，是因为伪元素本身不单单是一种选择规则，它还是一种机制。</p>
<p>所以本节课，我就来讲一讲伪元素机制。伪元素的语法跟伪类相似，但是实际产生的效果却是把不存在的元素硬选出来。</p>
<p>目前兼容性达到可用的伪元素有以下几种。</p>
<ul>
<li>::first-line</li>
<li>::first-letter</li>
<li>::before</li>
<li>::after</li>
</ul>
<p>下面我们就来分别讲讲它们。</p>
<p><strong>::first-line 和 ::first-letter 是比较类似的伪元素</strong>，其中一个表示元素的第一行，一个表示元素的第一个字母。</p>
<p>我们可以看一个示例：</p>
<pre><code>&lt;p&gt;This is a somewhat long HTML
paragraph that will be broken into several
lines. The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/p&gt;


p::first-line { 
    text-transform: uppercase 
}</code></pre><p>这一段代码把段落的第一行字母变为大写。注意这里的第一行指的是排版后显示的第一行，跟HTML代码中的换行无关。</p>
<p>::first-letter 则指第一个字母。首字母变大并向左浮动是一个非常常见的排版方式。</p>
<pre><code>&lt;p&gt;This is a somewhat long HTML
paragraph that will be broken into several
lines. The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/p&gt;


p::first-letter { 
    text-transform: uppercase;
    font-size:2em;
    float:left; 
}</code></pre><p>虽然听上去很简单，但是实际上，我们遇到的HTML结构要更为复杂，一旦元素中不是纯文本，规则就变得复杂了。</p>
<p>CSS标准规定了first-line必须出现在最内层的块级元素之内。因此，我们考虑以下代码。</p>
<pre><code>&lt;div&gt;
  &lt;p id=a&gt;First paragraph&lt;/p&gt;
  &lt;p&gt;Second paragraph&lt;/p&gt;
&lt;/div&gt;


div&gt;p#a {
    color:green;
}

div::first-line { 
    color:blue; 
}</code></pre><p>这段代码最终结果第一行是蓝色，因为p是块级元素，所以伪元素出现在块级元素之内，所以内层的color覆盖了外层的color属性。</p>
<p>如果我们把p换成span，结果就是相反的。</p>
<pre><code>&lt;div&gt;
  &lt;span id=a&gt;First paragraph&lt;/span&gt;&lt;br/&gt;
  &lt;span&gt;Second paragraph&lt;/span&gt;
&lt;/div&gt;


div&gt;span#a {
    color:green;
}

div::first-line { 
    color:blue; 
}</code></pre><p>这段代码的最终结果是绿色，这说明伪元素在span之外。</p>
<p>::first-letter的行为又有所不同，它的位置在所有标签之内，我们把前面的代码换成::first-letter。</p>
<pre><code>&lt;div&gt;
  &lt;span id=a&gt;First paragraph&lt;/span&gt;&lt;br/&gt;
  &lt;span&gt;Second paragraph&lt;/span&gt;
&lt;/div&gt;


div&gt;span#a {
    color:green;
}

div::first-letter { 
    color:blue; 
}</code></pre><p>执行这段代码，我们可以看到，首字母变成了蓝色，这说明伪元素出现在span之内。</p>
<p>CSS标准只要求 ::first-line 和 ::first-letter 实现有限的几个CSS属性，都是文本相关，这些属性是下面这些。</p>
<p><img src="https://static001.geekbang.org/resource/image/6e/48/6e050ee9f7a0b1657388271cceb0c548.png" alt></p>
<p><strong>接下来我们说说 ::before 和 ::after 伪元素。</strong></p>
<p>这两个伪元素跟前面两个不同的是，它不是把已有的内容套上一个元素，而是真正的无中生有，造出一个元素。</p>
<p>::before 表示在元素内容之前插入一个虚拟的元素，::after 则表示在元素内容之后插入。</p>
<p>这两个伪元素所在的CSS规则必须指定content属性才会生效，我们看下例子：</p>
<pre><code>&lt;p class=&quot;special&quot;&gt;I&apos;m real element&lt;/p&gt;


p.special::before {
    display: block;
    content: &quot;pseudo! &quot;;
}</code></pre><p>这里要注意一点，::before 和 ::after 还支持content为counter，如：</p>
<pre><code>&lt;p class=&quot;special&quot;&gt;I&apos;m real element&lt;/p&gt;
p.special::before {
    display: block;
    content: counter(chapno, upper-roman) &quot;. &quot;;
}</code></pre><p>这对于实现一些列表样式是非常有用的。</p>
<p>::before 和 ::after 中支持所有的CSS属性。实际开发中，这两个伪元素非常有用，有了这两个伪元素，一些修饰性元素，可以使用纯粹的CSS代码添加进去，这能够很好地保持HTML代码中的语义，既完成了显示效果，又不会让DOM中出现很多无语义的空元素。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这一课，我们讲了CSS选择器的三种机制：选择器的组合、选择器优先级、以及伪元素。</p>
<p>在选择器组合这一部分，我们讲到了，选择器的连接方式像四则运算一样有优先级。</p>
<p>第一优先级是无连接符号；第二优先级是：“空格”“~”“+”“&gt;”“||”；第三优先级是“,”。</p>
<p>然后我们又介绍了选择器优先级的计算方式。</p>
<p>最后我们介绍了伪元素，我们逐次讲解了：</p>
<ul>
<li>::first-line</li>
<li>::first-letter</li>
<li>::before</li>
<li>::after</li>
</ul>
<p>四种伪元素。伪元素的语法跟伪类相似，但是实际产生的效果是把不存在的元素硬选出来。这一点就与伪类不太一样了。</p>
<p>结合上一节课我们讲的简单选择器，对它们灵活运用，就能够满足大部分CSS的使用场景的需求了。</p>
<p>最后，留给你一个问题，你所在的团队，如何规定CSS选择器的编写规范？你觉得它好吗？</p>
<h1 id="猜你喜欢"><a href="#猜你喜欢" class="headerlink" title="猜你喜欢"></a>猜你喜欢</h1><p><a href="https://time.geekbang.org/course/intro/163?utm_term=zeusMTA7L&amp;utm_source=app&amp;utm_medium=chongxueqianduan&amp;utm_campaign=163-presell" target="_blank" rel="noopener"><img src="https://static001.geekbang.org/resource/image/1a/08/1a49758821bdbdf6f0a8a1dc5bf39f08.jpg" alt="unpreview"></a></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:02:45.219Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/重学前端/">重学前端</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    18 minutes read (About 2668 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/重学前端/CSS 选择器：如何选中svg里的a元素？/">CSS 选择器：如何选中svg里的a元素？</a>
            
        </h1>
        <div class="content">
            <p>你好，我是winter。</p>
<p>我们在之前CSS语法课程中，已经介绍了关于选择器的一部分基础知识。在今天的这一课里，我们来系统学习一下CSS选择器。</p>
<p>在CSS语法课程中，我们已经见过一些选择器了，但在进入到具体的选择器介绍之前，我们首先要对选择器有一个整体的认识。</p>
<p>我先来讲讲选择器是什么，选择器是由CSS最先引入的一个机制（但随着document.querySelector等API的加入，选择器已经不仅仅是CSS的一部分了）。我们今天这一课，就重点讲讲CSS选择器的一些机制。</p>
<p><strong>选择器的基本意义是：根据一些特征，选中元素树上的一批元素。</strong></p>
<p>我们把选择器的结构分一下类，那么由简单到复杂可以分成以下几种。</p>
<ul>
<li>简单选择器：针对某一特征判断是否选中元素。</li>
<li>复合选择器：连续写在一起的简单选择器，针对元素自身特征选择单个元素。</li>
<li>复杂选择器：由“（空格）”“ &gt;”“ ~”“ +”“ ||”等符号连接的复合选择器，根据父元素或者前序元素检查单个元素。</li>
<li>选择器列表：由逗号分隔的复杂选择器，表示“或”的关系。</li>
</ul>
<p>我们可以看到，选择器是由简单选择器逐级组合而成的结构，那么我们就来首先看一下简单选择器。</p>
<h2 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h2><p>我们在前面说过，简单选择器是针对某一特征判断是否为选中元素。今天我会为你介绍一系列常见的简单选择器，我们把相似的简单选择器放在一起，这样更易于你去记忆。</p>
<p><img src="https://static001.geekbang.org/resource/image/4c/ce/4c9ac78870342dc802137ea9c848c0ce.png" alt></p>
<h2 id="类型选择器和全体选择器"><a href="#类型选择器和全体选择器" class="headerlink" title="类型选择器和全体选择器"></a>类型选择器和全体选择器</h2><p>我们要介绍的第一个简单选择器就是类型选择器，它根据一个元素的标签名来选中元素。</p>
<p>比如：</p>
<pre><code>div {

}</code></pre><p>这看上去非常简单，但是实际上，我们还必须要考虑HTML或者XML元素的命名空间问题。</p>
<p>比如我们的svg元素，实际上在： <a href="http://www.w3.org/2000/svg" target="_blank" rel="noopener">http://www.w3.org/2000/svg</a> 命名空间之下。</p>
<p>svg和HTML中都有a元素，我们若要想区分选择svg中的a和HTML中的a，就必须用带命名空间的类型选择器。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;JS Bin&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;svg width=&quot;100&quot; height=&quot;28&quot; viewBox=&quot;0 0 100 28&quot; version=&quot;1.1&quot;
     xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt;
  &lt;desc&gt;Example link01 - a link on an ellipse
  &lt;/desc&gt;
  &lt;a xlink:href=&quot;http://www.w3.org&quot;&gt;
    &lt;text y=&quot;100%&quot;&gt;name&lt;/text&gt;
  &lt;/a&gt;
&lt;/svg&gt;
&lt;br/&gt;
&lt;a href=&quot;javascript:void 0;&quot;&gt;name&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;

@namespace svg url(http://www.w3.org/2000/svg);
@namespace html url(http://www.w3.org/1999/xhtml);
svg|a {
  stroke:blue;
  stroke-width:1;
}

html|a {
  font-size:40px
}</code></pre><p>这里有一个特殊的选择器，就是“ * ” ，它称为全体选择器，可以选中任意元素。它的用法跟类型选择器是完全一致的，这里就把它们放到一起介绍了。</p>
<h2 id="id选择器与class选择器"><a href="#id选择器与class选择器" class="headerlink" title="id选择器与class选择器"></a>id选择器与class选择器</h2><p>id选择器和class选择器都是针对特定属性的选择器。id选择器是“#”号后面跟随id名，class选择器是“.”后面跟随class名。我们来看看基本用法：</p>
<pre><code>#myid {
  stroke:blue;
  stroke-width:1;
}

.mycls {
  font-size:40px
}</code></pre><p>这两个选择器都是在属性选择器之前就设计出来的选择器，属性选择器出来了以后，理论上可以一定程度上替代它们。但是要注意，class选择器识别的是：用空格分隔的class语法。</p>
<pre><code>&lt;a class=&quot;a b c&quot;&gt;xxx&lt;/a&gt;
.a {
    color:red;
}</code></pre><p>在这个例子中，我们使用了用空格分隔的class属性，使用“.a”“.b”或者“.c”都能够选中元素，也可以使用多个class选择器来要求元素具有多个类。</p>
<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>属性选择器根据HTML元素的属性来选中元素。属性选择器有四种形态。</p>
<ul>
<li>第一种，[att]</li>
</ul>
<p>直接在方括号中放入属性名，是检查元素是否具有这个属性，只要元素有这个属性，不论属性是什么值，都可以被选中。</p>
<ul>
<li>第二种，[att=val]</li>
</ul>
<p>精确匹配，检查一个元素属性的值是否是val。</p>
<ul>
<li>第三种，[att~=val]</li>
</ul>
<p>多种匹配，检查一个元素的值是否是若干值之一，这里的val不是一个单一的值了，可以是用空格分隔的一个序列。</p>
<ul>
<li>第四种，[att|=val]</li>
</ul>
<p>开头匹配，检查一个元素的值是否是以val开头，它跟精确匹配的区别是属性只要以val开头即可，后面内容不管。</p>
<p>有些HTML属性含有特殊字符，这个时候，可以把val用引号括起来，形成一个CSS字符串。CSS字符串允许使用单双引号来规避特殊字符，也可以用反斜杠转义，这样，就可以表示出任意属性值啦。</p>
<h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>接下来我们开始介绍伪类选择器，伪类选择器是一系列由CSS规定好的选择器，它们以冒号开头。伪类选择器有普通型和函数型两种。</p>
<p>我们首先来介绍一下伪类中最常用的部分：树结构关系伪类。</p>
<h3 id="树结构关系伪类选择器"><a href="#树结构关系伪类选择器" class="headerlink" title="树结构关系伪类选择器"></a>树结构关系伪类选择器</h3><p>:root 伪类表示树的根元素，在选择器是针对完整的HTML文档情况，我们一般用HTML标签即可选中根元素。但是随着scoped css和shadow root等场景出现，选择器可以针对某一子树来选择，这时候就很需要root伪类了。</p>
<ul>
<li>:empty 伪类表示没有子节点的元素，这里有个例外就是子节点为空白文本节点的情况。</li>
<li>:nth-child 和 :nth-last-child 这是两个函数型的伪类，CSS的An+B语法设计的是比较复杂的，我们这里仅仅介绍基本用法。我们还是看几个例子：</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/1e/a9/1ebdba2978a22c13844d108318b271a9.png" alt></p>
<ul>
<li>:nth-last-child的区别仅仅是从后往前数。</li>
<li>:first-child :last-child 分别表示第一个和最后一个元素。</li>
<li>:only-child 按字面意思理解即可，选中唯一一个子元素。</li>
</ul>
<p>of-type系列，是一个变形的语法糖，S:nth-of-type(An+B)是:nth-child(|An+B| of S)的另一种写法。</p>
<p>以此类推，还有nth-last-of-type、first-of-type、last-of-type、only-of-type。</p>
<h3 id="链接与行为伪类选择器"><a href="#链接与行为伪类选择器" class="headerlink" title="链接与行为伪类选择器"></a>链接与行为伪类选择器</h3><p>链接与行为是第一批设计出来的伪类，也是最常用的一批。</p>
<ul>
<li>:any-link 表示任意的链接，包括a、area和link标签都可能匹配到这个伪类。</li>
<li>:link 表示未访问过的链接， :visited 表示已经访问过的链接。</li>
<li>:hover 表示鼠标悬停在上的元素。</li>
<li>:active 表示用户正在激活这个元素，如用户按下按钮，鼠标还未抬起时，这个按钮就处于激活状态。</li>
<li>:focus 表示焦点落在这个元素之上。</li>
<li>:target 用于选中浏览器URL的hash部分所指示的元素。</li>
</ul>
<p>在Selector Level 4草案中，还引入了 target-within、focus-within 等伪类，用于表示target或者focus的父容器。</p>
<h3 id="逻辑伪类选择器"><a href="#逻辑伪类选择器" class="headerlink" title="逻辑伪类选择器"></a>逻辑伪类选择器</h3><p>我们这里介绍一个逻辑伪类 —— :not 伪类。</p>
<p>这个伪类是个函数型伪类，它的作用时选中内部的简单选择器命中的元素。</p>
<pre><code>*|*:not(:hover)</code></pre><p>选择器3级标准中，not只支持简单选择器，在选择器4级标准，则允许not接受一个选择器列表，这意味着选择器支持嵌套，仅靠not即可完成选择器的一阶真值逻辑完备，但目前还没有看到浏览器实现它。</p>
<p>在Selector Level 4草案中，还引入了:is :where :has 等逻辑伪类，但是它们有一些违背了选择器匹配DOM树不回溯的原则，所以这部分设计最终的命运如何还不太确定。</p>
<h3 id="其它伪类选择器"><a href="#其它伪类选择器" class="headerlink" title="其它伪类选择器"></a>其它伪类选择器</h3><p>还有一些草案中或者不常用的选择器，你仅做大概了解即可。</p>
<ul>
<li><p>国际化：用于处理国际化和多语言问题。</p>
</li>
<li><p>dir</p>
</li>
<li><p>lang</p>
</li>
<li><p>音频/视频：用于区分音视频播放状态。</p>
</li>
<li><p>play</p>
</li>
<li><p>pause</p>
</li>
<li><p>时序：用于配合读屏软件等时序性客户端的伪类。</p>
</li>
<li><p>current</p>
</li>
<li><p>past</p>
</li>
<li><p>future</p>
</li>
<li><p>表格：用于处理table的列的伪类。</p>
</li>
<li><p>nth-col</p>
</li>
<li><p>nth-last-col</p>
</li>
</ul>
<p>伪类是很大的一类简单选择器，它是选择器能力的一种补充。在实际使用中，我还是建议你尽量通过合适的id和class来标识元素，约束伪类的使用。最好只在不得不使用伪类的场景使用伪类，这对于CSS代码的性能和可读性都有好处。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这一节课程中，我们介绍了CSS选择器的整体结构，并且介绍了一系列简单选择器。它们包括了下面这些内容。</p>
<ul>
<li>类型选择器：根据一个元素的标签名来选中元素。</li>
<li>全体选择器：与类型选择器类似，选择任意元素。</li>
<li>id选择器：#后面跟随id名。</li>
<li>class选择器：.后面跟随class名。</li>
<li>伪类选择器：一系列由CSS规定好的选择器，它们以冒号开头，伪类有普通型和函数型。</li>
</ul>
<p>在下一节课，我们开始进入到更复杂的情况，我们将会介绍选择器的组合使用方式和选择器的一些机制。</p>
<p>今天留给你的思考题是：用JavaScript实现一个能够处理所有简单选择器的querySelector（行为伪类除外），你可以把你的答案分享出来，我们一起来探讨吧。</p>
<p><img src="https://static001.geekbang.org/resource/image/7c/b1/7ca7c24e92d25bde2e8609ed5386b5b1.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:02:43.315Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/重学前端/">重学前端</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    15 minutes read (About 2252 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/重学前端/JavaScript执行（四）：try里面放return，finally还会执行吗？/">JavaScript执行（四）：try里面放return，finally还会执行吗？</a>
            
        </h1>
        <div class="content">
            <p>你好，我是winter。</p>
<p>在前面几篇文章中，我们已经了解了关于执行上下文、作用域、闭包之间的关系。</p>
<p>今天，我们则要说一说更为细节的部分：语句。</p>
<p>语句是任何编程语言的基础结构，与JavaScript对象一样，JavaScript语句同样具有“看起来很像其它语言，但是其实一点都不一样”的特点。</p>
<p>我们比较常见的语句包括变量声明、表达式、条件、循环等，这些都是大家非常熟悉的东西，对于它们的行为，我在这里就不赘述了。</p>
<p>为了了解JavaScript语句有哪些特别之处，首先我们要看一个不太常见的例子，我会通过这个例子，来向你介绍JavaScript语句执行机制涉及的一种基础类型：Completion类型。</p>
<h2 id="Completion类型"><a href="#Completion类型" class="headerlink" title="Completion类型"></a>Completion类型</h2><p>我们来看一个例子。在函数foo中，使用了一组try语句。我们可以先来做一个小实验，在try中有return语句，finally中的内容还会执行吗？我们来看一段代码。</p>
<pre><code>function foo(){
  try{
    return 0;
  } catch(err) {

  } finally {
    console.log(&quot;a&quot;)
  }
}

console.log(foo());</code></pre><p>通过实际试验，我们可以看到，finally确实执行了，而且return语句也生效了，foo()返回了结果0。</p>
<p>虽然return执行了，但是函数并没有立即返回，又执行了finally里面的内容，这样的行为违背了很多人的直觉。</p>
<p>如果在这个例子中，我们在finally中加入return语句，会发生什么呢？</p>
<pre><code>function foo(){
  try{
    return 0;
  } catch(err) {

  } finally {
    return 1;
  }
}

console.log(foo());</code></pre><p>通过实际执行，我们看到，finally中的return “覆盖”了try中的return。在一个函数中执行了两次return，这已经超出了很多人的常识，也是其它语言中不会出现的一种行为。</p>
<p>面对如此怪异的行为，我们当然可以把它作为一个孤立的知识去记忆，但是实际上，这背后有一套机制在运作。</p>
<p>这一机制的基础正是JavaScript语句执行的完成状态，我们用一个标准类型来表示：Completion Record（我在类型一节提到过，Completion Record用于描述异常、跳出等语句执行过程）。</p>
<p>Completion Record 表示一个语句执行完之后的结果，它有三个字段：</p>
<ul>
<li>[[type]] 表示完成的类型，有break continue return throw和normal几种类型；</li>
<li>[[value]] 表示语句的返回值，如果语句没有，则是empty；</li>
<li>[[target]] 表示语句的目标，通常是一个JavaScript标签（标签在后文会有介绍）。</li>
</ul>
<p>JavaScript正是依靠语句的 Completion Record类型，方才可以在语句的复杂嵌套结构中，实现各种控制。接下来我们要来了解一下JavaScript使用Completion Record类型，控制语句执行的过程。</p>
<p>首先我们来看看语句有几种分类。</p>
<p><img src="https://static001.geekbang.org/resource/image/98/d5/98ce53be306344c018cddd6c083392d5.jpg" alt></p>
<h2 id="普通的语句"><a href="#普通的语句" class="headerlink" title="普通的语句"></a>普通的语句</h2><p>在JavaScript中，我们把不带控制能力的语句称为普通语句。普通语句有下面几种。</p>
<ul>
<li><p>声明类语句</p>
</li>
<li><p>var声明</p>
</li>
<li><p>const声明</p>
</li>
<li><p>let声明</p>
</li>
<li><p>函数声明</p>
</li>
<li><p>类声明</p>
</li>
<li><p>表达式语句</p>
</li>
<li><p>空语句</p>
</li>
<li><p>debugger语句</p>
</li>
</ul>
<p>这些语句在执行时，从前到后顺次执行（我们这里先忽略var和函数声明的预处理机制），没有任何分支或者重复执行逻辑。</p>
<p>普通语句执行后，会得到 [[type]] 为 normal 的 Completion Record，JavaScript引擎遇到这样的Completion Record，会继续执行下一条语句。</p>
<p>这些语句中，只有表达式语句会产生 [[value]]，当然，从引擎控制的角度，这个value并没有什么用处。</p>
<p>如果你经常使用Chrome自带的调试工具，可以知道，输入一个表达式，在控制台可以得到结果，但是在前面加上var，就变成了undefined。</p>
<p><img src="https://static001.geekbang.org/resource/image/a3/67/a35801b1b82654d17e413e51b340d767.png" alt></p>
<p>Chrome控制台显示的正是语句的Completion Record的[[value]]。</p>
<h2 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h2><p>介绍完了普通语句，我们再来介绍一个比较特殊的语句：语句块。</p>
<p>语句块就是拿大括号括起来的一组语句，它是一种语句的复合结构，可以嵌套。</p>
<p>语句块本身并不复杂，我们需要注意的是语句块内部的语句的Completion Record的[[type]] 如果不为 normal，会打断语句块后续的语句执行。</p>
<p>比如我们考虑，一个[[type]]为return的语句，出现在一个语句块中的情况。</p>
<p>从语句的这个type中，我们大概可以猜到它由哪些特定语句产生，我们就来说说最开始的例子中的 return。</p>
<p>return语句可能产生return或者throw类型的Completion Record。我们来看一个例子。</p>
<p>先给出一个内部为普通语句的语句块：</p>
<pre><code>{
  var i = 1; // normal, empty, empty
  i ++; // normal, 1, empty
  console.log(i) //normal, undefined, empty
} // normal, undefined, empty</code></pre><p>在每一行的注释中，我给出了语句的Completion Record。</p>
<p>我们看到，在一个block中，如果每一个语句都是normal类型，那么它会顺次执行。接下来我们加入return试试看。</p>
<pre><code>{
  var i = 1; // normal, empty, empty
  return i; // return, 1, empty
  i ++; 
  console.log(i)
} // return, 1, empty</code></pre><p>但是假如我们在block中插入了一条return语句，产生了一个非normal记录，那么整个block会成为非normal。这个结构就保证了非normal的完成类型可以穿透复杂的语句嵌套结构，产生控制效果。</p>
<p>接下来我们就具体讲讲控制类语句。</p>
<h2 id="控制型语句"><a href="#控制型语句" class="headerlink" title="控制型语句"></a>控制型语句</h2><p>控制型语句带有 if、switch关键字，它们会对不同类型的Completion Record产生反应。</p>
<p>控制类语句分成两部分，一类是对其内部造成影响，如if、switch、while/for、try。</p>
<p>另一类是对外部造成影响如break、continue、return、throw，这两类语句的配合，会产生控制代码执行顺序和执行逻辑的效果，这也是我们编程的主要工作。</p>
<p>一般来说， for/while - break/continue 和 try - throw 这样比较符合逻辑的组合，是大家比较熟悉的，但是，实际上，我们需要控制语句跟break 、continue 、return 、throw四种类型与控制语句两两组合产生的效果。</p>
<p><img src="https://static001.geekbang.org/resource/image/77/d3/7760027d7ee09bdc8ec140efa9caf1d3.png" alt></p>
<p>通过这个表，我们不难发现知识的盲点，也就是我们最初的的case中的try和return的组合了。</p>
<p>因为finally中的内容必须保证执行，所以 try/catch执行完毕，即使得到的结果是非normal型的完成记录，也必须要执行finally。</p>
<p>而当finally执行也得到了非normal记录，则会使finally中的记录作为整个try结构的结果。</p>
<h2 id="带标签的语句"><a href="#带标签的语句" class="headerlink" title="带标签的语句"></a>带标签的语句</h2><p>前文我重点讲了type在语句控制中的作用，接下来我们重点来讲一下最后一个字段：target，这涉及了JavaScript中的一个语法，带标签的语句。</p>
<p>实际上，任何JavaScript语句是可以加标签的，在语句前加冒号即可：</p>
<pre><code>firstStatement: var i = 1;</code></pre><p>大部分时候，这个东西类似于注释，没有任何用处。唯一有作用的时候是：与完成记录类型中的target相配合，用于跳出多层循环。</p>
<pre><code>outer: while(true) {
  inner: while(true) {
      break outer;
  }
}
console.log(&quot;finished&quot;)</code></pre><p>break/continue 语句如果后跟了关键字，会产生带target的完成记录。一旦完成记录带了target，那么只有拥有对应label的循环语句会消费它。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我们以Completion Record类型为线索，为你讲解了JavaScript语句执行的原理。</p>
<p>因为JavaScript语句存在着嵌套关系，所以执行过程实际上主要在一个树形结构上进行， 树形结构的每一个节点执行后产生Completion Record，根据语句的结构和Completion Record，JavaScript实现了各种分支和跳出逻辑。</p>
<p>你遇到哪些语句中的执行的实际效果，是跟你想象的有所出入呢，你可以给我留言，我们一起讨论。</p>
<p><img src="https://static001.geekbang.org/resource/image/7c/b1/7ca7c24e92d25bde2e8609ed5386b5b1.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>









    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous">
            <a class="is-flex-grow has-text-black-ter" href="/page/6/">Préc</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/page/8/">Suiv</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link has-text-black-ter" href="/">1</a></li>
            
            <li><span class="pagination-ellipsis has-text-black-ter">&hellip;</span></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/6/">6</a></li>
            
            <li><a class="pagination-link is-current" href="/page/7/">7</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/8/">8</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/9/">9</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/10/">10</a></li>
            
        </ul>
    </nav>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                        <figure class="image is-128x128 has-mb-6">
                            <img class="is-rounded" src="https://ws2.sinaimg.cn/large/0067tbKZgy1g6j281yfbqj30ox0oxq41.jpg" alt="xcool">
                        </figure>
                    
                    
                    <p class="is-size-4 is-block">
                        xcool
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        enchanter
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>http://www.enchanter.tech</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Articles
                    </p>
                    <p class="title has-text-weight-normal">
                        99
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Catégories
                    </p>
                    <p class="title has-text-weight-normal">
                        2
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Tags
                    </p>
                    <p class="title has-text-weight-normal">
                        0
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/zhangxiongxin/blog" target="_blank">
                SUIVRE</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Github" href="https://github.com/zhangxiongxin">
                
                <i class="fab fa-github"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
        


    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Catégories
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/许世伟的架构课/">
            <span class="level-start">
                <span class="level-item">许世伟的架构课</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">42</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/重学前端/">
            <span class="level-start">
                <span class="level-item">重学前端</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">57</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Nuage de tags
        </h3>
        
    </div>
</div>

    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Récents
        </h3>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/37 | 键值存储与数据库/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="37 | 键值存储与数据库">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:23.566Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/37 | 键值存储与数据库/" class="title has-link-black-ter is-size-6 has-text-weight-normal">37 | 键值存储与数据库</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/36 | 业务状态与存储中间件/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="36 | 业务状态与存储中间件">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:21.648Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/36 | 业务状态与存储中间件/" class="title has-link-black-ter is-size-6 has-text-weight-normal">36 | 业务状态与存储中间件</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/35 | 流量调度与负载均衡/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="35 | 流量调度与负载均衡">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:19.672Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/35 | 流量调度与负载均衡/" class="title has-link-black-ter is-size-6 has-text-weight-normal">35 | 流量调度与负载均衡</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/34 | 服务端开发的宏观视角/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="34 | 服务端开发的宏观视角">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:17.750Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/34 | 服务端开发的宏观视角/" class="title has-link-black-ter is-size-6 has-text-weight-normal">34 | 服务端开发的宏观视角</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/33 | 桌面开发篇：回顾与总结/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="33 | 桌面开发篇：回顾与总结">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:15.818Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/33 | 桌面开发篇：回顾与总结/" class="title has-link-black-ter is-size-6 has-text-weight-normal">33 | 桌面开发篇：回顾与总结</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">August 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">99</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
            </div>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Récents
        </h3>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/37 | 键值存储与数据库/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="37 | 键值存储与数据库">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:23.566Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/37 | 键值存储与数据库/" class="title has-link-black-ter is-size-6 has-text-weight-normal">37 | 键值存储与数据库</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/36 | 业务状态与存储中间件/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="36 | 业务状态与存储中间件">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:21.648Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/36 | 业务状态与存储中间件/" class="title has-link-black-ter is-size-6 has-text-weight-normal">36 | 业务状态与存储中间件</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/35 | 流量调度与负载均衡/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="35 | 流量调度与负载均衡">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:19.672Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/35 | 流量调度与负载均衡/" class="title has-link-black-ter is-size-6 has-text-weight-normal">35 | 流量调度与负载均衡</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/34 | 服务端开发的宏观视角/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="34 | 服务端开发的宏观视角">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:17.750Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/34 | 服务端开发的宏观视角/" class="title has-link-black-ter is-size-6 has-text-weight-normal">34 | 服务端开发的宏观视角</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/33 | 桌面开发篇：回顾与总结/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="33 | 桌面开发篇：回顾与总结">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:15.818Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/33 | 桌面开发篇：回顾与总结/" class="title has-link-black-ter is-size-6 has-text-weight-normal">33 | 桌面开发篇：回顾与总结</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">August 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">99</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="Enchanter" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2019 xcool&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("en");</script>

<script>
var IcarusThemeSettings = {
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>



    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Articles',
                PAGES: 'Pages',
                CATEGORIES: 'Catégories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>