{"pages":[],"posts":[{"title":"01 | 架构设计的宏观视角","text":"你好，我是七牛云许式伟。今天我们来谈谈架构设计的宏观视角。 在信息科技高度发展的今天，我们每个人随时随地都可以接触到由程序驱动的智能电子设备，包括手机（如iPhone、oppo拍照手机）、平板电脑（如iPad）、手表（如iWatch、小天才智能手表）、音箱（如天猫精灵）、汽车（如特斯拉）等等。 这些东西背后是怎么工作的？单就其中的软件系统而言，这些小小的设备上往往运行着成千上万个软件模块，这些模块是如何如此精密地一起协作的？ 对此，我过去接触过很多的软件开发工程师，或者架构师，很多人对这些原理也是一知半解，虽然“知其然”，但却“不知其所以然”。甚至有些朋友可能觉得，学这些有什么用处呢，在我看来，这部分内容恰恰是我们成为架构师很重要的一门基础课。 为什么需要建立宏观视角？如同造房子有建筑工人（负责搬砖）和建筑师（负责架构设计）一样，软件系统的开发过程同样需要有程序员（负责搬“砖”）和架构师（负责架构设计）。作为架构师，我们需要的第一个能力是宏观的全局掌控能力。 如果把应用程序比作一座大厦，那么我们作为大厦的架构师，需要把大厦的结构搭建好，让程序员可以把砖填充进去，我们都知道，一个大厦的结构建得是否稳固，与地基密不可分。 所以，我们首先就需要从大厦的地基开始，熟悉这座大厦。毕竟，你对所依赖的基础架构了解得越全面，做业务架构设计就会越发从容。 介绍基础架构的知识点并不是让你真的去实现它们。但你仍然需要懂得它们的核心思想是什么，知道有哪些信息是你必须深刻理解的，以便可以更好地驾驭它们。 我们的整个专栏内容也会从基础架构开始讲起，最后逐步过渡到业务架构，到最终完成一个完整应用程序的设计过程。 那么，在今天的开篇第一篇，我们需要站在宏观视角，从基础架构开始，逐渐来解剖一个应用程序的整体构成，我希望，通过今天的文章，可以让你对于一个程序的全貌，形成完整的认识。 我们从头开始。 应用程序的基础架构我们想学习一个程序的基础架构，其实就是弄清楚电脑的工作原理，以及程序的运行原理。 无论是什么样的智能电子设备，手机也好，汽车也罢，它们都可以称为“电脑”。所有的电脑都可以统一看作由“中央处理器+存储+一系列的输入输出设备”构成。 中央处理器，也就是我们平常说的CPU，负责按指令执行命令；存储负责保存数据，包括我们要执行的命令，也是以数据形式保存在存储中的。 每次在打开电脑的电源后，中央处理器都会从存储的某个固定位置处开始读入数据（也就是指令），并且按指令执行命令，执行完一条指令就会继续执行下一条指令。电脑就这样开始工作了。 你可能会说，就这么简单？是的，就是这么简单。 那这么简单的话，为何电脑能够完成这么多复杂而多样化的工作？ 这整个过程，在我看来主要依赖两点。 第一是可编程性。大体来说，中央处理器（CPU）的指令分为如下这几类。 计算类，也就是支持我们大家都熟知的各类数学运算，如加减乘除、sin/cos等等。 I/O类，（从存储读写数据）从输入输出设备读数据、写数据。 指令跳转类，在满足特定条件下跳转到新的当前程序执行位置。 虽然， CPU 指令是一个很有限的指令集，但是CPU 执行的指令序列（或者叫“程序”）并不是固定的，而是依赖保存在存储中的数据—— 由软件工程师（或者叫“程序员”）编写的软件来决定。指令序列的可能性是无穷的，这也就意味着电脑能够做的事情的可能性也是无穷的。 第二是开放设计的外部设备支持。虽然我们电脑可以连接非常非常多种类的外部设备，比如键盘、打印机、屏幕、汽车马达等等，但CPU 并不理解这些设备具体有什么样的能力，它只和这些设备交换数据。它能够做的是从某个编号的设备（通常这个设备编号被称为“端口”）读入一段数据，或者向设备的端口写入一段数据。 例如，当你在键盘上按下了A的时候，CPU 可以从键盘连接的端口读到一段数据，通过这段数据来表达你按了“A”，可能CPU 会向打印机连接的端口发送一段数据，来驱动打印机打印特定的文本；还有可能CPU 会向汽车马达所在的端口发送数据，来驱动马达转动，从而让汽车按照预期来行驶。 值得注意的是，CPU 知道的是如何和这些设备交换数据，但是并不理解数据代表什么含义。这些外部设备的厂商在提供设备硬件的同时，往往也需要提供和硬件匹配的软件，来完成和CPU 的协作，让软件工程师可以轻松使用这些设备。 从上面可以看出，电脑的 CPU 是一个非常简洁的模型，它只读入和写出数据，对数据进行计算。这也是为什么我们往往把电脑也叫作“计算机”，这是因为 CPU 这个计算机的大脑的确只会做“计算”。 这个基础的设计体系，我们很多人都知道，这就是冯·诺依曼计算机体系。1945年6月，冯·诺依曼以“关于EDVAC的报告草案”为题起草的长达101页的总结报告，定义了“冯·诺依曼体系结构”，他现在也被称为计算机之父。我想看到这里，你应该不难理解他的伟大之处了吧？ 有了这个基础的计算机体系之后，我们就可以编写软件了。 当然我们遇到的第一个问题是直接用机器指令编写软件太累，而且这些机器指令像天书一样没人看得懂，没法维护。 所以，编程语言+编译器就出现了。编译器负责把我们人类容易理解的语言，转换为机器可以理解的机器指令，这样一来就大大解放了编写软件的门槛。 在编写软件不是问题时，我们遇到的第二个问题，就是多个软件在同一个电脑上怎么共处。多个软件大家往同一个存储地址写数据冲突怎么办？一起往打印机去发送打印指令怎么办？有的软件可能偷偷搞破坏怎么办？ 于是，操作系统就出现了。 它首先要解决的是软件治理的问题。它要建立安全保护机制，确保你的电脑免受恶意软件侵害。同时，它也要建立软件之间的协作秩序，让大家按照期望的方式进行协作。比如存储你写到这里，那么我就要写到别处；使用打印机要排队，你打完了，我才能接着去打印。 操作系统其次解决的是基础编程接口问题。这些编程接口一方面简化了软件开发，另一方面提供了多软件共存（多任务）的环境，实现了软件治理。 例如，对于屏幕设备，操作系统需要提供多任务窗口系统，以避免屏幕被多个软件画得乱七八糟；对于键盘输入设备，操作系统引入焦点窗口，以确定键盘输入的事件被正确发送到正确的软件程序。 你会发现，今天的我们开发软件的时候，已经处于一些基础的架构设计之中。像冯·诺依曼计算机体系，像操作系统和编程语言，这些都是我们开发一个应用程序所依赖的基础架构。 基础架构解决的是与业务无关的一些通用性的问题，这些问题往往无论你具体要做什么样的应用都需要面对。而且，基础架构通常以独立的软件存在，所以也称为基础软件。 例如，我们熟知的Linux、Nginx、MySQL、PHP 等这些软件都属于基础软件，这些基础软件极大地降低了应用开发的难度。在今天软件服务化的大趋势下，很多基础软件最终以互联网服务的方式提供，这就是所谓的“云计算”。 完整的程序架构是怎样的？讲完了程序的地基，让我们来总览一下程序的完整架构。 在越强大的基础架构支撑下，应用程序开发需要关注的问题就越收敛，我们的开发效率就越高。在我们只需要关注应用程序本身的业务问题如何构建时，我们说自己是在设计应用程序的业务架构（或者叫“应用架构”）。 业务架构虽然会因为应用的领域不同而有很大的差异，但不同业务架构之间，仍然会有许多共通的东西。它们不只遵循相同的架构原则，还可以遵循相同的设计范式。 一些设计范式被人们以应用程序框架的方式固化下来。例如，在用户交互领域有著名的MVC 框架（如JavaScript 语言的Angular，PHP 语言的Zend，Python 语言的 Django），在游戏开发领域有各种游戏引擎（如JavaScript 语言的 Phaser，C# 语言的 Unity3D），等等。 对于一个服务端应用程序来说，其完整的架构体系大体如下，如果你在收听音频，你可以点击文稿查看： 对于客户端应用程序来说，和服务端的情况会有非常大的差别。客户端首先面临的是多样性的挑战。 单就操作系统来说，PC 就有Windows、Mac、Linux 等数十种，手机也有Android、iOS，Windows Mobile 等等。而设备种类而言就更多了，不只有笔记本、平板电脑，还有手机、手表、汽车，未来只会更加多样化。 第一个想消除客户端的多样性，并且跨平台提供统一编程接口的，是浏览器。 可能在很多人看来，浏览器主要改变的是软件分发的方式，让软件可以即取即用，无需安装。但从技术角度来说，底层操作系统对软件的支持同样可以做到即取即用。 这方面苹果在iOS 上已经在尝试，大家可能已经留意到，如果你一个软件很久没有用，iPhone 就会把这个软件从本地清理出去，而在你下一次使用它时又自动安装回来。 假如软件包足够小，那么这种行为和 Web 应用就毫无区别。不同之处只在于Web 应用基于的指令不是机器码，而是更高阶的 JavaScript 脚本。 JavaScript 因为指令更高阶，所以程序的尺寸比机器码会有优势。但另一方面来说 JavaScript 是文本指令，表达效率又要比机器码低。 但这一点也在发生变化，近年来 WebAssembly 技术开始蓬勃发展，JavaScript 作为浏览器的机器码的地位会被逐步改变，我们前端开发会面临更多的可能性。 浏览器的地位非常特殊，我们可以看作操作系统之上的操作系统。一旦某种浏览器流行起来，开发人员都在浏览器上做应用，那么必然会导致底层操作系统管道化，这是操作系统厂商所不愿意看到的。 而如果浏览器用户量比较少，那么通过它能够触达的用户量就太少，消除不同底层操作系统差异的价值就不存在，开发人员也就不乐意在上面开发应用。 我们知道，PC 的浏览器之战打到今天，基本上就剩下Chrome、Internet Explorer、Safari、Firefox 等。 有趣的是，移动浏览器的战场似乎是从中国开始打起的，这就是微信引发的小程序之战，它本质上是一场浏览器的战争。 浏览器是一个基础软件，它能够解决多大的问题，依赖于它的市场占有率。但是基于同样的浏览器技术核心也可以构建出跨平台的应用框架。我们看到 React Native 就是沿着这个思路走的。当然这不是唯一的一条路，还有人会基于类似 QT 这样的传统跨平台方案。 整体来说，对于一个客户端应用程序来说，其完整的架构体系大体如下，你可以点击文稿查看： 对于架构师来说，不仅仅只是想清楚业务应该怎么去做好分解，整个应用从底到最顶层的上层建筑，每一层都需要进行各种决策。先做 iOS 版本，还是先做小程序？是选择 Java 还是 Go 语言？这些都是架构的一部分。 结语今天，我们从“计算机是如何工作”开始，一起登高鸟瞰，总览了程序完整的架构体系。 可能有人看到今天的内容心里会有些担心：“原来架构师要学这么多东西，看来我离成为架构师好远。” 好消息是：我们就是来打消这个担心的。如果我们把写代码的能力比作武功招式，那么架构能力就好比内功。内功修炼好了，武功招式的运用才能得心应手。 而架构能力的提升，本质上是对你的知识脉络（全身经络）的反复梳理与融会贯通的过程。具备架构思维并不难，而且极有必要。不管今天的你是不是团队里的一位架构师，对任何一位程序员来说，具备架构思维将会成为让你脱颖而出的关键。 这就像你没有从事云计算行业，但是你仍然需要理解云计算的本质，需要驾驭云计算。你也不必去做出一个浏览器，但是你需要理解它们的思考方式，因为你在深度依赖于它们。 接下来我们将进一步展开来谈这个程序架构体系里面的每一个环节。你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/01 | 架构设计的宏观视角/"},{"title":"02 | 大厦基石：无生有，有生万物","text":"你好，我是七牛云许式伟。 在上一讲中，我们把“构建一个应用程序”类比成“构建一座大厦”，并从宏观全局的视角剖析了应用程序这座大厦的构成。今天，我们将更加近距离地去解剖这座大厦的地基：冯·诺依曼体系结构。 解剖架构的关键点是什么？在解剖之前，我想和你先谈谈“解剖学”：我们应该如何去分析架构设计中涉及的每一个零部件。换一句话说，当我们设计或分析一个零部件时，我们会关心哪些问题。 第一个问题，是需求。这个零部件的作用是什么？它能被用来做哪些事情？（某种意义上来说更重要的是）它不会被用来做哪些事情？ 你可能会说，呀，这个问题很简单，既然我设计了这个零部件，自然知道它是用来干嘛的。但实质上这里真正艰难的是“为什么”：为何这个零件被设计成用来干这些事情的，而不是多干一点事情，或者为什么不是少干某些事情？ 第二个问题，是规格。这个零部件接口是什么样的？它如何与其他零件连接在一起的？ 规格是零部件的连接需求的抽象。符合规格的零部件可以有非常多种可能的实现方案，但是，一旦规格中某个条件不能满足了，它就无法正常完成与其他零件的连接，以达到预期的需求目标。 规格的约束条件会非常多样化，可能是外观（比如形状和颜色），可能是交互方式（比如用键盘、鼠标，或者语音和触摸屏），也可能是质量（比如硬度、耐热性等等）。 那么，冯·诺依曼体系结构的需求和规格又是什么样的呢？ 为“解决一切的问题”而生冯·诺依曼体系结构不但是应用程序这座大厦的地基，同时也是整个信息科技的地基。 当我们去审视整个信息科技时，仅把它形容为一座大厦显得如此不贴切，甚至你也不能用“一个城市”去形容它，事实上，它更像是一个无中生有的全新世界：在其中，有个体、有族群、有生态，还有喜怒哀乐。 冯·诺依曼体系结构的迷人之处在于，从需求来说，它想解决一切问题。解决一切可以用“计算”来解决的问题。 “计算”的边界在哪里？今天我们还没有人能够真正说得清。计算能不能解决“智能”的问题？通过计算能力，计算机是否终有一天可以获得和人类一样的智能？ 今天人工智能热潮的兴起，证明对于这个问题我们很乐观：计算终将解决智能的问题。尽管我们不能确定什么时候能够达到，但是让人欣慰的是，我们一直在进步 —— 如果人类智能无法完成进一步的进化，那么我们就一直一直在前进，最终无限逼近甚至超越人类智能。 甚至有科幻小说家设想（例如在Google的“AlphaGo”大热后，霍炬和西乔创作的漫画“BetaCat”），计算机演进出超过人类的智能是生物进化的一个自然演进路径，它将取代人类成为新的食物链顶端，并最终基于其悠久的生命力，去完成人类有限生命无法实现的星际航行之路。 冯·诺依曼体系的规格为了实现“解决一切可以用‘计算’来解决的问题”这个目标，冯·诺依曼引入了三类基础零部件： 中央处理器； 存储； 输入输出设备。 首先我们来看看存储。它负责存放计算涉及的相关数据，作为计算的输入参数和输出结果。 我们日常见到的存储设备非常的多样化。比如：中央处理器自己内置的寄存器、内存、传统机械硬盘、USB固态硬盘、光盘等等。 从中央处理器的角度，存储可简单分为两类：一类是内置支持的存储，通过常规的处理器指令可直接访问，比如寄存器、内存、计算机主板的ROM。一类是外置存储，它们属于输入输出设备。中央处理器本身并不能直接读写其中的数据。 冯·诺依曼体系中涉及的“存储”，指的是中央处理器内置支持的存储。 我们再来看看输入输出设备。它是计算机开放性的体现，大大拓展了计算机的能力。每个设备通过一个端口与中央处理器连接。通过这个端口地址，中央处理器可以和设备进行数据交换。数据交换涉及的数据格式由设备定义，中央处理器并不理解。 但这并不影响设备的接入。设备数据交换的发起方（设备使用方）通常理解并可以解释所接收的数据含义。为了方便使用，设备厂商或操作系统厂商通常会提供设备相关的驱动程序，把设备数据交换的细节隐藏起来，设备的使用方只需要调用相关的接口函数就可以操作设备。 最后我们来看看中央处理器。它负责程序（指令序列）的执行。指令序列在哪里？也存放在存储里面。计算机加电启动后，中央处理器从一个固定的存储地址开始执行。 中央处理器支持的指令大体如下（我们在第一篇文章中也曾提到过）： 计算类，也就是支持我们大家都熟知的各类数学运算，如加减乘除、sin/cos等等； I/O类，从存储读写数据，从输入输出设备读数据、写数据； 指令跳转类，在满足特定条件下跳转到新的当前程序执行位置、调用自定义的函数。 和“解决一切可以用‘计算’来解决的问题”这个伟大的目标相比，冯·诺依曼体系的三类零部件的规格设计显得如此精简。 为什么这么简洁的规格设计，居然可以解决这么复杂的需求？ 需求是怎么被满足的？我们来设想一下：假如今天让我们从零开始设计一个叫电脑的东西，我们的目标是“解决一切可以用‘计算’来解决的问题”。 对于这么含糊的需求，如果你是“电脑”这个产品的主架构师，你会如何应对？ 让我们来分析一下。 一方面，需求的变化点在于，要解决的问题是五花八门包罗万象的。如何以某种稳定但可扩展的架构来支持这样的变化？而另一方面，需求的稳定之处在于，电脑的核心能力是固定的，怎么表达电脑的核心能力？ 电脑的核心能力是“计算”。什么是计算？计算就是对一个数据（输入）进行变换，变为另一个数据（输出）。在数学中我们把它叫“函数”。如下： y = F(x) 这里 x、y 是数据。它们可能只是一个简单的数值，也可能是文本、图片、视频，各种我们对现实问题进行参数化建模后的测量值，当然也可能是多个输入数据。但无论它的逻辑含义为何，物理上都可以以一段连续的字节内容来表达。用 Go 的语法表达就是： func F(x []byte) (y []byte)那么 x、y 物理上在哪里？思路推理到这里，“存储” 这个概念自然就产生了：存储，就是存放计算所要操作的数据的所在。 下面的问题是：一个具体的计算（也就是 F 函数）怎么表达？ 这里的难点在于，F 对于电脑的架构师来说是未知的。那么，怎么设计一种系统架构让用户可以表达任意复杂的计算（函数）？ 逻辑上来看，无论多复杂的自定义函数，都可以通过下面这些元素的组合来定义： 内置函数，比如整数或小数运算（加减乘除、sin/cos等）； 循环和条件分支； 子函数（也是自定义函数）。 这样一来，对于任意的一个具体的计算（自定义函数）来说，都可以用一组指令序列来表达。 那么函数 F 物理上在哪里？以指令序列形式存放在存储里面。所以，存储不只存放计算所要操作的数据，也存放“计算”本身。 只是，存储里面存放的“计算”只是数据，需要有人理解并执行这些数据背后的计算行为，才变成真正意义的“计算”。这个执行者，就是中央处理器（CPU）。它支持很多计算指令，包括执行内置函数、循环和条件分支、执行子函数等。 所以，有了中央处理器+存储，就可以支持任意复杂的“计算”了。 只是如果电脑只有“中央处理器+存储”，那它就如同一个人只有头脑而没有四肢五官，尽管很可能很聪明，但是这种聪明无法展现出来，因为它没法和现实世界发生交互。 交互，抽象来看就是输入和输出。对人来说，输入靠的是五官：眼睛看、耳朵听、鼻子闻、舌头尝，以及肌肤接触产生的触觉。输出靠语言（说话）和各种动作，如微笑、眨眼、皱眉、手势等等。 对于电脑来说，输入输出的需求就更多了，不只是四肢五官，而可能是千肢万官。 从输入需求来说，可能采集静态图像、声音、视频；也可能采集结构化数据，如GPS位置、脉搏、心电图、温度、湿度等；还可能是用户控制指令如键盘按键、鼠标、触摸屏动作等。 从输出需求来说，可能是向屏幕输出信息；也可能是播放声音；还可能是执行某项动作，如交通灯开关、汽车马达转动、打印机打印等。 但不管是什么样交互用途的器官（设备），我们要做的只是定义好统一的数据交换协议。这个数据交换机制，和网络上两台电脑通过互联网，需要通过某种数据交换协议进行通讯，需求上没有实质性的差别。 也就是说，除了纯正的“计算”能力外，中央处理器还要有“数据交换”能力（或者叫IO能力）。最终，电脑可以被看做由 “中央处理器+存储+一系列的输入输出设备” 构成。如下图： 尽管输入输出设备引入的最初灵感可能是来自于“交互”，但是当我们去审视输入输出设备到底是什么的时候，我们很自然发现，它能够做的不单单是交互。 比如常见的外置存储如机械硬盘、光盘等，它们也是输入输出设备，但并不是用于交互，而是显著提升了电脑处理的数据体量。 输入输出设备从根本上解决的问题是什么？ 是电脑无限可能的扩展能力。 最重要的一点，输入输出设备和电脑是完全异构的。输入输出设备对电脑来说就只是实现了某项能力的黑盒子。 这个黑盒子内部如何？没有规定。它可以只是一个原始的数字化的元器件，也可以是另一台冯·诺依曼架构的电脑，还可以是完全不同架构的电脑，比如GPU电脑、量子计算机。 你可以发现，引入了输入输出设备的电脑，不再只能做狭义上的“计算”（也就是数学意义上的计算），如果我们把交互能力也看做一种计算能力的话，电脑理论上能够解决的“计算”问题变得无所不包。 架构思维上我们学习到什么？架构的第一步是需求分析。从需求分析角度来说，关键要抓住需求的稳定点和变化点。需求的稳定点，往往是系统的核心价值点；而需求的变化点，则往往需要相应去做开放性设计。 对于“电脑”这个产品而言，需求的稳定点是电脑的“计算”能力。需求的变化点，一是用户“计算”需求的多样性，二是用户交互方式的多样性。 电脑的“计算”能力，最终体现为中央处理器的指令集，这是需求相对稳定的部分。 用户“计算”需求的多样性，最终是通过在存储中的指令序列实现。计算机加电启动后，中央处理器并不是按自己固有的“计算”过程进行，而是从一个固定的存储地址加载指令序列执行。 通常，这个固定的存储地址指向计算机主板的ROM上的一段启动程序（BIOS）。这段启动程序通常包含以下这些内容。 存储设备的驱动程序，用以识别常规的外置存储设备，比如硬盘、光驱、U盘。 基础外部设备的驱动程序，比如键盘、鼠标、显示器（显卡）。 设备和启动配置的基础管理能力。 在外置存储上执行程序的能力（中央处理器只支持在内存上执行程序，当然它也为在外置存储执行程序提供了一些支持，比如内存页缺失的中断处理）。 将执行权转移到外置存储（第一次安装操作系统的时候可能是光驱甚至是网络存储，平常通常是硬盘）上的操作系统启动程序。这样，操作系统就开始干活了。 这样一来，“计算”需求的多样性只需要通过调整计算机主板上的BIOS程序，乃至外置存储中的操作系统启动程序就可以实现，而不必去修改中央处理器本身。 用户交互方式的多样性，则通过定义外部设备与中央处理器的数据交换协议实现。 当我们把所有的变化点从电脑的最核心部件中央处理器剥离后，中央处理器的需求变得极其稳定，可独立作为产品进行其核心价值的演进。 结语总结一下，今天，我们近距离地去解剖了整个信息世界地基：冯·诺依曼体系结构。 冯·诺依曼体系结构的不凡之处在于，它想“解决一切可以用‘计算’来解决的问题”。 为了实现这个目标，冯·诺依曼引入了三类基础零部件：中央处理器、存储、输入输出设备。所有计算机都可以看做由 “中央处理器+存储+一系列的输入输出设备” 构成。 为了方便理解，我在尝试用 Go 语言模拟来实现冯·诺依曼架构体系的电脑： https://github.com/qiniu/arch/tree/master/von 如果你对此感兴趣，欢迎 fork 并对其进行修改迭代。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/02 | 大厦基石：无生有，有生万物/"},{"title":"03 | 汇编：编程语言的诞生","text":"你好，我是七牛云许式伟。 在上一讲中，我们一起解剖了架构大厦的地基：冯·诺依曼体系。接下来，我们就开始沿着这座大厦攀登，一起来聊聊编程语言。 对于现代计算机来说，虽然 CPU 指令是一个很有限的指令集，但是CPU 执行的指令序列（或者叫“程序”）并不是固定的，它依赖于保存在存储中的数据，由软件工程师（或者叫“程序员”）编写的软件决定。 从上一讲中，我们可以知道，计算机的程序可能被保存在计算机主板的ROM上（这段程序也叫计算机的启动程序），也可能被保存在外置的存储设备（比如硬盘）上，并在合适的时机加载执行。 程序称得上是计算机的灵魂。指令序列的可能性是无穷的，程序的可能性就是无穷的。今天计算机创造的世界如此多姿多彩，正是得益于程序无穷的可能性。 那么，软件工程师是怎么编写程序的？ 编程的史前时代在第一门面向程序员的编程语言出现前，人们只能通过理解CPU指令的二进制表示，将程序以二进制数据方式刻录到存储（比如ROM或硬盘）上。 这个时期的编程无疑是痛苦的，效率是极其低下的：且不说我们怎么去修改和迭代我们的程序，光将我们的想法表达出来就极其困难。 我们首先要把表达的执行指令翻译成二进制的比特数据，然后再把这些数据刻录到存储上。 这个时候软件和硬件的边界还非常模糊，并不存在所谓软件工程师（或者叫“程序员”）这样的职业。写程序也并不是一个纯软件的行为，把程序刻录到存储上往往还涉及了硬件的电气操作。 为了解决编程效率的问题，汇编语言（和解释它的编译器）诞生了。汇编语言的编译器将汇编语言写的程序编译成为CPU指令序列，并将其保存到外置的存储设备（比如硬盘）上。 汇编语言非常接近计算机的CPU 指令，一条汇编指令基本上和CPU指令一一对应。 与机器对话汇编语言的出现，让写程序（编程）成为一个纯软件行为（出现“程序员”这个分工的标志），人们可以反复修改程序，然后通过汇编编译器将其翻译成机器语言，并写入到外置的存储设备（比如硬盘）。并且，程序员可以按需执行该程序。 在表达能力上，汇编语言主要做了如下效率优化。 用文本符号（symbol）表达机器指令，例如 add 表示加法运算，而不用记忆对应的 CPU 指令的二进制表示。 用文本符号（symbol）表达要操作的内存地址，并支持内存地址的自动分配。比如我们在程序中使用了“Hello” 这样一段文本，那么汇编编译器将为程序开辟一段静态存储区（通常我们叫“数据段”）来存放这段文本，并用一个文本符号（也就是“变量名-variable”）指向它。用变量名去表达一段内存数据，这样我们就不用去关注内存的物理地址，而把精力放在程序的逻辑表达上。 用文本符号（symbol）表达要调用的函数（function，也叫“过程-procedure”）地址。对 CPU 指令来说，函数只有地址没有名字。但从编程的角度，函数是机器指令的扩展，和机器指令需要用文本符号来助记一样，函数的名称也需要用文本符号来助记。 用文本符号（symbol）表达要跳转的目标地址。高级语言里面，流程控制的语法有很多，比如 goto、if … else、for、while、until 等等。但是从汇编角度来说，只有两种基本的跳转指令：无条件跳转（jmp）和条件跳转(je、jne)。同样，跳转的目标地址用文本符号（也就是“标签-label”）有助于程序逻辑的表达，而不是让人把精力放在具体的指令跳转地址上。 总结来说，汇编从指令能力上来说，和机器指令并无二致，它只不过把人们从物理硬件地址中解脱出来，以便专注于程序逻辑的表达。 但是，这一步所解放的生产力是惊人的，毕竟如果有选择的话，没有人会愿意用0101这样的东西来表达自己的思想。 可自我迭代的计算机从探究历史的角度，你可能会期望了解最真实的历史发展过程。比如：怎么产生了现代计算机（以键盘作为输入，显示器作为输出）？怎么产生了汇编语言？怎么产生了操作系统？ 不过，本专栏是以架构设计为目的，我们目的并不是还原最真实的历史。架构的意义在于创造。我们甚至可以设想一个有趣的场景：假设今天我们的信息科技的一切尚不存在，那么从架构设计角度，我们从工程上来说，如何更高效地完成从0到1的信息科技的构建？ 最早的输入输出设备并不是键盘和显示器，而是打孔卡和打印机。用打孔卡来作为机器指令的输入，早在18世纪初就被用在织布机上了。早期的数字计算机就是用打孔卡来表达程序指令和输入的数据。 下图是 IBM 制造的打孔卡： 我们可以想象一下，第一台以键盘+显示器为标准输入输出的现代计算机出现后，一个最小功能集的计算机主板的ROM上，应该刻上什么样的启动程序？换句话说，这个现代计算机具备的最基本功能是什么？ 从高效的角度（不代表真实的历史，真实历史可能经历过很多曲折的发展过程），我想，它最好具备下面的这些能力。 键盘和显示器的驱动程序。 当时最主流的外置存储设备（不一定是现代的硬盘）的驱动程序。 一个汇编程序编辑器。可从存储中读取汇编程序代码，修改并保存到存储中。 一个汇编编译器。可将汇编程序代码编译成机器代码程序，并保存到存储中。 可以执行一段保存在外置存储设备中的机器代码程序。 本质上，我们是要实现一个最小化的计算能力可自我迭代的计算机。 这个时期还没有操作系统（当然，把ROM上的启动程序BIOS看做一种最小化的操作系统，我觉得也可以，但毕竟不是现实中我们说的操作系统）。 汇编语言的出现要早于操作系统。操作系统的核心目标是软件治理，只有在计算机需要管理很多的任务时，才需要有操作系统。 所以，在没有操作系统之前，BIOS 包含的内容很可能是下面这样的： 外置存储设备的驱动程序； 基础外部设备的驱动程序，比如键盘、显示器； 汇编语言的编辑器、编译器； 把程序的源代码写入磁盘，从磁盘读入的能力。 最早期的计算机毫无疑问是单任务的，计算的职能也多于存储的职能。每次做完任务，计算机的状态重新归零（回到初始状态）都没有关系。 但是，有了上面这样一个 BIOS 程序后，计算机就开始发展起它存储的能力：程序的源代码可以进行迭代演进了。 这一步非常非常重要。计算机的存储能力的重要性如同人类发明了纸。纸让人类存储了知识，一代代传递下去并不断演进，不断发扬光大。 而同样有了存储能力的计算机，我们的软件程序就会不断被传承，不断演进发扬光大，并最终演进出今天越来越多姿多彩的信息科技的世界。 结语今天我们一起回到了编程的史前时代，共同回溯了编程语言诞生的历史。 为了不再用“0101”表达自己的思想，人们创造了汇编语言，这一步让编程成为一个纯软件行为，程序员这一个分工也由此诞生。 为了进一步支持程序员这个职业，我们设计了MVP版（最小化可行产品）的可自我迭代的计算机。有了这个计算机，我们就可以不断演进，并最终演进出今天越来越多姿多彩的信息科技的世界。 架构上的思考题在上一讲中，我们谈架构思维时提到，我们在需求分析时，要区分需求的变化点和稳定点。稳定点往往是系统的核心能力，而变化点则需要对应地去考虑扩展性上的设计。 今天，我们假设要实现一个最小化的计算能力可自我迭代的计算机，需求如上所述。 那么，它的变化点和稳定点分别是什么？为此，你会怎么设计出哪些子系统，每个子系统的规格是什么？扩展性上有哪些考虑？ 欢迎把你的想法告诉我，我们一起讨论。感谢你的收听，再见。","link":"/2019/08/31/许世伟的架构课/03 | 汇编：编程语言的诞生/"},{"title":"04 | 编程语言的进化","text":"你好，我是七牛云许式伟。今天我们继续来聊聊编程语言。 编程语言的出现，诞生了软件工程师（也叫程序员）这样一个职业，而汇编语言则可以看做是软件工程师这个分工出现的标志。 通过编程语言，软件工程师和计算机可以进行交互，表达自己的思想。但是，如果我们把掌握编程语言看做是软件工程师的专业技能，其实又低估了编程语言带来的革命性变化。 编程语言在信息科技发展中的位置，如同人类文明中语言所在的位置。而编程语言写出来的软件（及其源代码），如同人类文明中不断被传承下来的图书典籍。 软件是活的书籍我个人一直有一个观点：软件是活的书籍，是我们人类知识传承能力的一次伟大进化。书籍能够通过文字来记载事件、传递情感、揭示规律、传承技术。书籍能够让人们进行远程的沟通（飞鸽传书），也能够让我们了解古人的生活习性，与古人沟通（虽然是单向的）。 这些事情软件都可以做到，而且做得更好。为什么我说软件是活的书籍，有两方面的原因。 其一，表达方式的多样性。书籍只能通过文字描述来进行表达，这种表达方式依赖于人们对文字的理解，以及人的想象能力对场景进行还原。软件除了能够通过文字，还能够通过超链接、声音、动画、视频、实时的交互反馈等方式来还原场景。 其二，对技术的现场还原。书籍只能通过文字来描述技术，但是因为人与人对同样的文字理解不同，领悟能力不同，这些都可能导致技术的传承会出现偏差，如果文字的记载不够详尽，可能就会出现“谁也看不懂，学不会”的情况，从而导致技术的失传。 但是，软件对技术的还原可以是精确的，甚至软件本身可以是技术的一部分。当软件是技术的一部分的时候，技术传承就是精确的，失传的概率就大大降低（除非技术本身适应不了潮流，退出了历史舞台）。 信息科技发展到今天，已经影响人类活动的方方面面。无论你从事什么职业，不管你是否会从事软件开发的工作，你都无法和信息科技脱节。如果希望能够站在职业发展的至高点，你就需要理解和计算机沟通的语言，也就需要理解软件工程师们的语言。 不仅如此，如果你把编程语言升华为人类知识传承能力的进化，你就更能够清晰地预判到这样的未来：每一个小孩的基础教育中一定会有编程教育，就如同每一个小孩都需要学习物理和数学一样。 编程范式的进化编程语言从汇编开始，到今天还只有六十多年的历史，但是迭代之迅速，远超自然语言的迭代速度。从思想表达的角度来说，我们通常会听到以下这些编程范式。 其一是过程式。过程式就是以一条条命令的方式，让计算机按我们的意愿来执行。今天计算机的机器语言本身就是一条条指令构成，本身也是过程式的。所以过程式最为常见，每个语言都有一定过程式的影子。过程式语言的代表是 Fortran、C/C++、JavaScript、Go 等等。 过程式编程中最核心的两个概念是结构体（自定义的类型）和过程（也叫函数）。通过结构体对数据进行组合，可以构建出任意复杂的自定义数据结构。通过过程可以抽象出任意复杂的自定义指令，复用以前的成果，简化意图的表达。 其二是函数式。函数式本质上是过程式编程的一种约束，它最核心的主张就是变量不可变，函数尽可能没有副作用（对于通用语言来说，所有函数都没副作用是不可能的，内部有 IO 行为的函数就有副作用）。 既然变量不可变，函数没有副作用，自然人们犯错的机会也就更少，代码质量就会更高。函数式语言的代表是 Haskell、Erlang 等等。大部分语言会比较难以彻底实施函数式的编程思想，但在思想上会有所借鉴。 函数式编程相对小众。因为这样写代码质量虽然高，但是学习门槛也高。举一个最简单的例子：在过程式编程中，数组是一个最常规的数据结构，但是在函数式中因为变量不可变，对某个下标的数组元素的修改，就需要复制整个数组（因为数组作为一个变量它不可变），非常低效。 所以，函数式编程里面，需要通过一种复杂的平衡二叉树来实现一个使用界面（接口）上和过程式语言数组一致的“数组”。这个简单的例子表明，如果你想用函数式编程，你需要重修数据结构这门课程，大学里面学的数据结构是不顶用了。 其三是面向对象。面向对象在过程式的基础上，引入了对象（类）和对象方法（类成员函数），它主张尽可能把方法（其实就是过程）归纳到合适的对象（类）上，不主张全局函数（过程）。面向对象语言的代表是 Java、C#、C++、Go 等等。 从“面向对象”到“面向连接”面向对象的核心思想是引入契约，基于对象这样一个概念对代码的使用界面进行抽象和封装。 它有两个显著的优点。 其一是清晰的使用界面，某种类型的对象有哪些方法一目了然，而不像过程式编程，数据结构和过程的关系是非常松散的。 其二是信息的封装。面向对象不主张绕过对象的使用接口侵入到对象的内部实现细节。因为这样做破坏了信息的封装，降低了类的可复用性，有一天对象的内部实现方式改变了，依赖该对象的相关代码也需要跟着调整。 面向对象还有一个至关重要的概念是接口。通过接口，我们可以优雅地实现过程式编程中很费劲才能做到的一个能力：多态。 由于对象和对象方法的强关联，我们可以引入接口来抽象不同对象相同的行为（比如鸟和猪是不同的对象，但是它们有相同的方法，比如移动和吃东西）。这样不同对象就可以用相同的代码来实现类似的复杂行为，这就是多态了。 多数面向对象语言往往还会引入一个叫继承的概念。大家对这个概念褒贬不一。虽然继承带来了编码上的便捷性，但也带来了不必要的心智负担：本来复合对象的唯一构造方法是组合，现在多了一个选择，继承。 究竟什么时候应该用继承，什么时候应该用组合？这着实会让人纠结。不过，这件事情最完美的答案是 Go 语言给出来的：放弃继承，全面强化组合能力（要了解 Go 语言强大的组合能力，参阅我的演讲）。 不同编程范式并不是互斥的。虽然有些编程语言会有明确的编程范式主张，比如 Java 是纯正的面向对象语言，它反对全局过程。但是，也有一些语言明确主张说自己是多范式的，典型代表是 C++。 当然，可能 C++ 不是一个好例子，因为它太复杂了，让人觉得多范式会大大增加语言的复杂性，虽然其实 C++ 的复杂性和多范式并没有什么关系。 可能 Go 语言是多范式更好的例子。它没有声称自己是多范式的，但是实际上每一种编程范式它都保留了精华部分。这并没有使得 Go 语言变得很复杂，整个语言的特性极其精简。 Go 语言之所以没有像 C++ 那样声称是多范式的，是因为 Go 官方认为 Go 是一门面向连接的语言。 什么是面向连接的语言？在此之前，你可能并没有听过这样的编程范式，这应该算 Go 自己发明出来的范式名称。在我看来，所谓面向连接就是朴素的组合思想。研究连接，就是研究人与人如何组合，研究代码与代码之间怎么组合。 面向对象创造性地把契约的重要性提高到了非常重要的高度，但这还远远不够。这是因为，并不是只有对象需要契约，语言设计的方方面面都需要契约。 比如，代码规范约束了人的行为，是人与人的连接契约。如果面对同一种语言，大家写代码的方式很不一样，语言就可能存在很多种方言，这对达成共识十分不利。所以 Go 语言直接从语言设计上就消灭掉那些最容易发生口水的地方，让大家专注于意图的表达。 再比如，消息传递约束了进程（这里的进程是抽象意义上的，在 Go 语言中叫 goroutine）的行为，是进程与进程的连接契约。消息传递是多核背景下流行起来的一种编程思想，其核心主张是：尽可能用消息传递来取代共享内存，从而尽可能避免显式的锁，降低编程负担。 Go 语言不只是提供了语言内建的消息传递机制（channel），同时它的消息传递是类型安全的。这种类型安全的消息传递契约机制，大大降低了犯错的机会。 其他方面的进化除了编程范式，编程语言的进化还体现在工程化能力的完善上。工程化能力主要体现在如下这些方面。 包（package），即代码的发布单元。 版本（version），即包的依赖管理。 文档生成（doc）。 单元测试（test）。 从语言的执行器的行为看，出现了这样三种分类的语言。 编译的目标文件为可执行程序。典型代表是 Fortran、C/C++、Go 等。 生成跨平台的虚拟机字节码，有独立的执行器（虚拟机）执行字节码 。典型代表为 Java、Erlang 等。 直接解释执行。典型代表是 JavaScript。当然现在纯解释执行的语言已经不多。大多数语言也只是看起来直接执行，内部还是会有基于字节码的虚拟机以提升性能。 语言对架构的影响是什么？我们思考一个问题：从架构设计角度来看，编程语言的选择对架构的影响是什么？ 我们在第一篇“架构设计的宏观视角”中，介绍了服务端程序和客户端程序的整体架构图。细心的读者可能留意到了，在架构图中我用了三种不同的颜色来表示不同层次的依赖。 无论服务端，还是客户端，我们可以统一将其架构图简化为下图所示。 图中淡紫色是硬件层次的依赖，是我们程序工作的物理基础。淡绿色的是软件层次的依赖，是我们程序工作的生态环境。桔色的是库或源代码层次的依赖，是我们程序本身的组成部分。细分的话它又可以分两部分：一部分是业务无关的框架和基础库，还有一部分是业务架构。 从软件的业务架构来说，本身应该怎么拆分模块，每个模块具体做什么样的事情（业务边界是什么），这是业务需求本身决定的，和编程语言并没有关系。但在我们描述每个模块的规格时，采用的规格描述语言会面临如下两种选择： 选择某种语言无关的接口表示； 选择团队开发时采用的语言来描述接口。 两种选择的差异并不是实质性的。只要团队内有共识，选哪一种都无所谓。本着“如无必要勿增实体”的原则，我个人会倾向于后者，用开发语言来做接口表示。在七牛云的话自然就是选 Go 了。 站在唯技术论的角度，业务架构与语言无关，影响的只是模块规格的描述语法。但语言的选择在实践中对业务架构决策的影响仍然极其关键。 原因之一是开发效率。抛开语言本身的开发效率差异不谈，不同语言会有不同的社区资源。语言长期以来的演进，社区所沉淀下来的框架和基础库，还有你所在的企业长期发展形成的框架和基础库，都会导致巨大的开发效率上的差异。 原因之二是后期维护。语言的历史通常都很悠久，很难实质性地消亡。但是语言的确有它的生命周期，语言也会走向衰落。选择公司现在更熟悉的语言，还是选择一个面向未来更优的语言，对架构师来说也是一个两难选择。 结语今天我们抛开具体的语言发展史，而从编程范式演进的角度来谈编程语言的进化。过程式、函数式、面向对象，这些都是大家熟悉的编程范式；所以我们把重点放在了介绍由 Go 语言带来的面向连接的编程思想，并将其与面向对象做了详细的对比。 未来编程语言还将出现什么样的新思想，我们不得而知。但可以预见，出现新的创造性思维的挑战将越来越大。历史的发展是曲折螺旋上升的。 要想有所突破，需要建立批判性思维。一种新思潮的兴起过程很容易用力过猛。面向对象是一个很好的例子。面向对象是非常重要的进步，但是继承是一个过度设计，不只让软件工程师在组合与继承中纠结，也产生了复杂的对象继承树。我们只有在实践中不断总结与反思，才有可能产生新的突破。 你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/04 | 编程语言的进化/"},{"title":"05 | 思考题解读：如何实现可自我迭代的计算机？","text":"你好，我是七牛云许式伟。 在“03 | 汇编：编程语言的诞生”中，我给出了一个架构思考题： 第一台以键盘+显示器为标准输入输出的现代计算机出现后，一个最小功能集，但计算能力可自我迭代的计算机应该是什么样的？ 从需求上来说，我们期望它有如下能力。 键盘和显示器的驱动程序。 当时最主流的外置存储设备（不一定是现代的硬盘）的驱动程序。 一个汇编程序编辑器。可从存储中读取汇编程序代码，修改并保存到存储中。 一个汇编编译器。可将汇编程序代码编译成机器代码程序，并保存到存储中。 支持执行一段保存在外置存储设备中的机器代码程序。 那么，它的变化点和稳定点分别是什么？为此，你会怎么设计，设计出哪些子系统，每个子系统的规格是什么？扩展性上有哪些考虑？ 需求分析我们前面谈架构思维时提到：做架构，第一件事情要学会做需求分析。 需求分析的重要性怎么形容都不过分。准确的需求分析是做出良好架构设计的基础。我个人认为，架构师在整个架构的过程中，至少应该花费三分之一的精力在需求分析上。 这也是为什么很多非常优秀的架构师换到一个新领域后，一上来并不能保证一定能够设计出良好的架构，而是往往需要经过几次迭代才趋于稳定，原因就在于：领域的需求理解是需要一个过程的，对客户需求的理解不可能一蹴而就。 所以，一个优秀的架构师除了需要“在心里对需求反复推敲”的严谨态度外，对客户反馈的尊重之心也至关重要。只有心里装着客户，才能理解好需求，做好架构。 前面我们也强调过：在需求分析时，要区分需求的变化点和稳定点。稳定点往往是系统的核心能力，而变化点则需要对应地去考虑扩展性上的设计。 那么今天我们来实战一番，要实现一个最小化的计算能力可自我迭代的计算机，我们怎么做需求分析。 怎么实现可自我迭代的计算机？通过前面对计算机工作原理的分析，我们已经知道，计算机分为三大类的零部件： 中央处理器； 存储； 输入输出设备。 中央处理器作为“计算”能力的核心，我们已经对它的工作范畴解剖清晰，这里不提。 存储，一方面作为“计算”的输入输出，另一方面作为“计算”本身的承载（也就是程序），主要的变数在后者。存储上的程序主要是： 计算机主板ROM上的启动程序（BIOS）； 外置存储上的软件。 接下来我们要考虑清楚的是：BIOS 负责做什么，外置存储上的软件负责做什么。这里我们先不展开。 输入输出设备，除了键盘和显示器外，还有外置存储。键盘和显示器我们只需要准备好对应的驱动程序，并没有特别需要考虑的内容。主要的变数在外置存储上。 外置存储在我们为它准备好了驱动程序后，就可以对它进行数据的读写了，但是我们接着需要考虑的问题是：我们准备把外置存储的数据格式设计成什么样？ 回答这个问题前，先回顾下我们要做什么。目前我们已知的功能需求有如下这些。 键盘和显示器的驱动程序。 外置存储设备的驱动程序。 汇编程序编辑器。可从外置存储中读取汇编程序代码，修改并保存到外置存储中。 汇编编译器。可将汇编程序代码编译成机器代码程序，并保存到外置存储中。 支持执行一段保存在外置存储设备中的机器代码程序。 我们可以看到，外置存储需要保存的内容有： 汇编程序的源代码； 汇编编译器编译出来的可执行程序。 可见，外置存储它不应该只能保存一个文件，而是应该是多个。既然是多个，就需要组织这些文件。那么，怎么组织呢？ 今天我们当然知道，操作系统的设计者们设计了文件系统这样的东西，来组织这些文件。虽然文件系统的种类有很多（比如：FAT32、NTFS、EXT3、EXT4 等等），但是它们有统一的抽象：文件系统是一颗树；节点要么是目录，要么是文件；文件必然是叶节点；根节点是目录，目录可以有子节点。 但是，文件系统（File System）是否是唯一的可能性？当然不是。键值存储（Key-Value 存储）也挺好，尤其是早期外置存储容量很可能极其有限的情况下。可以做这样统一的抽象： 每个文件都有一个名字（Key），通过名字（Key）可以唯一定位该文件，以进行文件内容的读写； 为了方便管理文件，可以对文件名做模糊查询（List），查询（List）操作支持通配符（比如我们现在习惯用的*和?）； 未来外置存储的空间有可能很大，需要考虑文件管理的延展性问题；可以考虑允许每个文件设定额外的元数据（Meta），例如创建时间、编辑时间、最后访问时间、以及其他用户自定义的元数据。通过元数据我们也可以检索（Search）到我们感兴趣的文件。 聊完了外置存储，让我们再回来看看 BIOS 和外置存储的软件怎么分工。 首先，BIOS 和外置存储上的软件分工的标准是什么？BIOS 是刻在计算机主板ROM上的启动程序，它的变更非常麻烦。所以 BIOS 负责的事情最好越少越好，只做最稳定不变的事情。 我们一一来看当前已知的需求。 首先是外部设备的驱动程序：键盘和显示器的驱动程序、外置存储设备的驱动程序。一方面，只要键盘、显示器、外置存储没有大的演进，驱动程序就不变，所以这块是稳定的；另一方面，它们是 BIOS 干其他业务的基础。所以，这个事情 BIOS 必然会做。 其次是汇编程序编辑器。编辑器的需求是模糊的，虽然我们知道它支持用户来编写程序，但是整个编辑器的操作范式是什么样的，没有规定。所以它不像是给键盘写一个驱动程序那样，是一个确定性的需求，而有很多额外的交互细节，需要去进一步明确。 你可以留意下自己日常使用的编辑器，去试着列一下它们的功能列表。你会发现小小的编辑器，功能远比你接触的大部分常规软件要多得多。 再次是汇编编译器。汇编编译器从输入输出来看，似乎需求相对确定。输入的是汇编源代码，输出的是可执行程序。但认真分析你会发现，它实际上也有很大的不确定性。 其一，CPU 会增加指令，这时候汇编指令也会相应地增加。对于大部分应用程序，CPU 新增的指令如果自己用不到，可以当它不存在。但是汇编语言及编译器需要完整呈现 CPU 的能力，因此需要及时跟进。 其二，虽然汇编指令基本上和机器指令一一对应，但是它毕竟是面向程序员的生产力工具，所以汇编语言还是会演进出一些高阶的语法，比如宏汇编指令。 所谓宏汇编指令，就是用一个命令去取代一小段汇编指令序列，它和C语言里面的宏非常类似。所以汇编语言并不是稳定的东西，它和其他高级语言类似，也会迭代变化。这就意味着汇编编译器也需要相应地迭代变化。 最后，执行一段保存在外置存储设备中的机器代码程序。这个需求看似比较明确，但是实际上需求也需要进一步细化。它究竟是基于外置存储的物理地址来执行程序，还是基于文件系统中的文件（文件内容逻辑上连续，但是物理上很可能不连续）来执行程序？ 实现上，这两者有很大的不同。前者只需要依赖外置存储的驱动程序就可以完成，后者则还需要额外理解文件系统的格式才能做到。 那么，BIOS 到底怎么把执行控制权交到外置存储呢？ 在学冯·诺依曼结构的时候，我们提到过，CPU 加电启动时，它会从存储的一个固定地址开始执行指令，这个固定地址指向的正是 BIOS 程序。 类似的，我们的 BIOS 也可以认定一个外置存储的固定地址来加载程序并执行，而无需关心磁盘的数据格式是什么样的。这个固定地址所在的数据区域，我们可以把它叫做引导区。 引导区的存在非常重要，它实际上是 BIOS 与操作系统的边界。 对于 BIOS 来说，执行外置存储上的程序能力肯定是需要具备的，否则它没有办法把执行权交给外置存储。但是这个能力可以是非常简约的。BIOS 只需要执行引导区的程序，这个程序并不长，完全可以直接读入到内存中，然后再执行。 我们是否需要基于文件系统中的文件来执行程序的能力？答案是需要。因为汇编编译器编译后的程序在外置存储中，需要有人能够去执行它。 综上，我们确认 BIOS 需要负责的事情是： 键盘和显示器的驱动程序； 外置存储设备的驱动程序； 支持执行外置存储中引导区的机器代码程序； 跳转到外置存储的固定地址，把执行权交给该地址上的引导程序。 而汇编程序编辑器、汇编编译器 ，以及支持执行文件系统中的程序，则不应该由 BIOS 来负责。 那么，外置存储上的引导程序拿到执行权后干什么呢？ 我们再来总结下当前我们遇到的需求。 需要有人负责支持外置存储的数据格式，提供统一的功能给其他程序使用。无论它是文件系统，还是Key-Value存储系统。 需要有人提供管理外置存储的基础能力，比如查询（List）一下外置存储里面都有些什么文件。它可以实现为一个独立的程序，比如我们命名为 ls。 需要有人执行外置存储上的可执行程序。它可以实现为一个独立的程序，比如我们命名为 sh。 汇编程序编辑器。其实这个程序和汇编语言没什么关系，就是一个纯正的文本编辑器。我们可以把这个程序命名为 vi。 汇编编译器。它可以实现为一个独立的程序，比如我们命名为 asm。 引导程序拿到执行权后，我们不管它额外做了哪些事情，最终它要把执行权交给 sh 程序。因为，sh 程序算得上是可自我迭代的计算机扩展性的体现：通过 sh 程序来执行外置存储上的任意程序，这也相当于在扩展 CPU 的指令集。 结语我们来回顾一下今天的内容。一个最小功能集、计算能力可自我迭代的计算机，它的变化点和稳定点分别是什么？为此，你会怎么设计，设计出哪些子系统，每个子系统的规格是什么？扩展性上有哪些考虑？ 需求的变化点在于下面这几点。 外置存储的数据格式。对此，我们设计文件系统（或Key-Value存储）子系统来负责这件事情。另外，我们也提供了 ls 程序来管理外置存储中的文件。 用户最终拿到这个计算机后，会迭代出什么能力。对此，我们设计了 sh 程序，让它支持在外置存储上执行任何应用程序。 编辑器的交互范式。对此，我们设计了 vi 程序，让它迭代编辑器的能力。 汇编语言的使用范式。对此，我们设计了 asm 程序，让它响应 CPU 指令集的迭代，以及汇编语言进化的迭代。 最终，我们设计出来的“可自我迭代的计算机”，它的系统架构看起来是这样的： 你的需求分析和系统设计跟上面的架构一致吗？ 不一致非常正常，架构并无标准答案。但通过对比别人的方案与自己的不同之处，可以加深你对架构设计在决策上的体会。 另外，在 “可自我迭代的计算机” 这样相对模糊需求的细化过程中，也会很自然出现不太一样的理解，这些都是正常的，这也是需求分析的重要性所在，它本身就是一个需求从模糊到细化并最终清晰定义的过程。 如果你觉得系统过于复杂，不知道如何下手，也不要紧，设计“一个可自我迭代的计算机” 的确是一个复杂的系统，它并不是一个非常适合架构新手的任务。但是我仍然希望通过这样一个例子的剖析，你对需求分析中稳定点和变化点的判断有所感悟。 如果你有什么样的想法和疑问，欢迎你给我留言，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/05 | 思考题解读：如何实现可自我迭代的计算机？/"},{"title":"06 | 操作系统进场","text":"你好，我是七牛云许式伟。 在编程语言出现后，软件生产效率得到了大幅度的提升。随着越来越多软件的出现，自然而然就诞生了多个软件如何共处，也就是软件治理的需求。比如下面的这些需求场景。 多个软件如何同时运行（多任务的需求）？ 多个软件如何共同使用计算机上的存储空间（内存管理、文件系统的需求）？ 多个软件如何共同使用同一个外部设备（设备管理的需求）？ 多个软件如何相互通讯，如何进行数据交换（进程间通讯、共享内存的需求）？ 病毒、恶意软件如何治理（安全管理的需求）？ 如果没有一个中间的协调方，软件与软件之间并不知道彼此的存在，你不难想象出，这种没有统一规则约束下的场面，会有多么凌乱。 于是，操作系统就出现了。对于软件而言，它像一个大法官，制定规则并据此约束大家的行为。 操作系统的启动过程操作系统是怎么获得执行权的？ 这是计算机主板ROM上的启动程序（BIOS）交给它的。 计算机加电启动后，中央处理器（CPU）会从一个固定的存储地址加载指令序列执行。通常，这个固定的存储地址指向计算机主板的ROM上的一段启动程序（BIOS）。这段启动程序通常包含以下这些内容。 存储设备的驱动程序，用以识别常规的外置存储设备，比如硬盘、光驱、U盘。 基础外部设备的驱动程序，比如键盘、鼠标、显示器。 设备和启动配置的基础管理能力。 支持执行外置存储中引导区的机器代码程序。 跳转到外置存储引导区的固定地址，把执行权交给该地址上的引导程序。 引导区的引导程序有长度限制（关于这一点我在上一讲已经介绍过），只能做非常少的事情。在常规情况下，它只是简单地跳转到真正的操作系统的启动程序，但有时计算机上安装了多个操作系统，此时引导程序会提供菜单让你选择要运行的操作系统。 这样，操作系统就开始干活了。 操作系统的需求演进那么，操作系统是做什么的？前面我们说的“软件治理”是否可以涵盖它完整的目标？ 让我们从操作系统的发展历程说起。 最早期的计算机是大型机。这个时期的计算机笨重、昂贵，并且操作困难，主要使用人群是搞科研性质的科学家或其他高端人群。 虽然这个时期催生了 IBM 这样的硬件巨头，但大多数人根本就意识不到，这玩意儿对后世人们的生活能够产生如此翻天覆地的变化。 这个时期的计算机还是单任务的，以计算为主，软件为操作硬件服务。如果我们认为“软件治理”是操作系统的根源需求的话，那么可以认为这个时期还不存在操作系统。但的确会有一些辅助工具库来简化用户使用计算机的负担，我们可以把它看做操作系统的萌芽。 从这个意义来说，提供计算机的“基础编程接口”，降低软件开发的负担，是操作系统更为原始的需求。 此后，小型机和个人计算机（PC）的崛起，分别诞生了 UNIX 和 DOS 这两个影响深远的操作系统。 UNIX 就不用说了，它几乎算得上今天所有现代操作系统的鼻祖。 DOS 的历史非常有趣。首先是 IBM 没把操作系统当回事儿，把这个活儿包给了微软。然后是微软只花了 5 万美元向西雅图公司购买了 86-DOS 操作系统的版权，更名为 MS-DOS。 那么 86-DOS 是怎么来的？西雅图公司的一个24岁小伙叫蒂姆·帕特森（Tim Paterson），单枪匹马花了4个月时间写出来的。 可以看到，这个时期人们对操作系统并没有太深刻的认知，多数人只把它看做硬件的附属品。IBM 不把它当回事，西雅图公司也没把它当回事，几万就把它卖了。只有微软认认真真地把它当做生意做了起来（在此之前微软的生意是卖 BASIC 语言的解析器起家，所以微软一直对 BASIC 语言情有独钟，直到很久以后微软搞出了 C# 语言后，情况才有所改变）。 等到 IBM 意识到操作系统是个金蛋，改由自己做 PC-DOS 操作系统的时候，微软已经通过推动 PC 兼容机的发展，让操作系统不再依赖特定的硬件设备，微软也就因此脱离 IBM 的臂膀，自己一飞冲天了。 回到问题。要回答操作系统在做什么，我们可以从客户价值和商业价值两个维度来看。 客户价值来说，操作系统首先要解决的是软件治理的问题，大体可分为以下六个子系统：进程管理、存储管理、输入设备管理、输出设备管理、网络管理、安全管理等。 操作系统其次解决的是基础编程接口问题。这些编程接口一方面简化了软件开发，另一方面提供了多软件共同运行的环境，实现了软件治理。 商业价值来说，操作系统是基础的刚需软件。计算机离开了操作系统就是一堆废铜烂铁。随着个人计算机采购需求的急速增加，光靠软件 License 的费用就让操作系统厂商赚翻了。 虽然第一个广为人知的操作系统是 UNIX，但从商业上来说最成功的操作系统则是 DOS/Windows，成就了微软的霸主地位。 为什么是 DOS/Windows 赢得了市场，这无关技术优劣，关键在于两者的商业路线差异：UNIX 走的是企业市场，而 DOS/Windows 选择了更为巨大的市场：个人计算机（PC）市场。 操作系统也是核心的流量入口。占领了操作系统，就占有了用户，想推什么内容给用户都很容易。微软对这一点显然心知肚明。 这也是为什么当年网景推 Netscape 浏览器的时候，微软很紧张。因为浏览器是另一个软件治理的入口，本质上是操作系统之上的操作系统。如果软件都运行在浏览器上，那么本地操作系统就沦为和硬件一般无二的管道了。 虽然早期操作系统没有应用市场（AppStore），但是通过操作系统预装软件的方式向软件厂商收租，这是一直以来都有的盈利方式。国内盗版的番茄花园 Windows 发行版就是通过在 Windows 系统上预装软件来盈利。 当然预装软件只是一种可能性，流量变现的方式还有很多。苹果的 iOS 操作系统开启了新的玩法，它构建了新的商业闭环：账号（Account）、支付（Pay）、应用市场（AppStore）。 我们把这个商业模式叫收税模式。帐号（注意是互联网账号，不是过去用于权限管理的本地账号）是前提。没有帐号，就没有支付系统，也没有办法判断用户是否购买过某个软件。 应用市场实现了应用的分发，既解决了系统能力的无限扩展问题（客户价值），也解决了预装软件的软件个数总归有限的问题（商业价值）。支付则是收税模式的承载体，无论是下载应用收费，还是应用内购买内容收费，都可以通过这个关卡去收税。 无论是本地操作系统 iOS 和 Android，还是 Web 操作系统（浏览器）如微信小程序，都实现了“帐号-支付-应用市场”这样的商业闭环。这类操作系统，我们不妨把它叫做现代操作系统。 操作系统的边界在哪里？架构的第一步是需求分析。上一讲我提到了在架构设计过程中，需求分析至少应该花费三分之一的精力。通过这一节我们对操作系统演进过程的回顾，你可能更容易体会到这一点。 当我们说要做一个操作系统的时候，实际上我们自己对这句话的理解也是非常模糊的。尤其是我们正准备去做的事情是一个新生事物时，我们对其理解往往更加粗浅。 在本专栏开篇词中我也提过，架构也关乎用户需求，作为架构师我们不只是要知道当前的用户需求是什么，我们还要预测需求未来可能的变化，预判什么会发生，而什么一定不会发生。 我们可以问一下自己：我是否能够预料到，有一天支付（Pay）系统会成为操作系统的核心子系统？如果不能，那么怎么才能做到？ 操作系统的边界到底在哪里？ 要回答这个问题，我们需要看清楚这样三个角色的关系： 硬件（个人计算机、手机或其他）； 操作系统； 浏览器。 首先我们来看操作系统与硬件的关系。如果操作系统厂商不做硬件会怎样？我们知道个人计算机（PC）市场就是如此。微软虽然占据了 PC 操作系统（DOS/Windows）绝大部分江山，但是它自身并不生产硬件。这里面，PC 兼容机的发展对 DOS/Windows 的发展有着至关重要的支撑意义。它让操作系统厂商有了独立的生存空间。 到了移动时代，Google 收购 Android 后，通过免费策略占领移动操作系统的大半江山，一定程度上复制了微软的过程，但实际上并没有那么理想。 首先，Android 是免费的，Google 并没有从中收取软件 License 费用，而是借助 Android 的市场占有率来推动 Google 的服务（例如搜索、Gmail 等等），通过 Google 服务来获取商业回报。 其次，iOS 操作系统引入的 “账号-支付-应用市场” 的收税模式，受益方是硬件（手机）厂商，而非操作系统厂商。其中最关键的一点，几乎所有手机厂商都不接受把支付（Pay）这个核心系统交给 Google。 最后，不止支付系统，一旦手机厂商长大立足 ，Google 服务也会被逐步替换。所以 Google 和 Android 手机厂商之间的联盟并不可靠，养肥的手机厂商会不断试探 Google 的底线，而 Google 也会尝试去收紧政策，双方在博弈中达到平衡。 之所以会这样，我觉得原因有这么几个： 其一，历史是不可复制的，人们对操作系统的重要性认知已经非常充分。所以大部分手机厂商，都不会放弃操作系统的核心子系统的主控权。Android 系统的开源策略无法完全达到预期的目标，这也是 Google 最终还是免不了要自己做手机的原因。 其二，手机是个性化产品，硬件上并没有 PC 那么标准化。所以个人计算机有兼容机，而手机并没有所谓的标准化硬件。 分析完操作系统和硬件的关系，我们再来看它和浏览器的关系。在 PC 时期，操作系统和浏览器看起来至少需求上是有差异化的：操作系统，是以管理本地软件和内容为主（对内）。浏览器，是以管理互联网内容为主（对外）。 但，这个边界必然会越来越模糊。 操作系统不涉足互联网内容？这是不可能的。应用市场（AppStore）其实就是典型的互联网内容；而另一方面，在浏览器的生态里也有一些特殊角色：网址导航、搜索引擎、Web 应用市场，它们共同构成了探索互联网世界的“地图”。 问题在于： 操作系统、浏览器和（互联网）搜索引擎的关系是什么； 移动时代的浏览器会是什么样的；它和操作系统的关系又如何相处？ 欢迎把你对这几个问题的想法告诉我。 结语让我们简单回顾下今天我所讲到的内容。 从客户需求来说，操作系统的核心价值在于： 实现软件治理，让多个软件和谐共处； 提供基础的编程接口，降低软件开发难度。 从商业价值来说，操作系统是刚性需求，核心的流量入口，兵家必争之地。所以，围绕它的核心能力，操作系统必然会不断演化出新的形态。 我们把引入了 “账号-支付-应用市场” 商业闭环的收税模式的操作系统，称为现代操作系统。 操作系统的边界到底在什么地方？我们通过分析硬件、操作系统、浏览器三者的关系，也做了定性的分析。这样的分析将有助于你对需求发展做出预判。 最后，你可以在留言区给我留言，分享你对于操作系统技术、商业的看法，让我们一起交流。","link":"/2019/08/31/许世伟的架构课/06 | 操作系统进场/"},{"title":"07 | 软件运行机制及内存管理","text":"你好，我是七牛云许式伟。 操作系统的核心职能是软件治理，而软件治理的一个很重要的部分，就是让多个软件可以共同合理使用计算机的资源，不至于出现争抢的局面。 内存作为计算机最基础的硬件资源，有着非常特殊的位置。我们知道，CPU 可以直接访问的存储资源非常少，只有：寄存器、内存（RAM）、主板上的 ROM。 寄存器的访问速度非常非常快，但是数量很少，大部分程序员不直接打交道，而是由编程语言的编译器根据需要自动选择寄存器来优化程序的运行性能。 主板上的 ROM 是非易失的只读的存储。所谓非易失，是计算机重新启动后它里面的数据仍然会存在。这不像内存（RAM），计算机重新启动后它上面的数据就丢失了。ROM 非易失和只读的特点，决定了它非常适合存储计算机的启动程序（BIOS）。 所以你可以看到，内存的地位非常特殊，它是唯一的 CPU 内置支持，且和程序员直接会打交道的基础资源。 内存有什么用？前面我们在 “02 | 大厦基石：无生有，有生万物” 一讲中介绍冯·诺依曼结构的时候，画过一个图： 从图中可以看出，存储的作用有两个：一个是作为 “计算” 的操作对象，输入和输出数据存放的所在；另一个是存放 “计算” 本身，也就是程序员写的程序。 这里说的存储，主要指的就是内存。 计算机运行全过程当然，这是从 CPU 角度看到的视图：对于 CPU 来说，“计算” 过程从计算机加电启动，执行 BIOS 程序的第一条指令开始，到最后计算机关机，整个就是一个完整的 “计算” 过程。这个过程有多少个“子的 ‘计算’过程”，它并不关心。 但是从操作系统的视角来看，计算机从开机到关机，整个 “计算” 过程，由很多软件，也就是子 “计算” 过程，共同完成。从时序来说，计算机完整的 “计算” 过程如下： 整个 “计算” 过程的每个子过程都有其明确的考量。 首先，BIOS 程序没有固化在 CPU 中，而是独立放到主板的 ROM 上，是因为不同历史时期的计算机输入输出设备很不一样，有键盘+鼠标+显示器的，有触摸屏的，也有纯语音交互的，外置存储则有软盘，硬盘，闪存，这些变化我们通过调整 BIOS 程序就可以应对，而不需要修改 CPU。 引导区引导程序，则是程序从内置存储（ROM）转到外置存储的边界。引导区引导程序很短，BIOS 只需要把它加载到内存执行就可以，但是这样系统的控制权就很巧妙地转到外置存储了。 引导区引导程序不固化在 BIOS 中，而是写在外置存储的引导区，是为了避免 BIOS 程序需要经常性修改。毕竟 BIOS 还是硬件，而引导区引导程序已经属于软件范畴了，修改起来会方便很多。 OS 引导程序，则是外置存储接手计算机控制权的真正开始。这里 OS 是操作系统（Operating System）的缩写。操作系统从这里开始干活了。这个过程发生了很多很多事情，这里我们先略过。但是最终所有的初始化工作完成后，操作系统会把执行权交给 OS Shell 程序。 OS Shell 程序负责操作系统与用户的交互。最早的时候，计算机的交互界面是字符界面，OS Shell 程序是一个命令行程序。DOS 中叫 command.com，而在 Linux 下则叫 sh 或者 bash 之类。这里的 sh 就是 shell 的缩写。 这个时期启动一个软件的方式就是在 Shell 程序中输入一个命令行，Shell 负责解释命令行理解用户的意图，然后启动相应的软件。到了图形界面时期，在 Shell 中启动软件就变成点点鼠标，或者动动手指（触摸屏）就行了，交互范式简化了很多。 在了解了计算机从开机到关机的整个过程后，你可能很快会发现，这里面有一个很关键的细节没有交代：计算机是如何运行外置存储上的软件的？ 这和内存管理有关。 结合内存的作用，我们谈内存管理，只需要谈清楚两个问题： 如何分配内存（给运行中的软件，避免它们发生资源争抢）； 如何运行外置存储（比如硬盘）上的软件？ 在回答这两个问题之前，我们先了解一个背景知识：CPU 的实模式和保护模式。这两个模式 CPU 对内存的操作方式完全不同。在实模式下，CPU 直接通过物理地址访问内存。在保护模式下，CPU 通过一个地址映射表把虚拟的内存地址转为物理的内存地址，然后再去读取数据。 相应的，工作在实模式下的操作系统，我们叫实模式操作系统；工作在保护模式下的操作系统，我们叫保护模式操作系统。 实模式下的内存管理先看实模式操作系统。 在实模式操作系统下，所有软件包括操作系统本身，都在同一个物理地址空间下。在 CPU 看来，它们是同一个程序。操作系统如何分配内存？至少有两种可行的方法。 其一，把操作系统内存管理相关的函数地址，放到一个大家公认的地方（比如 0x10000 处），每个软件要想申请内存就到这个地方取得内存管理函数并调用它。 其二，把内存管理功能设计为一个中断请求。所谓中断，是 CPU 响应硬件设备事件的一个机制。当某个输入输出设备发生了一件需要 CPU 来处理的事情，它就会触发一个中断。 内存的全局有一个中断向量表，本质上就是在一个大家公认的地方放了一堆函数地址。比如键盘按了一个键，它会触发 9 号中断。在 CPU 收到中断请求时，它会先停下手头的活来响应中断请求（到中断向量表找到第 9 项对应的函数地址并去执行它），完成后再回去干原来的活。 中断机制设计之初本来为响应硬件事件之用，但是 CPU 也提供了指令允许软件触发一个中断，我们把它叫软中断。比如我们约定 77 号中断为内存管理中断，操作系统在初始化时把自己的内存管理函数写到中断向量表的第 77 项。 所以，上面两种方法实质上是同一个方法，只是机制细节有所不同而已。中断机制远不止是函数向量表那么简单。比如中断会有优先级，高优先级中断可以打断低优先级中断，反之则不能。 那么，在实模式下，操作系统如何运行外置存储（比如硬盘）上的软件？ 很简单，就是把软件完整从外置存储读入到内存然后执行它。不过，在执行前它干了一件事情，把浮动地址固定下来。为什么会有浮动地址？因为软件还没有加载到内存的时候并不知道自己会在哪里，所以有很多涉及数据的地址、函数的地址都没法固定下来，要在操作系统把它加载到内存时来确定。 整体来说，实模式内存管理的机制是非常容易理解的。因为它毕竟实质上是一个程序被拆分为很多个软件（程序代码片段），实现了程序代码片段的动态加载而已。 保护模式下的内存管理但实模式有两个问题。 其一是安全性。操作系统以及所有软件都运行在一起，相互之间可以随意修改对方的数据甚至程序指令，这样搞破坏就非常容易。 其二是支持的软件复杂性低，同时可运行的软件数量少。 一方面，软件越复杂，它的程序代码量就越多，需要的存储空间越大，甚至可能出现单个软件的大小超过计算机的可用内存，这时在实模式下就没法执行它。 另一方面，哪怕单个软件可运行，但是一旦我们同时运行的软件多几个，操作系统对内存的需求量就会急剧增加。相比这么多软件加起来的内存需求量，内存的存储空间往往仍然是不足的。 但是为什么平常我们可以毫无顾忌地不断打开新的软件，从来不曾担心过内存会不足呢？ 这就是保护模式的作用了。保护模式下，内存访问不再是直接通过物理内存，而是基于虚拟内存。虚拟内存模式下，整个内存空间被分成很多个连续的内存页。每个内存页大小是固定的，比如 64K。 这样，每次 CPU 访问某个虚拟内存地址中的数据，它都会先计算出这是要访问哪个内存页，然后 CPU 再通过一个地址映射表，把虚拟的内存地址转为物理的内存地址，然后到这个物理内存地址去读取数据。地址映射表是一个数组，下标是内存页页号，值是该内存页对应的物理内存首地址。 当然，也有可能某一个内存页对应的物理内存地址还不存在，这种情况叫缺页，没法读取数据，这时 CPU 就会发起一个缺页的中断请求。 这个缺页的中断请求会被操作系统接管。发生缺页时，操作系统会为这个内存页分配物理的内存，并恢复这个内存页的数据。如果没有空闲的物理内存可以分配，它就会选择一个最久没有被访问的内存页进行淘汰。 当然，淘汰前会把这个内存页的数据保存起来，因为下次 CPU 访问这个被淘汰的内存页时一样会发生缺页中断请求，那时操作系统还要去恢复数据。 通过这个虚拟内存的机制，操作系统并不需要一上来就把整个软件装进内存中，而是通过缺页中断按需加载对应的程序代码片段。多个软件同时运行的问题也解决了，内存不够用的时候，就把最久没有用过的内存页淘汰掉，腾出物理内存出来。 运行软件的问题解决了。那么，操作系统如何分配内存给运行中的软件？ 其实，内存分配的问题也解决了，并不需要任何额外的机制。反正内存地址空间是虚拟的，操作系统可以一上来就给要运行的软件分配超级大的内存，你想怎么用随你。软件如果不用某个内存页，什么都不发生。软件一旦用了某个内存页，通过缺页中断，操作系统就分配真正的物理内存给它。 通过引入虚拟内存及其缺页机制，CPU 很好地解决了操作系统和软件的配合关系。 每个运行中的软件，我们把它叫进程，都有自己的地址映射表。也就是说，虚拟地址并不是全局的，而是每个进程有一个自己独立的虚拟地址空间。 在保护模式下，计算机的基础架构体系和操作系统共同在努力做的一件事情，就是让每个软件“感觉”自己在独占整个计算机的资源。独立的虚拟地址空间很好地伪装了这一点：看起来我独自在享用所有内存资源。在实模式下的浮动地址的问题也解决了，软件可以假设自己代码加载的绝对地址是什么，不需要在加载的时候重新调整 CPU 指令操作的地址。 这和实模式很不一样。在实模式下，所有进程都在同在物理内存的地址空间里，它们相互可以访问对方的数据，修改甚至破坏对方的数据，进而导致其他进程（包括操作系统本身的进程）崩溃。内存是进程运行的基础资源，保持进程基础资源的独立性，是软件治理的最基础的要求。这也是保护模式之所以叫“保护”模式的原因。 架构思维上我们学到什么？虚拟内存它本质上要解决这样两个很核心的需求。 其一，软件越来越大，我们需要考虑在外置存储上执行指令，而不是完整加载到内存中。但是外置存储一方面它的数据 CPU 并不知道怎么读；另一方面就算知道怎么读，也不知道它的数据格式是什么样的，这依赖文件系统的设计。让 CPU 理解外置存储的实现细节？这并不是一个\b好的设计。 其二，要同时运行的软件越来越多，计算机内存的供给与软件运行的内存需求相比，捉襟见肘。怎么才能把有限的内存的使用效率最大化？一个很容易想到的思路是把不经常使用的内存数据交换到外置存储。但是问题仍然是，CPU 并不了解外置存储的实现细节，怎么才能把内存按需交换出去？ 通过把虚拟内存地址分页，引入缺页中断，我们非常巧妙地解决了这个问题。缺页中断很像是 CPU 留给操作系统的回调函数，通过它对变化点实现了很好的开放性设计。 结语总结一下。我们今天先概要地阐述了计算机运行的全过程，并对每一步的核心意义做了简单的介绍。然后我们把话题转到我们这一节的重心：内存管理。 谈内存管理，需要谈清楚两个核心问题： 如何分配内存（给运行中的软件，避免它们发生资源争抢）； 如何运行外置存储（比如硬盘）上的软件？ 我们分别就在实模式下和保护模式下的内存管理进行了讨论。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/07 | 软件运行机制及内存管理/"},{"title":"08 | 操作系统内核与编程接口","text":"你好，我是七牛云许式伟。 今天我们在开发软件的时候，已经处于一些基础的架构设计之中，像冯·诺依曼计算机体系，像操作系统和编程语言，这些都是我们开发一个应用程序所依赖的基础架构。 在上一讲“07 | 软件运行机制及内存管理” 中，我们着重介绍了软件是如何被运行起来的。今天，我们着重聊一聊软件如何利用它所依赖的基础架构。 首先是冯·诺依曼计算机体系，它由 “中央处理器+存储+一系列的输入输出设备” 构成。这一层，提供了编程接口的是中央处理器（CPU），编程接口是 CPU 指令，但 CPU 指令非常难用。 为此，人们发明了编程语言来降低 CPU 指令的使用门槛。编程语言面向人类，CPU 指令面向机器，编译器负责将人类容易理解和掌握的编程语言的程序，翻译成机器能够理解的 CPU 指令序列。 其次是编程语言。虽然编程语言出现的起因是降低 CPU 指令的使用门槛，第一门编程语言汇编语言的能力也很接近 CPU 指令，但是语言的自然演化会越来越脱离 CPU 所限制的条条框框，大部分语言都会演化出很多基础的算法库。 比如，字符串算法库有：字符串连接（concat）、字符串子串（substring），字符串比较（compare）、字符串长度（length）等等。 系统调用最后就是操作系统了。 操作系统和前两者非常不同。软件都是某种编程语言写成的，而 CPU 和编程语言的能力，统一以语言的语法或者库体现。 操作系统则属于基础软件，它和我们编写的软件并不在同一个进程（进程是软件的一个运行后产生的实例，同一个软件可以运行多次得到多个进程）中。 如果是实模式下的操作系统，大家都在同一个地址空间下，那么只需要知道操作系统的接口函数地址，理论上就可以直接访问。但是今天主流的操作系统都是保护模式的，操作系统和软件不在同一个进程，软件怎么才能使用操作系统的能力呢？ 你可能想说，那就用进程与进程之间的通信机制？ 的确，操作系统提供了很多进程与进程之间通讯的机制，后面我们也会涉及。但是今天我们讲的操作系统的编程接口是更为基础的机制，它是所有软件进程使用操作系统能力的基础，包括进程与进程之间通讯的机制，也是建立在这个基础之上。 它应该是一种成本非常非常低的方案，性能上要接近函数调用，否则我们为保护模式付出的成本就太高了。 有这样的机制么？有，就是上一讲我们已经提到过的“中断”。 中断的设计初衷是 CPU 响应硬件设备事件的一个机制。当某个输入输出设备发生了一件需要 CPU 来处理的事情，它就会触发一个中断；但是 CPU 也提供了指令允许软件触发一个中断，我们把它叫软中断。 大部分情况下，操作系统的能力通过软中断向我们写的软件开放，为此还专门引入了一个术语叫 “系统调用（syscall）”。 系统调用是怎么工作的？ 我们需要先理解下 CPU 的代码执行权限等级。 在保护模式下，CPU 引入了 “保护环（Protection Rings）” 的概念。说白了，代码有执行权限等级的，如果权限不够，有一些 CPU 指令就不能执行。 这一点比较容易理解：上一讲我们介绍过，从内存管理的角度，虚拟内存机制让软件运行在一个沙盒中，这个沙盒让软件感觉自己在独享系统的内存。但如果不对软件的执行权限进行约束，它就可以打破沙盒，了解到真实的世界。 我们通常说的操作系统是很泛的概念。完整的操作系统非常庞大。根据与应用的关系，我们可以把操作系统分为内核与外围。 所谓操作系统内核，其实就是指那些会向我们写的应用程序提供系统服务的子系统的集合，它们管理着计算机的所有硬件资源，也管理着所有运行中的应用软件（进程）。 操作系统内核的执行权限等级，和我们常规的软件进程不同。像 Intel CPU 通常把代码执行权限分为 Ring 0-3 四个等级。 操作系统内核通常运行在 Ring 0，而常规的软件进程运行在 Ring 3（当然近年来虚拟化机制流行，为了更好地提升虚拟化的效率，Intel CPU 又引入了 Ring -1 级别的指令，这些指令只允许虚拟机所在的宿主操作系统才能调用）。 系统调用所基于的软中断，它很像一次间接的“函数调用”，但是又颇有不同。在实模式下，这种区别并不强烈。但是在保护模式下，这种差异会十分明显。 原因在于，我们的应用程序运行在 Ring 3（我们通常叫用户态），而操作系统内核运行在 Ring 0（我们通常叫内核态）。所以一次中断调用，不只是“函数调用”，更重要的是改变了执行权限，从用户态跃迁到了内核态。 但是这似乎不够。我们之前说了，操作系统与我们编写的软件并不同属一个进程，两边的内存地址空间都是独立的，我们系统调用请求是过去了，但是我们传给操作系统的内存地址，对它真的有意义吗？ 答案在于，从虚拟内存机制的视角，操作系统内核和所有进程都在同一个地址空间，也就是，操作系统内核，它是所有进程共享的内存。示意如下： 这非常有趣。操作系统内核的代码和数据，不只为所有进程所共享，而且在所有进程中拥有相同的地址。这样无论哪个进程请求过来，对内核来说看起来都是一次本进程内的请求。 从单个进程的视角，中断向量表的地址，以及操作系统内核的地址空间是一个契约。有了中断向量表的地址约定，用户态函数就可以发起一次系统调用（软中断）。 当然你可能要问：既然操作系统内核和我同属一个地址空间，我是否可以跳过中断，直接访问调用内核函数？ 这不单单是执行权限的问题。你可能会说，也许某个内核函数里面没有调用任何特权指令，我是否可以调用？ 当然不能。这涉及虚拟内存中的内存页保护机制。内存页可以设置 “可读、可写、可执行” 三个标记位。操作系统内核虽然和用户进程同属一个地址空间，但是被设置为“不可读、不可写、不可执行”。虽然这段地址空间是有内容的，但是对于用户来说是个黑洞。 编程接口理解了操作系统内核，以及它的调用方法 “系统调用”，我们来聊一聊操作系统的编程接口。 自然，最原始的调用方式，是用软中断指令。在汇编语言里面通常是： int &lt;中断号&gt; ; // 对每个操作系统来说中断号是固定的，比如 Linux 是 0x80这里的 int 不是整数（integer）的缩写，而是中断（interrupt）的缩写。 当然用汇编语言来写软件并不是一个好主意。大部分高级语言都实现了操作系统编程接口的封装。 前面我们说，操作系统（内核）有六大子系统：存储管理、输入设备管理、输出设备管理、进程管理、网络管理、安全管理。除了安全管理是一个“润物细无声”的能力外，其他子系统都会有所包装。 我们以 C 语言和 Go 语言为例给一个简表，方便大家索引： 这些标准库的能力，大部分与操作系统能力相关，但或多或少进行了适度的包装。 例如，HTTP 是应用层协议，和操作系统内核关联性并不大，基于 TCP 的编程接口可以自己实现，但由于 HTTP 协议细节非常多，这个网络协议又是互联网世界最为广泛应用的应用层协议，故此 Go 语言提供了对应的标准库。 进程内通讯最为复杂。虽然操作系统往往引入了 thread 这样的概念，但 Go 语言自己搞了一套goroutine 这样的东西，原因是什么，我们在后面讨论 “进程管理” 相关的内容时，再做详细讨论。 动态库从操作系统的角度来说，它仅仅提供最原始的系统调用是不够的，有很多业务逻辑的封装，在用户态来做更合适。但是，它也无法去穷举所有的编程语言，然后一一为它们开发各种语言的基础库。那怎么办？ 聪明的操作系统设计者们想了一个好办法：动态库。几乎所有主流操作系统都有自己的动态库设计，包括： Windows 的 dll（Dynamic Link Library）； Linux/Android 的 so（shared object）； Mac/iOS 的 dylib（Mach-O Dynamic Library）。 动态库本质上是实现了一个语言无关的代码复用机制。它是二进制级别的复用，而不是代码级别的。这很有用，大大降低了编程语言标准库的工作量。 动态库的原理其实很简单，核心考虑两个东西。 浮动地址。动态库本质上是在一个进程地址空间中动态加载程序片段，这个程序片段的地址显然在编译阶段是没法确定的，需要在加载动态库的过程把浮动地址固定下来。这块的技术非常成熟，我们在实模式下加载进程就已经在使用这样的技术了。 导出函数表。动态库需要记录有哪些函数被导出（export），这样用户就可以通过函数的名字来取得对应的函数地址。 有了动态库，编程语言的设计者实现其标准库来说就多了一个选择：直接调用动态库的函数并进行适度的语义包装。大部分语言会选择这条路，而不是直接用系统调用。 操作系统与编程语言我们这个专栏从计算机硬件结构讲起，然后再到编程语言，到现在开始介绍操作系统，有些同学可能会觉得话题有那么一些跳跃。虽然每一节的开头，我其实对话题的脉络有所交代，但是，今天我还是有必要去做一个梳理。 编程语言和操作系统是两个非常独立的演化方向，却又彼此交融，它们有点像是某种“孪生关系”。虽然操作系统的诞生离不开编程语言，但是操作系统和 CPU 一样，是编程语言背后所依赖的基础设施。 和这个话题相关的，有这么一些有趣的问题： 先有编程语言，还是先有操作系统； 编程语言怎么做到自举的（比如用C语言来实现C语言编译器）； 操作系统开发的环境是什么样的，能够做到操作系统自身迭代本操作系统（自举）么？ 对于第一个问题：先有编程语言，还是先有操作系统？这个问题的答案比较简单，先有编程语言。之所以有这个疑问，是因为两点： 其一，大部分人习惯认为运行软件是操作系统的责任。少了责任方，软件是怎么跑起来的？但实际上软件跑起来是很容易的，看 BIOS 程序把控制权交给哪个软件。 其二，大部分常见的应用程序都直接或间接依赖操作系统的系统调用。这样来看，编程语言编译出来的程序是无法脱离操作系统而存在的。但是实际上常见的系统级语言（比如 C 语言）都是可以编写出不依赖任何内核的程序的。 对于第二个问题：编程语言怎么做到自举的？ 从鸡生蛋的角度，编译器的进化史应该是这样的：先用机器码直接写第一个汇编语言的编译器，然后汇编语言编译器编出第一个 C 语言编译器。有了 C 语言编译器后，可以反过来用 C 语言重写汇编语言编译器和 C 语言编译器，做更多的功能增强。 这个过程理论上每出现一种新 CPU 指令集、新操作系统，就需要重新来一遍。但是人是聪明的。所以交叉编译这样的东西产生了。所谓交叉编译就是在一种 “CPU +操作系统” 架构下，生成另一种 “CPU +操作系统” 架构下的软件。这就避免了需要把整个编译器进化史重新演绎一遍。 对于第三个问题：操作系统能够做到自身迭代本操作系统（自举）么？ 当然可以。通常一门新的操作系统开发之初，会用上面提到的交叉编译技术先干出来，然后等到新操作系统稳定到一定程度后再实现自举，也就是用本操作系统自己来做操作系统的后续迭代开发。 结语这一节我们介绍了我们的基础架构：中央处理器（CPU）、编程语言、操作系统这三者对应用软件开放的编程接口。总结来看就是下面这样一幅图： 其中，我们着重介绍的是操作系统的系统调用背后的实现机理。通过系统调用这个机制，我们很好地实现了操作系统和应用软件的隔离性和安全性，同时仍然保证了极好的执行性能。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/08 | 操作系统内核与编程接口/"},{"title":"11 | 多任务：进程、线程与协程","text":"你好，我是七牛云许式伟。 到现在为止，我们已经介绍了操作系统的存储管理：内存与外存；也已经介绍了输入与输出设备的管理。 当然，考虑到输入与输出设备属于人机交互范畴，我们主要会留到下一章 “桌面软件开发” 去详细介绍，这一章，我们仅概要地回顾输入与输出设备的需求演进过程。 CPU + 存储 + 输入与输出，软件开发最基础的内容基本上就都覆盖到了。 今天开始，我们就来聊一聊多任务。 多任务与执行体多任务的需求是随处可见的。常见的场景，比如我们想边工作边听音乐；又或者我们需要跑一个后台监控程序，以报告随时可能发生的异常。 那么，怎么才能做到多任务？ 我们先从物理层面看。最早期的 CPU 基本上都是单核的，也就是同一时间只能执行一条指令。尽管如此，大家可能都听过 “摩尔定律”，简单地说就是，每隔一年半到两年，同样的钱能买到的计算力能够翻一倍。 这当然不是什么严谨的物理学定律，更多的是一定历史时期下的经验之谈。早期 CPU 工艺的发展，基本上是通过提高电子元器件的密集程度实现的；但是电子元器件大小总归有个极限，不可能无限小下去。 那么怎么办？不能更小的话，那就横向多铺几个，一颗 CPU 多加几颗核心。这样多核技术就出现了。多核的意思是说，单核速度我提不上去了，多给你几个，价格一样。 所以物理层面的多任务，有两个方法：一个是多颗 CPU，一个是单颗 CPU 多个核心。 在桌面端，大多数情况用的是后者，因为桌面端的产品（个人计算机、手机、手表等）还是很在意产品的体积如何尽可能做得更小；而服务器领域，通常同时使用两者，它更多关注的是如何尽可能提升单台计算机的计算力密度。 但如果我们实际就只有一个单核的 CPU，是否就没办法实现多任务呢？ 当然可以。方法是把 CPU 的时间切成一段段时间片，每个时间片只运行某一个软件。这个时间片给软件 A，下一个时间片给软件 B。因为时间片很小，我们会感觉这些软件同时都在运行。这种分时间片实现的多任务系统，我们把它叫分时系统。 分时系统的原理说起来比较简单，把当前任务状态先保存起来，把另一个任务的状态恢复，并把执行权交给它即可。这里面涉及的问题有： 任务是什么，怎么抽象任务这样一个概念； 任务的状态都有什么？怎么保存与恢复； 什么时机会发生任务切换？ 从今天的现实看，任务的抽象并不是唯一的。大部分操作系统提供了两套：进程和线程。有的操作系统还会提供第三套叫协程（也叫纤程）。 我个人喜欢统一用来 “执行体” 一词来统称它们。所谓执行体，是指可被 CPU 赋予执行权的对象，它至少包含下一个执行位置（获得执行权后会从这里开始执行）以及其他的运行状态。 任务的状态都有什么？ 从 CPU 的角度，执行程序主要依赖的是内置存储：寄存器和内存（RAM），它们构成执行体的上下文。 先看寄存器。寄存器的数量很少且可枚举，我们直接通过寄存器名进行数据的存取。 在我们把 CPU 的执行权从软件 A 切换到软件 B 的时候，要把软件 A 所有用到的寄存器先保存起来（以便后续轮到软件 A 执行的时候恢复），并且把寄存器的值恢复到软件 B 上一次执行时的值，然后才把执行权交给软件 B。 这样，在软件 A 和 B 的视角看来，它们好像一直都是独自在使用 CPU，从未受到过其他软件的打扰。 我们再看内存（RAM）。CPU 在实模式和保护模式下的内存访问机制完全不同，我们分别进行讨论。在实模式下，多个执行体同在一个内存地址空间，相互并无干扰（非恶意情况下）。 在保护模式下，不同任务可以有不同的地址空间，它主要通过不同的地址映射表来体现。怎么切换地址映射表？也是寄存器。 所以，总结就一句话：执行体的上下文，就是一堆寄存器的值。要切换执行体，只需要保存和恢复一堆寄存器的值即可。无论是进程、线程还是协程，都是如此。 进程与线程那么，不同的执行体究竟有何不同？为何会出现不同种类的执行体？ 进程是操作系统从安全角度来说的隔离单位，不同进程之间基于最低授权的原则。 在创建一个进程这个事情上，UNIX 偷了一次懒，用的是 fork（分叉）语义。所谓 fork，就是先 clone 然后再分支，父子进程各干各的。 这样创建进程很讨巧，不用传递一堆的参数，使用上非常便利。但我认为从架构设计的角度，这是 UNIX 操作系统设计中最糟糕的 API，没有之一。而更不幸的是 Linux 把这一点继承下来了。 为什么进程 fork 是糟糕的？这是因为：进程是操作系统最基本的隔离单元，我们怕的就是摘不清楚，但是 fork 偏偏要藕断丝连。 这一点 Windows 要清晰很多，哪些文件句柄在子进程中还要用到，一一明确点名，而不是 fork 一下糊里糊涂就继承过去了。 事实上我个人那么多年工程经验表明，除了会接管子进程的标准输入和标准输出，我们几乎从来不会通过向子进程传递文件句柄来通讯。 所以 fork 这种传递进程上下文的方式，是彻头彻尾的一次过度设计。甚至严重一点说，是设计事故。 线程的出现，则是因为操作系统发现同一个软件内还是会有多任务的需求，这些任务处在相同的地址空间，彼此之间相互可以信任。 从线程角度去理解 UNIX 的 fork，能够稍微理解一些设计者们当年的考量。 早期操作系统中没有线程的概念，也不会有人想到要搞两套执行体。所以进程实际上承担了一部分来自线程的需求：我需要父进程的环境。 协程与goroutine协程并不是操作系统内核提供的，它有时候也被称为用户态线程。这是因为协程是在用户态下实现的。如果你感兴趣，也可以自己实现一个。 但为什么会出现协程呢？看起来它要应对的需求与线程一样，但是功能比线程弱很多？ 答案是因为实现高性能的网络服务器的需要。对于常规的桌面程序来说，进程+线程绰绰有余。 但对于一个网络服务器，我们可以用下面这个简单的模型看它： 对网络服务器来说，大量的来自客户端的请求包和服务器的返回包，都是网络 IO；在响应请求的过程中，往往需要访问存储来保存和读取自身的状态，这也涉及本地或网络 IO。 如果这个网络服务器有很多客户，那么整个服务器就充斥着大量并行的 IO 请求。 操作系统提供的标准网络 IO 有以下这些成本： 系统调用机制产生的开销； 数据多次拷贝的开销（数据总是先写到操作系统缓存再到用户传入的内存）； 因为没有数据而阻塞，产生调度重新获得执行权，产生的时间成本； 线程的空间成本和时间成本（标准 IO 请求都是同步调用，要想 IO 请求并行只能使用更多线程）。 在一些人心目中会有一个误区：操作系统的系统调用很慢。这句话很容易被错误地理解为系统调用机制产生的开销很大。 但这是很大的误解。系统调用虽然比函数调用多做了一点点事情，比如查询了中断向量表（这类似编程语言中的虚函数），比如改变 CPU 的执行权限（从用户态跃迁到内核态再回到用户态）。 但是注意这里并没有发生过调度行为，所以归根结底还是一次函数调用的成本。怎么理解操作系统内核我们示意如下： 从操作系统内核的主线程来说，内核是独立进程，但是从系统调用的角度来说，操作系统内核更像是一个多线程的程序，每个系统调用是来自某个线程的函数调用。 为了改进网络服务器的吞吐能力，现在主流的做法是用 epoll（Linux）或 IOCP（Windows）机制，这两个机制颇为类似，都是在需要 IO 时登记一个 IO 请求，然后统一在某个线程查询谁的 IO 先完成了，谁先完成了就让谁处理。 从系统调用次数的角度，epoll 或 IOCP 都是产生了更多次数的系统调用。从内存拷贝来说也没有减少。所以真正最有意义的事情是：减少了线程的数量。 既然不希望用太多的线程，网络服务器就不能用标准的同步 IO（read/write）来写程序。知名的异步 IO 网络库 libevent 就是对 epoll 和 IOCP 这些机制包装了一套跨平台的异步 IO 编程模型。 NodeJS 一炮而红，也是因为把 JavaScript 的低门槛和 libevent 的高性能结合起来，给了前端程序员一个“我也能搞高性能服务器”的梦想。 但是异步 IO 编程真的很反人类，它让程序逻辑因为 IO 异步回调函数而碎片化。我们开始怀念写同步 IO 的那些日子了。 让我们再回头来看：我们为什么希望减少线程数量？因为线程的成本高？我们分析一下。 首先，我们看下时间成本。它可以拆解为： 执行体切换本身的开销，它主要是寄存器保存和恢复的成本，可腾挪的余地非常有限； 执行体的调度开销，它主要是如何在大量已准备好的执行体中选出谁获得执行权； 执行体之间的同步与互斥成本。 我们再看线程的空间成本。它可以拆解为： 执行体的执行状态； TLS（线程局部存储）； 执行体的堆栈。 空间成本是第一根稻草。默认情况下 Linux 线程在数 MB 左右，其中最大的成本是堆栈（虽然，线程的堆栈大小是可以设置的，但是出于线程执行安全性的考虑，线程的堆栈不能太小）。 我们可以算一下，如果一个线程 1MB，那么有 1000 个线程就已经到 GB 级别了，消耗太快。 执行体的调度开销，以及执行体之间的同步与互斥成本，也是一个不可忽略的成本。虽然单位成本看起来还好，但是盖不住次数实在太多。 我们想象一下：系统中有大量的 IO 请求，大部分的 IO 请求并未命中而发生调度。另外，网络服务器的存储是个共享状态，也必然伴随着大量的同步与互斥操作。 综上，协程就是为了这样两个目的而来： 回归到同步 IO 的编程模式； 降低执行体的空间成本和时间成本。 但是，大部分你看到的协程（纤程）库只是一个半吊子。它们都只实现了协程的创建和执行权的切换，缺了非常多的内容。包括： 协程的调度； 协程的同步、互斥与通讯； 协程的系统调用包装，尤其是网络 IO 请求的包装。 这包含太多的东西，基本上你看到的服务端操作系统所需的东西都要包装一遍。而且，大部分协程库，连协程的基础功能也是半吊子的。这里面最难搞的是堆栈。 为什么协程的堆栈是个难题？因为，协程的堆栈如果太小则可能不够用；而如果太大则协程的空间成本过高，影响能够处理的网络请求的并发数。理想情况下，堆栈大小需要能够自动适应需要。 所以，一个完备的协程库你可以把它理解为用户态的操作系统，而协程就是用户态操作系统里面的 “进程”。 这世界上有完备的协程库么？有。有两个语言干了这事儿：Erlang 和 Go 语言。Erlang 语言它基于虚拟机，但是道理上是一致的。Go 语言里面的用户态 “进程” 叫 goroutine。它有这样一些重要设计： 堆栈开始很小（只有 4K），但可按需自动增长； 坚决干掉了 “线程局部存储（TLS）” 特性的支持，让执行体更加精简； 提供了同步、互斥和其他常规执行体间的通讯手段，包括大家非常喜欢的 channel； 提供了几乎所有重要的系统调用（尤其是 IO 请求）的包装。 架构师的批判性思维多任务的需求非常复杂。 为了满足需要，人们不只发明了三套执行体：进程、线程和协程，还发明了各种五花八门的执行体间的通讯机制（可以参考 “08 | 操作系统内核与编程接口” 中我们给出的表格）。有一些执行体间的通讯机制在逐渐消亡，退出历史舞台。 操作系统内核之中，不乏无数精妙的设计思想。但是，前辈们也并非圣贤，也可能会出现一些决策上失误，留下了诸多后遗症。 这非常正常。操作系统内核是非常庞大而复杂的基础软件。它并不像计算机基础体系结构，简洁优雅。 对 CPU 而言，统一的、接口一致的输入输出设备，到了操作系统这里，它需要依据每一种设备的需求特性，抽象出对应的更加用户友好的使用接口。这个工作既繁重，又需要极强的预见性。 而作为后辈的我们，在体会这些精妙的设计思想的同时，也要批判性去吸收。日常我们天天依赖于这些基础架构，受到它们的影响与约束，这些实在是最佳的学习材料。 结语今天我们重点介绍了多任务，以及多任务带来的复杂需求，由此介绍了进程、线程和协程等三套执行体的设计。后面我们还会分进程内和进程间来介绍进程的通讯机制。 执行体的设计，有非常多值得反思的地方。UNIX 的 fork API 是否是一个好的设计？线程的设计是否成功？如果线程的设计是优良的，是不是就不再有 Go 语言这种在用户态重造执行体和 IO 子系统的必要性？ 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/11 | 多任务：进程、线程与协程/"},{"title":"09 | 外存管理与文件系统","text":"你好，我是七牛云许式伟。 在 “07 | 软件运行机制及内存管理”中，我们已经聊了内存管理，这一讲我们聊聊外置存储设备的管理。 外存的分类计算机有非常多样化的外置存储设备，比如：磁带、光盘、硬盘、U盘、SSD 等等。外置存储设备的种类是不可穷尽的。随着科技的发展，新的存储设备会不断涌现，有着更低的单位能耗（存储量/每日能源消耗成本），更低的单位存储成本（存储量/可存储的时间/设备价格），或者更高的访问性能。 但不管这些存储设备内部如何存储数据的原理怎么变，改变的主要是质量，而不是它的功能。对操作系统来说，管理它们的方式是非常一致的。这些外置存储设备依据其功能特性不同，简单可以分为如下三类。 顺序读写型。如：磁带。 随机只读型。更准确说是单次完整写入多次读取型，也就是每次写数据都是整个存储介质一次性完整写入数据。如：光盘（含可擦写光盘）。 随机读写型。如：软盘、硬盘、U盘、SSD 等等。 顺序读写型的外置存储（如磁带）我们日常并不常见，它的主要应用场景是归档，也就是数据备份。今天我们略过不提。 随机只读型的外置存储（如光盘）我们日常有较多应用，常见的应用场景是资料分发和归档。资料发布的内容很广泛，比如：软件、娱乐媒体包括电影、MTV、音乐等等。 随机读写型的外置存储最为常见，我们今天在所有“能够称得上叫电脑”的设备上，无论是PC、笔记本、手机，还是手表、汽车，随处可见它们的身影。 外存的数据格式外置存储和内存最大的区别是什么？ 毫无疑问，外置存储是持久存储，它的目的是用来存储资料的。而内存是临时存储，虽然是存储，但是它实质上是为 CPU 的计算服务的。 那么，怎么让很多的软件进程同时使用这些外置存储设备，而不会乱呢？直接基于物理的存储地址进行读写肯定是行不通的，过上几个月你自己可能都不记得什么数据写到哪里了。 所以和内存管理不同，外部存储的管理，我们希望这些写到存储中的数据是“自描述”的某种数据格式，我们可以随时查看之前写了哪些内容，都什么时候写的。 这就是文件系统的来源。 文件系统把存储设备中的数据组织成为了一棵树。节点可以是目录（也叫“文件夹”），也可以是文件。 树的根节点为目录，我们叫根目录。如果是目录，那么它还可以有子节点，子节点同样可以是子目录或文件。文件则是叶节点，保存我们希望存储的资料。 每个节点，无论是目录还是文件，都有自己的名字、创建时间、最后编辑时间、最后访问时间等信息。有些文件系统还会提供最近一段时间的操作日志。这些信息有助于提醒我们有什么内容，以前都做过什么。 尽管几乎所有文件系统的接口是非常一致的，但文件系统的实现却有很多。对于随机只读型的外置存储（如光盘），常见的文件系统有如下这些。 由于这类存储设备的写特征是批量写，一次把所有的数据写完，所以它的数据格式通常偏向于读优化（存储系统一般都有读写操作，所谓读优化是指在数据结构和算法设计时尽可能考虑让读操作更高效）。整个文件系统的元数据和文件数据都会非常紧凑，比如文件数据不必支持分块等等。 对于随机读写型的存储（如硬盘），常见的文件系统有如下这些。 从文件系统格式的设计角度来说，它和架构关联性不大，更多的是数据结构与算法的问题；而且，不是基于内存的数据结构，而是基于外存的数据结构，这两者非常不同。 尽管文件系统的种类非常多，但是它们的设计思路其实基本相似。大部分现代文件系统都基于日志（journal）来改善文件系统的防灾难能力（比如突然断电，或不正常的 unmount 行为），基于 B 树或 B+ 树组织元数据。 古老的 DOS 引入的 FAT 文件系统（典型代表为 FAT32）是个例外，它直接把目录当作一个特殊的文件，里面依次列出了这个目录里的所有子节点的元信息。 这个结构简单是简单了，但是缺点非常明显，如果目录树深、目录里的子节点数量多，都会大幅降低文件系统的性能。 对于随机读写型的存储设备，操作系统往往还支持对其进行分区，尤其是在这个存储设备的容量非常大的情况下。分区是一个非常简单而容易理解的行为，本质上只是把一个存储设备模拟成多个存储设备来使用而已。 一般来说，拿到一块存储设备，我们往往第一步是对其进行分区（当然也可以省略这一步，把整个设备看做一个分区）。 第二步是对每个分区进行格式化。所谓格式化就是给这个分区生成文件系统的初始状态。格式化最重要的是标记分区的文件系统格式（用来告诉别人这个分区是数据是怎么组织的），并且生成文件系统的根目录。 第三步是把该分区挂载（mount）到操作系统管理的文件系统名字空间中。完成挂载后，该分区的文件系统管理程序就工作起来了，我们可以对这个文件系统进行目录和文件的读取、创建、删除、修改等操作。 外存的使用接口怎么使用这些外置存储设备？ 最简单的方式是用操作系统提供的命令行工具。例如： 目录相关：ls, mkdir, mv, cp, rmdir 等。 文件相关：cat, vi, mv, cp, rm 等。 当然，最原始的方式还是我们上一讲介绍的 “系统调用”。但大部分编程语言对此都有相应的封装，例如 Go 语言中的相关功能如下所示。 目录相关：os.Mkdir, os.Rename, os.Remove 等。 文件相关：os.Open/Create/OpenFile, os.Rename, os.Remove 等。 有意思的是，在早期，操作系统试图将所有的输入输出设备的接口都统一以 “文件” 来抽象它。 最典型的代表就是标准输入（stdin）和标准输出（stdout）这两个虚拟的文件，分别代表了键盘和显示器。在 UNIX 系里面有个 “一切皆文件” 的口号，便由此而来。 但事实证明 UNIX 错了。输入输出设备太多样化了，所谓的 “一切皆文件” 不过是象牙塔式的理想。就拿键盘和显示器来说，图形界面时代到来，所谓标准输入和标准输出就被推翻了，编程接口产生颠覆性的变化。 有了文件系统的使用接口，进程就可以互不影响地去使用这些外置存储设备。除非这些进程要操作的文件或目录的路径产生冲突（所谓路径，是指从根目录到该节点的访问序列。例如路径 /a/b/c 是从根目录访问子目录a，再访问子子目录b，最后访问节点c），一般情况下它们并不需要感知到其他进程的存在。 路径冲突是可以避免的，只要我们对路径取名进行一些基础的名字空间约定，但有时候也会故意利用这种路径的冲突，来实现进程间的通讯。 操作系统提供了一些冲突检查的机制。例如 “检查文件是否存在，不存在就创建它”，这个语义在保证原子性的前提下，就可以用于做进程间的互斥。例如，我们希望一个软件不要运行多个进程实例，就可以基于这个机制来实现。 虚拟内存的支持前面我们在 “07 | 软件运行机制及内存管理” 一讲中提到，在物理内存不足的时候，操作系统会利用外存把一些很久没有使用的内存页的数据，保存到外存以进行淘汰。 在 UNIX 系的操作系统中，操作系统为此分配了一个磁盘分区叫 swap 分区，专门用于内存页的保存和恢复。在 Windows 操作系统中则通过一个具有隐藏属性的 .swp 文件来实现。 在缺页发生比较频繁时，内存页的数据经常性发生保存和恢复，这会发生大量的磁盘 IO 操作，非常占用 CPU 时间，这时候我们通常能够非常明显感觉到计算机变得很慢。 在计算机变慢，并且计算机的硬盘灯不停闪烁的时候，我们基本可以确定是物理内存严重不足，不能满足运行中的软件的内存需要。 结语回顾一下我们今天的内容。整体来说，外存管理从架构角度来说比较简单，复杂性主要集中在外存数据格式，也就是文件系统的设计上。 文件系统的实作非常多。如果你希望进一步研究某个文件系统的具体实现细节，我这里推荐一个由七牛云开源的 BPL 语言（Binary Processing Language，二进制处理语言）。地址如下： https://github.com/qiniu/bpl 顾名思义，BPL 语言主要用于分析二进制数据格式。应用场景包括：文件格式分析（含磁盘分区格式，因为一个磁盘分区可以把它理解为一个大文件）、网络协议分析。 我们在后面的介绍文本处理相关的章节，还会专门拿出 BPL 语言进行讨论。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/09 | 外存管理与文件系统/"},{"title":"10 | 输入和输出设备：交互的演进","text":"你好，我是七牛云许式伟。 前面我们已经介绍了操作系统的存储管理：内存和外存。今天，让我们来聊一聊操作系统是如何管理输入和输出设备的。 输入和输出设备有非常非常多。例如输入设备除了你常见的键盘、鼠标、触摸屏外，还有一些采集信息的传感器，如GPS位置、脉搏、心电图、温度、湿度等。我们会把关注点收敛在人机交互相关的设备管理上。 交互的演进在计算机外部设备的演进上，人机交互设备的演进毫无疑问是最为剧烈的部分。 计算机刚出现的时候，人们使用“打孔卡+打印机”作为人机交互方式。这个时期还没有操作系统，表达意图非常痛苦，只能在打孔卡上打孔来发送指令。 但很快，人们找到了 “键盘+显示器”， 这对最为经典的人机交互设备。而随着计算机使用人群越来越多，以及使用场景的变化，人机交互的方式也相应地发生了一次又一次的改变。 总结这些改变，我们会发现，人机交互在往越来越自然的方向发展。所谓自然，就是越来越接近于两个人直接的面对面沟通。 那么，这些人机交互的改变，对于操作系统来说又意味着什么呢？ 输入设备我们先看输入设备：键盘、鼠标、麦克风、摄像头。 键盘键盘输入的管理机制和窗口系统的设计密切相关。为了让用户清楚键盘输入的目的地，窗口系统往往会有一个焦点窗口。 在窗口系统里面，窗口间还有父子关系，焦点窗口还会有父窗口，还有父窗口的父窗口，这些窗口属于活动窗口。 大部分情况下，键盘输入的事件会先发给焦点窗口，焦点窗口不处理则发给其父窗口，按此传递，直到有人处理了该按键事件，或者直到顶层窗口。 键盘从功能上来说，有两个不同的能力：其一是输入文本，其二是触发命令。从输入文本的角度来说，要有一个输入光标（在Windows里面叫Caret）来指示输入的目的窗口。目的窗口也必然是焦点窗口，否则就会显得很不自然。 这个交互的呈现方式非常稳定，从 DOS到Windows/Mac，到iOS/Android 都是如此。但是从触发命令的角度来说，命令的响应并不一定是在焦点窗口，甚至不一定在活跃窗口。 比如Windows下就有热键（HotKey）的概念，能够让非活跃窗口（Inactive Window）也获得响应键盘命令的机会。一个常见的例子是截屏软件，往往需要一个热键来触发截屏。 到了移动时代，键盘不再是交互主体，但是，键盘作为输入文本的能力很难被替代（虽然有语音输入法），于是它便自然而然地保留下来。 不过移动设备不太会有人会基于键盘来触发命令，只有常见的热键需求比如截屏、调大或调小音量、拍照等等，被设计为系统功能（对应的，这些功能的热键也被设计为系统按键）保留下来。 鼠标鼠标输入的管理机制和键盘一样，和窗口系统的设计密切相关。但鼠标因为有位置，确定鼠标事件的目的地相比键盘事件要简单的多，大部分情况下，鼠标事件总是交给鼠标位置所属的窗口来处理，但也会有一些例外的场景，比如拖放。 为了支持拖放，Windows操作系统引入了鼠标捕获（Mouse Capture）的概念，一旦鼠标被某个窗口捕获，哪怕鼠标已经移出该窗口，鼠标事件仍然会继续发往该窗口。 到了移动时代，鼠标已经完全消失（虽然在智能手机之前还是出现过WinCE这样的支持鼠标的移动操作系统），取而代之的是触摸屏。窗口系统也和PC时期完全不同，在屏幕可见范围内只有单个应用程序占满整个屏幕，这让交互的目的地确认不再是个问题。 麦克风麦克风是一个非常有潜力的下一代输入设备。今天 IoT 领域如汽车、智能音箱都是很好的发展语音交互能力的场景。包括今天大行其道的手机，语音交互也是一个很好的补充。 交互方式不管怎么变化，其核心需要实现的都是这样的两大能力：输入文本和触发命令，这一点是不变的。 语音交互今天仍然还很不成熟，究其原因，语音交互在 IoT 领域还停留在触发命令为主，且哪怕是触发命令这一件事情，也还有重重关卡需要去突破。 在手机软件中，语音输入文本在部分软件中已经有较多应用，但是主要优势还在日常用语和长文本，在个性化场景如“输入人名之类”，较难达到好的结果。 从更本源的角度看，语音交互今天仍然在相对封闭的应用技术场景里面发展为主，而作为操作系统的主体交互手段，其能力必须是开放的。因为操作系统是开放的，场景是开放的。 摄像头摄像头作为交互设备，除了引入语音，也引入了手势、表情。从表达能力来说，这是最为丰富也是最为自然的一种表达方法。但是技术所限，这种交互方式还只在萌芽阶段。微软的 Kinect 是一个非常经典的案例，它能够让玩家通过语音和手势发指令来玩游戏。 输出设备输出设备主要负责向用户反馈信息。比如：显示器（显卡）、音箱（声卡）、打印机。输出设备的演化并不大，最主要的输出设备还是以显示器为主。 显示器显示器虽然经历了 CRT 到液晶屏多代更新，但也只是支持的色彩更多（从黑白到彩色到真彩色），分辨率越来越高。实际上，从操作系统的软件治理角度来看，显示器并没有发生过实质性的变化。 为了让不同软件可以在同一显示器屏幕上呈现，操作系统引入了窗口系统的概念。每个软件有一个或多个窗口（Window，有时候也叫视图，即View）。在 PC 操作系统中，不同窗口还可以层叠（Cascade）或平铺（Tile）。 通过引入窗口，操作系统在逻辑上把显示器屏幕这个有限的设备资源，分配给了多个软件。和 PC 不同的是，移动设备由于屏幕过小，所以操作系统选择了让软件的顶层窗口全屏占据整个屏幕。这让显示器屏幕的管理变得更为简单。 除了窗口系统，显示设备管理的另一大挑战是绘制子系统。窗口里面的内容是什么，呈现成什么样子，完全是软件来决定的，这就意味着软件需要绘制能力。 绘制能力牵涉面非常之广，在操作系统里面，往往有一个独立的子系统（通常叫GDI）与之对应。这里我们简单罗列一下GDI子系统会涉及哪些东西。 2D图形相关。包含 Path(路径)、Brush(画刷)、Pen(画笔) 等概念。 3D图形相关。包含 Model(模型)、Material(材质)、Lighting(光照) 等概念。 文本相关。包含 Font(字体) 等概念。而字体又分点阵字体和 TrueType 字体。TrueType 字体的优势是可以自由缩放。今天我们见到的大部分字体都是 TrueType 字体。 图像处理相关。包含 Bitmap(位图) 对象及常见图像格式的编解码器(Encoder/Decoder)。 窗口系统结合输入设备对应的事件管理系统、绘制(GDI)系统，我们就可以随心所欲地实现各类用户体验非常友好的视窗软件了。 但是，为了进一步简化开发过程，操作系统往往还提供了一些通用的界面元素，通常我们称之为控件(Control)。常见的控件有如下这些： 静态文本 (Label)； 按钮 (Button)； 单选框 (RadioBox)； 复选框 (CheckBox)； 输入框 (Input，也叫EditBox/EditText)； 进度条 (ProgressBar)； 等等。 不同操作系统提供的基础控件大同小异。不过一些处理细节上的差异往往会成为跨平台开发的坑，如果你希望一份代码多平台使用，在这方面就需要谨慎处理。 音箱相比显示器的管理，音箱的设备管理要简单得多。我们很容易做到多个软件同时操作设备，而有合理的结果。 例如，调整音量我们遵循覆盖原则即可，谁后设置音量就听谁的。而声音的播放则可进行混音处理，多个软件播放的声音同时播放出来，让人听起来像是同时有多个人在说话。 当然，特定情况下要允许某个软件禁止其他软件播放出来的声音，比如接听电话的软件，需要在电话接通的时候屏蔽掉所有其他软件播放的声音。 打印机打印机的管理方式又很不一样，软件使用打印机的过程基本上是互斥的。一个软件在打印文档的时候，其他的软件只能等待它打印完毕后，才能进行打印。 打印机的使用是以文档为互斥的单位。为了避免软件之间出现长时间的相互等待，操作系统往往在打印机的管理程序中引入很大的打印缓冲。 软件操作打印机的时候，并不是等待打印机真把内容打印出来，而是把文档打印到打印缓冲中就完成打印。这样，在大部分情况下多个软件不需要因为使用打印机而出现相互等待。 结语后面我们在谈“桌面开发”一章中，还会涉及人机交互的更多细节，这一章侧重点在于领域无关的通用操作系统相关的问题域，相关的内容这里仅做概要性的阐述。 但是，仅通过简单对比所有输入和输出设备的管理方式，我们就可以看出，不同输入和输出设备的管理方法差异非常大，没有太大的共性可言。 尽管对 CPU 而言，所有外部设备有着相同的抽象，但这些设备的业务逻辑却如此不同，并不能统一抽象它们。正是因为有了操作系统这样的基础软件，这些设备业务逻辑的复杂性才从我们的软件开发过程中解放出来。 人机交互演化的核心变化是输入设备的变化。我们看到，输入手段的变化是非常剧烈的，且每一次演变都是颠覆性的变化。 事实上输入意图的理解越来越难了，因为交互在朝着自然（Nature）和智能（Intelligence）的方向发展。我们不可能让每一个软件都自己去做输入意图的理解（今天的现状是每个软件自己做），在未来，必然将由操作系统来实现智能交互的基础架构。 今天的内容就到这里。你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/10 | 输入和输出设备：交互的演进/"},{"title":"12 | 进程内协同：同步、互斥与通讯","text":"你好，我是七牛云许式伟。 上一讲开始我们进入了多任务的世界，我们详细介绍了三类执行体：进程、线程和协程，并且介绍了每一种执行体的特点。 既然启动了多个执行体，它们就需要相互协同，今天我们先讨论进程内的执行体协同。 考虑到进程内的执行体有两类：用户态的协程（以 Go 语言的 goroutine 为代表）、操作系统的线程，我们对这两类执行体的协同机制做个概要。如下： 让我们逐一详细分析一下它们。 原子操作首先让我们看一下原子操作。需要注意的是，原子操作是 CPU 提供的能力，与操作系统无关。这里列上只是为了让你能够看到进程内通讯的全貌。 顾名思义，原子操作的每一个操作都是原子的，不会中途被人打断，这个原子性是 CPU 保证的，与执行体的种类无关，无论 goroutine 还是操作系统线程都适用。 从语义上来说，原子操作可以用互斥体来实现，只不过原子操作要快得多。 例如： var val int32 ... newval = atomic.AddInt32(&amp;val, delta)等价于： var val int32 var mutex sync.Mutex ... mutex.Lock() val += delta newval = val mutex.Unlock()执行体的互斥互斥体也叫锁。锁用于多个执行体之间的互斥访问，避免多个执行体同时操作一组数据产生竞争。其使用界面上大概是这样的： func (m *Mutex) Lock() func (m *Mutex) Unlock()锁的使用范式比较简单：在操作需要互斥的数据前，先调用 Lock，操作完成后就调用 Unlock。但总是存在一些不求甚解的人，对锁存在各种误解。 有的人会说锁很慢。甚至我曾看到有 Go 程序员用 channel 来模拟锁，理由就是锁太慢了，尽量不要用锁。产生“锁慢，channel 快”这种错觉的一个原因，可能是人们经常看到这样的忠告： 不要通过共享内存（锁）来通信，要通过通信（channel）来共享内存。 不明就里的人们看到这话后，可能就有了这样的印象：锁是坏的，锁是性能杀手，channel 是好的，是 Go 发明的先进武器，应该尽可能用 channel，而不要用锁。 快慢是相对而言的。锁的确会导致代码串行执行，所以在某段代码并发度非常高的情况下，串行执行的确会导致性能的显著降低。但平心而论，相比其他的进程内通讯的原语来说，锁并不慢。从进程内通讯来说，比锁快的东西，只有原子操作。 例如 channel，作为进程内执行体间传递数据的设施来说，它本身是共享变量，所以 channel 的每个操作必然是有锁的。事实上，channel 的每个操作都比较耗时。关于这一点，在下文解释 channel 背后的工作机理后，你就会清楚知道。 那么锁的问题在哪里？锁的最大问题在于不容易控制。锁 Lock 了但是忘记 Unlock 后是灾难性的，因为相当于服务器挂了，所有和该锁相关的代码都不能被执行。 比如： mutex.Lock() doSth() mutex.Unlock()在考虑异常的情况下，这段代码是不安全的，如果 doSth 抛出了异常，那么服务器就会出现问题。 为此 Go 语言还专门发明了一个 defer 语法来保证配对： mutex.Lock() defer mutex.Unlock() doSth()这样可以保证即使 doSth 发生异常，mutex.Unlock 仍然会被正确地执行。这类在异常情况下也能够正常工作的代码，我们称之为 “对异常安全的代码”。如果语言不支持 defer，而是支持 try … catch，那么代码可能是这样的： mutex.Lock() try { doSth() } catch (e Exception) { mutex.Unlock() throw e } mutex.Unlock()锁不容易控制的另一个表现是锁粒度的问题。例如上面 doSth 函数里面如果调用了网络 IO 请求，而网络 IO 请求在少数特殊情况下可能会出现慢请求，要好几秒才返回。那么这几秒对服务器来说就好像挂了，无法处理请求。 对服务器来说这是极为致命的。对后端程序员来说，有一句箴言要牢记： 不要在锁里面执行费时操作。 这里 “锁里面” 是指在mutex.Lock和mutex.Unlock之间的代码。 在锁的最佳编程实践中，如果明确一组数据的并发访问符合 “绝大部分情况下是读操作，少量情况有写操作” ，这种 “读多写少” 特征，那么应该用读写锁。 所谓读写锁，是把锁里面的操作分为读操作和写操作两种，对应调用不同的互斥操作。 如果是读操作，代码如下： mutex.RLock() defer mutex.RUnlock() doReadOnlyThings如果是锁里面是写操作，代码就和普通锁一样，如下： mutex.Lock() defer mutex.Unlock() doWriteThings为什么在 “读多写少” 的情况下，这样的使用范式能够优化性能？ 因为从需求上来说，如果当前我们正在执行某个读操作，那么再来一个新的读操作，是不应该挡在外面的，大家都不修改数据，可以安全地并发执行。但如果来的是写操作，就应该挡在外面，等待读操作执行完。整体来说，读写锁的特性就是： 读操作不阻止读操作，阻止写操作；写操作阻止一切，不管读操作还是写操作。 执行体的同步聊完了执行体的互斥，我们再来看下执行体之间的同步。 同步的一个最常见的场景是：把一个大任务分解为n个小任务，分配给n个执行体并行去做，等待它们一起做完。这种同步机制我们叫 “等待组”。 其使用界面上大概是这样的： func (wg *WaitGroup) Add(n int) func (wg *WaitGroup) Done() func (wg *WaitGroup) Wait()用法上大概是这样的： var wg WaitGroup ... wg.Add(n) for 循环n次 { go func() { defer wg.Done() doTaski // 执行第i个任务 }() } wg.Wait()简而言之，在每个任务开始的时候调用 wg.Add(1)，结束的时候调用 wg.Done()，然后在主执行体调用 wg.Wait() 等待这些任务结束。 需要注意的是，wg.Add(1) 是要在任务的 goroutine 还没有开始就先调用，否则可能出现某个任务还没有开始执行就被认为结束了。 条件变量（Condition Variable）是一个更通用的同步原语，设计精巧又极为强大。强大到什么程度？像 channel 这样的通讯机制都可以用它来实现。 条件变量的使用界面上大概是这样的： func NewCond(l Locker) *Cond func (c *Cond) Broadcast() func (c *Cond) Signal() func (c *Cond) Wait()那么，怎么用条件变量？ 我们先看下初始化。条件变量初始化的时候需要传入一个互斥体，它可以是普通锁（Mutex)，也可以是读写锁（RWMutex）。如下： var mutex sync.Mutex // 也可以是 sync.RWMutex var cond = sync.NewCond(&amp;mutex) ...为什么创建条件变量需要传入锁？因为 cond.Wait() 的需要。Wait 内部实现逻辑是： 把自己加入到挂起队列 mutex.Unlock() 等待被唤醒 // 挂起的执行体会被后续的 cond.Broadcast 或 cond.Signal() 唤醒 mutex.Lock()初始化了条件变量后，我们再来看看它的使用方式。条件变量的用法有一个标准化的模板，看起来大概是这样的： mutex.Lock() defer mutex.Unlock() for conditionNotMetToDo { cond.Wait() } doSomething if conditionNeedNotify { cond.Broadcast() // 有时可以优化为 cond.Signal() }看起来有些复杂，让我们来解释一下。加锁后，先用一个 for 循环判断当前是否能够做我们想做的事情，如果做不了就调用 cond.Wait() 进行等待。 这里很重要的一个细节是注意用的是 for 循环，而不是 if 语句。这是因为 cond.Wait() 得到了执行权后不代表我们想做的事情就一定能够干了，所以要再重新判断一次条件是否满足。 确定能够做事情了，于是 doSomething。在做的过程中间，如果我们判断可能挂起队列中的部分执行体满足了重新执行的条件，就用 cond.Broadcast 或 cond.Signal 唤醒它们。 cond.Broadcast 比较粗暴，它唤醒了所有在这个条件变量挂起的执行体，而 cond.Signal 则只唤醒其中的一个。 什么情况下应该用 cond.Broadcast，什么情况下应该用 cond.Signal？最偷懒的方式当然是不管三七二十一，用 cond.Broadcast 一定没问题。但是本着经济的角度，我们还是要交代清楚 cond.Signal 的适用范围： 挂起在这个条件变量上的执行体，它们等待的条件是一致的； 本次 doSomething 操作完成后，所释放的资源只够一个执行体来做事情。 Cond 原语虽然叫条件变量，但是实际上它既没有明白说变量具体是什么样的，也没有说条件具体是什么样的。变量是指 “一组要在多个执行体之间协同的数据”。条件是指做任务前 Wait 的 “前置条件”，和做任务时需要唤醒其它人的 “唤醒条件”。 这样的介绍相当的抽象。我们拿 Go 语言的 channel 开刀，自己实现一个。代码如下： type Channel struct { mutex sync.Mutex cond *sync.Cond queue *Queue n int } func NewChannel(n int) *Channel { if n &lt; 1 { panic(&quot;todo: support unbuffered channel&quot;) } c := new(Channel) c.cond = sync.NewCond(&amp;c.mutex) c.queue = NewQueue() // 这里 NewQueue 得到一个普通的队列 // 代码从略 c.n = n return c } func (c *Channel) Push(v interface{}) { c.mutex.Lock() defer c.mutex.Unlock() for c.queue.Len() == c.n { // 等待队列不满 c.cond.Wait() } if c.queue.Len() == 0 { // 原来队列是空的，可能有人等待数据，通知它们 c.cond.Broadcast() } c.queue.Push(v) } func (c *Channel) Pop() (v interface{}) { c.mutex.Lock() defer c.mutex.Unlock() for c.queue.Len() == 0 { // 等待队列不空 c.cond.Wait() } if c.queue.Len() == c.n { // 原来队列是满的，可能有人等着写数据，通知它们 c.cond.Broadcast() } return c.queue.Pop() } func (c *Channel) TryPop() (v interface{}, ok bool) { c.mutex.Lock() defer c.mutex.Unlock() if c.queue.Len() == 0 { // 如果队列为空，直接返回 return } if c.queue.Len() == c.n { // 原来队列是满的，可能有人等着写数据，通知它们 c.cond.Broadcast() } return c.queue.Pop(), true } func (c *Channel) TryPush(v interface{}) (ok bool) { c.mutex.Lock() defer c.mutex.Unlock() if c.queue.Len() == c.n { // 如果队列满，直接返回 return } if c.queue.Len() == 0 { // 原来队列是空的，可能有人等待数据，通知它们 c.cond.Broadcast() } c.queue.Push(v) return true }对着这个 Channel 的实现，你是否对条件变量有感觉很多？顺便提醒一点，这个 Channel 的实现不支持无缓冲 channel，也就是不支持 NewChannel(0) 的情况。如果你感兴趣，可以改改这个问题。 执行体的通讯聊完同步与互斥，我们接着聊执行体的通讯：怎么在执行体间收发消息。 管道是大家都很熟知的执行体间的通讯机制。规格如下： func Pipe() (pr *PipeReader, pw PipeWriter)用法上，先调用pr, pw := io.Pipe()得到管道的写入端和读出端，分别传给两个并行执行的 goroutine（其他语言也类似），然后一个 goroutine 读，一个 goroutine 写就好了。 管道用处很多。一个比较常见的用法是做读写转换，例如，假设我手头有一个算法： func Foo(w io.Writer) error这个算法生成的数据流，需要作为另一个函数的输入，但是这个函数的输入是 io.Reader，原型如下： func Bar(r io.Reader)那么怎么把它们串起来呢？用管道我们很容易实现这样的变换： func FooReader() io.ReadCloser { pr, pw := io.Pipe() go func() { err := Foo(pw) pw.CloseWithError(err) }() return pr }这个 FooReader 函数几句话就把 Foo 变成了一个符合 io.Reader 接口的对象，它就可以很方便的和 Bar 函数结合了。 其实 Go 语言中引入的 channel 也是管道，只不过它是类型安全的管道。具体用法如下： c := make(chan Type, n) // 创建一个能够传递 Type 类型数据的管道，缓冲大小为 n ... go func() { val := &lt;-c // 从管道读入 }() ... go func() { c &lt;- val // 向管道写入 }()我们后面在 “服务端开发” 一章，我们还会比较详细讨论 channel，今天先了解一个大体的语义。 结语总结一下，我们今天主要聊了执行体间的协同机制：原子操作、同步、互斥与通讯。我们重点聊了锁和同步原语 “条件变量”。 锁在一些人心中是有误解的，但实际上锁在服务端编程中的比重并不低，我们可能经常需要和它打交道，建议多花精力理解它们。 条件变量是最复杂的同步原语，功能强大。虽然平常我们直接使用条件变量的机会不是太多，大部分常见的场景往往有更高阶的原语（例如 channel）可以取代。但是它的设计精巧而高效，值得细细体会。 你会发现，操作系统课本上的信号量这样的同步原语，我们这里没有交代，这是因为它被更强大而且性能更好的同步原语 “条件变量” 所取代了。 上面我们为了介绍条件变量的用法，我们实作了一个 channel，你也可以考虑用信号量这样的东西来实现一遍，然后分析一下为什么我们说基于 “条件变量” 的版本是更优的。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。在下期，我们将讨论进程与进程之间的协同：进程间的同步互斥、资源共享与通讯。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/12 | 进程内协同：同步、互斥与通讯/"},{"title":"13 | 进程间的同步互斥、资源共享与通讯","text":"你好，我是七牛云许式伟。 在上一讲，我们介绍了进程内执行体之间的协同机制。今天我们接着聊进程与进程之间的协同。 这些协同机制大体可分为：互斥、同步、资源共享以及通讯等原语。对于这些协同机制，我们对比了 Linux、Windows、iOS 这三大操作系统的支持情况，整理内容如下： 在逐一详细分析它们之前，我们先讨论一个问题：从需求角度来讲，进程内协同与进程间协同有何不同？ 在早期，操作系统还只有进程这个唯一的执行体。而今天，进程内的执行体（线程与协程）被发明出来并蓬勃发展，事情发生了怎样的变化？ 请先思考一下这个问题。我们在这一讲最后总结的时候一起聊聊。 启动进程在讨论进程间的协同前，我们先看下怎么在一个进程中启动另一个进程。这通常有两种方法： 创建子进程； 让Shell配合执行某个动作。 前面在 “11 | 多任务：进程、线程与协程” 一讲中我们已经提到过，创建子进程 UNIX 系的操作系统都用了 fork API，它使用上很简洁，但是从架构角度来说是一个糟糕的设计。Windows 中我们用 CreateProcess，这个函数有很多的参数。 iOS 很有意思，它并不支持创建子进程。在进程启动这件事情上，它做了两个很重要的变化： 软件不再创建多个进程实例，永远是单例的； 一个进程要调用另一个进程的能力，不是去创建它，而是基于 URL Scheme 去打开它。 什么是 URL Scheme ？我们平常看到一个 URL 地址。比如： https://www.qiniu.com/ ftp://example.com/hello.doc 这里面的 https 和 ftp 就是 URL Scheme，它代表了某种协议规范。在 iOS 下，一个软件可以声明自己实现了某种 URL Scheme，比如微信可能注册了“weixin”这个 URL Scheme，那么调用 UIApplication.openURL(&quot;weixin://...&quot;) 都会跳转到微信。通过这个机制，我们实现了支付宝和微信支付能力的对接。 URL Scheme 机制并不是 iOS 的发明，它应该是浏览器出现后形成的一种扩展机制。Windows 和 Linux 的桌面也支持类似的能力，在 Windows 下调用的是 ShellExecute 函数。 同步与互斥聊完进程的启动，我们正式开始谈进程间的协同。 首先我们来看一下同步和互斥体。从上一讲 “12 | 进程内协同：同步、互斥与通讯”看，同步互斥相关的内容有： 锁（Mutex）； 读写锁（RWMutex）； 信号量（Semaphore）； 等待组（WaitGroup）； 条件变量（Cond）。 进程间协同来说，主流操作系统支持了锁（Mutex）和信号量（Semaphore）。Windows 还额外支持了事件（Event）同步原语，这里我们略过不提。 进程间的锁（Mutex），语义上和进程内没有什么区别，只不过标识互斥资源的方法不同。Windows 最简单，用名称（Name）标识资源，iOS 用路径（Path），Linux 则用共享内存。 从使用接口看，Windows 和 iOS 更为合理，虽然大家背后实现上可能都是基于共享内存（对用户进程来说，操作系统内核对象都是共享的），但是没必要把实现机理暴露给用户。 我们再看信号量。 信号量（Semaphore）概念是 Dijkstra（学过数据结构可能会立刻回忆起图的最短路径算法，对的，就是他发明的）提出来的。信号量本身是一个整型数值，代表着某种共享资源的数量（简记为 S）。信号量的操作界面为 PV 操作。 P 操作意味着请求或等待资源。执行 P 操作 P(S) 时，S 的值减 1，如果 S &lt; 0，说明没有资源可用，等待其他执行体释放资源。 V 操作意味着释放资源并唤醒执行体。执行 V 操作 V(S) 时，S 的值加 1，如果 S &lt;= 0，则意味着有其他执行体在等待中，唤醒其中的一个。 看到这里，你可能敏锐地意识到，条件变量的设计灵感实际上是从信号量的 PV 操作进一步抽象而来，只不过信号量中的变量是确定的，条件也是确定的。 进程间的同步与互斥原语并没有进程内那么丰富（比如没有 WaitGroup，也没有 Cond），甚至没那么牢靠。 为什么？因为进程可能会异常挂掉，这会导致同步和互斥的状态发生异常。比如，进程获得了锁，但是在做任务的时候异常挂掉，这会导致锁没有得到正常的释放，那么另一个等待该锁的进程可能就会永远饥饿。 信号量同样有类似的问题，甚至更麻烦。对锁来说，进程挂掉还可能可以把释放锁的责任交给操作系统内核。但是信号量做不到这一点，操作系统并不清楚信号量的值（S）应该是多少才是合理的。 资源共享两个进程再怎么被隔离，只要有共同的中间人，就可以相互对话（通讯）。中间人可以是谁？共享资源。进程之间都有哪些共享的存储型资源？比较典型的是： 文件系统； 剪贴板。 文件系统本身是因存储设备的管理而来。但因为存储设备本身天然是共享资源，某个进程在存储设备上创建一个文件或目录，其他进程自然可以访问到。 因此，文件系统天然是一个进程间通讯的中间人。而且，在很多操作系统里面，文件的概念被抽象化，“一切皆文件”。比如，命名管道就只是一种特殊的 “文件” 而已。 和文件系统相关的进程间协同机制有： 文件； 文件锁； 管道（包括匿名管道和命名管道）； 共享内存。 这里我们重点介绍一下共享内存。 共享内存其实是虚拟内存机制的自然结果。关于虚拟内存的详细介绍，可以参阅 “07 | 软件运行机制及内存管理” 一讲。虚拟内存本来就需要在内存页与磁盘文件之间进行数据的保存与恢复。 将虚拟内存的内存页和磁盘文件的内容建立映射关系，在虚拟内存管理机制中原本就存在。 只需要让两个进程的内存页关联到同一个文件句柄，即可完成进程间的数据共享。这可能是性能最高的进程间数据通讯手段了。 Linux 的共享内存的使用界面大体是这样的： func Map(addr unsafe.Pointer, len int64, prot, flags int, fd int, off int64) unsafe.Pointer func Unmap(addr unsafe.Pointer, len int64)其中，Map 是将文件 fd 中的[off, off+len)区间的数据，映射到[addr, addr+len) 这段虚拟内存地址上去。 addr 可以传入 nil 表示选择一段空闲的虚拟内存地址空间来进行映射。Unmap 则是将[addr, addr+len)这段虚拟内存地址对应的内存页取消映射，此后如果代码中还对这段内存地址进行访问，就会发生缺页异常。 在 Windows 下共享内存的使用界面和 Linux 略有不同，但语义上大同小异，这里略过不提。 真正值得注意的是 iOS，你会发现基于文件系统的进程间通讯机制，一律不支持。为什么？因为 iOS 操作系统做了一个极大的改变：软件被装到了一个沙箱（Sandbox）里面，不同进程间的存储完全隔离。 存储分为内存和外存。内存通过虚拟内存机制实现跨进程的隔离，这个之前我们已经谈到过。现在 iOS 更进一步，外存的文件系统也相互独立。软件 A 创建的文件，软件 B 默认情况下并不能访问。在一个个软件进程看来，自己在独享着整个外存的文件系统。 文件系统之外，进程间共享的存储型资源，就剩下剪贴板了。 但剪贴板并不是一个常规的进程间通讯方式。从进程间通讯角度来说它有很大的限制：剪贴板只有一个，有人共享数据上去，就会把别人存放的数据覆盖掉。 实践中，剪贴板通常作为一种用户实现跨进程交互的手段，而不太会被用来作为进程间的通讯。相反它更可能被恶意程序所利用。比如，写个木马程序来监听剪贴板，以此来窃取其他程序使用过程中留下的痕迹。 收发消息那么，不用文件系统和剪贴板这样的共享资源，还有其他的通讯机制么？ 有，基于网络。很重要的一个事实是：这些进程同在一台机器上，同在一个局域网中。 套接字作为网络通讯的抽象，本身就是最强大的通讯方式，没有之一。进程间基于套接字来进行通讯，也是极其自然的一个选择。 况且，UNIX 还发明了一个专门用于本地通讯的套接字：UNIX 域。UNIX 域不同于常规套接字的是，它通过一个 name 来作为访问地址，而不是用ip:port来作为访问地址。 Windows 平台并不支持 UNIX 域。但是有趣的是，Windows 的命名管道（NamedPipe）也不是一个常规意义上的管道那么简单，它更像是一个管道服务器（PipeServer），一个客户端连上来可以分配一个独立的管道给服务器和客户端进行通讯。从这个事实看，Windows 的命名管道和 UNIX 域在能力上是等价的。 关于套接字更详细的内容，后文在讨论网络设备管理时我们会进一步介绍。 架构思维上我们学习到什么？对比不同操作系统的进程间协同机制，差异无疑是非常巨大的。 总结来说，进程间协同的机制真的很多了，五花八门，我们这里不见得就列全了。但是有趣的是，iOS 把其中绝大部分的协同机制给堵死了。 创新性的系统往往有其颠覆性，带着批判吸收的精神而来，做的是大大的减法。 iOS 就是这样的一个操作系统。它告诉我们： 软件不需要启动多份实例。一个软件只需启动一个进程实例。 大部分进程间的协同机制都是多余的。你只需要能够调用其他软件的能力（URL Scheme）、能够互斥、能够收发消息就够了。 这的确是一个让人五体投地的决策。虽然从进程间协同机制的角度，看起来 iOS 少了很多能力。但这恰恰也给了我们一个启示：这么多的进程通讯机制，是否都是必需的？ 至少从桌面操作系统的视角看，进程间协同的机制，大部分都属于过度设计。当然，后面在 “服务端开发” 一章中，我们也会继续站在服务端开发视角来谈论这个话题。 并不是早期操作系统的设计者们喜欢过度设计。实际上这是因为有了线程和协程这样的进程内多任务设施之后，进程的边界已经发生了极大的变化。 前面我们讨论架构思维的时候说过，架构的第一步是做需求分析。那么需求分析之后呢？是概要设计。概要设计做什么？是做子系统的划分。它包括这样一些内容： 子系统职责范围的定义； 子系统的规格（接口），子系统与子系统之间的边界； 需求分解与组合的过程，系统如何满足需求、需求适用性（变化点）的应对策略。 从架构角度来看，进程至少应该是子系统级别的边界。子系统和子系统应该尽可能是规格级别的协同，而不是某种实现框架级别的协同。规格强调的是自然体现需求，所以规格是稳定的，是子系统的契约。而实现框架是技巧，是不稳定的，也许下次重构的时候实现框架就改变了。 所以站在架构视角，站在子系统的边界看进程边界，我们就很清楚，进程间协同只需要有另一个进程能力的调用，而无需有复杂的高频协作、高度耦合的配合需求。 不过，为什么 iOS 会如此大刀阔斧地做出改变，除了这些机制的确多余之外，还有一个极其核心的原因，那就是安全。关于这一点，我们在后面探讨操作系统的安全管理时，会进一步进行分析。 结语今天我们从进程启动开始入手，介绍了同步与互斥、资源共享、收发消息等进程间的协同机制。通过对比不同操作系统，我们会发现以 “剧烈变动” 来形容进程间协同的需求演进一点也不过分。 我认为 iOS 是对的。大刀阔斧干掉很多惯例要支持的功能后，进程这个执行体，相比线程和协程就有了更为清晰的分工。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。到这一讲为止，我们单机软件相关的内容就介绍完了。从下一讲开始我们将进入多姿多彩的互联网世界。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/13 | 进程间的同步互斥、资源共享与通讯/"},{"title":"14 | IP 网络：连接世界的桥梁","text":"你好，我是七牛云许式伟。 到目前为止，我们介绍了操作系统的六大子系统中的四项：进程、存储、输入、输出。当你理解了这些东西背后的道理，基本上做一款单机软件就游刃有余了。 但是，如果仅仅局限于单机，一台计算机并不见得比计算器高明太多。网络对整个信息科技的重要性不言而喻。它让计算机连接在了一起，这一连接就发生了巨大的变化。 没有了网络，我们只能用用 Office 软件，玩玩扫雷。没有网络，就没有 QQ 和微信，不会有淘宝和支付宝，也不会有 BAT。 网络连接一切。它连接了人（个人和企业）、服务（由软件系统构建的服务接口）和物（大自然产物和智能终端），构建了多姿多彩的互联网。 它让地球上的任何两个人都可以随时随地进行沟通，远程做生意。在互联网出现之前，旧的商业文明我们可以一言以蔽之：一手交钱，一手交货。而建立在互联网之上的新商业文明，我们一手下单付款，一手收钱发货，足不出户，货物就通过便捷的物流服务送到了你手上。 这是多么巨大的效率变革，但这一切是怎么做到的呢？ 数据的封包过程网络和其他所有的输入输出设备一样，只能交换数据。无论你要对方做什么，你首先需要发送对方理解得了的数据给它。所以双方要就沟通的语言达成共识，这就是网络协议。 网络协议是计算机与计算机远程沟通的数据格式。它包含很多信息。这些信息不同部分的内容，有不同的职责，关心它的人也各有不同。 网络是传递数据的，是数字内容的物流。作为类比，我们可以看看实物快递的物流协议是什么样的。下面这张快递面单大家应该都很熟悉： 这个快递面单包含很多内容，其中最重要的当然是寄件人信息和收件人信息。有了收件人信息，物流系统才能够知道怎么把要邮寄的物品进行一站站中转，并最终到达目的地。 有了寄件人信息，收件人收到信息才知道是谁寄过来的，如果回复的话应该邮寄往何方。而在物流过程如果出错的话，物流系统也知道如何与寄件人沟通协调错误的处置方法。 寄件人关心什么？他很可能关心物流订单号。这是他掌握物流状态的唯一凭据。另外，为了传输过程的便捷，物流系统可能还会给我们要邮寄的物品用信封袋或者包装箱进行封装。 所有这些寄件人信息、收件人信息、物流订单号、信封袋、包装箱，都不是寄件人要邮寄的内容，而是物流系统对物流协议所产生的需求。 为了支持整个物流系统的不间断运转，我们会有很多不同的部门。有负责最后一公里的快递员，也有负责骨干线路的航空运输部门，或者火车货运部门等等。 同样的，数字物流系统也有很多不同的部门，有的部门负责局域网（LAN）内最后一公里的，也有人负责广域网（WAN）骨干线路的运输的。网络协议作为数字物流的载体，会收到来自这些不同部门的需求。 我们平常可能经常听人提及，网络协议有 OSI 模型，它把网络协议分成了七层结构，从上到下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。但这样描述有点过于抽象，我们不妨用下图来理解网络协议的分层结构。 让我们设想：我们要传输一部电影，它就是我们的 “物品”，或者用技术术语叫 “应用层数据”，怎么传？ 第一步，分批次。数字物流系统单次能够传递的数据大小是有限的。如果数据太大，就必须分开多次来传输。从物理网络视角看，数据是并不是流（stream），而是一个个大小有明确限制的数据包。 第二步，套上信封，写好寄件单位的部门（源端口号）、收件单位的部门（目标端口号）、批次编号。为什么要写部门（端口号）？方便知道由谁（哪个应用程序软件）来负责收件。为什么要写批次编号？是为了防止寄丢了，寄丢了就得重新传一份该批次编号的东西。 这层我们叫传输层。它主要是为了解决传输可靠性的问题。当然传输层有两套协议（两种信封），一套是 TCP 协议，另一套是 UDP 协议。UDP 协议不保证对方一定收到，信封上就没写批次编号。 第三步，再套上一层信封，上面写上寄件单位地址（源 IP 地址）、收件单位地址（目标 IP 地址）。有了地址，这封信在广域网（WAN）上流转，就知道自己应该去往何方了。这一层叫做网络层，它定义的信封格式，叫 IP 协议。 互联网的复杂性是在于，它不是一家数字物流公司的事。信寄到某处，可能就换一家物流公司了。它是所有的数字物流公司通力协作的结果。 所以 IP 协议最核心的意义是标准化，解决跨物流公司传输的问题。为什么我们要这样一层信封套一层信封？因为越往外层的信封，内容越和具体的物流公司相关。但无论你外层套的信封如何各有不同，拆到这一层，信的格式就是标准化的。 第四步，再套上一层信封，这层我们叫它数据链路层。具体信封上写什么，完全是具体负责这段路程的物流公司说了算。当信件从一个物流公司转到另一个物流公司做交接的时候，这一层信封拆掉，重新换上新的信封。 数据链路层的信封格式（网络协议）非常多样化。局域网（LAN）现在最流行的是以太网（Ethernet）协议，广域网（WAN）现在常见的有 HDLC、PPP、Frame-Relay 等网络协议。 无论如何，写完了特定物流公司所需要的信息，信件就可以进入数字物流系统（物理层）去流转了。 网络协议上面那一层套一层的信件（网络协议）放的是用户要邮寄的东西，比如一部电影。但为了支持整个邮寄过程的顺利进行，获得更好的用户体验，还会有一些辅助用途的信件（网络协议）在网络上传递，有的是面向用户的，有的是面向数字网络系统内部的。 完整来说，在整个数字物流系统中，与数据传输这件事本身有关的网络协议，我们整理如下： 在这个图中，链路层协议最为复杂，MAC+LLC、PPP、HDLC、Frame-Replay，这些是目前最为常见的。未来也必然会出来很多新的网络通讯技术，用的是全新的协议。链路层之上，IP -&gt; TCP/UDP，这些协议我们最为耳熟能详，上面我们也已经介绍过了。 其他都还有些什么？除了 ICMP 和 IGMP 协议，这些协议都和网络地址的解析有关。所以，在谈协议用途前，我们先聊一聊网络地址。 要通讯，首先要有地址。数字物流世界的地址有三层。最底下的是链路层地址。不同链路层协议的地址表示非常不同。 比如，局域网所采纳的以太网（Ethernet）协议用的是 MAC 地址。一台计算机有一个或多个网卡，每个网卡会有自己的唯一标识即 MAC 地址。这个标识跟随网卡设备存在，和网络环境无关。你把计算机从北京搬到上海，MAC 地址保持不变。 链路层的网络地址我们平常接触并不多，常规我们理解的网络地址是位于第二层的 IP 地址。 IP 地址类似于门牌号：你家住在哪个城市哪条路几号。它决定了网络路由怎么走，信息如何到达你的计算机网卡。IP 地址已经发展了两代，分别为 IPv4 和 IPv6。升级的原因是 IPv4 地址空间太小，只有 4G（即40多亿）个地址。 就像我们通常会更喜欢用 “我要去金茂大厦” 而不是 “我要去上海市浦东新区世纪大道88号” 一样，IP地址并不容易记忆，所以就有了第三层的网络地址：域名。 比如，我们会用 www.qiniu.com 这个地址来找到七牛云的官网，而不是记住枯燥的 IP 地址。 理解了这三类网络地址，我们一一介绍下这些协议的用途。 首先是 DNS 协议。这个协议就像是个地址簿，主要负责 “域名” =&gt; “IP地址” 的查询。每次我们要邮寄信件之前都要拿出来查一查。 其次是 DHCP 协议。DHCP 全称叫动态主机配置协议（Dynamic Host Configuration Protocol），主要负责计算机接入网络时的初始化。计算机刚开始就只有网卡的 MAC 地址，通过 DHCP 可以给它分配 IP 地址，并得到默认网关地址（这很重要，不知道网关就上不了网）和 DNS 服务器的地址。有了这些东西，这台计算机就可以和外界通讯了。 然后是 ARP 协议。ARP 全称叫地址解析协议（Address Resolution Protocol），它服务于现在局域网中最流行的以太网协议。在以太网中，ARP 协议负责解析远程主机 IP 地址对应的 MAC 地址。之所以需要 ARP 协议，是因为我们平常应用程序连接目标计算机进行网络通讯时，都是提供了域名或 IP 地址。但对以太网来说，要想发信件出去，它要的是对方的 MAC 地址。 然后是 RARP 协议。RARP 全称叫反向地址转换协议（Reverse Address Resolution Protocol）。顾名思义，它和 ARP 协议相反，负责的是 MAC 地址到 IP 地址的转换。RARP 协议已经被上面的 DHCP 协议所取代，平常用不太到了。 然后是 ICMP 协议。ICMP 全称叫互联网控制报文协议（Internet Control Message Protocol），它能够检测网路的连线状况，以保证连线的有效性。基于这个协议实现的常见程序有两个：ping 和 traceroute，它们可以用来判断和定位网络问题。 最后是 IGMP 协议。IGMP 全称叫互联网组管理协议（Internet Group Management Protocol），它负责 IP 组播（Multicast）成员管理。本文略过这块的内容。 数据传输过程了解了数据包的结构，也了解了数据传输相关的网络协议，接下来我们聊一聊数据传输的过程。为了方便理解，我们画了一幅数据传输的示意图： 简化理解来说，我们可以认为，在需要传输数据的源主机和目标主机之间，它们通过若干路由器或交换机连接。我们分以下几种情况来分析： 情形一，源主机和目标主机在同一个局域网内，中间通过交换机连接，采用了最常见的以太网协议。 通讯开始的时候，源主机只有目标主机的 IP 地址，并没有 MAC 地址。但以太网通讯要的是 MAC 地址，所以源主机会发起一个 ARP 请求去获得目标 IP 对应的 MAC 地址。 当然，源主机会缓存这个对应关系。第二次继续给相同 IP 发信息的时候，就不需要重新发起 ARP 请求了。 无论是 ARP 请求，还是普通的数据包，都会先到达交换机。ARP 是一个广播请求，所以交换机会转发给所有其他主机，目标主机发现这个 IP 地址是自己的，于是返回自己的 MAC 地址。 有了目标主机的 MAC 地址，源主机就可以发数据了。同样的，所有数据包都发给了交换机。 交换机是性能极高的网络数据交换设备。它通常工作在网络协议的第二层，也就是数据链路层。这一层只认 MAC 地址，不认 IP 地址。MAC 地址本身是个唯一身份标识，就像我们的身份证号，并没有可寻址的作用。那么交换机怎么做到这么高的数据传输的效率？ 交换机在工作的过程中，会不断地收集资料去创建一个地址映射表：MAC 地址 =&gt; 交换机端口。这个表很简单，它记录了某个MAC 地址是在哪个端口上被发现的。 交换机收到一个数据包后，首先会进行学习，把源 MAC 地址和收到数据包的交换机端口对应起来。然后交换机查看数据包的目标 MAC 地址，并在地址映射表中找，如果找到对应的端口，那么就往这个端口转发数据包。 如果没找到，交换机可能会把这个数据包 “扩散” 出去，就好像收到广播数据包一样。这时如果目标主机收到广播过来的数据包后，回复了这个数据包，那么它的 MAC 地址和交换机端口的映射关系就也会被学习到。 当交换机初次加入网络时，由于地址映射表是空的，所以，所有的数据包将发往局域网内的全部端口，直到交换机 “学习” 到各个MAC 地址为止。这样看来，交换机刚刚启动时与传统的共享式集线器类似，直到地址映射表比较完整地建立起来后，它才真正发挥它的高性能。 我们总结一下，当一台交换机安装配置好之后，其工作过程如下。 收到某端口（设为A）MAC 地址为 X 的计算机发给 MAC 地址为 Y 的计算机的数据包。交换机从而记下了 MAC 地址 X 在端口 A。这称为学习（learning）。 交换机还不知道 MAC 地址 Y 在哪个端口上，于是向除了 A 以外的所有端口转发该数据包。这称为泛洪（flooding）。 MAC 地址 Y 的计算机收到该数据包，向 MAC 地址 X 发出确认包。交换机收到该包后，从而记录下 MAC 地址 Y 所在的端口。 交换机向 MAC 地址 X 转发确认包。这称为转发（forwarding）。 交换机收到一个数据包，查表后发现该数据包的来源地址与目的地址属于同一端口。交换机将不处理该数据包。这称为过滤（filtering）。 交换机内部的 “MAC 地址 =&gt; 端口” 查询表的每条记录采用时间戳记录最后一次访问的时间。早于某个阈值（用户可配置）的记录被清除。这称为老化（aging）。 情形二，源主机和目标主机都有公网 IP 地址，它们中间经过若干交换机和路由器相连。 路由器和交换机不太一样，交换机因为没有门牌号，通讯基本靠吼。好的一点是，圈子比较小，吼上一段时间后，路都记住了，闭着眼睛都不会走错。 但广域网太大了，靠吼没几个人听得见。所以路由器工作在网络协议的第三层，也就是网络层。网络层看到的是 IP 协议，能够知道数据传输的源 IP 地址和目标 IP 地址。 有了 IP 地址，就相当于有了门牌号，开启导航按图索骥就可以把东西带过去了。这也是路由器为什么叫路由器的原因，它有导航（路由）功能，知道哪些目标 IP 地址的数据包应该往哪条路走的。 路由器可以拥有一部分交换机的能力，比如，如果发现请求是局域网内的话，也可以引入类似交换机那样的基于 MAC 地址的映射表实现高速通讯。但总体来说，路由器要考虑的问题复杂很多，因为涉及 “最佳路由路径” 的问题。 简单说，所谓 “最佳路由路径” 是指，到达目标主机的路有很多种可能性，我应该选择哪一条。大家在大学可能都学过带权的有向图，路由器面临的正是这种情况。而且情况可能更复杂的是，每一小段路径的权重都是动态的，因为网络状况一直在变。 如果你对路由算法感兴趣，可以在维基百科查找 “路由” ，进一步研究。 路由器除了解决路由问题，它往往还要解决异构网络的封包转换问题。作为局域网的接入方，它可能走的是固网或 WiFi 网络。 作为 Internet 的接入方，它可能走的是光纤宽带。所以它需要把局域网的数据链路层的封包解开并重组，以适应广域网数据链路协议的需求。 理解了以上两点，我们回到话题：广域网的两台具备公网 IP 的主机之间如何完成数据传输？ 大体来说，整个过程如下。 首先，源主机发送的数据包，经由交换机（可选），到达本局域网的公网网关（路由器）。这个过程属于局域网内通讯，同情形一。 路由器收到了数据包，发现目标主机是 Internet 上的某个远端的目标主机，于是对数据包进行拆包重组，形成新的数据包。 循着自身的路由表，把这个新数据包层层转发，最后到达目标主机对应的公网网关（路由器）上。 路由器发现是发给本局域网内的目标主机，于是再拆包重组，形成新的数据包。 新数据包转到局域网内，经由交换机（可选），并最终到达目标主机。如此，整个数据传输过程就结束了。 情形三，源主机和目标主机至少有一方在局域网内且只有私有 IP 地址，它们中间经过若干交换机和路由器相连。 解释一下私有 IP 地址。在 IPv4 地址区间中，有一些区段比如 10.0.0.0 ~ 10.255.255.255、172.16.0.0 ~ 172.31.255.255、192.168.0.0 ~ 192.168.255.255 这几个 IP 地址区间都是私有 IP 地址，只用于局域网内通讯。 常规来说，只有私有 IP 而没有公网 IP 的主机只能和局域网内的主机通讯，而无法和 Internet 上的其他主机相互通讯。 但这一点又和我们日常的感受不符：比如家庭用户往往网络结构是一个 WiFi 路由器连接公网，所有的家庭设备如手机、平板、笔记本，都以 WiFi 路由器为网关构成一个局域网。那么我们的这些设备是怎么上网的呢？ 答案是 NAT（Network Address Translation，网络地址转换）技术。它的原理比较简单，假设我们现在源主机用的IP+端口为 iAddr:port1，经过 NAT 网关后，NAT 将源主机的 IP 换成自己的公网 IP，比如 eAddr，端口随机分配一个，比如 port2。 也就是从目标主机看来，这个数据包看起来是来自于 eAddr:port2。然后，目标主机把数据包回复到 eAddr:port2，NAT 网关再把它转发给 iAddr:port1。 也就是说，NAT 网关临时建立了一个双向的映射表 iAddr:port1 &lt;=&gt; eAddr:port2，一旦完成映射关系的建立，在映射关系删除前，eAddr:port2 就变成了 iAddr:port1 的 “替身”。这样，内网主机也就能够上网了。 NAT 网关并不一定是公网网关（路由器），它可以由局域网内任何一台有公网 IP 的主机担当。但显然如果公网网关担当 NAT 网关，链路的效率会高一点。 我们家用的 WiFi 路由器，就充当了 NAT 网关的作用，这也是我们能够上网的原因。 那么，最极端的情形，源主机和目标主机在不同的局域网内，且都没有公网 IP，它们是否可以通讯呢？ 答案是不确定。 首先，在这种情况下，源主机和目标主机没法直接通讯，需要中间人去帮忙搭建通讯的链路。怎么做呢？找一个有公网 IP 的主机作为中间人服务器，目标主机向它发包，这样，在目标主机的 NAT 网关就形成了一对双向的映射表： iDestAddr:portDest1 &lt;=&gt; eDestAddr:portDest2 然后，中间人服务器再把 eDestAddr:portDest2 告诉源主机。这样源主机就可以通过向 eDestAddr:portDest2 发送数据包来和目标主机 iDestAddr:portDest1 通讯了。 我们不少 P2P 软件就利用了这个技术实现 NAT 穿透，让两台不同内网的计算机相互能够直接通讯。 那么，答案为什么是不确定？因为上面这个机制只有在目标主机的 NAT 网关是 Full cone NAT，即一对一（one-to-one）NAT 网关时才成立。 什么是 Full cone NAT？它是指 NAT 网关临时建立了 iAddr:port1 &lt;=&gt; eAddr:port2 双向映射后，任何主机给 eAddr:port2 发送数据包，都会被转给 iAddr:port1，并不局限于构建这个映射时数据包发送的目标主机是谁。 但在其他类型的 NAT 网关下，一般都对回包的主机 IP 地址有约束。也就是说，NAT 网关形成的双向映射表是因为哪个目标主机建立的，那么回包也必须来自哪台主机。 这种情况下，中间人服务器就没办法来搭桥让它们直接通讯了，数据包需要由中间人服务器来中转。 结语总结一下，今天我们介绍了数据封包过程、与 IP 数据包传输相关的网络协议，并对数据传输过程做了整体的描述。 我们主要介绍的重点是 IP 协议之下的网络工作过程。我们不讨论如何进行数据重传，更不关心数据到达应用层我们收到数据包后，如何去处理它们。 互联网背后的世界，和互联网一样精彩。精妙之处，值得细细体会。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将进一步来探讨一下网络世界的编程接口。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/14 | IP 网络：连接世界的桥梁/"},{"title":"16 | 安全管理：数字世界的守护","text":"你好，我是七牛云许式伟。今天我们要聊的话题是操作系统的最后一个子系统：安全管理。 数字世界是高效的，但数字世界也是脆弱的。在越来越多的日常生活被数字化的今天，安全问题也越来越凸显出了它的重要性。 有经验的安全工程师都知道，做好安全的基本逻辑是：不要开太多的门和窗，最好所有人都在同一道门进出，安全检查工作就可以非常便利地进行。 要想构建一个安全可靠的环境，从最底层就开始设计显然是最好的。所以安全管理是一个基础架构问题。现代操作系统必然会越来越关注安全性相关的问题。因为一旦安全问题严重到触及人们的心里防线，整个数字世界都有可能随之崩塌。 让我们从头回顾一下操作系统安全能力的演进。 病毒与木马首先是实模式的操作系统，以微软的 DOS 系统为代表。实模式的操作系统进程都运行在物理地址空间下。 这意味着，每个软件进程都可以访问到其它软件进程（包括操作系统）的内存数据，也可以随意地修改它。所以这个时期的计算机是非常脆弱的，它选择的是信任模式：我相信你不会搞破坏。 不过，好在这个时期网络还并不发达，所以一个单机版本的恶意软件，能够干的真正恶意的事情也很有限。这一时期恶意软件以计算机病毒为主，其特征主要是繁衍自己（复制自己），对计算机系统本身做某种程度的破坏。 现代操作系统基本上都是保护模式的操作系统。保护模式就是让软件运行的内存地址空间隔离，进程之间相互不能访问（除非基于共享内存技术，那也是进程自己主动选择，与被动无感知的情况下被人窥视不同）。 这从安全角度来说，是很重要的进步。不管怎么说，内存数据是最为敏感的，因为它无所不包。况且，从 Windows 开始，互联网逐步进入人们的视野。计算机的联网，一下子让安全问题变得严峻起来。 恶意软件目的开始变得不单纯。它不再只是黑客的技术炫耀，而是切切实实的黑色产业链的关键依赖。 这一时期恶意软件开始以木马为主。木马和病毒一样会去繁衍自己（复制自己），但是它较少以破坏计算机的运行为目的，相反它默默隐藏起来，窃取着你的隐私。然后，它再通过互联网把窃取的信息默默地传递出去（比如通过电子邮件）。 哪些信息是木马感兴趣的？有很多。比如以下这些信息： 键盘按键； 剪贴板的内容； 内存数据； 文件系统中关键文件的内容； …… 你可能奇怪，前面不是说保护模式已经把内存数据隔离了么，为什么木马还是能够取到内存数据？ 其实这一点不难想明白，虽然跨进程已经无法取得数据了，但是木马本来就是靠复制自己，把自己伪装成正常软件的一部分。这样，木马程序和正常的软件代码同属于一个进程内，所有信息对其仍然一览无余。 为了彻底阻止木马程序篡改正常的应用程序，聪明的操作系统创造者们想到了好方法：数字签名。 这本质上是白名单技术。所有正常发布的软件都到操作系统厂商那里登记一下。这样，一旦木马去修改软件，把自己附加上去，这个软件的签名验证就通不过，也就直接暴露了。 其实 Windows 操作系统已经引入了数字签名的概念，可以用以鉴别软件的可信度。但是考虑到从开放转向封闭有极大的历史负担，所以无论是 Windows 还是 Mac，都没有完全杜绝无签名的软件，最多当你运行无数字签名的软件时，会给个不可信的警告。 第一个大规模把软件发布变成一个封闭环境的是苹果的 iOS 操作系统。苹果通过引入 App Store，要求所有应用发布都必须通过 App Store 进行。今天无论是 Android 还是 iOS 操作系统都基于应用市场这样的封闭软件发布的形态。 这样一来，软件无法被非法修改，木马基本上就无所遁形了。当然，这并不代表木马在这些平台上就消失了。虽然不容易，但是通过感染开发人员的软件开发环境，还是可以在软件编译或其它环节中把木马注入到要发布的软件中。 要发现这种异常，iOS 和 Android 系统的厂商对软件进行数字签名前，往往会对其进行安全扫描，以发现各种潜在的安全风险。一旦某个软件被鉴定为恶意软件，就无法通过数字签名，也无法发布到应用市场上。 通过这些机制，木马很难再有机会得到传播。 软件的信息安全但是，这意味着我们没有安全风险了么？当然不是。在移动设备上，安全问题的大环境发生了巨大的变化。 首先，移动时代随着我们数字世界对现实生活影响的加深，我们越来越多的敏感信息更加容易被软件触及。有很多新增的敏感信息是PC时代所不具备的，例如： 通讯录和通话记录； 短信； 个人照片和视频； 个人地理位置（GPS）信息； 移动支付的支付密码、支付验证码； 录像和录音权限； 通话权限； .…… 正因为如此，尽管操作系统正变得越来越安全，但我们面临的安全威胁却也在日趋严重。 其实， iOS 操作系统在安全管理上的考虑不可谓不周全。 首先，在软件隔离机制上，除了基于 CPU 的保护模式，确保软件之间的内存隔离外，iOS 还引入了沙盒系统（Sandbox），确保软件之间文件系统隔离，相互之间不能访问对方保存在磁盘上的文件。 其次，通过上面我们已经提及的数字签名机制，防止了软件被恶意篡改，让病毒和木马无法传播繁衍。 最后，对涉及敏感信息的系统权限进行管控。各类敏感信息的授予均是在应用程序使用的过程中进行提示，提醒用户注意潜在的安全风险。 在这一点上，Android 操作系统往往则是在安装软件时索要权限。这两者看似只是时机不同，但是从安全管理角度来说， iOS 强很多。 还没有见到软件真身就让用户判断要不要给权限，用户往往只能无脑选择接受。而如果是在软件运行到特定场景时再索要权限，那么权限给不给就有合理的场景支持决策。 但是，在利益面前，软件厂商们是很难抵御住诱惑的。所以不仅仅是恶意软件会去过度索要系统权限，很多我们耳熟能详的常规软件也会索要运行该软件所不需要的权限。 移动时代，恶意软件的形态已经再一次发生变化。它既不是病毒也不是木马，而是“具备实用功能，但背地却通过获取用户的敏感信息来获利”的应用软件。 它通过诱导用户下载，然后在软件安装或者使用时索要敏感信息的获取权限。 一个软件到底是正常的还是恶意的？边界已经越来越模糊了。 以前病毒和木马都有复制和繁衍自己，这样一个显著的特征，但如今病毒和木马的复制繁衍能力已经被操作系统的安全机制所阻止，所以恶意软件和普通软件一样，都是通过某种手段吸引用户下载安装。 怎么保护好用户的隐私信息？道高一尺，魔高一丈。攻防之间的斗争仍将继续下去。 网络环境的信息安全如果我们不轻易尝试不可信的软件，就可以一切安全无虞？并不然，我们还要考虑我们的计算机所处的网络环境安全问题。 我们上网过程需要经过一系列的中间节点，有交换机，有路由器。我们的上网产生的所有数据包，都经由这些中间节点，这意味着我们有以下三个级别的安全风险。 被窃听的风险。可能会有人在这些节点上监听你访问和提交的内容。 被篡改的风险。可能会有人在这些节点上截获并修改你访问的内容。 被钓鱼的风险。可能会有人冒充你要访问的服务提供方和你通讯。 虽然大部分的中间节点由网络运营商提供，我们刨除这些节点被黑客所黑的情形，基本上认为可信。但这并不绝对，至少在中国，运营商修改中转的数据包这样的事情是干得出来的，常见的手法有： 在正常的 HTML 页面插入广告； 修改用户下载的 apk 文件，替换成自己想分发的 apk 文件； 修改 404 类型的 HTML 页面，替换成自己的搜索引擎的搜索页； .…… 其次是 WiFi 路由器。WiFi 路由器因为其提供方鱼龙混杂，天生是安全问题的大户。运营商能够干的事情它全都可以干，甚至可以更加肆无忌惮，以李鬼替换李逵，钓鱼的风险并不低。 比如你以为登录的是交通银行官网，它可能给你一个一模一样外观的网站，但是一旦你输入用户名和密码就会被它偷偷记录下来。 怎么解决中间人问题？ 首先是怎么防篡改。应用场景是电子合同/公章、网络请求授权（例如你要用七牛的云服务，需要确认这个请求的确是你，而不是别人发出的）等。这类场景的特征是不在乎内容是否有人看到，在乎的是内容是不是真的是某个人写的。 解决方法是数字签名技术。一般来说，一个受数字签名保护的文档可示意如下： 其中，“要防篡改的内容” 是信息原文。“密钥提示” 是在数字签名的 “密钥” 有多个的情况下，通过 “密钥提示” 找到对应的 “密钥”。如果用于保护信息的 “密钥” 只有一个，那么可以没有 “密钥提示”。“指纹” 则是对信息使用特定 “密钥” 和信息摘要算法生成的信息摘要。 大部分情况下，数字签名的信息摘要算法会选择 HMAC MD5 或者 HMAC SHA1。在 Go 语言中，使用上示意如下： import &quot;crypto/hmac&quot; import &quot;crypto/sha1&quot; import &quot;encoding/base64&quot; textToProtected := &quot;要防篡改的内容&quot; keyHint := &quot;123&quot; key := findKey(keyHint) // 根据 keyHint 查找到 key []byte h := hmac.New(sha1.New, key) // 这里用sha1，也可以改成别的 h.Write([]byte(textToProtected)) textDigest := base64.URLEncoding.EncodeToString(h.Sum(nil)) textResult := textToProtected + &quot;:&quot; + keyHint + &quot;:&quot; + textDigest得到的 textResult 就是我们期望的不可篡改信息。验证信息是否被篡改和以上这个过程相反。 首先根据 textResult 分解得到 textToProtected、keyHint、textDigest，然后根据 keyHint 查找到 key；再根据 textToProtected 和 key 算一次我们期望的信息摘要 textDigestExp。 如果 textDigestExp 和 textDigest 相同，表示没被篡改，否则则表示信息不可信，应丢弃。 如果我们希望更彻底的隐私保护，避免被窃听、被篡改、被钓鱼，那么数字签名就不顶用了，而需要对内容进行加密。 加密算法上，一般分为对称加密和非对称加密。对称加密是指用什么样的密钥（key）加密，就用什么样的密钥解密，这比较符合大家惯常的思维。 非对称加密非常有趣。它有一对钥匙，分私钥（private key）和公钥（public key）。私钥自己拿着，永远不要给别人知道。公钥顾名思义是可以公开的，任何人都允许拿。 那么公私钥怎么配合？首先，通过公钥加密的文本，只有私钥才能解得开。这就解决了定向发送的问题。网络中间人看到加密后的信息是没有用的，因为没有私钥解不开。 另外，私钥拥有人可以用私钥对信息进行数字签名（防止篡改），所有有公钥的人都可以验证签名，以确认信息的确来自私钥的拥有者，这就解决了请求来源验证的问题。 那么 A、B 两个人怎么才能进行安全通讯呢？首先A、B两人都要有自己的公私钥，并把公钥发给对方。这样 A 就有 A-private-key、B-public-key，B 就有 B-private-key、A-public-key。通讯过程如下所示。 A 向 B 发信息 R。具体来说，A 首先用 A-private-key 对 R 进行签名，得到（R，R-digest）；然后用 B-public-key 对（R，R-digest）加密，得到 encoded（R，R-digest）；然后把最终的加密信息发出去。 B 收到 encoded（R，R-digest），用 B-private-key 解密得到（R，R-digest），然后再用 A-public-key 验证信息的确来自 A。 B 理解了 R 后，回复信息给 A。这时两人的角色互换，其他同上。 非对称加密机制非常有效地解决了在不可信的网络环境下的安全通讯问题。但是它也有一个缺点，那就是慢。相比之下，它的速度比对称加密慢很多。 所以，一个改善思路是结合两者。非对称加密仅用于传输关键信息，比如对称加密所需的密码。完整的通讯过程如下所示。 A 生成一个临时用的随机密码 random-key。 A 向 B 发送 random-key，机制用的就是上面的非对称加密，基于 B-public-key。 B 收到 A 发送的 random-key，把它记录下来，并回复 A 成功。回复的信息可以基于 random-key 做对称加密。 此后，A 向 B 发、B 向 A 发信息，都用 random-key 作对称加密，直到本次会话结束。 你可能发现，整个过程中 A 自己已经不再需要非对称的公私钥对了。只要 A 事先有 B 的公钥（B-public-key）就可以。 当然，上面我们的讨论，没有涉及 B 如何把自己的 B-public-key 交给对方的。在假设网络不可信的前提下，这似乎是个难题。 我觉得有两个可能性。一个是 A 和 B 很熟悉，平常都经常一起玩。那么他们交换 public-key 完全可以不依赖任何现代通讯设备，包括电话和互联网，而是写在一张纸上，某天聚会的时候交换给对方。 另一个是更为常见的互联网世界场景：我要访问一个网站。我怎么才能避免被窃听、被篡改、被钓鱼？ 通常我们用 HTTPS 协议。 在 HTTPS 协议中，第一步是 A 作为客户端（Client）去获取 B 作为网站的公钥（B-public-key）。 怎么获取？如果我们认为网络不可信，那么我们就需要找一个可信的中间人，第三方权威机构 G，由它来证明，我们网站 B 返回客户端 A 的公钥（B-public-key），的确来自于 B，中间没有被其他人篡改。 这意味着网站 B 不能直接返回自己的公钥（B-public-key）给客户端 A，而是需要返回由权威机构 G 做了数字签名的公证书（简称数字证书），里面记录了网站 B 的域名（domain），和对应的公钥（B-public-key），还有证书的颁发人 G 的代号。 这张数字证书的作用是什么？最重要的并不是它怎么在网络上传递的。而是它记录了这样一个事实：域名 domain 对应的公钥是 B-public-key，它是由权威机构 G 做出的公证，因为上面有 G 的数字签名。 所以这张数字证书并不需要临时生成，而是提前在网站部署时就已经生成好了，而且也可以随意传递给任何人，因为它是完全公开的信息。 当然这里还有一个前提，我们客户端 A 已经提前拥有第三方权威机构 G 的公钥（G-public-key）了。整个过程如下： 客户端 A 向 网站 B 请求网站的数字证书。 网站 B 返回它的数字证书。 客户端 A 收到数字证书，用 G-public-key 验证该数字证书的确由权威机构 G 认证，于是选择相信证书里面的 (domain, public-key) 信息。 客户端 A 检查证书中的 domain，和我们要访问的网站 B 域名是否一致。如果不一致，那么说明数字证书虽然是真的，但是是别人找权威机构 G 认证的其他域名的证书，于是结束会话；如果一致，于是相信证书中的 public-key 就是网站 B 的公钥（B-public-key）。 有了 B-public-key，客户端 A 就可以愉快地上网，不必担心网络通讯的安全了。 但是，HTTPS 并不能完全解决钓鱼问题。它假设用户对要访问的网站域名（domain）可靠性有自己的判断力。 这当然并不全是事实。所以，高级一点的浏览器（例如 Google Chrome），它会建立不靠谱网站域名的数据库，在用户访问这些网站时进行风险提示。 更多的信息安全话题上面我们更多从服务终端用户角度，操作系统和浏览器以及我们的应用程序需要考虑的信息安全问题。有以下这些信息安全问题没有涉及： 服务器的安全问题（DDOS 攻击、漏洞与入侵）； 企业信息安全； 社会工程学的安全问题； …… 结语总结一下，我们今天聊了软件安全态势的演变过程，从最早的病毒和木马，演化到今天敏感信息如通讯录等内容的窃取，正常软件与恶意软件的判断边界越来越模糊。 我们也聊了网络环境带来的安全问题。今天主流的假设是网络链路是不可信的，在不可信的网络之上如何去做安全的通讯，可以做到防窃听、防篡改、防钓鱼。这也是苹果前几年强制要求 iOS App 必须走 HTTPS 协议的原因。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。本章关于操作系统的话题到此就结束了。下一讲我们结合前面的内容，讨论并实战架构第一步，怎么做需求分析。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/16 | 安全管理：数字世界的守护/"},{"title":"15 | 可编程的互联网世界","text":"你好，我是七牛云许式伟。 前面我们讨论架构思维的时候说过，架构的第一步是做需求分析。需求分析之后呢？是概要设计。概要设计做什么？是做子系统的划分。它包括这样一些内容： 子系统职责范围的定义； 子系统的规格（接口），子系统与子系统之间的边界； 需求分解与组合的过程，系统如何满足需求、需求适用性（变化点）的应对策略。 对于我们理解这个精彩的互联网世界来说，理解它的子系统的划分思路是非常非常重要的。 网络应用程序的全视图在上一讲 “14 | IP 网络：连接世界的桥梁” 中我们介绍了 IP 网络的工作原理。我们还画了一幅与数据传输这件事本身有关的网络协议图，如下： 那么，从一个典型的网络应用程序角度来说，它的完整视图又是什么样子的呢？ 上图是我给出的答案。当然，它并不代表所有的网络应用程序，但这不影响我们借它的结构来解释网络世界是怎么划分子系统的，每个子系统都负责了些什么。 第一层是物理层。你可以理解为网络设备的原生能力，它定义了硬件层次来看的基础网络协议。 第二层是数据链路层。它负责解决的是局部网络世界的数据传输能力。网络数据传输技术会层出不穷，今天主流有固网、WiFi、3G/4G，明天有 5G/6G，未来也必然还会出现更快速的网络新技术。 这些网络技术虽然都有自己独特的链路层协议，但都可以很自然融入整个互联网世界。原因在于什么？在于 IP 网络。 所以第三层是 IP 网络层，它负责的是互联网世界的一体化，彼此包容与协作。如果拿单机的应用程序的全视图来类比的话，IP 网络类似于单机体系中的操作系统。 在单机体系，操作系统是一台计算机真正可编程的开始。同样地，互联网世界的体系中，IP 网络是互联网 “操作系统” 的核心，是互联网世界可编程的开始。 第四层是 TCP/UDP 传输层。它也是互联网 “操作系统” 的重要组成部分，和 IP 网络一起构成互联网 “操作系统” 的内核。IP 网络解决的是网如何通的问题，而传输层解决的是如何让互联网通讯可信赖的问题，从而大幅降低互联网应用程序开发的负担。 互联网并不是世界上的第一张网。但是只有拥有了 TCP/IP 这一层 “操作系统”，这才真正实现了网络价值的最大化：连接一切。 有了操作系统，应用软件才得以蓬勃发展。上图我们列出的应用层协议，仅仅只是沧海一粟。但是，要说当前最主流的应用层协议，无疑当属 HTTP 协议（超文本传输协议，HyperText Transfer Protocol）和 SMTP/POP3 协议了。 HTTP 协议是因为万维网（World Wide Web，简称 WWW）这个应用场景而诞生，冲着传输静态网页而去的。但是由于设计上的开放性，几经演进到今天，已经俨然成为一个通用传输协议了。 通用到什么程度？DNS 地址簿这样的基础协议，也搞出来一个新的 HTTP DNS。当然今天 HTTP DNS 还只是传统 DNS 协议的补充，使用还并不广泛。但由此可知人们对 HTTP 协议的喜爱。 除了呈现网页之外，HTTP 协议也经常被用来作为业务开放协议 RESTful API 的承载。另外，一些通用 RPC 框架也基于 HTTP 协议，比如 Google 的 gRPC 框架。 SMTP/POP3 协议是电子邮件（Email）应用所采用的，它们没有像 HTTP 协议那么被广泛借用，只是局限于电子邮件应用领域。但 SMTP/POP3 协议使用仍然极为广泛，原因是因为电子邮件是最通用的连接协议，它连接了人和人，连接了企业和企业。 我们都很佩服微信的成功，因为它连接了几乎所有的中国人。但是相比电子邮件，微信仍然只是小巫见大巫，因为电子邮件连接了世界上的每一个人和企业。 这是怎么做到的？因为开放的力量。如果说有谁能够打败微信，那么我个人一个基本的思考是：用微信的方式打败微信恐怕很难，但微信是封闭协议，开放也许是一个打败微信的机会？ 还有其他很多应用层协议上图没有列出来，比如 FTP、NFS、Telnet 等等。它们大都应用范围相对小，甚至有一些渐渐有被 HTTP 协议替代的趋势。 对于一个网络应用程序来说，它往往还依赖存储和数据库（DB/Storage）。目前存储和数据库这块使用 HTTP 的还不多，除了对象存储（Object Storage），大部分还是直接基于 TCP 协议为主。 对象存储作为一种最新颖的存储类型，现在主流都是基于 HTTP 协议来提供 RESTful API，比如七牛云的对象存储服务。 所以你可以看到，网络应用程序所基于的基础平台，比单机软件要庞大得多。前面我们介绍的单机软件所依赖的 CPU + 编程语言 + 操作系统就不说了，它一样要依赖。 上图所示的网络世界所构建的庞大基础平台，从物理层 -&gt; 数据链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用平台层，也都是我们业务架构的依赖点。选择自定义网络协议，基于 gRPC，还是基于 HTTP 提供 RESTful API ？这是架构师需要做出的决策之一。 应用层协议与网关上一讲 “14 | IP 网络：连接世界的桥梁” 中我们谈到两台主机是如何通讯时，我们介绍了让局域网主机能够上网的 NAT 技术。NAT 网关本质上是一个透明代理（中间人），工作在网络协议的第四层，即传输层，基于 TCP/UDP 协议。 如果我们限定传输的数据包一定是某种应用层协议时，就会出现所谓的应用层网关，工作在网络协议的第七层，所以有时候我们也叫七层网关。 我们熟知的 Nginx、Apache 都可以用作应用层网关。应用层协议通常我们采用的是 HTTP/HTTPS 协议。 为什么 HTTP 协议这么受欢迎，甚至获得了传输层协议才有的待遇，出现专用的网关？ 这得益于 HTTP 协议的良好设计。 我们一起来看一看 HTTP 协议长什么样。先看获取资源的 GET 请求（Request）： GET /abc/example?id=123 HTTP/1.1 Host: api.qiniu.com User-Agent: curl/7.54.0 Accept: */*HTTP 协议的请求（Request）分协议头和正文两部分，中间以空行分隔。GET 请求一般正文为空。 协议头的第一行是请求的命令行，具体分为三部分，以空格分隔。第一部分为命令，常见有 GET、HEAD、PUT、POST、DELETE 等。第二部分是请求的资源路径。第三部分为协议版本。 协议头从第二行开始，每行均为请求的上下文环境或参数，我们不妨统一叫字段（Field）。格式为： 字段名: 字段值HTTP 服务器收到一个请求后，往往会返回这样一个回复（Response）： HTTP/1.1 200 OK Content-Type: text/html; charset=utf-8 Content-Length: 68 ETag: W/&quot;fb751fe2cb812eb5d466ed9e3c3cd519&quot; &lt;html&gt;&lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;qiniu.com&lt;/body&gt;&lt;/html&gt;HTTP 请求（Request）和回复（Response）格式上只有第一行不同。回复的第一行也分为三部分，以空格分割。 第一部分为协议版本。 第二部分是状态码（Status Code），用来表征请求的结果，200 表示成功，4xx 通常表示请求（Request）本身不合法，5xx 则通常表示 HTTP 服务器有异常。 第三部分是状态文本（Status Text），方便接收方看到回复后可以立刻判断问题，而不用去查状态码对应的文档。 当协议正文非空的时候，往往还需要用 Content-Type 字段来指示协议正文的格式。例如这里我们用 text/html 表征返回的协议正文是一个 html 文档。Content-Length 字段则用来指示协议正文的长度。 我们再来看一下修改资源的 POST 请求： POST /abc/example HTTP/1.1 Host: api.qiniu.com User-Agent: curl/7.54.0 Authorization: Qiniu dXNlcj14dXNoaXdlaSZwYXNzd2Q9MTIzCg Content-Type: application/x-www-form-urlencoded;charset=utf-8 Content-Length: 18 id=123&amp;title=Hello和 GET 不一样，修改资源往往需要授权，所以往往会有 Authorization 字段。另外这里我们用 Content-Type 字段表示我们协议正文用了表单（form）格式。 最后我们看下删除资源的 DELETE 请求： DELETE /abc/example HTTP/1.1 Host: api.qiniu.com User-Agent: curl/7.54.0 Authorization: Qiniu dXNlcj14dXNoaXdlaSZwYXNzd2Q9MTIzCg Content-Type: application/json Content-Length: 11 {&quot;id&quot;: 123}删除和修改完全类似。除了我这里刻意换了一种 Content-Type，协议正文用 json 格式了。实际业务中当然不是这样，通常会选择一致的表达方法。 大致了解了 HTTP 协议的样子，我们一起来分析一下它到底好在哪里？ 毫无疑问，最关键的是它的协议头设计。具体表现在如下这些方面。 极其开放的协议头设计。虽然 HTTP 定义了很多标准的协议头字段（Field），但是用户还是可以加自己的字段，惯例上以 X- 开头。例如，七牛引入了 X-Reqid 作为请求的内部调用过程的跟踪线索。关于 X-Reqid 本专栏后续我们还会继续谈到。 规范了业务的表达范式。虽然业务有千千万万种可能，但是实质上不外乎有什么资源，以及对资源的 CURD（创建-修改-读取-删除）。相对应地，在HTTP 协议中以 “资源路径” 表达资源，以 PUT-POST-GET-DELETE 表达 CURD 操作（也有一些服务以 POST 而不是用 PUT 请求来创建资源）。 规范了应用层的路由方式。我们知道，在传输层网络的路由基于 IP 地址，但是对于应用而言，IP 地址是一个无意义的字段，在 HTTP 协议头中，有一个字段是强制的，那就是 Host 字段，它用来表征请求的目标主机。通常，在正式生产环境下它是个域名，比如 api.qiniu.com 。以域名来表征目标主机，无疑更加能够体现业务特性。故而，对应用层而言，“域名+资源路径” 是更好的路由依据，方便进行业务的切分。 正因为 HTTP 协议的这些好处，逐渐地它成为了网络应用层协议的模板。无论业务具体是什么样子的，都可以基于 HTTP 协议表达自己的业务逻辑。 TCP/IP 层编程接口理解清楚了我们网络应用程序的结构，也理解了我们最主流的应用层协议 HTTP 协议，那么我们就可以考虑去实现一个互联网软件了。 从编程接口来说，网络的可编程性是从网络层 IP 协议开始。这是最底层的网络 “操作系统” 的能力体现。 从基于 IP 协议的网络视角来看，数据是并不是源源不断的流（stream），而是一个个大小有明确限制的 IP 数据包。IP 协议是无连接的，它可以在不连接对方的情况下向其发送数据。规格示意如下： package net type IPAddr struct { IP IP Zone string // IPv6 scoped addressing zone } func DialIP(network string, laddr, raddr *IPAddr) (*IPConn, error) func ListenIP(network string, laddr *IPAddr) (*IPConn, error) func (c *IPConn) Read(b []byte) (int, error) func (c *IPConn) ReadFrom(b []byte) (int, Addr, error) func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error) func (c *IPConn) Write(b []byte) (int, error) func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error) func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error) func (c *IPConn) Close() errorIP 协议本身只定义了数据的目标 IP，那么这个 IP 地址对应的计算机收到数据后，究竟应该交给哪个软件应用程序来处理收到的数据呢？ 为了解决这个问题，在 IP 协议的基础上定义了两套传输层的协议：UDP 和 TCP 协议。它们都引入了端口（port）的概念。 端口很好地解决了软件间的冲突问题。一个IP地址+端口，我们通常记为 ip:port，代表了软件层面上来说唯一定位的通讯地址。每个软件只处理自己所使用的 ip:port 的数据。 当然，既然 IP 和端口被传输层一起作为唯一地址，端口上一定程度上缓解了 IPv4 地址空间紧张的问题。 虽然从设计者的角度来说，最初端口的设计意图，更多是作为应用层协议的区分。例如 port = 80 表示 HTTP 协议，port = 25 表示 SMTP 协议。 应用协议的多样化很容易理解，这是应用的多样化决定的。尽管从架构的角度，我们并不太建议轻易去选择创造新的协议，我们会优先选择 HTTP 这样成熟的应用层协议。但是随着时间的沉淀，还是会不断诞生新的优秀的应用层协议。 但是，为什么需要有多套传输层的协议（TCP 和 UDP）呢？ 还是因为应用需求是多样的。底层的 IP 协议不保证数据是否到达目标，也不保证数据到达的次序。出于编程便捷性的考虑，TCP 协议就产生了。 TCP 协议包含了 IP 数据包的序号、重传次数等信息，它可以解决丢包重传，纠正乱序，确保了数据传输的可靠性。 但是 TCP 协议对传输协议的可靠性保证，对某些应用场景来说并不是一个好特性。最典型的就是音视频的传输。在网络比较差的情况下，我们往往希望丢掉一些帧，但是由于 TCP 重传机制的存在，可能会反而加剧了网络拥塞的情况。 这种情况下，UDP 协议就比较理想，它在 IP 协议基础上的额外开销非常小，基本上可以认为除了引入端口（port）外并没有额外做什么，非常适合音视频的传输需求。 编程接口来说，TCP 的编程接口看起来是这样的： package net type TCPAddr struct { IP IP Port int Zone string // IPv6 scoped addressing zone } func DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error) func ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error) func (c *TCPConn) Read(b []byte) (int, error) func (c *TCPConn) Write(b []byte) (int, error) func (c *TCPConn) Close() error func (l *TCPListener) Accept() (Conn, error) func (l *TCPListener) AcceptTCP() (*TCPConn, error) func (l *TCPListener) Close() errorUDP 的编程接口看起来是这样的： package net type UDPAddr struct { IP IP Port int Zone string // IPv6 scoped addressing zone } func DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error) func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error) func (c *UDPConn) Read(b []byte) (int, error) func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error) func (c *UDPConn) ReadFromUDP(b []byte) (int, *UDPAddr, error) func (c *UDPConn) Write(b []byte) (int, error) func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error) func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error) func (c *UDPConn) Close() error对比看，IP 和 UDP 的区别非常小，都是无连接的协议，唯一差别就是 UDPAddr 在 IPAddr 基础上增加了一个端口。也正因为如此，我们很少有应用程序会直接基于 IP 协议来编程。 客户端来说，无论 TCP 还是 UDP，使用方式都很像，其示意代码如下： c, err := net.Dial(&quot;tcp&quot;, addrServer) c.Write(...) c.Read(...) c.Close()net.Dial 背后会根据 network 字段选择调用 DialTCP 还是 DialUDP。然后我们就像操作一个文件一样来操作就行，理解上非常简单，只是 UDP 的读写在应用层面需要考虑可能会丢包。 但是服务端不太一样。服务端并不知道谁会给自己发信息，它只能监听自己的 “邮箱”，不时看看是不是有人来信了。 对于 TCP 协议，服务端示意代码如下： l, err := net.Listen(&quot;tcp&quot;, addrServer) for { c, err := l.Accept() if err != nil { 错误处理 continue } go handleConnection(c) }对于 UDP 协议，服务端示意代码如下： c, err := net.ListenUDP(&quot;udp&quot;, addrServer) for { n, srcAddr, err := c.ReadFromUDP(...) if err != nil { 错误处理 continue } // 根据 srcAddr.IP+port 确定是谁发过来的包，怎么处理 }由于 TCP 基于连接（connection），所以每 Accept 一个连接后，我们可以有一个独立的执行体（goroutine）去处理它。但是 UDP 是无连接的，需要我们手工根据请求的来源 IP+port 来判断如何分派。 HTTP 层编程接口尽管基于 TCP/IP 层编程是一个选择，但是在当前如果没有特殊的理由，架构师做业务架构的时候，往往还是优先选择基于 HTTP 协议。 我们简单来看一下 HTTP 层的编程接口： package http func Get(url string) (*Response, error) func Post(url, contentType string, body io.Reader) (*Response, error) func PostForm(url string, data url.Values) (*Response, error) func NewRequest(method, url string, body io.Reader) (*Request, error) var DefaultClient = new(Client) func (c *Client) Do(req *Request) (*Response, error) func NewServeMux() *ServeMux func (mux *ServeMux) Handle(pattern string, handler Handler) func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) func ListenAndServe(addr string, handler Handler) error func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error对于 HTTP 客户端，使用上要比 TCP/UDP 简单得多，常见情况下直接调用 Get、Post 这些函数调用就满足业务需求。 在需要在 HTTP 协议头写一些额外字段的，会略微麻烦一点，需要先 NewRequest 生成一个请求，并添加一些字段（Field），然后再调用 Client.Do 去发起请求。整体上比调用 Read/Write 这样的基础 IO 函数要简便得多。 对于 HTTP 服务端，使用上的示意代码如下： mux := http.NewServeMux() mux.HandleFunc(&quot;/abc/example&quot;, handleAbcExampe) mux.HandleFunc(&quot;/abc/hello/&quot;, handleAbcHello) http.ListenAndServe(addServer, mux)简单解释一下，一个 HTTP 服务器最基础的就是需要有根据 “资源路径” 的路由能力，这依赖 ServeMux 对象来完成。 简单对比可以看出，基于 HTTP 协议的编程接口，和基于 TCP/IP 协议裸写业务，其复杂程度完全不可同日而语。前者一个程序的架子已经呈现，基本上只需要填写业务逻辑就好。这也是采纳通用的应用层协议的威力所在。 结语这一讲我们希望给大家呈现的是应用程序的全貌。当然，我们现在看到的仍然是非常高维的样子，后面在 “服务端开发” 一章，我们将进一步展开所有的细节。 在应用层协议介绍上，我们很难有全面的介绍，因而我们把侧重点放在 HTTP 协议的概要介绍上。同样，后面我们在 “服务端开发” 一章会进一步介绍 HTTP 协议。 最后，我们整理了基于 TCP/UDP 协议编程和基于 HTTP 协议编程的主体逻辑。虽然介绍非常简要，但通过对比我们仍然可以感受到业务架构基于成熟的应用层协议的优势所在。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。网络编程本章就到此结束，后面我们有专门的章节来进一步展开。下一讲，我们将探讨操作系统的最后一个子系统：安全管理。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/15 | 可编程的互联网世界/"},{"title":"18 | 架构：需求分析 (下) · 实战案例","text":"你好，我是七牛云许式伟。 今天，我们继续上一讲关于架构第一步 “需求分析” 的讨论。为了能够获得更加具体的观感，我们选了两个实战的案例，如下： 打造 “互联网”； 存储新兵 “对象存储”。 案例: 打造 “互联网”从对信息科技的影响面来说，最为标志性的两个事件，一个是计算机的诞生，另一个是互联网的诞生。 我们前面在 “05 | 思考题解读: 如何实现可自我迭代的计算机？”这一讲中，已经剖析过一个 MVP 版本的计算机是什么样的。 今天，我们就以 “互联网” 这个产品为题，看看应该怎么去做需求分析。 我们想象一下，把我们自己置身于互联网诞生之前。互联网并不是第一张网。在此之前的信息世界中，更多的是某个企业专用的局域网。不同的企业会选择不同公司所提供的网络方案。这些网络方案缺乏统一的规划，彼此并不兼容。 那么，怎么才能打造一个连接人与人、企业与企业，甚至是物与物，能够 “连接一切” 的 “互联网”？ 首先，从根源需求来说，我们期望这不是某个巨头公司的网，也不是政府的网。这是需求的原点，这一点上的不同，产生的结果可能就很不一样。 如果我们忽略这一点，就有可能会把它做成微信网（WechatNet），或者中国网（ChinaNet）。它们可能会是一张巨大的网，但都不是 “互联网”。 所谓 “互联网” 首先应该是一张开放的网。它应该可以让很多国家很多公司参与其中，形成合力。它不应该存在 “造物主”，一个可以在这张网络中主宰一切的人。 开放，最基础的层次来说，意味着需要定义网络协议标准，尤其是跨网的数据交换标准。这里的跨网，指的是跨不同的网络设备，不同的网络运营商。 开放，从另一个角度来说，是对应用程序软件的开放。想要 “互联网” 真正能够连接一切，只是把物理的网络连接在一起是不够的，还要有能够丰富的 “连接一切” 的应用。 为了能够让更多应用可以更便捷地连接网络，我们需要提供方便应用接入的高层协议。这个协议需要屏蔽掉网络连接的复杂性（丢包重传等）。 但这还不够。“互联网” 这样的基础设施，启动阶段没有应用去吸引用户是不行的。所以我们需要 “吃自己的狗粮”，开发若干互联网应用的典型代表。 有一些需求可能非常非常重要，但是我们需要阶段性放弃，例如安全。加密传输并没有作为互联网的内建特性，这极大降低了互联网的实施难度。 从另一个角度考虑，为什么不把安全放在最底层，也要考虑方案的可持续性。一个安全方案是否能够长期有效，这非常存疑。 但是物理网络一旦存在，就很难做出改变（想想我们从 IPv4 过渡到 IPv6 需要多少年吧）。所以从这个角度来说，我们也不希望安全是一个网络的底层设施。 这并不意味着安全问题可以不解决，只是把这事儿留给了软件层，留给操作系统和应用程序。这是一个极其明智的选择。相比物理网络而言，软件层更加能够经受得起变更。 总结来说，要想把 “互联网” 这个项目做成，需要考虑这样一些事情。 一个能够连接所有既有网络的协议标准，我们不妨叫它互联网协议（Internet Protocol），简称 IP 协议。 一张连接城市的骨干网络，至少有两个城市互联的试点。 打通骨干网络和主流企业专用网络的路由器。 一套方便应用开发的高阶网络协议，工作在 IP 协议之上。 一份支撑互联网应用程序的基础网络协议栈源代码或包（package），方便主流操作系统厂商、网络设备厂商集成。 若干典型互联网应用，如电子邮件（Email）、万维网（WWW）等。 一份安全传输的网络协议方案（远期），及其源代码或包（package）。 让我们先来看下物理网络的构建。 首先，构建骨干网络。不同城市可以由若干个骨干网路由器相连。骨干路由器可以看做是由一个负责路由算法的计算机，和若干网络端口构成，如下图所示。 每个端口可能和其他城市相连，也可能和该城市内的某些大型局域网相连。一个局域网和城际网络从抽象视角看，没有非常本质的不同，只不过是采用的网络技术有异，使用的网络协议有异。 一个局域网可以简化理解为由若干台交换机连接所有的计算机设备。而交换机同样也可以看做是由一个负责路由算法的计算机，和若干网络端口构成，如下图所示： 剩下的问题是怎么对接骨干网络和局域网。这需要有人负责进行网络协议转换，它就是路由器。一台路由器上有两类端口，一类端口为本地端口，连接局域网内的设备，比如交换机，或者直接连普通的计算机。另一类端口为远程端口，负责接入互联网。 理清楚了物理网络后，我们再来看应用构建。我们打算打造两个杀手级应用（Killer Application）：电子邮件（Email）和万维网（WWW）。 在考虑应用的用户交互体验时，我们发现，物理网络能够处理的 IP 地址，和人类方便记忆的地址非常不同，故而我们决定引入域名（domain）作为人与人交流用途的地址。为此，我们引入了 DNS 地址簿协议，用于将域名解析为物理网络可理解的 IP 地址。 综上分析，最终我们得到 MVP 版本的 Internet 项目的各子系统如下： 案例: 存储新兵 “对象存储”对象存储是非常新兴的一种存储系统。是什么样的需求满足方式的变化，导致人们要创造一种新的存储呢？ 对象存储是伴随互联网的兴起，尤其是移动互联网的兴起而产生的。 首先，互联网应用兴起，软件不再是单机软件，用户在使用应用软件的过程中产生的数据，并不是跟随设备，而是跟随账号。这样，用户可以随心所欲地切换设备，不必考虑数据要在设备间倒来倒去的问题。 数据跟随账号，这是互联网应用的第一大特征，区别于单机软件的关键所在。 其次，用户交互方式的变化。用户不再打字用纯文本沟通，而是用照片、视频、语音等多媒体内容来表达自己的想法。 移动化加剧了这一趋势，在手机上打字是非常痛苦的事情。拍拍照、拍拍视频、说说话（语音输入）更加符合人的天性，尤其是手机用户覆盖面越来越宽，大部分用户属于没有经过专业培训的普通用户，这些手段是最低准入门槛的交互方式。 最后，用户体验诉求的提升。计算机显示器早年是黑白的，后来有了256色，有了真彩色（TrueColor）；显示器的屏幕分辨率，也从320x240，到640x480，到今天我们再也不关心具体分辨率是多大。随之发生变化的，是一张照片从100K，到几兆，到几十兆。 这些趋势，对存储系统带来的挑战是什么？ 其一，规模。那么多用户的数据，一台机器显然放不下了，要很多很多台机器一起来保存。 其二，可靠。用户单机对存储的要求并不高，机器硬盘出问题了，不会想着找操作系统厂商或者软件应用厂商去投诉。但是，用户数据在服务端，数据丢了那就是软件厂商的责任，要投诉。 其三，成本。从软件厂商来说，那么多的用户数据，怎么做才能让成本更低一些。 其四，并发吞吐能力。大量的用户同时操作，有读有写，怎么保证系统是高效的。 另外，从存储系统的操作接口来说，我们分为关系型存储（数据库，结构化数据）和文件型存储（非结构化数据）。我们今天的关注点在文件型存储上。 对于文件型存储来说，相关的备选解决方案有很多，我们简单罗列如下。 第一类是大家最熟悉的、最古老的存储系统：本地文件系统。虽然有很多种具体的实现方案，但是它们的使用接口大同小异，实现方案也只是在有限的几种选择中平衡。我们在 “09 | 外存管理与文件系统” 这一讲中已经有过详细的介绍，这里不提。 第二类是网络文件系统，可以统称为 NAS，如上面的 NFS、FTP、Samba（CIFS）、WebDAV，都只是 NAS 存储不同的访问接口。 第三类是数据库，它通常用于存储结构化数据，比较少作为文件型存储。但也有人在这么做，如果单个文件太大，会切成多个块放到多行。 第四类是 SAN，它是块存储。块存储和关系型存储、文件型存储都不同，它模拟的是硬盘，是非常底层的存储接口。很少会有应用直接基于块存储，更多的是 mount 到虚拟机或物理机上，然后供应用软件需要的存储系统使用。 第五类是分布式文件系统 GFS/HDFS。GFS 最早是为搜索引擎网页库的存储而设计，通常单个文件比较大，非常适合用于日志类数据的存储。这也是为什么 Hadoop最后从大数据领域跑出来，原因就是因为大数据处理的就是日志。 你可以看到，除了数据库和 SAN，我们不用细分析就知道它们不是文件型存储的最佳选择，其他几类包括本地文件系统、NAS、GFS/HDFS 有一个共同特征，就是它们的使用接口都是文件系统（FileSystem）。 那么，我们就来看下文件系统（FileSystem）对于大规模的文件型存储来说有什么问题。 最大的问题，是文件系统是一棵树（Tree）。除了对单个文件的操作只需要锁住该文件外，所有对树节点的修改操作，比如把 A 节点移到 B 处，都是一次事务操作，需要锁住整棵树。 这对规模和并发吞吐能力都是伤害。从规模来说，分布式事务是很难的（这也是为什么分布式数据库很难做的原因），做出来性能也往往好不到哪里去。从并发吞吐能力来说，如果系统存在大锁，即在锁里面执行费时的操作，就会大幅降低系统的并发吞吐能力。 传统的 NAS 出现比较早，所以它没有考虑“大规模条件下存储会有什么样的挑战”是非常正常的。 GFS/HDFS 为什么没有考虑大规模问题？这是 Google 设计 GFS 的背景导致的，网页库存储，或者日志型存储的共同特征是单个文件很大，可以到几个 G 级别，这样的话文件系统的元数据就会减少到单台机器就可以存储的级别。 所以对象存储出现了。它打破了文件型存储访问接口一定是文件系统（FileSystem）的惯例。它用的是键值存储（Key-Value Storage）。 从使用接口来说，首先选择文件所在的桶（Bucket），它类似于数据库的表（Table），只是一个逻辑划分的手段；然后选择文件的键（Key），就可以存取文件了。 这意味着文件之间并不存在关联（树型结构是文件之间的一种关联），可以通过某种算法将文件元信息分散到不同的机器上。 那么为什么文件型存储，不必考虑文件之间的关联？因为关系都在数据库里面，文件型存储只需要负责文件内容的存储，有个键（Key）能够找到文件内容即可。 从本质上来说，这是因为服务端和桌面软件面临的用户场景是完全不同的。文件系统是在桌面软件下的产物，桌面系统是单用户使用的，没有那么高的并发访问需求。 服务端一上来就面临着并发访问的问题，所以很早就出现了数据库这样的存储中间件。数据库的出现，其实已经证明文件系统并不适合服务端。只不过因为文件型存储在早期的服务端开发的比重并不大，所以没有被重视。 但是，互联网的发展极大地加速了文件型存储的发展。互联网增加的 90% 以上的数据，都是非结构化数据，包括图片、音频、视频、日志。 对象存储能够支撑的文件数量规模上非常非常大。比如七牛云存储，我们已经支持万亿级别的文件。 这在传统 NAS 这种基于文件系统访问接口的存储是难以想象的，我们看到的 NAS 存储 POC 测试要求基本上都是要能够支持 1-2 亿级别的文件存储规模。 另外，对象存储的高速发展，很大程度上会逐步侵蚀 Hadoop 生态的市场。因为 HDFS 这种日志型存储，其实只是对象存储里面的一个特例。在人们习惯了对象存储后，他们并不希望需要学习太多的存储系统；所以大数据的整个生态会逐步过渡到以对象存储为基石。 这已经发生了。这两年你可能也能够听到，Hadoop 生态的公司活得挺不好的，几家公司合并了也没有解决掉没落的问题。这和大数据生态向对象存储迁徙是分不开的，只不过这方面我们国内还处在相对比较落后的阶段。 案例分析通过对打造“互联网”和存储新兵“对象存储”这两个案例的分析，我们可以看出不同市场差异还是很大的。“互联网” 这个产品它并不是替换某种既有的方案，而是把既有的方案连接在一起。所以 “互联网” 的历史包袱很少，基本上不太需要考虑历史问题。 “对象存储” 产品则不同。在对象存储之前，存储已经经历了很长时间的发展。只不过因为文件型的数据爆发式的增长，带来了存储系统的新挑战，从而给对象存储这样的新技术一个市场机会。 当然，另外一个原因是云服务的诞生，让存储有了新的交付形态。我们不再需要拿着硬件往用户家里搬，这就出现了一个新的空白市场。 但是解决了空白市场的需求后，对象存储还是要面临 “既有市场中用户采用的老存储方案怎么搬迁” 的问题。所以存储网关这样的产品就出现了。存储网关做什么？简单说，就是把对象存储包装成 NAS，提供 NFS、FTP、Samba（CIFS）、WebDAV 这些访问接口给用户使用。 结语需求分析相关的讨论就到此结束了。不同市场差异非常大，并不存在大一统的产品定义和市场策略，需要具体问题具体分析。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲将是我们第一章的回顾与总结。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/18 | 架构：需求分析 (下) · 实战案例/"},{"title":"19 | 基础平台篇：回顾与总结","text":"你好，我是七牛云许式伟。 到今天为止，我们第一章 “基础平台篇” 就要结束了。今天，让我们对整章的内容做一个回顾与总结。 抽象信息世界的骨架基础平台篇主要涉及的内容如下。 这些内容如果展开来讲，每一系统（或模块）都会是很厚的一本书。我们的目的，当然不是为了取代这里每一个领域知识相关的专业书籍。 我们的核心目标是以架构为导向，抽象出系统的骨架，融会贯通，把这些领域知识串起来，拼出完整的信息世界的版图。 抽象出系统骨架的过程时信息必然是有损的，怎么才能做到忽略掉众多的实现细节，把系统以简洁易于理解的方式呈现出来？ 这很大程度取决于你对系统的理解程度和抽象能力。如果我们把系统想象成一个人，大部分情况下我们比较容易对其进行详尽而具体的描述，好比下图。 这相对容易。因为你只需要陈述你看到的事实，而不必拷问背后的原因。但实际上为了在最短的时间里让别人理解你的想法，你也许应该这样来描述它，见下图。 当你不是在描述这个系统本身，而是描述它与其他系统的相互关系时，你可能需要进一步简化它，变成如下图这样。 抽象有助于记忆，因为骨架需要逻辑的自洽。 这种抽象能力之所以重要，是因为它是融会贯通、疏通整个信息世界的知识脉络的关键。当你做到对世界的认知可宏观、可微观，自然一切皆在掌握。 比如，本章我们首先介绍的是冯·诺依曼体系结构，我们把它抽象为“中央处理器（CPU）+ 存储 + 一系列的输入输出设备”，并给出了系统的示意图如下。 这个图相当笼统，并没有涉及中央处理器（CPU）指令设计的真正细节。比如，我们没有介绍栈（stack）这个概念，虽然它实际上也非常关键。 为什么需要引入栈？它在中央处理器中起到了什么样的作用？ 要了解这个问题，你就需要深入到中央处理器的架构设计中去。如果你对梳理中央处理器的架构设计感兴趣，可以尝试写一篇介绍它的文字。 做这样的事情会对你非常的锻炼。“你自己理解一个事物”和“把你的理解表述成文，去引导其他人也能够理解它”，是完全不同难度的事情。 如果你对中央处理器的设计细节感兴趣，可以进一步查阅相关的参考资料。也欢迎与我分享你的心得体会。 基础平台篇的内容回顾这一章前面我们讲了些什么？为了让大家对第一章内容有个宏观的了解，我画了一幅图，如下。 首先，我们介绍了冯·诺依曼体系结构。从需求演进角度看，虽然我们信息科技发展日新月异，但是底层设计并没有发生过变化，非常稳定。从这一点来说，我们不能不佩服他们的远见。 随后，我们介绍了编程语言的演进。从汇编语言的诞生，出现了程序员这个新职业开始，此后编程语言的演进便进入高速发展期。 然而，尽管语言很多，但是编程范式的演进却并不剧烈。大家熟知的过程式、函数式、面向对象基本上能够把几乎所有的语言都囊括其中。Go 语言独树一帜地宣称自己是面向连接的语言，我们着重对比了面向对象与面向连接思想上的差异。 编程语言本身与业务架构的设计关联性不大，虽然模块规格的描述会借助语言的文法。但是语言长期演进所沉淀下来的社区资源，是我们架构设计所依赖的重要基础。充分利用好这些资源可以大大降低系统的研发成本。 最后，我们开始聊操作系统。从 UNIX =&gt; DOS =&gt; Windows/Mac/Linux =&gt; iOS/Android，从用户交互、进程管理、安全管理等角度看，操作系统的需求演变非常剧烈。 传统操作系统主要包含五个子系统：设备管理（包括存储设备、输入/输出设备、网络设备）、进程管理和安全管理。 输入/输出设备主要和交互有关，我们概要描述，基本上一笔带过。我会在后面 “桌面软件开发” 这一章再详加讨论。而服务端的交互比较简单，命令行基本上就满足需求，所以 “服务端开发” 一章我们不会再特意去展开。 另外，操作系统的商业模式也发生了剧烈的变化。 早期操作系统的营收模式以软件销售收入为主。但是从苹果的 iOS 开始，操作系统都无一例外地增加了以下三个模块： 账号（Account）； 支付（Pay）； 应用市场（AppStore）。 注意，这里我们说的账号是指互联网账号。传统操作系统虽然也有账号概念，但是，它是本地账号，属于多用户权限隔离所需。 而互联网账号的价值完全不同，它是支付和应用商店的基础。没有账号，就没有支付系统，也没有办法判断用户是否在应用市场上购买过软件。 实现了“帐号-支付-应用市场”这样的商业闭环，意味着操作系统的商业模式，从软件销售转向了收税模式。这类操作系统，我们称之为现代操作系统。所有现代操作系统，所凭借的都是自己拥有巨大的流量红利。 基础平台篇的参考资料概要回顾了我们 “基础平台篇” 的内容后，我们这里补充一下有助于理解我们内容的相关资料，如下。 有了本专栏梳理的骨架，相信对你学习和理解以上这些材料会一定的指引意义。 如果你有什么推荐的优秀参考资料，也欢迎在留言区分享，我补充到这个表格中来，我们一起来完善它。 架构之美在于悟信息世界是无中生有创造出来的，我们不需要去记忆，而是要找到创造背后的骨架和逻辑。 架构即创造。 学架构在于匠心和悟心。它靠的是悟，不是记忆。用思考的方式去记忆，而不是用记忆的方式去思考。 我们日常所依赖的基础平台，随处可见的架构之美，看到了，悟到了，就学到了。如果你只能从你自己写业务代码中感受架构之道，那么你可能就要多留些心思了。 比如，如果你日常用的是 Go 语言，那么你可以做一个作业：“谈谈 Go 语言之美”。你从Go语言的设计中感悟到了什么样的架构思维？当然如果你不常接触 Go 语言，可以给自己换一个题目，比如 “Java 语言之美”。 作为架构师，如何构建需求分析能力，尤其是需求的预判能力？ 首先，归纳总结能力很重要。分析现象背后的原因，并对未来可能性进行推测。判断错了并不要紧，分析一下你的推测哪些地方漏判了，哪些重要信息没有考虑到。 另外，批判精神也同样至关重要。批判不是无中生有的批评，而是切实找到技术中存在的效率瓶颈和心智负担。尤其在你看经典书籍的时候，要善于找出现状与书的历史背景差异，总结技术演进的螺旋上升之路，培养科学的批判方法论。 结语今天我们对本章内容做了概要的回顾，并借此对整个基础平台的骨架进行了一次梳理。 我们最为依赖，也最为强调的，是抽象能力。它对于构建信息世界的骨架至关重要。为此我们需要不断改造自己的抽象体系。例如，前面 “02 | 大厦基石：无生有，有生万物” 这一讲中提到过： 引入了输入输出设备的电脑，不再只能做狭义上的“计算”（也就是数学意义上的计算），如果我们把交互能力也看做一种计算能力的话，电脑理论上能够解决的“计算”问题变得无所不包。 有同学留言问：输入/输出设备提供的明明是一种 IO 能力，怎么能够算得上是“计算”？ 但是实际上，我们人类其实就是在这种“否定自己，不断延展自己的抽象体系”，补全自己的想象力。我们以数学中最为基础的 “数” 为例子。数的演化大概经历了： 自然数 =&gt; 整数 =&gt; 有理数 =&gt; 实数 =&gt; 复数 输入/输出能力算不算是“计算”？我们不妨以广义的“计算”角度来看。 输入（Input），无非是采集物理世界的信息，将其数字化，所以一个输入设备其实可以看作是一个模数转换的“算子”。只不过这个算子非 CPU 的指令可以表达。 输出（Output），无非是将数字内容反作用于物理世界，一个输出设备其实可以看作是一个数模转换的“算子”。同样，这个算子非 CPU 的指令可以表达。 计算机 CPU 自身只能做数数转换，输入是比特信息，输出还是比特信息。结合了输入/输出设备提供的数模和模数转换的 “算子”，连接了数字世界和物理世界的计算机，在数学上也就完备了。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。本章到此结束，我们将开始第二章：桌面开发的宏观视角。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。 限时放送推荐阅读专栏《Go语言核心36讲》正在拼团中，限时特惠79元，点击链接订阅专栏。","link":"/2019/08/31/许世伟的架构课/19 | 基础平台篇：回顾与总结/"},{"title":"17 | 架构：需求分析 (上)","text":"你好，我是七牛云许式伟。 前面我们多次提到过，架构的第一步是需求分析。那么，为什么要做需求分析？如何做好需求分析？ 今天让我们一起聊一聊需求分析这个话题。 关于需求分析的那些事为何要做需求分析？ 首先，当然是因为我们做软件本身就是为了满足用户需求。那么，用户需求到底为何，我们需要清楚定义。 其次，需求边界定义的需要。用户需求理清楚了，不代表产品理清楚了。用户需求的满足一定会有行业分工，我们做什么，合作伙伴做什么，需要厘清大家的边界。 最后，架构设计的需要。架构需要切分子系统，需要我们梳理并对用户需求进行归纳与抽象。架构还需要防止过度设计，把简单的事情复杂化。 但什么是过度设计？不会发生的事情你考虑了并且为它做足了准备，就是过度设计。所以判断是不是过度设计是很困难的，需要对需求未来演化有很强的判断力。 从这几个维度来看，需求分析过程必然会涉及以下这些内容。 我们要面向的核心用户人群是谁？ 用户原始需求是什么？最核心问题是哪几个？ 已经有哪些玩家在里面？上下游有哪些类型的公司，在我们之前，用户是怎么解决他们的问题的？我们的替换方案又是怎样的？ 进而，我们的产品创造的价值点是什么？用户最关注的核心指标是什么？ 用户需求潜在的变化在哪些地方？区分出需求的变化点和稳定点。 当然，我并不是说，我们应该在需求分析的文档中完整地回答这些问题。需求分析文档目的并不是回答这些问题。但是在我们梳理需求的过程中，我们无法回避对这些问题的思考。 可能有人会认为，这些问题是 CEO 或产品经理这样的角色需要回答的，而不是架构师需要回答的。 某种意义上来说这句话没错。回答这些问题的首要责任方是 CEO 或产品经理。他们有责任让团队中的每一个人理解我们的产品逻辑。 但是，如果架构师只是被动地接受产品需求，以按图索骥的方式来做架构设计，是不足以成为顶级架构师的。原因在于两点。 一方面，用户需求的深层理解是很难传递的。你看到的产品文档，是产品经理和用户沟通交流后的二次理解，是需求的提炼和二次加工，很难原汁原味地传递用户的述求。 所以架构师自己亲身近距离地接触用户，和用户沟通，去体会用户的述求是非常有必要的。 况且，大部分人并不会那么仔仔细细地阅读别人写的文档。当然这不完全是看文档的人单方面的原因，如果团队文档平均质量不高的话，也会影响到阅读者的心态。 另一方面，产品设计过程需要架构师的深度参与，而不是单向的信息传递。产品经理非常需要来自架构师的建设性意见。 为什么我会有这样的看法呢？这涉及我对产品的理解。产品本身是运用先进的技术来满足用户需求过程的产物。 用户需求的变化是缓慢的，真正改变的是需求的满足方式。而需求满足方式的变化，深层次来说，其背后往往由技术迭代所驱动。 从这个角度来说，产品是桥，它一端连接了用户需求，一端连接了先进的技术。产品经理是需要有技术高度的，他不一定要深刻了解技术的原理，但是一定要深刻理解新技术的边界。 某项技术能够做什么，不能做到什么，顶级产品经理甚至比实现这项技术的开发人员还要清楚。 认为产品经理不需要理解技术，这可能是我们普遍存在的社会现象，但很可能并不符合这个岗位的内在诉求。 回到架构师这个角色。 我经常说一个观点，产品经理和架构师其实是一体两面。两者都需要关心用户需求与产品定义。 只不过产品经理更多从用户需求出发，而架构师更多从技术实现出发，两者是在产品这座桥的两端相向而行，最终必然殊途同归。 这也是我为什么说架构师需要深度参与产品设计的原因。产品经理很可能会缺乏他应该有的技术广度，这就需要架构师去补位。产品定义过程需要反复推敲琢磨，并最终成型。 需求分析并不是纯技术的东西，和编程这件事情无关。它关乎的是用户需求的梳理、产品的清晰定义、可能的演变方向。 需求分析的重要性怎么形容都不过分。准确的需求分析是做出良好架构设计的基础。 前面我也说过，我个人认为架构师在整个架构设计的过程中，至少应该花费三分之一的精力在需求分析上。 这也是为什么很多非常优秀的架构师换到一个新领域后，一上来并不能保证一定能够设计出良好的架构，而是往往需要经过几次迭代才趋于稳定。 原因就在于：领域的需求理解是需要一个过程的，对客户需求的理解不可能一蹴而就。 怎么做需求分析那么怎么才能做好需求分析？ 首先，心态第一，心里得装着用户。除了需要 “在心里对需求反复推敲” 的严谨态度外，对用户反馈的尊重之心也至关重要。 其次，对问题刨根究底，找到根源需求。有很多用户反馈需求的时候，往往已经带着他自己给出的解决方案。 这种需求反馈已经属于二次加工的需求，而非原始需求。这个时候我们要多问多推敲，把它还原到不带任何技术实现假设的根源需求。 如上图所示，根源需求可能会有非常非常多的技术方案可以满足它。我们上面示意图中的小圆点是一个个用户反馈的需求。在用户提这些需求的时候，往往可能会带着他熟悉的技术方案的烙印。 对于那些我们明显不关心的需求，如上图的小红点，相对容易排除在外。毕竟产品的边界意识大家还是会有的，产品不可能无限制膨胀下去。 但是对于上面的小绿点，决策上就比较难了。不做？可能会丢了这个客户。做？如果我们手放宽一点，最后产品需求就会被放大（如上图中蓝色的圆圈），做出一个四不像的产品。 最后，在理清楚需求后，要对需求进行归纳整理。一方面，将需求分别归类到不同的子类别中。另一方面，形成需求的变化点和稳定点的基本判断。 前面我们也强调过：在需求分析时，要区分需求的变化点和稳定点。稳定点往往是系统的核心能力，而变化点则需要对应地去考虑扩展性上的设计。 要注意的是，在讨论需求的变化点和稳定点的时候，我们需要有明确参考的坐标系。在不同视角下，稳定点和变化点的判断是完全不同的。 所以需要明确的一点是，当我们说需求的变化点和稳定点时，这是站在我们要设计的产品角度来说的。 比如我们要设计一台计算机，那么多样化的外部设备是一个变化点。但是如果我们今天是在设计一台显示器，问题域就完全变了，需求的变化点和稳定点也就完全发生了变化。 本质上来说，对变化点的梳理，是一次产品边界的确立过程。所谓的开放性设计，就是说我把这个功能交给了合作伙伴，但是我得考虑怎么和合作伙伴配合的问题。 开放性设计并不是一个纯粹的用户需求问题，它通常涉及技术方案的探讨。因此，产品边界的确立不是一个纯需求，也不是一个纯技术，而是两者合而为一的过程。 对变化点的梳理至关重要。产品功能必须是收敛的，必须是可完成的。 如果某个子类别的需求呈现出发散而无法收敛的趋势，这个事情，团队一定要坐下来一起去反复推敲。不断拷问，不断明确响应需求的正确姿势到底为何。 产品定义需求分析的目标和最终结果，都是要最终形成清晰的产品定义。产品定义并不是简单的产品需求的归类。 上面我也说过，产品是桥，它一端连接了用户需求，一端连接了先进的技术。所以产品定义不可能做到和技术方案完全没关系。 首先，需要明确产品中有哪些元素，或者叫资源，以及这些资源的各类操作方式。如果我们从技术的视角来理解，这就是定义对象和方法。当然这仅仅是这么理解，实际上一个我们技术上的对象方法，从产品需求角度会有多条路径的操作方式来达到相同的目的。 其次，需要对产品如何满足用户需求进行确认。用户的使用场景未必全部是我们的产品所能直接满足的，面向特定的行业，有可能需要相应的行业解决方案，把我们的产品整合进去。 我们要避免把行业方案视作产品的一部分。更多的情况下，需要我们更加开放的心态来看待这件事情，优先寻找合作伙伴来一起完成这类行业的需求覆盖。 最后，产品定义还需要考虑市场策略，我们的产品如何进入市场，和既有市场格局中的其他主流解决方案的关系是什么样的。 我们希望获取的用户，可能大部分都已经有一个既有的产品和技术方案，在满足他的需求。在考虑如何让客户从既有方案迁移到我们的产品后，我们确定产品的边界时又会复杂很多。 在一些极其关键的市场，我们有可能会把迁移需求视作产品需求的一部分。但更多的情况下，我们产品上只为这些市场上的主流方案提供迁移路径，而不是完整的迁移方案。 为何架构课从基础平台开始？很抱歉我说得很抽象，但是总结需求分析的方法论的确是一件很难的事情。 为什么我们谈架构会从 “基础平台” 讲起？为什么从硬件架构，到编程语言，再到操作系统，我们似乎绕了一大圈，还没有谈到架构？ 有两个原因。 最直接的原因是 “基础平台” 是我们所依赖的环境，是我们应用的业务架构的一部分。越了解我们所处的环境，我们就越能够运用自如。 但还有一个重要的原因是架构的探讨容易过度抽象。所以我并没有先长篇大论谈架构方法论，谈需求应该怎么怎么去分析，而是围绕着基础平台的演进过程来谈需求分析。 信息世界的构建过程，本身就是一个最宏大的架构实践。我们通过对信息世界的骨架构成的参悟，自然能够感悟到架构思维的要点。 学内功需要悟心，学架构也需要悟心。怎么准确研判需求，对需求演进进行预测，这并不是靠技术技能，而是靠谦和求取的心态。 所以我们第一章 “基础平台” 篇整体来说，内容介绍以产品的需求分析为主、核心技术原理为辅。我们尝试把整个基础平台融为一个整体，宏观上不留任何疑惑。 实际上这一章的内容很难做到只看一遍就可以，可能要时时看，反复看。还需要查阅一些资料，也可以与人一起探讨。当然，我们也欢迎留言一起交流。 这一章我们介绍的内容，大部分内容都有一些对应的经典书籍，在后面 “基础平台篇: 回顾与总结” 一讲中，我也会给大家推荐一些经典的图书。 但我们并不是要重复这些书籍中的内容。我们的关注点在于：一是构建信息世界的宏观骨架，二是需求演进。 经典书籍虽然好，但是它们写作时候的历史背景和今天有很大不同。从架构视角来说，结合我们今天的现实情况来看，一方面我们可以总结今天区别于当初的所有变化，另一方面主动去思考为什么发生了这样的变化。以这样的视角去读经典书籍，会别有一番滋味。 结语在我们介绍完第一章 “基础平台” 篇的所有内容后，今天我们终于正式开始谈架构思维。我们探讨的是架构的第一步：需求分析。 需求分析并不是纯技术的东西，和编程这件事情无关。它关乎的是用户需求的梳理、产品的清晰定义、可能的演变方向。 怎么提升需求分析能力，尤其是预判能力？ 首先，心态第一，心里得装着用户。除了需要 “在心里对需求反复推敲” 的严谨态度外，对用户反馈的尊重之心也至关重要。 其次，对问题刨根究底，找到根源需求。 最后，对需求进行归纳整理。一方面，将需求分别归类到不同的子类别中。另一方面，形成需求的变化点和稳定点的基本判断。 需求分析的目标和最终结果，都是要最终形成清晰的产品定义。产品定义将明确产品的元素，明确产品的边界，与产业上下游、合作伙伴的分工。 为什么我们的架构课从日常最平常之处，我们日日接触的基础平台讲起？ 你真了解它们吗？你真感悟到它们的不凡之处了吗？ 学习架构，关键在于匠心与悟心。 用思考的方式去记忆，而不是用记忆的方式去思考。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲将是 “架构: 需求分析（下）· 实战案例”。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/17 | 架构：需求分析 (上)/"},{"title":"20 | 桌面开发的宏观视角","text":"你好，我是七牛云许式伟。今天开始，我们进入第二章，谈谈桌面软件开发。 从架构的角度，无论你在什么样的终端设备（比如：PC、手机、手表、手机等等），也无论你在做 Native 应用，还是基于 Web 和小程序，我们都可以统一称之为桌面程序。 如前文所述，一个桌面程序完整的架构体系如下： 对于桌面程序，最核心的话题是交互。为了把关注点收敛到交互上，我们下面重点讨论操作系统对交互范式的设计。 从需求角度看，桌面程序的交互方式并不稳定，它的交互范式经历了很多次的迭代。 命令行交互最早出现的交互范式是命令行交互程序。使用的交互设备为键盘+显示器。 输入被抽象为一段以回车（Enter键）为结束的文本（通常是单行文本，要输入多行文本，需要在行末输入“ \\ ”对回车进行转义）。 输入方式有二：一是命令行，二是标准输入（stdin）。输出也是文本，但输出目标可能是标准输出（stdout），也可能是标准错误（stderr）。 正常情况下，标准输出（stdout）和标准错误（stderr）都是向屏幕输出。这种情况下，肉眼并不能区分输出的内容是标准输出，还是标准错误。 命令行交互程序的输入输出可以被重定向。一个程序的输出，可以被重定向写入到文件（标准输出和标准错误可以输出到不同的文件以进行区分），也可以通过管道功能重定向为另一个程序的输入。 总结一下，命令行交互程序的结构可示意如下： 但命令行程序的限制过大了，人们很容易发现，在很多需求场景下这是非常反人类的，最典型的就是编辑器。稍微想象一下，你就会为怎么做好交互设计而头疼不已。 字符界面于是，字符界面程序出现了。使用的交互设备仍然是键盘+显示器，但是输入不再是一段文本，而是键盘按键事件（KeyDown 和 KeyUp）。 输出也不是一段文本，而是可以修改屏幕任何位置显示的字符（屏幕被分割成M*N的格子，每个格子可以显示一个字符）。 这个时候，键盘的功用在需求上分化为两个：一是输入文本，二是输入命令（通常通过扩展键比如方向键，或者组合键比如Ctrl-A、Alt-X）。从输入文本的角度，需要有当前输入的光标（Caret）位置。 字符界面程序保留命令行输入的方式，但一般不太使用标准输入。其结构示意如下： 上图的 TDI 含义是字符设备接口（Text Device Interface），它指的是一组向屏幕绘制文本的方法集合。大体看起来是这样的： func ClearScreen() func DrawText(x, y int, text string) ...但是，字符界面程序也有很大的局限。最典型的需求场景是游戏。一些简单的游戏比如俄罗斯方块是可以基于字符界面做出来的，但大部分情况下，字符界面对于游戏类场景能够做的事情非常有限。 图形界面于是，图形界面程序出现了。使用的交互设备是键盘+鼠标+显示器+音箱。从交互演进角度，这是一个划时代的变化。 与字符界面时期相比，图形界面时代变化的根源是输出的变化：从字符变成像素。屏幕被分割为精度更高的M * N的格子，每个格子显示的是一个很小很小的像素，每个像素可以有不同的颜色。 为什么会出现鼠标？因为屏幕精度太高，用键盘的方向键改变当前位置不只是看起来非常笨拙，而且操作上也很不自然。 为什么出现音箱的原因则比较平凡，它只不过是声音设备演进的自然结果。事实上在字符交互时期声音设备就已经有了，计算机主板上有内置的喇叭。 这个喇叭最大的用途是出现重大错误（比如计算机启动失败）的时候会响几声给予提示。 开发人员可以通过向标准输出（stdout）或标准错误（stderr）输出一个特殊的字符让喇叭响一声。 前面我们说过，输出到标准输出和标准错误对肉眼来说不可区分，所以如果我们向标准错误输出文本前让喇叭响一声，也是一个不错的一种交互范式。 与字符界面程序相比，图形界面程序还有一个重大变化，是多窗口（当然，部分复杂的字符界面程序也是多窗口的，比如 Turbo C++ 3.0，它用的是 Turbo Vision 这个知名的字符界面库）。 窗口（Window），也有人会把它叫视图（View），是一个独立可复用的界面元素。复杂的窗口可以切分出多个逻辑独立的子窗口，以降低单个窗口的程序复杂性。 窗口有了父子和兄弟关系，就有了窗口系统。一旦界面涉及复杂的窗口系统，交互变得更为复杂。例如，键盘和鼠标事件的目标窗口的确定，需要一系列复杂的逻辑。 为了降低编程的负担，窗口系统往往接管了桌面程序的主逻辑，提供了一套基于事件驱动的编程框架，业务代码由窗口系统提供的界面框架所驱动。整个程序的结构如下所示。 上图的 GDI 含义是图形设备接口（Graphic Device Interface），它指的是一组向指定窗口（注意不是屏幕）绘制图形的方法集合。绘制的对象包括有几何图形、图像、文本等。 此后，到了移动时代，手机成了最主流的计算机。使用的交互设备发生了变化，变成了触摸屏+麦克风+内置扬声器。 鼠标交互方式被淘汰，变成了多点触摸。键盘+鼠标+显示器的能力被融合到触摸屏上。 音箱也被内置到手机中，变成内置扬声器。这些变化都因移动设备便携性的述求引起。从架构的角度，它们并没有引起实质性的变化，只是鼠标事件变成了触摸事件。 智能交互麦克风让计算机多了一个输入：语音。有三种典型的用法。 一是在应用内把语音录下来，直接作为类似照片视频的媒体消息，或者识别为文本去应用（比如语音搜索）。 二是作为语音输入法输入文本（逻辑上可以认为是第一种情况的特例，只不过输入法在操作系统中往往有其特殊的地位）。 三是基于类似 Siri 语音助手来交互。 语音助手是被寄予厚望的新的交互范式。它可能开启了新的交互时代，我们不妨把它叫智能交互时代。但当前它与图形界面程序结构并不相容，而是完全自成体系，如下： 为什么语音交互和图形界面交互没法很好地融合在一起？我认为有两个原因。 一是语音交互有很强的上下文，所以语音交互程序通常其业务代码也由语音交互系统提供的框架所驱动。框架的特点是侵入性强，框架与框架之间很难融合。 二是语音交互还不成熟，所以独立发展更简单，如果有一天成熟了，完全可以重写框架，把语音和触摸屏结合起来，形成全新的交互范式。 未来交互会怎样？智能交互很可能不会止步于语音，而是视频（同是兼顾视觉和听觉），且与触摸屏完美融合。使用的交互设备有触摸屏+摄像头+麦克风+内置扬声器。整个程序的结构如下所示。 结语通过以上对交互演化历程的回顾，我们看到交互范式的演进是非常剧烈的。交互体验越来越自然，但从编程的角度来说，如果没有操作系统支持，实现难度也将越来越高。 这也说明了一点，桌面操作系统和服务端操作系统的演进方向非常不一样。桌面操作系统的演进方向主要是交互范式的迭代，在向着越来越自然、越来越智能的交互前进。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将介绍：“图形界面程序的框架”。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/20 | 桌面开发的宏观视角/"},{"title":"21 | 图形界面程序的框架","text":"你好，我是七牛云许式伟。 上一讲我们回顾了交互的演化历程。今天，我们将关注点收敛到现在仍然占主流地位的图形界面程序。它的结构如下图所示。 实现一个图形界面程序，最大的复杂性在于不同操作系统的使用接口完全不同，差异非常巨大。这给开发一个跨平台的图形界面程序带来巨大挑战。 好在，尽管操作系统的使用接口有异，但基本的大逻辑差不多。今天我们从统一的视角来看待，谈谈图形界面程序的框架。 事件无论是什么桌面操作系统，每个进程都有一个全局的事件队列（Event Queue）。当我们在键盘上按了一个键、移动或者点击鼠标、触摸屏幕等等，都会产生一个事件（Event），并由操作系统负责将它扔到进程的事件队列。整个过程大体如下。 键盘、鼠标、触摸屏等硬件产生了一个硬件中断； 操作系统的硬件中断处理程序收到对应的事件（Event）； 确定该事件的目标进程； 将事件放入目标进程的事件队列（Event Queue）。 窗口与事件响应窗口（Window），也有人会把它叫视图（View），是一个独立可复用的界面元素（UI Element）。一个窗口响应发送给它的事件（Event），修改内部的状态，然后调用 GDI 绘制子系统更新界面显示。 响应事件的常见机制有两种。 一种是事件处理类（EventHandler，在 iOS 中叫 Responder）。通常，我们自定义的窗口类会直接或间接从事件处理类继承。Windows 平台有些特殊，为了让窗口类可复用，且与语言无关，它将事件处理做成了回调函数，术语叫窗口过程（WindowProc）。这只是形式上的不同，并无本质差异。 另一种是用委托（delegate）。顾名思义，用委托的意思是事件处理不是收到事件的人自己来做，而是把它委托给了别人。这只是一种编程的手法。比如，在 Web 编程中我们给一个界面元素（UI Element）实现 onclick 方法，这可以理解为是一种委托（delegate）。 有一个事件比较特殊，它往往被叫做 onPaint 或 onDraw。为什么会有这样的事件？我们想象一下，当一个窗口在另一个窗口的上面，并且我们移动其中一个窗口时，部分被遮挡的窗口内容会显露出来。 这个过程我们可能觉得很自然，但实际上，操作系统并不会帮我们保存被遮挡的窗口内容，而是发送 onPaint 事件给对应的窗口让它重新绘制。 另外，不只是窗口可以响应事件，应用程序（Application）也可以。因为有一些事件并不是发送给窗口的，而是发给应用程序的，比如：本进程即将被杀死、手机低电量告警等等。 当然如果我们约定一定存在一个主窗口（Main Window），那么把应用程序级别的事件理解为是发给主窗口的也可以。 事件分派事件是怎么从全局的事件队列（Event Queue）到窗口的呢？ 这就是事件分派（Event Dispatch）过程，它通常由一个事件分派循环（Event Dispatch Loop）来完成。一些平台把这个过程隐藏起来，直接提供一个类似 RunLoop 这样的函数。也有一些平台则让你自己实现。 例如，对于 Windows 平台，它把事件叫消息（Message），事件分派循环的代码看起来是这样的： func RunLoop() { for { msg, ok := winapi.GetMessage() // 从事件队列中取出一个消息 if !ok { break } winapi.TranslateMessage(msg) winapi.DispatchMessage(msg) } }大体来说，就是一个简单的取消息（GetMessage）然后对消息进行分派（DispatchMessage）的过程。其中 TranslateMessage 函数你可能比较陌生，它负责的是将键盘按键事件（onKeyDown、onKeyUp）转化为字符事件（onChar）。 窗口有了父子和兄弟关系，就有了窗口系统。一旦界面涉及复杂的窗口系统，交互变得更为复杂。事件分派过程怎么知道应该由哪个窗口响应事件呢？ 这就是事件处理链（EventHandler Chain）。 不同事件的分派过程并不一样。 对于鼠标或者触摸屏的触摸事件，事件的响应方理应是事件发生处所在的窗口。但也会有一些例外的场景，比如拖放。为了支持拖放，Windows 系统引入了鼠标捕获（Mouse Capture）的概念，一旦鼠标被某个窗口捕获，哪怕鼠标已经移出该窗口，事件仍然会继续发往该窗口。 对于键盘事件（onKeyDown/onKeyUp/onChar），则通常焦点窗口先响应，如果它不感兴趣再逐层上升，直到最顶层的窗口。 键盘从功能上来说，有两个不同的能力：其一是输入文本，其二是触发命令。从输入文本的角度来说，要有一个输入光标（在Windows里面叫Caret）来指示输入的目的窗口。目的窗口也必然是焦点窗口，否则就会显得很不自然。 但是从触发命令的角度来说，命令的响应并不一定是在焦点窗口，甚至不一定在活跃窗口。比如Windows下就有热键（HotKey）的概念，能够让非活跃窗口（Inactive Window）也获得响应键盘命令的机会。一个常见的例子是截屏软件，它往往需要一个热键来触发截屏。 到了移动时代，键盘不再是交互主体，但是，键盘作为输入文本的能力很难被替代（虽然有语音输入法），于是它便自然而然地保留下来。 不过在移动设备里，不太会有人会基于键盘来触发命令，只有常见的热键需求比如截屏、调大/调小音量、拍照等等，被设计为系统功能（对应的，这些功能的热键也被设计为系统按键）保留下来。 窗口内容绘制在收到 onPaint 或 onDraw 消息时，我们就要绘制我们的窗口内容了，这时就需要操作系统的 GDI 子系统。 从大分类来说，我们首先要确定要绘制的内容是 2D 还是 3D 的。对于 2D 内容，操作系统 GDI 子系统往往有较好的支持，但是不同平台终究还是会有较大的差异。而对于 3D 内容来说，OpenGL 这样的跨平台方案占据了今天的主流市场，而 Vulkan 号称是 NextGL（下一代的 OpenGL），其潜力同样不容小觑。 从跨平台的难易程度来说，不同平台的 GDI 子系统往往概念上大同小异，相比整个桌面应用程序框架而言，更加容易抽象出跨平台的编程接口。 从另一个角度来说，GDI 是操作系统性能要求最高、最耗电的子系统。所以 GDI 优化往往通过硬件加速来完成，真正的关键角色是在硬件厂商这里。由此观之，由硬件厂商来推跨平台的 GDI 硬件加速方案可能会成为趋势。 通用控件有了以上这些内容，窗口系统本身已经完备，我们就可以实现一个任意复杂的桌面应用程序了。 但是，为了进一步简化开发过程，操作系统往往还提供了一些通用的界面元素，通常我们称之为控件(Control)。常见的控件有如下这些： 静态文本 (Label)； 按钮 (Button)； 单选框 (RadioBox)； 复选框 (CheckBox)； 输入框 (Input，也叫EditBox/EditText)； 进度条 (ProgressBar)； 等等。 不同操作系统提供的基础控件大同小异。不过一些处理细节上的差异往往会成为跨平台开发的坑，如果你希望一份代码多平台使用，在这方面就需要谨慎处理。 结语总结来说，桌面应用程序通常由用户交互所驱动。我们身处在由操作系统约定的编程框架中，这是桌面编程的特点。 在操作系统的所有子系统中，交互相关的子系统是毫无疑问的差异性最大的子系统。我们这里列了一个简单的对比表格： 这还不是差异的全部。要做一个跨平台的桌面应用程序并不容易。我们需要面对的平台太多，简单罗列，如下所示。 PC：Windows、MacOS、Linux 等； PC 浏览器：Chrome、Safri、Firefox 等； 手机/平板/手表：Android（不同手机厂商也会有细节差异）、iOS 等； 小程序：微信、支付宝、快应用等。 怎么安排不同平台的优先级？怎么规划未来版本的迭代计划？选择什么样的跨平台方案？这些问题在业务架构之外，但极其考验架构师的决策能力。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将聊聊 “桌面程序的架构建议”。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/21 | 图形界面程序的框架/"},{"title":"23 | Web开发：浏览器、小程序与PWA","text":"你好，我是七牛云许式伟。 前面几讲我们聊到桌面软件开发，是从原生应用（Native App）角度来讲的，我们的讨论范围还只是单机软件，没有涉及网络相关的部分。 虽然介绍 Model 层的时候，我拿基于数据库实现 Model 层来谈常见的两个误区，但这只是因为这种问题经常能够见到，比较典型。实际纯单机软件很少会基于数据库来做，通常是自己设计的内存中的数据结构。 浏览器今天开始我们聊聊浏览器。从商业价值看，浏览器带来的最为重大的进步是如下这三点。 其一，软件服务化。当产品交付从单机软件转向云服务后，社会分工就发生了巨大变化。 互联网让 “24 小时不间断服务”成为可能。任何一个环节的力量都得到百倍乃至千倍的放大，都有可能成长出一个超级节点，进而吞噬上下游，让服务链条更短。 其二，随时发布。这极大改进了软件迭代的效率。人们快速试验自己的想法，不必过度因为顾虑软件质量召回而束手束脚。 其三，跨平台。浏览器消除了不同操作系统平台的差异性，让一份代码到处运行成为可能。 不过我们今天把重心放到界面开发这个视角。从作为界面开发框架的角度看，浏览器带来的最重大变化又是哪些？ 其一，操作系统的窗口系统被颠覆。一个网页只是一个窗口，不再有父子窗口。所有网页中的界面元素，都是一个虚拟视图（Virtual View），无论是大家耳熟能详的通用控件（比如 input，image，div 等等），还是自绘窗口（canvas）都一样。 这一点非常关键。哪些元素是子 View，哪些元素是图形（Shape） 已经完全淡化了，更多的是通过一种统一机制来完成事件分派（Event Dispatch）。 其二，窗口的绘制机制变了。之前是调用操作系统的 GDI 生成界面，现在换成了 HTML+CSS。当然如果我们非要把 HTML+CSS 看作是另一种 GDI 语言，某种程度来看好像也可以。 但是实际上 GDI 与 HTML+CSS 有非常本质的差别。它们一个是在绘制界面，一个是在声明界面。这两者的本质差别，在视图更新（Update View）的时候一下子就显现出来。 上一讲我们在介绍 View 层的时候，介绍过 View 层的一大难点是做局部更新的优化。在 View 局部优化比较复杂的时候，我们甚至会引入 ViewModel 层来做视图局部更新的支持。 站在这个角度看 HTML+CSS，其实我们不能把它理解为 View 层，它其实是 ViewModel 层。View 层由谁干掉了？浏览器。在我们修改 HTML DOM 时，浏览器自动就更新了 View。怎么做到局部更新优化的？你不必关心，浏览器已经干完这件事情了。 这事的真正价值超过你的想象。它大幅提升了桌面应用开发的效率。 其三，语言限制。浏览器的确大幅改善了界面开发的效率，但是从语言支持的角度，大部分操作系统都支持各种语言作为开发工具，而浏览器长期以来只支持 JavaScript 一门语言。 这当然是一个不小的制约。所以有很多人在试图突破这个限制。Google 曾经想要把 Dart 语言打造为下一代的 JavaScript，但最终以失败告终。 今天主流的方案还是以代码转换器为主。也就是说，我可以用自己期望的语言（比如 Go 语言）来做开发。但是在发布前通过代码转换器转为 JavaScript。 今天还有一个重要的尝试是 WebAssembly。它的目标是打通各类语言与 Web 之间的桥梁。 其四，B/S 架构。无论是 B/S 还是 C/S，本质上还是软件服务化。这对软件架构产生了巨大影响。 一方面，从 Server 端的逻辑看，系统从单用户变成了多用户。另一方面，从 Browser 端（或 Client 端）看，仍然是单用户，但是没有了数据，数据都在 Server 端。这对应用架构提出了新的挑战。 应该怎么设计 Web 程序的架构？我们在下一讲中接着聊这个话题。 小程序2016年9月，微信小程序（最初叫“应用号”）开始内测。下面是当天七牛云团队的一番内部对话。 许式伟：看下这篇，微信应用号来了。 Gina：这个理念应该不是去构建一个Store，它的理念是用完即走，是场景通过扫码或者搜索触发的，并且应该打的是实体或者服务售卖群体，不会针对微信内消费，是订阅号的升级展现方式。 许式伟：关于微信小程序（应用号），我能透露的几个细节，这一篇更详细一些。 微信没有必要在微信App内放Appstore，可以只有Web版本的Appstore，App不需要安装，甚至可能以消息的方式发给别人，以服务号的形式存在，这是迭代式开发。 以后终极形态还可以变，当前重心应该在runtime的稳定。通过上面的介绍，微信实际上升级了浏览器内核的标准，符合我之前说的新一代浏览器的定义。 Gina：小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。 徐倒立：WebApp 这个技术和 idea最早来自 Google 浏览器 ，微信是商业化的最佳实践。Google浏览器在支持开发者开发App时就提出Intents，并且和Android是可以互动的。 Gina：没有好的土壤有好的功能也是没意义的。 许式伟：是，微信小程序在别的App不是做不到，是做了意义太小。苹果和腾讯不约而同在IM里面做App是有道理的。 Gina：IM比搜索和浏览器的封闭性更强。用户不容易跳转出去。封闭性强的土壤才能构建App生态。 许式伟：所以移动时代最佳的浏览器是IM，不再是以前传统浏览器。 杜江华：我们应该多讨论to B巨头们怎么玩、怎么思考的，对我们现阶段才更有意义，支付宝、微信等都是to C的。 许式伟：不是这样的。to C 的生态变化，会影响 to B。to C 是根源，我们是帮用户做App的，如果不知道以后App是怎么玩的，怎么可能做好。 杜江华：理解了，那应该是客户群之一互联网部分，还有不少大B 需要有其他不同的思考方式。 Gina：大B的趋势我挺想听的。这周聚会，阿杜能否把最近大项目和大传统客户的一些动作详细聊一下。你这边离业务最近。 许式伟：其实比你想象得还要恐怖，不管你是什么大B，你都得拥抱微信，只有微信和QQ让整个7亿中国网民在里面安家了，这就是一个虚拟的国家。所以我的判断是没有大B不开发微信小程序，这只是个眼光和时间问题。 吕桂华：这个微信应用号我们是应该关注的，相当于市场上多了一个操作系统。 许式伟：微信应用号不只是一个新OS，而且是下一代OS，苹果和谷歌不会坐视不理。当然还有一个痛点是跨平台。 Gina：这个东西可能对营销生态有大的影响。我们也要开发些营销工具。 在这段对话之后的一个月内，我们做出了七牛的第一笔对外投资：“即速应用”，它致力于帮助企业开始快速构建自己的小程序。 为什么微信小程序必然会成功？ 因为，有 7 亿人同时使用的操作系统，很少。如果我们把不同 Android 厂商归为不同的主体的话，微信小程序是当时世界上最大的单一来源的操作系统。 随后，支付宝发布了支付宝小程序，国内手机厂商联合发布了 “快应用”，今日头条也发布了自己的小程序。 一下子，小程序变成了一支巨大的新兴力量，成为真正意义上的国产操作系统，对抗着 Android 和 iOS 两大移动操作系统生态。 但是，目前来说，小程序生态仍然存在有诸多问题。 最为关键的，是标准不统一。虽然都叫小程序，但是它们的接口各自都在快速迭代，很难去建立统一的标准，更谈不上让开发者一次开发，到处可用。 这和 Android 不同。虽然 Android 厂商很多，但是不同 Android 的开发接口是一致的，开发工具链是一致的。 小程序的厂商们会好好坐下来谈一谈标准一致的事情吗？应该做，但可能他们现在没空管开发者们的体验，他们的关注点是怎么快速抢地盘。 聊了那么多，我们话题回到技术本身。小程序和传统的 Web 开发有何不同？ 其实有很大不同。小程序更像是 Native 程序在线化，而不是 PC Web 移动化。 为什么我们这么说？因为小程序是一个应用，而不是由一个个 Web 页面构成。 我们需要提交应用给微信或支付宝，他们也会像苹果审核 AppStore 上的应用一样，掌控着 App 的生杀大权。 而且理论上可以比苹果更牛的是，他们可以下线一个已经有千万甚至上亿级别用户的 App，让他们一无所有。苹果可以掐掉一个 App 的新增，他们可以掐掉一个 App 的全部。 这会带来新的社会问题：操作系统厂商的权限边界究竟在哪里。这不是一个简单的技术问题，而是一个伦理与法律的问题。 正因为这个风险如此之高，所以所有的厂商在拥抱微信的同时，必然时时刻刻想着如何逃离微信。 刀刃，永远是两面的。 这也是我个人非常佩服Facebook扎克伯格的地方。他看到了终局，所以在发布 Libra 的时候，他选择的是让一步，放弃 Control。 我还是那句话，他会成功。 让一步，其实就是进一百步。 PWA国内大厂们纷纷布局小程序的时候，Google 也在发力自己的移动浏览器方案，叫 PWA，全称 “Progressive Web App”。 其实 Google 想要让浏览器获得 Native 应用同等体验之心是路人皆知的事实。 在 PC 时期，Google 就搞了 Google Native Client (NaCl)，后来转向了 WebAssembly。移动应用的在线化，Google 也同样在探索。 PWA 开始于 2015 年，比微信小程序早很多，并得到了苹果和微软的支持。从这个角度来说，PWA 的潜力不容小觑。 怎么理解 PWA？你可以理解为海外版的小程序。 那么它和小程序的差别在哪？ 其一，演进思路不同。PWA 基本上以兼容并对 Web 进行逐步改造升级为导向。而小程序和 Web 还是有较大程度的差异。 其二，关注焦点不同。PWA 更技术化，它很大的精力重心放在如何让 PWA 在断网情况下和本地应用有更一致的体验。而小程序关注点在如何撬动这么庞大的用户市场，小程序之后专门出现小游戏，更加能够证明这一点。 其三，PWA 并没有中心化的 AppStore，它更像是一项技术标准，而不是一个封闭的操作系统。支持 PWA 的厂商们不用担心被人掐脖子，怎么更新你的应用自己说了算。 虽然技术上相似，但是如果以操作系统角度看，两者有代差。PWA 如果我们看作操作系统的话，相比小程序来说太传统。 为什么这么讲？因为小程序符合我前面介绍现代操作系统的 “账号(Account)-支付(Pay)-应用市场(AppStore)” 的商业闭环，但是 PWA 并没有账号，也没有支付。 怎么看待 PWA 的未来？ 最终把 PWA 发扬光大的，很可能是 Facebook（当然 Facebook 也非常大概率选择放弃包袱，和小程序一样重新出发）。加上 Libra，秒杀微信小程序。 结语今天我们聊了浏览器，结合浏览器的发展趋势，谈了现在仍然在高速迭代中的移动浏览器之争。有中国特色的小程序，和海外版小程序 PWA。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将聊聊 “跨平台与 Web 开发的建议”。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/23 | Web开发：浏览器、小程序与PWA/"},{"title":"22 | 桌面程序的架构建议","text":"你好，我是七牛云许式伟。 上一讲我们介绍了图形界面程序的框架。站在操作系统交互子系统的角度来看，我们桌面应用程序的结构是下面这样的。 今天我们换一个角度，站在应用架构的角度，来聊聊如何设计一个桌面应用程序。 从 MVC 说起关于桌面程序，我想你听得最多的莫过于 MVC 这个架构范式。MVC 全称是 “模型(Model)-视图(View)-控制器(Controller)”。 怎么理解 MVC 呢？一种理解是，Model 是 Input，View 是 Output，Controller 是 Process，认为 MVC 与计算机的 Input-Process-Ouput 这个基础模型暗合。 但更准确的解释是：Model 是数据，View 是数据的显示结果，同时也接受用户的交互动作，也就是事件。从这个意义来说，说 Model 是 Input 并不严谨，View 接受的用户交互，也是 Input 的一部分。 Controller 负责 Process（处理），它接受 “Model + 由 View 转发的事件” 作为 Input，处理的结果（Output）仍然是 Model，它更新了 Model 的数据。 View 之所以被理解为 Output，是因为 Model 的数据更新后，会发送 DataChanged（数据更新）事件，View 会在监听并收到 DataChanged 事件后，更新 View。所以把 View 理解为 Output 也并不算错，它从数据角度看其实是 Model 的镜像。 对 MVC 模式做些细微的调整，就会产生一些变种。比如，Model 的数据更新发出 DataChanged 事件后，由 Controller 负责监听并 Update View，这样就变成了 MVP 架构。MVP 全称是 “模型(Model)-视图(View)-表现(Presenter)”。 那么，我们究竟应该选择哪一种架构范式比较好？ 要想判断我们写的程序架构是否优良，那么我们心中就要有架构优劣的评判标准。比较知名且重要的一些基本原则如下。 最低耦合原则：不同子系统（或模块）之间有最少的交互频率，最简洁且自然的接口。 单一职责原则：不要让一个子系统（或模块）干多件事情，也不要让它不干事情。 如果在我们心中以遵循架构法则为导向，回过头再来看 MVC，又会有不同的理解。 理解 Model 层我们先看 Model。如果你真正理解 Model 层的价值，那么可以认为你的架构水平已经达到了较高层次的水准。因为 Model 层太重要了。 我上面说 Model 层是数据，这其实还不是太准确。更准确来说，Model 层是承载业务逻辑的 DOM，即 “文档对象模型（Document Object Model）”。直白理解，DOM 是 “面向对象” 意义上的数据。它不只是有数据结构，也有访问接口。 为了便于理解，假设我们基于数据库来实现 Model 层。这种情况下会有两种常见的架构误区。 一种是直接让 Controller 层直接操作数据库，也就是拿数据库的读写接口作为 Model 层的接口。 另一种看起来高级一些，用所谓的 ORM 技术来实现 Model 层，让 Controller 直接操作 ORM。 为什么我们说这两种做法都有问题呢？原因就在于对 Model 层的价值不明。Model 层的使用接口最重要的是要自然体现业务的需求。 只有这样，Model 层的边界才是稳定的，与你基于的技术无关。是用了 MySQL，还是用了 NoSQL？是直接裸写 SQL 语句，还是基于 ORM？这都没关系，未来喜欢了还可以改。 另外，从界面编程角度看，Model 层越厚越好。为什么这么说？因为这是和操作系统的界面程序框架最为无关的部分，是最容易测试的部分，也同时是跨平台最容易的部分。 我们把逻辑更多向 Model 层倾斜，那么 Controller 层就简洁很多，这对跨平台开发将极其有利。 这样来看，直接让 Controller 层直接操作数据库，或者基于 ORM 操作数据库，都是让 Model 层啥事不干，这非常非常浪费，同样也违背了 “单一职责原则”。 我们需要强调，单一职责不只是要求不要让一个子系统（或模块）干多件事情，同时也要求不要让它不干事情。 如果我们用一句话来描述 Model 层的职责，那么应该是 “负责业务需求的内核逻辑”，我们以前经常叫它 “DataCore”。 那么 Model 层为何要发出 DataChanged 事件？ 这是从 Model 层的独立性考虑。Model 层作为架构的最底层，它不需要知道其他层的存在，不需要知道到底是 MVC 还是 MVP，或者是其他的架构范式。 有了 DataChanged 事件，上层就能够感知到 Model 层的变化，从而作出自己的反应。 如果还记得第一章我们反复强调的稳定点与变化点，那么显然，DataChanged 事件就是 Model 层面对需求变化点的对策。大部分 Model 层的接口会自然体现业务需求，这是核心价值点，是稳定的。 但是业务的用户交互可能会变化多端，与 PC 还是手机，与屏幕尺寸，甚至可能与地区人文都有关系，是多变的。 用事件回调来解决需求的变化点，这一点 CPU 干过，操作系统也干过，今天你做业务架构也这么干，这就很赞。 理解 View 层View 层首要的责任，是负责界面呈现。界面呈现只有两个选择，要么自己直接调用 GDI 接口自己画，要么创建子 View 让别人画。 View 层另一个责任是被自然带来的，那就是：它是响应用户交互事件的入口，这是操作系统的界面编程框架决定的。比较理想的情况下，View 应该把自己所有的事件都委托（delegate）出去，不要自己干。 但在 View 的设计细节中，也有很多问题需要考虑。 其一，View 层不一定会负责生成所有用户看到的 View。有的 View 是 Controller 在做某个逻辑的过程中临时生成的，那么这样的 View 就应该是 Controller 的一部分，而不应该是 MVC 里面的 View 层的一部分。 其二，View 层可能需要非常友好的委托（delegate）机制的支持。例如，支持一组界面元素的交互事件共同做委托（delegate）。 其三，负责界面呈现，意味着 View 层和 Model 层的关系非常紧密，紧密到需要知道数据结构的细节，这可能会导致 Model 层要为 View 层提供一些专享的只读访问接口。这合乎情理，只是要确保这些访问接口不要扩散使用。 其四，负责界面呈现，看似只是根据数据绘制界面，似乎很简单，但实则不简单。原因在于：为了效率，我们往往需要做局部更新的优化。如果我们收到 onPaint 消息，永远是不管三七二十一，直接重新绘制，那么事情就很好办。但是在大部分情况下，只要业务稍微复杂一点，这样的做法都会遇到性能挑战。 在局部更新这个优化足够复杂时，我们往往不得不在 Model 和 View 之间，再额外引入一层 ViewModel 层来做这个事情。 ViewModel 层顾名思义，是为 View 的界面呈现而设计的 Model 层，它的数据组织更接近于 View 的表达，和 View 自身的数据呈一一对应关系（Bidi-data-binding）。 一个极端但又很典型的例子是 Word。它是数据流式的文档，但是界面显示人们用得最多的却是页面视图，内容是分页显示的。 这种情况下就需要有一个 ViewModel 层是按分页显示的结构来组织数据。其中负责维持 Model 与 ViewModel 层的数据一致性的模块，我们叫排版引擎。 从理解上来讲，我个人会倾向于认为 ViewModel 是 View 层的一部分，只不过是 View 层太复杂而进行了再次拆分的结果。也就是说，我并不倾向于认为存在所谓的 “Model-View-ViewModel” 这样的模式。 理解 Controller 层Controller 层是负责用户交互的。可以有很多个 Controller，分别负责不同的用户交互需求。 这和 Model 层、View 层不太一样。我们会倾向于认为 Model 层是一个整体。虽然这一个层会有很多类，但是它们共同构成了一个完整的逻辑：DOM。而 View 层也是如此，它是 DOM 的界面呈现，是 DOM 的镜像，同样是一个整体。 但负责用户交互的 Controller 层，是可以被正交分解的，而且应该作正交分解，彼此完全没有耦合关系。 一个 Controller 模块，可能包含一些属于自己的辅助 View，也会接受 View 层委托的一些事件，由事件驱动自己状态，并最终通过调用 Model 层的使用接口来完成一项业务。 Controller 模块的辅助 View 可能是持续可见的，比如菜单和工具条；也可能是一些临时性的，比如 Office 软件中旋转图形的控制点。 对于后者，如果存在 ViewModel 层的话，也有可能会被归到 ViewModel + View 来解决，因为 ViewModel 层可以有 Selection 这样的东西来表示 View 里面被选中的对象。 Controller 层最应该思考的问题是代码的内聚性。哪些代码是相关的，是应该放在一起的，需要一一理清。这也是我上面说的正交分解的含义。 如果我们做得恰当，Controller 之间应该是完全无关的。而且要干掉某一个交互特别容易，都不需要删除该 Controller 本身相关的代码，只需要把创建该 Controller 的一行代码注释掉就可以了。 从分层角度，我们会倾向于认为 Model 层在最底层；View 层在中间，它持有 Model 层的 DOM 指针；Controller 层在最上方，它知道 Model 和 View 层，它通过 DOM 接口操作 Model 层，但它并不操作 View 去改变数据，而只是监听自己感兴趣的事件。 如果 View 层提供了抽象得当的事件绑定接口，你会发现，其实 Controller 层大部分的逻辑都与操作系统提供的界面编程框架无关（除了少量辅助 View），是跨平台的。 谁负责把 MVC 各个模块串起来呢？当然是应用程序（Application）了。在应用开始的时候，它就把 Model 层、View 层，我们感兴趣的若干 Controller 模块都创建好，建立了彼此的关联，一切就如我们期望的那样工作起来了。 兼顾 API 与交互MVC 是很好的模型来支持用户交互。但这不是桌面程序面临的全部。另一个很重要的需求是提供应用程序的二次开发接口（API，全称为 Application Programming Interface）。 提供了 API 的应用程序，意味着它身处一个应用生态之中，可以与其他应用程序完美协作。 通过哪一层提供 API 接口？我个人会倾向于认为最佳的选择是在 ViewModel 层。Model 层也很容易提供 API，但是它可能会缺少一些重要的东西，比如 Selection。 结语这一讲我们探讨了一个桌面应用程序的业务架构设计。我们探讨了大家耳熟能详的 MVC 架构范式。一千个人眼中有一千个哈姆雷特，虽然都在谈 MVC，但是大家眼中的 MVC 各有不同。 我们站在什么样的架构是好架构的角度，剖析了 MVC 的每一层应该怎样去正确理解与设计，有哪些切实的问题需要去面对。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将聊聊基于浏览器的开发。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/22 | 桌面程序的架构建议/"},{"title":"24 | 跨平台与 Web 开发的建议","text":"你好，我是七牛云许式伟。 上一讲我们聊了浏览器，以及移动浏览器之争：小程序与 PWA。 当我们思考浏览器从技术上带来了什么的时候，我们可以把它分为两点。 跨平台桌面程序开发； Web 开发（B/S 架构的新型应用）。 今天我们分别就跨平台桌面程序和 Web 开发展开来聊一聊。 跨平台桌面程序开发跨平台的桌面程序开发是一个超级难题。无数人前仆后继，各种方案层出不穷，但至今为止，仍然没有称得上真正深入人心的解决方案。 原因很简单，因为桌面程序本身的范畴在变。有两个关键的因素会导致桌面开发产生巨大的差异性。 一个因素自然是操作系统。不同的操作系统抽象的界面程序框架并不一致。这些不一致必然导致开发工作量的增加。 放弃某个操作系统，就意味着放弃某个流量入口，也就意味着放弃这些用户。所以虽然很麻烦，我们还是不得不支持着每一个主流的操作系统。 另一个因素是屏幕尺寸。就算相同的操作系统，在不同尺寸的屏幕上，交互的范式也会存在很大的差异性，这也会导致不低的跨平台工作量。 首先我们看下操作系统。 PC 本地：Windows，macOS，Linux 等等； PC Web：Chrome，Safari，FireFox 等等； Mobile 本地：Android，iOS 等等； Mobile Web：小程序，PWA 等等。 我们再看下屏幕尺寸。 大屏：PC、笔记本，Pad 等等； 中屏：手机； 小屏：手表。 如此繁复多样的终端类型，无怪跨平台如此之难。我们来总结一下当前都有哪些跨平台的解决方案。 这个列表只是沧海一粟。之所以没有列那么多，也是因为大部分的跨平台框架都已经不怎么活跃，已经无疾而终了。 目前来说，还很难说哪个方案会胜出。 关于跨平台开发，我觉得有一句话特别深刻：“每一次统一的努力，都最终变成新的分裂”。当然，这样的事情在很多领域都会发生，只是跨平台开发更加如此。 但是无论如何，跨平台的梦还会继续。 Web 开发聊完了跨平台，我们来聊聊浏览器带来的另一面：Web 开发。 Web 的 B/S 架构意味着编写软件有了更高的复杂性。这主要表现在以下几个方面。 其一，多用户。有了 Server 端，意味着用户的数据不再是保存在 Client（Browser）端，而是存储在 Server 端。 其二，更高的数据可靠性要求。数据在 Client 端，客户自己对数据的可靠性负责。硬盘坏了，数据丢了，用户会后悔没有对数据进行备份。 但是一旦数据在 Server 端，数据可靠性的责任方就到了软件厂商这边。如果厂商不小心把数据搞丢了，用户就会跳起来。 其三，更多可能的分工安排。详细来说，Web 应用从流派来说，分为两大类：胖前端与胖后端。 所谓胖前端，是指把尽可能多的业务逻辑放在前端。极端情况下，整个网站就是一个单页的应用。胖前端无论开发体验还是用户体验，都更接近于本地应用（Native App）。 所谓胖后端，是指主要逻辑都在后端，包括界面交互的事件响应，也通过网络调用交给了后端来实现。 我们先看客户端（Client），也就是浏览器端（Browser）。上一讲我们提到，浏览器的界面框架并没有窗口系统，它通过 HTML+CSS 来描述界面。 HTML+CSS 与其理解为 View 层，不如理解为 ViewModel 层，因为 HTML DOM 从数据角度完整描述了界面的样子。而 View 层已经被浏览器自己实现了。 这极大简化了界面开发的复杂性，因为界面的局部更新是一个复杂的话题，今天浏览器通过引入 HTML+CSS 这样的 ViewModel 层把它解决了。 这个时候我们重新看 MVC 框架在浏览器下的样子，你会发现它变成了 MVMP 模式，全称为 “Model-ViewModel-Presenter”。 首先，我们看事件响应过程。浏览器的 View 收到了用户的交互事件，它把这些事件委托（delegate）给了 ViewModel 层，并且通过 HTML DOM 暴露出来。通过修改 HTML 元素的事件响应属性，一般名字叫 onXXX（比如 onclick），可以获得事件的响应机会。 然后我们看 Model 层的数据变化（DataChanged）事件。在标准的 MVC 模式中，Model 层的数据变化是通知到 View 层，但是在浏览器下 View 是由浏览器实现的，要想让它接受 DataChanged 事件并且去处理是不太可能了。 所以解决思路自然是让 Controlller 层来做，这样就变成了 MVP 模式。 但是我们又不是标准的 MVP，因为 Presenter 层更新界面（Update View）并不是操作 View，而是 ViewModel。 综上，浏览器下的 MVC，最终实际上是 MVMP（Model-ViewModel-Presenter）。 聊完了浏览器端，我们在来看下服务端（Server）。虽然这一章我们的重点不是聊服务端，但是为了有个完整的认识，我们还是要概要地梳理一下 Server 端的架构。 前面我们在 “22 | 桌面程序的架构建议” 中，曾提到桌面软件除了要支持用户交互外，另一个很重要的需求是提供应用程序的二次开发接口（API）。 到了 Web 开发，我们同样需要二次开发接口，只不过这个二次开发接口不再是在 Client 端完成的，而是在 Server 端完成。Server 端支持直接的 API 调用，以支持自动化（Automation）方面的需求。 所以，对 Server 端来说，最底层的是一个多租户的 Model 层（Multi-User Model），它实现了自动化（Automation）所需的 API。 在 Multi-User Model 层之上，有一个 Web 层。Web 层和 Model 层的假设不同，Web 层是基于会话的（Session-based），因为它负责用户的接入，每个用户登录后，会形成一个个会话（Session）。 如果我们对Web 层细究的话，又分为 Model 层和 ViewModel 层。为了区分，Web 这边的 Model 层我们叫它 Session-based Model。相应地，ViewModel 层我们叫它 Session-based ViewModel。 在服务端，Session-based Model 和 Session-based ViewModel 并不发生直接关联，它们通过自己网络遥控浏览器这一侧的 Model 和 ViewModel，从而响应用户的交互。 Session-based Model 是什么样的呢？它其实是 Multi-User Model 层的转译。把多租户的 API 转译成单租户的场景。所以这一层并不需要太多的代码，甚至理论上自动实现也是有可能的。 Session-based ViewModel 是一些 HTML+JavaScript+CSS 文件。它是真正的 Web 业务入口。它通过互联网把自己的数据返回给浏览器，浏览器基于 ViewModel 渲染出 View，这样整个系统就运转起来了。 结语今天我们聊了 Web 带来的两个重要改变。一个是跨平台，一个是 Web 开发，即 B/S 架构下的新型应用到底应该怎么实现。 从跨平台来说，这个话题是桌面程序员（也叫“大前端”）永远的痛。计划赶不上变化，用来形容大前端程序员面临的窘境是一点都不过分的。一个玩意还没搞熟悉了，另一个东西又出来了，变化太快，要跟上实属不易。 从 Web 开发来说，MVC 变成了 MVMP（Model-ViewModel-Presenter）。我们和单机的桌面软件一样的建议，认真对待 Model 层，认真思考它的使用接口是什么样的，把 Model 层做厚。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将结合一个实际的案例，来讲解一下桌面开发（含单机软件和 Web）到底是什么样的。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/24 | 跨平台与 Web 开发的建议/"},{"title":"25 | 桌面开发的未来","text":"你好，我是七牛云许式伟。 今天，我原本想结合一个实战例子，来回顾一下 “桌面软件开发” 一章到今天为止的内容，但是由于要准备的内容比较多，会延后一下。 所以，今天我还是会按原来大纲的内容，谈谈我个人对桌面开发未来趋势的判断。 桌面平台的演进与未来谈未来，我们要先看过去。 在 PC 时期，本地桌面操作系统主流的有 Windows、MacOS、Linux。为了消除不同平台的差异，于是就出现了 QT、wxWidgets 这样的跨平台解决方案。 但是它们都败了，败给了一个它们并没有意想得到的对手：PC 浏览器。 浏览器并不是为跨平台而来，但是除了干成了软件服务化外，也干成了跨平台这件事情。 虽然浏览器厂商很多，但是它们遵循相同的规范。这意味着支持了浏览器，就支持了所有的 PC 用户。 这太诱人了。 于是在软件服务化和跨平台开发的双重优势下，软件厂商们趋之若鹜，QT、wxWidgets 这些方案就变成小众需求。 QT 有机会反抗么？其实是有的。关于这一点我们后面再说。 然后，移动大潮来了。我记得 2006 年有一次我和雷军雷总吃饭，聊起对移动操作系统未来趋势的判断，我们俩各持己见。 雷总认为 WinCE 会赢，因为 Windows 已经培育了最大的开发者群体。而我认为 Symbian 会赢，因为它占据了最大的终端用户群。 结局大家已经知道了，最后赢的是谁都没有预料到的玩家：Android 和 iOS。 如果我们从事后看，实际上这个事情并不是完全没有迹象可循。iOS（诞生于2007年）固然当时还没有诞生，但是 Android 诞生于 2003 年，并于 2005 年被 Google 收购。作为搜索引擎厂商，Google 收购一个手机操作系统，显然不是随意为之的，而是公司发展战略上的考量。 Android 和 iOS 的诞生，一下子让操作系统的生态变得更为复杂。 操作系统不同，输入方式不同（鼠标 vs 触摸屏），屏幕大小不同，想要一套代码横跨 PC 和移动多个平台？太难。 这还不算。虽然还不像手机那么普遍，但是今天手表、电视机、汽车，以及各式各样的 IoT 传感设备，都需要操作系统的支持。 从操作系统发展来说，我个人会倾向于按交互方式来分。未来桌面操作系统和服务端操作系统会渐行渐远，差异越来越大。从交互来说，服务端会维持简约，经典的命令行交互会长期占据主流。 而桌面操作系统，笔记本市场，鼠标+键盘仍然会占据主流。虽然鼠标形态已经变了，变成了触控板，但是鼠标指针这种基于精确位置交互的方式会得到保留。多点触摸的交互，也会得到部分机型的支持。 移动市场，多点触摸+键盘会占据主流。但是语音助手也会得到一定程度的渗透。 IoT 市场，语音助手会占据交互的主流。但也会有一些设备引入多点触摸这种交互方式来补充。在这个市场，目前看技术上的 Amazon 和 Google 占据了领先地位。虽然苹果入场较早，但是 Siri 的表现还是和前两者有较大的差距。 IoT 设备会两极分化。一类 IoT 设备是专用设备，它的应用场景非常固定，它对操作系统最大诉求是裁剪能力：最好不要给我太多的东西，匹配场景就好。能不能提供AppStore？不是重点，有也只有很少的一些应用，其实直接找合作伙伴就好。 一类 IoT 设备则有较大的通用性。但受限于语音助手技术的限制，IoT 操作系统的开放性要比移动系统差很多。所以在有任何可能的时候，这些设备就会带上触摸屏变成一台由移动系统支持的设备。 长远来说，要看智能语音技术的发展。关于这一点，我个人抱谨慎乐观的态度。但显然，在很长一段时间里，我们面对的还是移动操作系统。 这么多操作系统怎么搞呢？ 于是 React-Native 出现了。理论上，React-Native 可以横跨 PC 和移动。因为 React 本身基于 Web 技术，可以支持 PC 浏览器，而 React-Native 又支持 iOS 和 Android，从而做到 “Learn once，write anywhere”。 平台差异不能完全消除，只能尽可能地减少。 手机操作系统这场仗刚有了眉目，移动浏览器之争又起来了。 国内涌现了大量的小程序厂商，国外 Google 也在推 PWA。还有 Facebook 意见不明，不知道会去支持 PWA，还是基于自己的 React-Native 技术搞一套新的移动浏览器标准。 这下好了，统一的 Web 分裂成多个技术阵营。 移动浏览器，国内外不统一已经是既成事实。海外巨头们除了 Facebook，已经用明确的行动支持 PWA。小程序在海外要想有市场，要看头条腾讯阿里们的海外市场占有率。 移动 WebApp 技术的分裂是否会最终得到纠正？这仍然是未知之数。 但由此观之，终端操作系统的多元化已经是既成现实。这对开发者生态将产生重要的影响。 我们可能有人留意到，QT 今天基本上支持了所有的桌面操作系统，不管是 PC 还是移动。但是这还不太够，因为还差 Web、小程序和 PWA。 今天的跨平台，重点是要跨 Android、iOS、Web、小程序和 PWA。如果精力顾不上，PC 桌面操作系统的优先级反而可以缓一缓，毕竟 Web 也能够顶一下。 QT 的机会在这里。但是很明显它并没有意识到兼容 Web 开发对于一个跨平台工具的重要性。 就算在 PC 时期，一个同时支持 Web 和本地操作系统的跨平台工具也能够受到欢迎。今天随着桌面平台的多元化，跨平台工具的需求达到了历史最高点。 当然还有一种跨平台的思路，是垂直发展，比如专做游戏开发的跨平台。不过单就游戏开发这个领域而言，已经有强大的玩家，比如 Unity 在里面。 那么，通用的跨平台怎么做到？ Google Flutter 给了一条路，它把对操作系统的要求最小化，整个界面系统完全自己在用户态构建。 这个思路和 Go 语言有点像。Go 语言其实是在用户态完全重写了操作系统的进程管理和 IO 子系统。 那么 Flutter 会像 Go 语言一样成功么？ 我个人持谨慎态度。不同操作系统的用户是有自己独特的交互范式的。比如 Android 和 iOS 用户的习惯就有一定的差异。而这可能恰恰是跨平台更难的一点。 另一个是软件体积问题。Android 是 Google 自己的，可以通过让 Android 预装基础库来减少体积。但是更多的系统有可能需要一个体积不小的跨平台层。 这会制约 Flutter 的发展。客户端软件的尺寸，对新用户的转化率有着至关重要的影响。何况像微信小程序这样的平台，还限制了小程序的尺寸，最早限制为 4M，后来放宽到 8M。 这和 Go 语言面临的环境不太一样。Go 语言因为面向的是服务端，用户对软件的尺寸不敏感，反倒是部署的便捷性更敏感。 我个人更倾向于尺寸更轻盈的跨平台工具。 其次是编程手法上的问题。大趋势是要用 Web 这种声明式的界面描述方式。至于是否需要在语法上进行一次重新梳理，我个人觉得是有必要的。React-Native 在这个方向的探索是个不错的尝试。 在这一点上，苹果的 SwiftUI 或许更值得关注。苹果以极简体验著称，SwiftUI 某种程度上来说代表了关于跨平台开发的可能方向。 儿童编程教育在我们谈论桌面开发的时候，我认为其实还有一个重要但又很容易被忽视的趋势，是儿童编程教育的走向。 说到儿童编程教育，我们大多数人可能都知道 Scratch 语言。但是要说儿童编程的鼻祖，毫无疑问应该算 Logo 语言，海龟作图。 Scratch 语言由美国麻省理工大学（MIT）于 2007 年发布，到现在已经发展到了 3.0 版本，项目正变得越来越活跃。 在 Scratch 之后，Google 也曾经发布了 Blockly 语言进军儿童编程教育。但是由于缺乏社区基础，Blockly 语言一直不温不火。 但有两件有趣的事情。 其一，Scratch 3.0 是基于 Blockly 的源代码改造而成的，为此据说 Google 也投入了大量的技术人员进行协助，双方协同开发。 其二，Google 基于 Blockly 语言搞出了一个 App Inventor，用于教育儿童学习 Android 开发。 无独有偶的是，苹果推出的 Swift 语言启蒙教程也是针对儿童的，在 AppStore 上可以下载到，叫 “Swift Playgrounds”。 这意味着，我们原本以为两件风马牛不相及的事情，其实是密切相关的。 桌面开发的未来是什么？ 从终局的视角来看，桌面开发的终极目标，是让儿童可以轻松编写出生产级的应用。 这不是痴人说梦。 在 iOS 出来之前，如果有人说他要开发一个让三岁小孩都会使用的电脑，可能会有很多人觉得绝无可能。 但是苹果的确做到了。虽然可能还不能完全识别电脑上常见的文字，但是一个三岁的儿童使用起 iPhone 或者 iPad 却毫不困难。 那么，让一个八岁刚刚上学没多久的小学生去做生产级的应用，这事也不是遥不可及的梦想。 桌面开发技术的演进，和儿童编程教育相向而行，有一天必然汇聚于一点上。 结语今天我们结合桌面开发和儿童编程教育，聊了个人对桌面的未来演进趋势的判断。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将结合一个实际的案例，来讲解一下桌面开发（含单机软件和 Web）到底是什么样的。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/25 | 桌面开发的未来/"},{"title":"27 | 实战（二）：怎么设计一个“画图”程序？","text":"你好，我是七牛云许式伟。 上一讲开始，我们进入了实战模式。从目前看到的反馈看，我的预期目标并没有达到。 我复盘了一下，虽然这个程序看起来比较简单，但是实际上仍然有很多需要交代而没有交代清楚的东西。 我个人对这个例子的期望是比较高的。因为我认为 “画图” 程序非常适合作为架构实战的第一课。“画图” 程序需求的可伸缩性非常大，完完全全是一个迷你小 Office 程序，很适合由浅及深去谈架构的演进。 所以我今天微调了一下计划，把服务端对接往后延后一讲，增加一篇 “实战（中）” 篇。这个“中”篇一方面把前面 “实战（上）” 篇没有交代清楚的补一下，另一方面对 “画图” 程序做一次需求的迭代。 MVP 版画图程序先回到 “实战（上）” 篇。这个版本对画图程序来说，基本上是一个 MVP 版本：只能增加新图形，没法删除，也没法修改。 怎么做？我们先看 Model 层，它的代码就是一个 dom.js 文件。从数据结构来说，它是一棵以 QPaintDoc 为根的 DOM 树。这个 DOM 树只有三级：Document -&gt; Shape -&gt; LineStyle。具体细节可以参阅下表： 这个表列出的是 Model 和 View、Controllers 的耦合关系：Model 都为它们提供了什么？可以看出，View 层当前对 Model 层除了绘制（onpaint），没有其他任何需求。而各个 Controller，对 Model 的需求看起来似乎方法数量不少，但是实质上目的也只有一个，那就是创建图形（addShape）。 我们再看 View 层。它的代码主要是一个 index.htm 文件和一个 view.js 文件。View 层只依赖 Model 层，并且只依赖一个 doc.onpaint 函数。所以我们把关注点放在 View 自身的功能。 View 层只有一个 QPaintView 类。我们将其功能分为了三类：属于 Model 层职责相关的，属于 View 自身职责相关的，以及为 Controller 层服务的，得到下表。 最后，我们来看 Controller 层。Controller 层的文件有很多，这还是一些 Controller 因为实现相近被合并到一个文件，如下所示。 Menu, PropSelectors, MousePosTracker： accel/menu.js Create Path：creator/path.js Create FreePath：creator/freepath.js Create Line, Rect, Ellipse, Circle： creator/rect.js Controller 位于 MVC 的最上层，我们对它的关注点就不再是它的规格本身，也没人去调用它的方法。所以我们把关注点放在了每个 Controller 都怎么用 Model 和 View 的。 我们列了个表，如下。注意 Controller 对事件（Event）的使用从 View 中单独列出来了。 通过以上三张表对照着看，可以清晰看出 Model、View、Controllers 是怎么关联起来的。 改进版的画图程序MVP 版本的画图程序，用着就会发现不好用，毕竟图形创建完就没法改了。所以我们打算做一个新版本出来，功能上有这样一些改进。 选择一个图形，允许删除、移动或者对其样式进行修改。 图形样式增加 fillColor（填充色）。 更加现代的交互范式：默认处于 ShapeSelector 状态，创建完图形后自动回到此状态。 选择图形后，界面上的当前样式自动更新为被选图形的样式。 怎么改我们的程序？ 完整的差异对比，请参见： https://github.com/qiniu/qpaint/compare/v26…v27 下面，我们将详细讲解这些修改背后的思考。 我们先看 Model 层，新的规格见下表。 dom.js 为了方便大家理解，我们做了一个 Model 的 ChangeNotes 表格，如下： 大部分是新功能的增加，不提。我们重点关注一个点：QLineStyle 改名为 QShapeStyle，且其属性 width、color 被改名为 lineWidth、lineColor。这些属于不兼容修改，相当于做了一次小重构。 重构关键是要及时处理，把控质量。尤其对 JavaScript 这种弱类型语言，重构的心智负担较大。为了保证质量仍然可控，最好辅以足够多的单元测试。 这也是我个人会更喜欢静态类型语言的原因，重构有任何遗漏，编译器会告诉你哪里漏改了。当然，这并不意味着单元测试可以省略，对每一门语言来说，自动化的测试永远是质量保障的重要手段。 话题回到图形样式。最初我们 new QLine、QRect、QEllipse、QPath 的时候，传入的最后一个参数是 QLineStyle，从设计上这是一次失误，这意味着后面这些构造还是都需要增加更多参数如 QFillStyle 之类。 把最后一个参数改为 QShapeStyle，这从设计上就完备了。后面图形样式就算有更多的演进，也会集中到 QShapeStyle 这一个类上。 当前 QShapeStyle 的数据结构是这样的： class QShapeStyle { lineWidth: number lineColor: string fillColor: string }那么，这是合理的么？未来潜在的演进是什么？ 对需求演进的推演，关键是眼光看多远。当前各类 GDI 对 LineStyle、FillStyle 支持都非常丰富。所以如果作为一个实实在在要去迭代的画图程序来说，上面这个 QShapeStyle 必然还会面临一次重构。变成如下这个样子： class QLineStyle { width: number color: string } class QFillStyle { color: string } class QShapeStyle { line: any fill: any }为什么 QShapeStyle 里面的 line 不是 QLineStyle，fill 不是 QFillStyle，而是 any 类型？因为它们都只是简单版本的线型样式和填充样式。 举个例子，在 GDI 系统中，FillStyle 往往还可以是一张图片平铺，也可以是多个颜色渐变填充，这些都无法用 QFillStyle 来表示。所以这里的 QFillStyle 更好的叫法也许是 QSimpleFillStyle。 聊完了 Model 层，我们再来看 View 层。 view.js View 层的变化不大。为了给大家更直观的感觉，我这里也列了一个 ChangeNotes 表格，如下： 其中，properties 改名为 style，以及删除了 get lineStyle()，和 properties 统一为 style。这个和我上面说的 Model 层的小重构相关，并不是本次新版本的功能引起的。 所以 View 层真正的变化是两个： 引入了 selection，当前只能单选一个 shape；在 selection 变化时会发出 onSelectionChanged 事件； 引入了 onControllerReset 事件，它在 Controller 完成或放弃图形的创建时发出。 引入 selection 比较常规。View 变复杂了通常都会有 selection，唯一需要考虑的是 selection 会有什么样的变化，对于 Office 类程序，如果 selection 只允许是单 shape 这不太合理，但我们这里略过，不进行展开。 我们重点谈 onControllerReset 事件。 onControllerReset 事件是创建图形的 Controller（例如 QPathCreator、QRectCreator 等）发出，并由 Menu 这个 Controller 接收。 这就涉及了一个问题：类似情况还会有多少？以后是不是还会有更多的事件需要在 Controller 之间传递，需要 View 来中转的？ 这个问题就涉及了 View 层事件机制的设计问题。和这个问题相关的有： 要不要支持任意的事件； 监听事件是支持单播还是多播？ 从最通用的角度，肯定是支持任意事件、支持多播。比如我们定义一个 QEventManager 类，规格如下。 class QEventManager { fire(eventName: string, params: ...any): void addListener(eventName: string, handler: Handler): void removeListener(eventName: string, handler: Handler): void }但是，View 的事件机制设定，需要在通用性与架构的可控性之平衡。一旦 View 聚合了这个 QEventManager，通用是通用了，但是 Controller 之间会有什么样的事件飞来飞去，就比较难去从机制上把控了。 代码即文档。如果能够用代码约束的事情，最好不要在文档中来约束。 所以，就算是我们底层实现 QEventManager 类，我个人也不倾向于在 View 的接口中直接将它暴露出去，而是定义更具体的 fireControllerReset、 onControllerReset/offControllerReset 方法，让架构的依赖直观化。 具体代码看起来是这样的： class QPaintView { constructor() { this._eventManager = new QEventManager() } onControllerReset(handler) { this._eventManager.addListener(&quot;onControllerReset&quot;, handler) } offControllerReset(handler) { this._eventManager.removeListener(&quot;onControllerReset&quot;, handler) } fireControllerReset() { this._eventManager.fire(&quot;onControllerReset&quot;) } }聊完了 View 层，我们接着聊 Controller 层。我们也把每个 Controller 怎么用 Model 和 View 列了个表，如下。 Menu, PropSelectors, MousePosTracker： accel/menu.js ShapeSelector：accel/select.js Create Path：creator/path.js Create FreePath：creator/freepath.js Create Line, Rect, Ellipse, Circle： creator/rect.js 内容有点多。为了更清楚地看到差异，我们做了 ChangeNotes 表格，如下： 首先，Menu、QPathCreator、QFreePathCreator、QRectCreator 的变更，主要因为引入了新的交互范式导致，我们为此引入了 onControllerReset 事件。还有一个变化是 QLineStyle 变 QShapeStyle，这一点前面已经详细讨论，不提。 所以 Controller 层的变化其实主要是两个。 其一，PropSelectors。这个 Controller 要比上一版本的复杂很多：之前只是修改 View 的 properties (现在是 style) 属性，以便于创建图形时引用。现在是改变它时还会作用于 selection (被选中的图形)，改变它的样式；而且，在 selection 改变时，会自动更新界面以反映被选图形的样式。 其二，QShapSelector。这是新增加的 Controller，支持选择图形，支持删除、移动被选择的图形。 通过这次的需求迭代我们可以看出，目前 Model、View、Controller 的分工，可以使需求的分解非常正交。 Model 只需要考虑需求导致的数据结构演进，并抽象出足够自然的业务接口。View 层非常稳定，主要起到各类角色之间的桥接作用。Controller 层每个 Controller 各司其职，彼此之间不会受到对方需求的干扰。 结语今天我们结合“画图” 程序重新梳理了一遍 MVC 架构。并且我们更进一步，通过对画图程序进行一次需求演进，来观察 MVC 架构各个角色对需求变更的敏感性。需要再次强调的是，虽然我们基于 Web 开发，但是我们当前给出的画图程序本质上还是单机版的。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将继续实战一个联网版本的画图程序。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/27 | 实战（二）：怎么设计一个“画图”程序？/"},{"title":"28 | 实战（三）：怎么设计一个“画图”程序？","text":"你好，我是七牛云许式伟。 前面的两节课结束后，我们的画图程序已经基本实用。它有如下功能： 可以选择全局的图形样式（lineWidth、lineColor、fillColor）； 可以以全局的图形样式来创建各类图形（Path、FreePath、Line、Rect、Ellipse、Circle）； 可以选择已经创建的图形，并修改其图形样式； 可以删除选择的图形； 可以移动选择的图形。 前面有一些同学的反馈，我这里想回答一下。 有一个反馈是对 JavaScript 的使用，我为什么会用 class 关键字。 这是因为我不太希望这是一篇某个语言的教程，我选择的是如何用最接近大家思维的表达方式来表达程序逻辑，你就算没有系统学过 JavaScript，也应该能够理解这段程序想要做什么。 另外有一个反馈，是希望我不要一上来就从 MVC 这种模式讲起，而是如果没有 MVC，我们用最基础的裸写代码，会写出一个什么样的程序来，里面有哪些弊端，从而引入 MVC 来让程序架构变得更加清晰，功能之间解耦。 这个意见我觉得是比较中肯的，后面我们会补充一讲来裸写 MVP 版本的画图程序。 今天我们开始进入“实战：怎么设计一个‘画图’程序”的第三讲，怎么和服务端连接。 考虑到大家普遍反馈内容有点深，我们把服务端连接分为两节课去聊。今天这一讲我们谈的是在浏览器端进行持久化。 为什么需要在浏览器端进行持久化？ 因为我们需要有更好的用户体验。在用户断网的情况下，这个画图程序还可以正常编辑，并且在恢复联网的情况下，需要能够把所有离线编辑的内容自动同步到服务端。 结合前面几讲的介绍，你可能立刻想到 Google 推的 PWA，它非常关注浏览器应用的离线体验。 但是当我们做一个技术选型的时候，显然首先要考虑的是这个技术的兼容性如何。我们今天并不基于 PWA 来干这件事情，而是基于更传统的 localStorage 技术来干。 具体我们改的代码如下： https://github.com/qiniu/qpaint/compare/v27…v28 最核心的变化是 Model 层。完整的离线支持的 Model 层代码如下： dom.js 对象 ID为了支持持久化，我们给每一个 Model 层 DOM 树的根 —— QPaintDoc 类引入了两个 ID，如下： localID: string displayID: string 其中 displayID 顾名思义，是用户可见的ID。我们的画图程序之前本地调试的行为是打开 http://localhost:8888/ 来编辑一篇文档（QPaintDoc），但是现在会自动跳转到 http://localhost:8888/#t10001 或类似的 URL。这里 t10001 就是文档的 displayID。 其中，displayID 前面带 t 开头，表示这篇文档从它被创建开始，从未与服务器同步过，是一篇临时的文档。一旦它完成与服务端的同步后，就会改用服务端返回的文档 ID。 那么，localID 是什么？顾名思义，是这篇文档的本地 ID。在文档还没有和服务端同步时，它和 displayID 是有关系的，如果 displayID 是 t10001，那么 localID 就是 10001。但是文档第一次保存到服务端后，它的 displayID 会变化，而 localID 则并不改变。 这有什么好处？ 好处在于，我们在 localStorage 存储 DOM 树的时候，并不是把整篇文档 JSON 化后保存，而是分层的，QPaintDoc 里面的 shapes 数组保存的只是 shapeID。 是的，每个 Shape（图形）也引入了一个 ID。这样，当 Shape 发生变化，比如修改图形样式、移动，我们修改 shapeID =&gt; shapeJsonData。 请注意，在浏览器的 localStorage 里面，shapeID 是要全局唯一的，我们实际存储的是 QPaintDoc.localID + “:” + shape.id。 看到这里我们回过头来看，为什么 QPaintDoc 有 displayID 和 localID 就可以理解了。如果只有一个 ID 并且这个 ID 是会发生变化的，那么在 ID 变化时，所有保存在 localStorage 中的这篇文档的图形对象 shapeID =&gt; shapeJsonData 数据都需要跟着变化。 引入 localID 就是让 QPaintDoc 一旦初始化（QPaintDoc.init 方法）后 ，ID 就固定下来了，只需要保证在同一个浏览器下是唯一就行。 所以，我们第一次访问 http://localhost:8888/ 自动跳转的是 http://localhost:8888/#t10001 ，第二次访问自动跳转的就是 http://localhost:8888/#t10002 了。这是因为在同一个浏览器下，我们不会让两个 QPaintDoc.localID 相同。 数据变更我们把数据变更分为了两级： shapeChanged documentChanged 什么情况下叫 shapeChanged？有这样三种： 增加一个图形（addShape），这个新增的 shape 发生了 shapeChanged； 修改一个 shape 的图形样式（setProp），这个被修改的 shape 发生了 shapeChanged； 移动一个 shape 的位置（move），这个位置改变的 shape 发生了 shapeChanged。 什么情况下发生 documentChanged？有这样两种： 增加一个图形（addShape），它会导致文档的图形数量增加一个，发生 documentChanged； 删除一个图形（deleteShape），它会导致文档的图形数量减少一个，发生 documentChanged。 当然，可以预见的未来，我们支持不同 shape 交换次序（改变 Z-Order），这时文档虽然图形的数目不变，但是 shapes 数组的内容还是发生了改变，发生 documentChanged。 发生数据变更做什么？ 在 shapeChanged 时，更新 localStorage 中的 shapeID =&gt; shapeJsonData 数据。在 documentChanged 时，更新 localID =&gt; documentJsonData 数据。 从未来的预期来说，数据变更不只是发生在用户交互。考虑多人同时编辑一篇文档的场景。数据变更消息，也会来自其他浏览器端的变更。具体的过程是： Client B 操作 =&gt; Client B 的 DOM 变更 =&gt; 服务端数据变更 =&gt; Client A 收到数据变更 =&gt; Client A 的 DOM 变更 =&gt; Client A 的 View 更新 在前面 26 讲、27 讲中，我们并没有引入数据变更事件，而是 Controller 变更完数据后，就自己主动调用 qview.invalidateRect 来通知 View 层重新绘制。这样做比较简单，虽然它并不符合标准的 MVC 架构。因为从 MVC 架构来说，界面更新并不是由 Controller 触发，而应该由 Model 层的数据变更（DataChanged）事件触发。 存储的容量限制与安全localStorage 的存储容量是有限制的，不同的浏览器并不一样，大部分在 5-10M 这个级别。在同一个浏览器下，会有多个 QPaintDoc 的数据同时被保存在 localStorage 中。 这意味着，随着时间的推移，localStorage 的存储空间占用会越来越大，所以我们需要考虑数据清理的机制。 目前，我们通过 localStorage_setItem 函数来统一接管 localStorage.setItem 调用，一旦 setItem 发生 QuotaExceededError 异常，说明 localStorage 空间满，我们就淘汰掉最远创建的一篇文档。 这样，我们就不会因为 localStorage 太满而没法保存。只要我们及时联网同步文档，数据也就不会丢失了。 最后一个话题是安全。 既然我们把数据保存在了 localStorage 中，只要用户打开浏览器，就能够去通过特定手段来查看 localStorage 的数据。 这意味着如果文档中存在敏感数据的话，是可以被人感知的。尤其是我们画图程序如果未来支持多租户的话，在同一个浏览器下多个用户帐号登录登出时，就会发生多个用户的文档都在同一个 localStorage 中可见。 这意味着你登出帐号之后，其他人用这个浏览器，其实还是可以看到你的数据。这样就有隐私泄漏的风险。 解决这个问题最简单的方法是在用户帐号登出的时候，清空所有的 localStorage 中的文档。 结语今天我们开始考虑 “画图” 程序的服务端连接。今天这一讲我们先做画图程序的本地浏览器存储的持久化，以便拥有更好的离线。 支持离线持久化存储的程序会很不一样。我们今天结合画图程序聊了 DOM 树在 JavaScript 内存和在 localStorage 存储上的差别。为了支持更新数据的粒度不是整个文档每次都保存一遍，存储分成 shape、document 两个级别。相应的，我们数据更新事件也分了 shapeChanged、documentChanged 两个级别。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将继续实战一个联网版本的画图程序。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/28 | 实战（三）：怎么设计一个“画图”程序？/"},{"title":"29 | 实战（四）：怎么设计一个“画图”程序？","text":"你好，我是七牛云许式伟。 今天继续我们的画图程序。上一讲完成后，我们的画图程序不只是功能实用，并且还支持了离线编辑与存储。 今天我们开始考虑服务端。 我们从哪里开始？ 第一步，我们要考虑的是网络协议。 网络协议为了简化，我们暂时不考虑多租户带授权的场景。后面我们在下一章服务端开发篇会继续实战这个画图程序，将其改造为多租户。 在浏览器中，一个浏览器的页面编辑的是一个文档，不同页面编辑不同的文档。所以在我们的浏览器端的 dom.js 里面，大家可以看到，我们的 DOM 模型是单文档的设计。 但显然，服务端和浏览器端这一点是不同的，就算没有多租户，但是多文档是跑不了的。我们不妨把 QPaint 的文档叫drawing，如此服务端的功能基本上是以下这些： 创建新 drawing 文档； 获取 drawing 文档； 删除 drawing 文档； 在 drawing 文档中创建一个新 shape； 取 drawing 文档中的一个 shape； 修改 drawing 文档中的一个 shape，包括移动位置、修改图形样式； 修改 drawing 文档中的一个 shape 的 zorder 次序（浏览器端未实现）； 删除 drawing 文档的一个 shape。 完整的网络协议见下表： 其中&lt;Shape&gt;是这样的： &quot;path&quot;: { &quot;points&quot;: [ {&quot;x&quot;: &lt;X&gt;, &quot;y&quot;: &lt;Y&gt;}, ... ], &quot;close&quot;: &lt;Boolean&gt;, &quot;style&quot;: &lt;ShapeStyle&gt; }或: &quot;line&quot;: { &quot;pt1&quot;: {&quot;x&quot;: &lt;X&gt;, &quot;y&quot;: &lt;Y&gt;}, &quot;pt2&quot;: {&quot;x&quot;: &lt;X&gt;, &quot;y&quot;: &lt;Y&gt;}, &quot;style&quot;: &lt;ShapeStyle&gt; }或： &quot;rect&quot;: { &quot;x&quot;: &lt;X&gt;, &quot;y&quot;: &lt;Y&gt;, &quot;width&quot;: &lt;Width&gt;, &quot;height&quot;: &lt;Height&gt;, &quot;style&quot;: &lt;ShapeStyle&gt; }或： &quot;ellipse&quot;: { &quot;x&quot;: &lt;X&gt;, &quot;y&quot;: &lt;Y&gt;, &quot;radiusX&quot;: &lt;RadiusX&gt;, &quot;radiusY&quot;: &lt;RadiusY&gt;, &quot;style&quot;: &lt;ShapeStyle&gt; }其中&lt;ShapeStyle&gt;是这样的： { &quot;lineWidth&quot;: &lt;Width&gt;, // 线宽 &quot;lineColor&quot;: &lt;Color&gt;, // 线型颜色 &quot;fillColor&quot;: &lt;Color&gt; // 填充色 }其中&lt;ZorderOperation&gt;可能的值为： “top”: 到最顶 “bottom”: 到最底 “front”: 往前一层 “back”: 往后一层 整体来说，这套网络协议比较直白体现了其对应的功能含义。我们遵循这样一套网络协议定义的范式： 创建对象：POST /objects 修改对象：POST /objects/&lt;ObjectID&gt; 删除对象：DELETE /objects/&lt;ObjectID&gt; 查询对象：GET /objects/&lt;ObjectID&gt; 其实还有一个列出对象，只不过我们这里没有用到： 列出所有对象：GET /objects 列出符合条件的对象：GET /objects?key=value 另外，有一个在网络设计时需要特别注意的点是：对重试的友好性。 为什么我们必须要充分考虑重试的友好性？因为网络是不稳定的。这意味着，在发生一次网络请求失败时，在一些场景下你不一定能确定请求的真实状态。 在小概率的情况下，有可能服务端已经执行了预期的操作，只不过返还给客户端的时候网络出现了问题。在重试时你以为只是重试，但实际上是同一个操作执行了两遍。 所谓重试的友好性，是指同一个操作执行两遍，其执行结果和只执行一遍一致。 只读操作，比如查询对象或列出对象，毫无疑问显然是重试友好的。 创建对象（POST /objects）往往容易被实现为重试不友好的，执行两遍会创建出两个对象来。我们对比一下这里创建新drawing和创建新shape的差别： POST /drawings POST /drawings/&lt;DrawingID&gt;/shapes Content-Type: application/json { &quot;id&quot;: &lt;ShapeID&gt;, &lt;Shape&gt; }可以看到，创建新 shape 时传入了 ShapeID，也就是说是由客户（浏览器端）分配 ShapeID。这样做的好处是如果上一次服务端已经执行过该对象的创建，可以返回对象已经存在的错误（我们用 status = 409 冲突来表示）。 而创建新 drawing 并没有传入什么参数，所以不会发生什么冲突，重复调用就会创建两个新 drawing 出来。 通过以上分析，我们可以认为：创建新 shape 是重试友好的，而创建 drawing 不是重试友好的。那么怎么解决这个问题？有这么几种可能： 客户端传 id（和上面创建新 shape 一样）； 客户端传 name； 客户端传 uuid。 当然这三种方式本质上的差别并不大。比如客户端传 name，如果后面其他操作引用时用的也是 name，那么本质上这个 name 就是 id。 传 uuid 可以认为是一种常规重试友好的改造手法。这里 uuid 并没有实际含义，你可以理解为它是 drawing 的唯一序列号，也可以理解为网络请求的唯一序列号。当然这两种不同理解的网络协议表现上会略有不同，如下： POST /drawings Content-Type: application/json { &quot;uuid&quot;: &lt;DrawingUUID&gt; } POST /drawings Content-Type: application/json X-Req-Uuid: &lt;RequestUUID&gt;修改对象和删除对象，往往是比较容易做到重试友好。但这并不绝对，比如我们这个例子中 “修改shape的顺序”，它的网络协议是这样的： POST /drawings/&lt;DrawingID&gt;/shapes/&lt;ShapeID&gt; Content-Type: application/json { &quot;zorder&quot;: &lt;ZorderOperation&gt; }其中&lt;ZorderOperation&gt;可能的值为： “top”: 到最顶 “bottom”: 到最底 “front”: 往前一层 “back”: 往后一层 在 ZorderOperation 为 “front” 或 “back” 时，重复执行两遍就会导致 shape 往前（或往后）移动 2 层。 怎么调整？ 有两个办法。一个方法是把修改操作用绝对值表示，而不是相对值。比如 ZorderOperation 为 “front” 或 “back” 是相对值，但是 Zorder = 5 是绝对值。 另一个方法是通用的，就是用请求的序列号（RequestUUID），这个方法在上面创建新 drawing 已经用过了，这里还可以用： POST /drawings/&lt;DrawingID&gt;/shapes/&lt;ShapeID&gt; Content-Type: application/json X-Req-Uuid: &lt;RequestUUID&gt; { &quot;zorder&quot;: &lt;ZorderOperation&gt; }当然用请求序列号是有额外代价的，因为这意味着服务端要把最近执行成功的所有的请求序列号（RequestUUID）记录下来，在收到带请求序列号的请求时，检查该序列号的请求是否已经成功执行，已经执行过就报冲突。 在网络协议的设计上，还有一个业务相关的细节值得一提。 细心的你可能留意到，我们 Shape 的 json 表示，在网络协议和 localStorage 存储的格式并不同。在网络协议中是： { &quot;id&quot;: &lt;ShapeID&gt;, &quot;path&quot;: { &quot;points&quot;: [ {&quot;x&quot;: &lt;X&gt;, &quot;y&quot;: &lt;Y&gt;}, ... ], &quot;close&quot;: &lt;Boolean&gt;, &quot;style&quot;: &lt;ShapeStyle&gt; } }而在 localStorage 中的是： { &quot;type&quot;: &quot;path&quot;, &quot;id&quot;: &lt;ShapeID&gt;, &quot;points&quot;: [ {&quot;x&quot;: &lt;X&gt;, &quot;y&quot;: &lt;Y&gt;}, ... ], &quot;close&quot;: &lt;Boolean&gt;, &quot;style&quot;: &lt;ShapeStyle&gt; }从结构化数据的 Schema 设计角度，localStorage 中的实现是无 Schema 模式，过于随意。这是因为 localStorage 只是本地自己用的缓存，影响范围比较小，故而我们选择了怎么方便怎么来的模式。而网络协议未来有可能作为业务的开放 API ，需要严谨对待。 版本升级另外，这个画图程序毕竟只是一个 DEMO 程序，所以还有一些常见网络协议的问题并没有在考虑范围之内。 比如从更长远的角度，网络协议往往还涉及协议的版本管理问题。网络协议是一组开放 API 接口，一旦放出去了就很难收回，需要考虑协议的兼容。 为了便于未来协议升级的边界，很多网络协议都会带上版本号。比如： POST /v1/objects POST /v1/objects/&lt;ObjectID&gt; DELETE /v1/objects/&lt;ObjectID&gt; GET /v1/objects/&lt;ObjectID&gt; GET /v1/objects?key=value在协议发生了不兼容的变更时，我们会倾向于升级版本，比如升为 v2 版本： POST /v2/objects POST /v2/objects/&lt;ObjectID&gt; DELETE /v2/objects/&lt;ObjectID&gt; GET /v2/objects/&lt;ObjectID&gt; GET /v2/objects?key=value这样做有这么一些好处： 可以逐步下线旧版本的流量，一段时间内让两个版本的协议并存； 可以新老版本的业务服务器相互独立，前端由 nginx 或其他的应用网关来分派。 第一个实现版本聊完了网络协议，我们就要开始考虑服务端的实现。在选择第一个实现版本怎么做时，有这样几种可能性。 第一种，当然是常规的憋大招模式。直接做业务架构设计、架构评审、编码、测试，并最后上线。 第二种，是做一个 Mock 版本的服务端程序。 两者有什么区别？ 区别在于，服务端程序从架构设计角度，就算是非业务相关的通用型问题也是很多的，比如高可靠和高可用。 高可靠是指数据不能丢。就算服务器的硬盘坏了，数据也不能丢。这还没什么，很多服务甚至要求，在机房层面出现大面积事故比如地震，也不能出现数据丢失。 高可用是指服务不能存在单点故障。任何一台甚至几台服务器停机了，用户还要能够正常访问。一些服务比如支付宝，甚至要求做到跨机房的异地双活。在一个机房故障时，整个业务不能出现中断。 在没有好的基础设施下，要做好一个好的服务端程序并不那么容易。所以另一个选择是先做一个 Mock 版本的服务端程序。 这不是增加了工作量？有什么意义？ 其一，是让团队工作并行。不同团队协作的基础就是网络协议。一个快速被打造的 Mock 的最小化版本服务端，可以让前端不用等待后端。而后端则可以非常便捷地自主针对网络协议进行单元测试，做很高的测试覆盖率以保证质量，进度不受前端影响。 其二 ，是让业务逻辑最快被串联，快速验证网络协议的有效性。中途如果发现网络协议不满足业务需求，可以及时调整过来。 所以我们第一版的服务端程序，是 Mock 的版本。Mock 版本不必考虑太多服务端领域的问题，它的核心价值就是串联业务。所以 Mock 版本的服务器甚至不需要依赖数据库，直接所有的业务逻辑基于内存中的数据结构就行。 代码如下： https://github.com/qiniu/qpaint/tree/v29/paintdom 正式版画图程序的服务端，我们会在后面服务端开发一章的实战中继续去完成。 从架构角度来说，这个 paintdom 程序分为两层：Model 层和 Controller 层。 我们首先看一下 Model 层。它的源代码是： paintdom/shape.go paintdom/drawing.go Model 层与网络无关，有的只是纯纯粹粹的业务核心逻辑。它实现了一个多文档版本的画图程序，逻辑结构也是一棵 DOM 树，只不过比浏览器端多了一层： Document =&gt; Drawing =&gt; Shape =&gt; ShapeStyle 浏览器端的 QPaintDoc，对应的是这里的 Drawing，而不是这里的 Document。 我们再来看一下 Controller 层。它的源代码是： paintdom/service.go Controller 层实现的是网络协议。你可能觉得奇怪，我为什么会把网络协议层看作 Controller 层，那么 MVC 中 View 层去了哪里。 首先服务端程序大部分情况下并不需要显示模块，所以不存在 View 层。网络协议层为什么可以看作 Controller 层，是因为它负责接受用户输入。只不过用户输入不是我们日常理解的用户交互，而是来自某个自动化控制（Automation）程序的 API 请求。 虽然这个 paintdom 程序的实现，有一些 Go 语言相关的知识点是挺值得讲的，尤其是网络协议实现相关的部分。不过我这里就不做展开了，感兴趣的同学可以自行学习一下 Go 语言。 总体来说，业务逻辑相关的部分理解起来相对容易，我们这里不再赘述。 结语今天我们重点讨论了 “画图” 程序的网络协议，给出了常规网络协议设计上的一些考量点。网络协议的地位非常关键，它是一个 B/S 或 C/S 程序前后端耦合的使用界面，因而也是影响团队开发效率的关键点。 如何及早稳定网络协议？如何及早让前端程序员可以与服务端联调？这些都是我们应该重点关注的地方。 定义清楚网络协议后，我们给出了满足我们定义的网络协议的第一个服务端实现版本 paintdom 程序，用于串联业务逻辑。这个实现版本是 Mock 程序，它只关注业务逻辑，不关心服务端程序的固有的高可靠、高可用等需求。后续在下一章服务端开发中，我们会继续迭代它。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们会把这个 paintdom 服务端程序，和我们的 paintweb 画图程序串联起来。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/29 | 实战（四）：怎么设计一个“画图”程序？/"},{"title":"26 | 实战（一）：怎么设计一个“画图”程序？","text":"你好，我是七牛云许式伟。 到上一讲为止，桌面程序架构设计的基本结构就讲完了。直到现在为止，我们没有讨论任何与具体的应用业务逻辑本身相关的内容。这是因为探讨的内容是普适有效的设计理念，整个讨论会显得很抽象。 今天我们结合一个实际的应用案例，来回顾一下前面我们介绍的内容。 我们选择了做一个 “画图” 程序。选它主要的原因是画图程序比较常见，需求上不需要花费过多的时间来陈述。 我们前面说过，一个 B/S 结构的 Web 程序，基本上分下面几块内容。 Model 层：一个多用户（Multi-User）的 Model 层，和单租户的 Session-based Model。从服务端来说，Session-based Model 是一个很简单的转译层。但是从浏览器端来说，Session-based Model 是一个完整的单租户 DOM 模型。 View 层：实际是 ViewModel 层，真正的 View 层被浏览器实现了。ViewModel 只有 View 层的数据和可被委托的事件。 Controller 层：由多个相互解耦的 Controller 构成。切记不要让 Controller 之间相互知道对方，更不要让 View 知道某个具体的 Controller 存在。 画图程序的源代码可以在 Github 上下载，地址如下： https://github.com/qiniu/qpaint 今天我们讨论浏览器端的 Model，View 和 Controller。 Model 层我们先看 Model 层。浏览器端的 Model 层，代码就是一个 dom.js 文件。它是一棵 DOM 树，根节点为 QPaintDoc 类。整个 DOM 树的规格如下： class QLineStyle { properties: width: number color: string methods: constructor(width: number, color: string) } class QLine { properties: pt1, pt2: Points lineStyle: QLineStyle methods: constructor(pt1, pt2: Point, lineStyle: QLineStyle) onpaint(ctx: CanvasRenderingContext2D): void } class QRect { properties: x, y, width, height: number lineStyle: QLineStyle methods: constructor(r: Rect, lineStyle: QLineStyle) onpaint(ctx: CanvasRenderingContext2D): void } class QEllipse { properties: x, y, radiusX, radiusY: number lineStyle: QLineStyle methods: constructor(x, y, radiusX, radiusY: number, lineStyle: QLineStyle) onpaint(ctx: CanvasRenderingContext2D): void } class QPath { properties: points: []Point close: bool lineStyle: QLineStyle methods: constructor(points: []Point, close: bool, lineStyle: QLineStyle) onpaint(ctx: CanvasRenderingContext2D): void } interface Shape { onpaint(ctx: CanvasRenderingContext2D): void } class QPaintDoc { methods: addShape(shape: Shape): void onpaint(ctx: CanvasRenderingContext2D): void }目前这个 DOM 还是单机版本的，没有和服务端的 Session-based Model 连起来。关于怎么连，我们下一讲再讨论。 这个 Model 层的使用是非常容易理解的，也非常直观体现了业务。主要支持的能力有以下两个方面。 其一，添加图形（Shape），可以是 QLine，QRect，QEllipse，QPath 等等。 其二，绘制（onpaint）。前面我们介绍 MVC 的时候，我曾提到为了 View 层能够绘制，需要让 DOM 层把自己的数据暴露给 View 层。 但是从简洁的方式来说，是让 Model 层自己来绘制，这样就避免暴露 DOM 层的实现细节。虽然这样让 Model 层变得有那么一点点不纯粹，因为和 GDI 耦合了。但是我个人认为耦合 GDI 比暴露 DOM 的数据细节要好，因为 GDI 的接口通常来说更稳定。 依赖选择是考虑耦合的一个关键因素。在依赖选择上，我们会更倾向于依赖接口更为稳定的组件，因为这意味着我们的接口也更稳定。 ViewModel 层我们再看 ViewModel 层。它的代码主要是一个 index.htm 文件和一个 view.js 文件。index.htm 是总控文件，主要包含两个东西： 界面布局（Layout）； 应用初始化（InitApplication），比如加载哪些 Controllers。 而 view.js 是我们 ViewModel 层的核心，实现了 QPaintView 类。它的规格如下： interface Controller { stop(): void onpaint(ctx: CanvasRenderingContext2D): void } class QPaintView { properties: doc: QPaintDoc properties: { lineWidth: number lineColor: string } drawing: DOMElement controllers: map[string]Controller methods: get currentKey: string get lineStyle: QLineStyle onpaint(ctx: CanvasRenderingContext2D): void invalidateRect(rect: Rect): void registerController(name: string, controller: Controller): void invokeController(name: string): void stopController(): void getMousePos(event: DOMEvent): Point events: onmousedown: (event: DOMEvent):void onmousemove: (event: DOMEvent):void onmouseup: (event: DOMEvent):void ondblclick: (event: DOMEvent):void onkeydown: (event: DOMEvent):void } var qview = new QPaintView()看起来 QPaintView 的内容有点多，我们归类一下： 和 Model 层相关的，就只有 doc: QPaintDoc 这个成员。有了它就可以操作 Model 层了。 属于 ViewModel 层自身的，数据上只有 properties 和 drawing。其中 properties 是典型的 ViewModel 数据，用来表示当前用户选择的 lineWidth 和 lineColor 等。drawing 则是浏览器对 HTML 元素的抽象，通过它以及 JavaScript 全局的 document 对象就可以操作 HTML DOM 了。 当然 ViewModel 层一个很重要的责任是绘制。onpaint 和 invalidRect 都是绘制相关。invalidRect 是让界面的某个区域重新绘制。当前为了实现简单，我们总是整个 View 全部重新绘制。 前面我说过， Web 开发一个很重要的优势是不用自己处理局部更新问题，为什么这里我们却又要自己处理呢？原因是我们没有用浏览器的 Virtual View，整个 DOM 的数据组织完全自己管理，这样我们面临的问题就和传统桌面开发完全一致。 剩下来的就是 Controller 相关的了。主要功能有： registerController（登记一个 Controller），invokeController（激活一个 Controller 成为当前 Controller），stopController（停止当前 Controller），View 层并不关心具体的 Controller 都有些什么，但是会对它们的行为规则进行定义； 事件委托（delegate），允许 Controller 选择自己感兴趣的事件进行响应； getMousePos 只是一个辅助方法，用来获取鼠标事件中的鼠标位置。 View 层在 MVC 里面是承上启下的桥梁作用。所以 View 层的边界设定非常关键。 如果我们把实际绘制（onpaint）的工作交给 Model 层，那么 View 基本上就只是胶水层了。但是就算如此，View 层仍然承担了一些极其重要的责任。 屏蔽平台的差异。Model 层很容易做到平台无关，除了 GDI 会略微费劲一点；Controller 层除了有少量的界面需要处理平台差异外，大部分代码都是响应事件处理业务逻辑，只要 View 对事件的抽象得当，也是跨平台的。 定义界面布局。不同尺寸的设备，界面交互也会不太一样，在 View 层来控制不同设备的整体界面布局比较妥当。 Controller 层最后我们看下 Controller 层。Controller 层的文件有很多，这还是一些 Controller 因为实现相近被合并到一个文件。详细信息如下。 Menu, PropSelectors, MousePosTracker： accel/menu.js Create Path：creator/path.js Create FreePath：creator/freepath.js Create Line, Rect, Ellipse, Circle： creator/rect.js 其中，menu.js 主要涉及各种命令菜单和状态显示用途的界面元素。用于创建各类图形（Shape），选择当前 lineWidth、lineColor，以及显示鼠标当前位置。 在创建图形这些菜单项上，有两点需要注意。 其一，菜单并不直接和各类创建图形的 Controller 打交道，而是调用 qview.invokeController 来激活对应的 Controller，这就避免了两类 Controller 相互耦合。 其二，虽然前面 Model 层支持的图形只有 QLine、QRect、QEllipse、QPath 等四种，但是界面表现有六种：Line、Rect、Ellipse、Circle、Path、FreePath 等等。这是非常正常的现象。同一个 DOM API 在 Controller 层往往会有多条实现路径。 选择当前 lineWidth、lineColor 操作的对象是 ViewModel 的数据，不是 Model。这一点前面几讲我们也有过交代。我们当时举的例子是 Selection。其实你把当前 lineWith、lineColor 看作是某种意义上的 Selection ，也是完全正确的认知。 鼠标位置跟踪（MousePosTracker）是一个极其简单，但也是一个很特殊的 Controller，它并不操作任何正统意义的数据（Model 或 ViewModel），而是操作输入的事件。 剩下来的几个 JavaScript 文件都是创建某种图形。它们的工作机理非常相似，我们可以随意选一个看一下。比如 QRectCreator 类，它的规格如下： class QRectCreator { methods: constructor(shapeType: string) stop(): void onpaint(ctx: CanvasRenderingContext2D): void onmousedown: (event: DOMEvent):void onmousemove: (event: DOMEvent):void onmouseup: (event: DOMEvent):void onkeydown: (event: DOMEvent):void }在初始化（构造）时，QRectCreator 要求传入一个 shapeType。这是因为 QRectCreator 实际上并不只是用于创建 Rect 图形，还支持 Line、Ellipse、Circle。只要通过选择两个 points 来构建的图形，都可以用 QRectCreator 这个 Controlller 来做。 QRectCreator 接管了 View 委托的 mousedown、mousemove、mouseup、keydown 事件。 其中，mousedown 事件记录下第一个 point，并由此开启了图形所需数据的收集过程，mouseup 收集第二个 point，随后后创建相应的 Shape 并加入到 DOM 中。keydown 做什么？它用来支持按 ESC 放弃创建图形的过程。 架构思维上我们学习到什么？通过分析这个 “画图” 程序，你对此最大的收获是什么？欢迎留言就此问题进行交流。这里我也说说我自己想强调的点。 首先，这个程序没有依赖任何第三方库，是裸写的 JavaScript 代码。关于这一点，我想强调的是： 第一，这并不是去鼓励裸写 JavaScript 代码，这只是为了消除不同人的喜好差异，避免因为不熟悉某个库而导致难以理解代码的逻辑； 第二，大家写代码的时候，不要被框架绑架，框架不应该增加代码的耦合，否则这样的框架就应该丢了；更真实的情况是，你很可能是在用一个好框架，但是是不是真用好了，还是取决于你自己的思维。 从架构设计角度来说，在完成需求分析之后，我们就进入了架构的第二步：概要设计（或者也可以叫系统设计）。这个阶段的核心话题是分解子系统，我们关心的问题是下面这些。 每个子系统负责什么事情？ 它依赖哪些子系统？它能够少知道一些子系统的存在么？ 它们是通过什么接口耦合的？这个接口是否自然体现了两者的业务关系？它们之间的接口是否足够稳定？ MVC 是一个分解子系统的基本框架，它对于桌面程序尤为适用。通过今天对 “画图” 程序的解剖，我们基本能够建立桌面程序框架上非常一致的套路： Model 层接口要自然体现业务逻辑； View 层连接 Model 与 Controller，它提供事件委托（delegate）方便 Controller 接收感兴趣的事件，但它不应该知道任何具体的 Controller； Controller 层中，每个 Controller 都彼此独立，一个 Controller 的职责基本上就是响应事件，然后调用 Model 或 ViewModel 的接口修改数据。 当然，这里没有讨论特定应用领域本身相关的架构问题。对于桌面程序而言，这件事通常发生在 Model 层。但对于我们今天的例子 “画图” 程序而言，Model 层比较简单，基本上还不太需要讨论。在后面，我们也可能会尝试把这个 “画图” 程序需求变复杂，看架构上应该怎么进行应对。 结语今天我们结合一个大家非常熟悉的例子 “画图” 程序来介绍 MVC 架构。虽然我们基于 Web 开发，但是我们当前给出的画图程序本质上还是单机版的。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将继续实战一个联网版本的画图程序。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/26 | 实战（一）：怎么设计一个“画图”程序？/"},{"title":"30  | 实战（五）：怎么设计一个“画图”程序？","text":"你好，我是七牛云许式伟。 我们继续聊我们的话题。这是画图程序的最后一讲了。当然我们后续还会结合这个实战程序展开讨论有关于架构的方方面面。 宏观的系统架构上一讲开始，我们的画图程序有了跨团队协作：因为我们开始有了 paintdom 和 paintweb 两大软件。paintdom 监听的地址是 localhost:9999，而 paintweb 监听的地址是 localhost:8888。 应当注意，在实际业务中它们是不同的软件，事实上我们 paintweb 程序也完全是以进程间协作的方式，通过反向代理机制来调用 paintdom 的功能。但是在我们这个画图 DEMO 程序中，它们同属一个进程，paintdom 作为 paintweb 的一个 goroutine 在跑。这纯粹是因为我们想让这两个程序 “同生共死”，方便调试的时候起停进程。 paintdom 和 paintweb 之间相互协作的基础，是它们之间所采用的网络协议。 当我们说起网络协议，它其实通常包含两个层面的意思：其一是我们网络协议的载体，也就是协议栈（我们这里采纳的是 HTTP 协议，而 HTTP 协议又基于 TCP/IP 协议）；其二是我们网络协议承载的业务逻辑。 当我们谈架构的时候，也会同时聊这两个层面，只是它们在不同的维度。我们会关心网络协议的协议栈选择什么，是基于 HTTP 还是基于自定义的二进制协议，这个是属于基础架构的维度。我们也会关心网络协议的业务逻辑，判断它是否自然体现业务需求，这是属于应用架构的维度。 明确了网络协议后，我们实现了 Mock 版本的服务端程序 paintdom。在实际项目中，Mock 程序往往会大幅提速团队的开发效率。这是因为它能够达到如下两个大的核心目标： 让团队的研发迭代并行，彼此可以独立演进。 及早验证网络协议的合理性，在实战中达到用最短时间稳定协议的目的。 上一讲我们的 paintdom 和 paintweb 之间虽然定义了网络协议，并且实现了第一版，但是并没有去做两者的对接。 今天我们就来对接它们。 虽然 paintweb 没有对接服务端，但从文档编辑的角度来说，它的功能是非常完整的。我们对接 paintdom 和 paintweb 的目的不是加编辑功能，而是让文档可以存储到服务端，以便于人们在世界任何可以联网的角落都可以打开它。 当然严谨来说，说 paintweb 没有服务端是不正确的，paintweb 本身是一个 B/S 结构，它有它自己的服务端。如下： var wwwServer = http.FileServer(http.Dir(&quot;www&quot;)) func handleDefault(w http.ResponseWriter, req *http.Request) { if req.URL.Path == &quot;/&quot; { http.ServeFile(w, req, &quot;www/index.htm&quot;) return } req.URL.RawQuery = &quot;&quot; // skip &quot;?params&quot; wwwServer.ServeHTTP(w, req) } func main() { http.HandleFunc(&quot;/&quot;, handleDefault) http.ListenAndServe(&quot;:8888&quot;, nil) }可以看出，paintweb 自己的服务端基本上没干什么事情，就是一个非常普通的静态文件下载服务器，提供给浏览器端下载 HTML + CSS + JavaScript 等内容。 所以 paintweb 的服务端完全是“平庸”的，与业务无关。具体的业务，都是通过 www 目录里面的文件来做到的。这些文件都是前端的浏览器端所依赖的，只不过被 “托管” 到 paintweb 服务端而已。 那么 paintweb 怎么对接 paintdom 呢？ 物理上的对接比较简单，只是个反向代理服务器而已，代码如下： func newReverseProxy(baseURL string) *httputil.ReverseProxy { rpURL, _ := url.Parse(baseURL) return httputil.NewSingleHostReverseProxy(rpURL) } var apiReverseProxy = newReverseProxy(&quot;http://localhost:9999&quot;) func main() { http.Handle(&quot;/api/&quot;, http.StripPrefix(&quot;/api/&quot;, apiReverseProxy)) }可以看出，paintweb 的服务端干的事情仍然是 “平庸” 的，只是把发往 http://localhost:8888/api/xxx 的请求，原封不动地发往 http://localhost:9999/xxx 而已。 在现实中，paintweb 的服务端干的事情稍微复杂一些。它背后不只是有业务服务器 paintdom，还有必不可少的帐号服务器（Account Service），用来支持用户登录/登出。 帐号服务器是一个基础架构类的服务，与业务无关。公司很可能不只有 QPaint 这样一个业务，还会有别的，但这些业务可以共享相同的帐号服务。更准确地说，是必须共享相同的帐号服务，否则一个公司弄出好多套独立的帐号体系来，用户也会有所诟病。 在需要对接帐号服务器的情况下，实际上 paintweb 的服务端并不是原封不动地转发业务请求，而是会对协议进行转义。 在 “24 | 跨平台与 Web 开发的建议”这一讲中我们提到过： 到了 Web 开发，我们同样需要二次开发接口，只不过这个二次开发接口不再是在 Client 端完成的，而是在 Server 端完成。Server 端支持直接的 API 调用，以支持自动化（Automation）方面的需求。 所以，对 Server 端来说，最底层的是一个多租户的 Model 层（Multi-User Model），它实现了自动化（Automation）所需的 API。 在 Multi-User Model 层之上，有一个 Web 层。Web 层和 Model 层的假设不同，Web 层是基于会话的（Session-based），因为它负责用户的接入，每个用户登录后，会形成一个个会话（Session）。 如果我们对Web 层细究的话，又分为 Model 层和 ViewModel 层。为了区分，Web 这边的 Model 层我们叫它 Session-based Model。相应地，ViewModel 层我们叫它 Session-based ViewModel。 在服务端，Session-based Model 和 Session-based ViewModel 并不发生直接关联，它们通过自己网络遥控浏览器这一侧的 Model 和 ViewModel，从而响应用户的交互。 Session-based Model 是什么样的呢？它其实是 Multi-User Model 层的转译。把多租户的 API 转译成单租户的场景。所以这一层并不需要太多的代码，甚至理论上自动实现也是有可能的。 Session-based ViewModel 是一些 HTML+JavaScript+CSS 文件。它是真正的 Web 业务入口。它通过互联网把自己的数据返回给浏览器，浏览器基于 ViewModel 渲染出View，这样整个系统就运转起来了。 这段话说的比较抽象，但结合 QPaint 这个实际的例子，就非常明朗了： paintdom 就是这里说的 Multi-User Model 层，负责多租户的业务服务器。 paintweb 服务端实现 Session-based Model 层，负责 Session-based 到 Multi-User 的转译。由于我们当前这个例子还不支持多租户，转译就变成了简单的转发。后面我们在 “服务端开发” 一节中会给大家看实际的转译层是怎么做的。 所以你可以看到，其实 paintweb 自身的服务端是业务无关的。它做这样一些事情： Web 前端文件的托管（作为静态文件下载服务器）； 支持帐号服务，实现 Web 的用户登录； 做业务协议的转译，将 Session-based 的 API 请求转为 Multi-User 的 API 请求。 当然，我们这里假设 Web 自身的业务逻辑都是通过 JavaScript 来实现的。这意味着我们是基于 “胖前端” 模式的。 但这并不一定符合事实，有些公司会基于 “胖后端” 模式。这意味着大部分的前端用户行为，都是由后端支持的，比如我们用 PHP 来实现 Web 后端的业务代码。 胖后端模式的好处是 Web 代码比较安全。这里的 “安全” 是指 IT 资产保全方面的安全，不是指业务存在安全问题，因为别人看不到完整的 Web 业务逻辑代码。 但是胖后端模式的\b缺点是没办法支持离线。大部分的用户交互都需要 Web 后端来响应，一旦断了网就什么都干不了了。 在 “胖后端” 模式下，我个人会倾向于基于类似 PHP 这种胶水语言来实现 Web 后端的业务代码。而一旦我们这么做，paintweb 的业务逻辑就被剥离了，paintweb 自身的后端仍然是业务无关的，只是多了一个职责：支持 PHP 脚本语言。 真正 Web 后端业务逻辑，还是放在了 www 目录中，以 PHP 文件存在，这些文件就不是简单的静态资源，而是 “胖后端” 的业务代码。 既然 paintweb 后端是 “平庸” 的，与业务无关，那么整个业务逻辑的串联，靠的就是 www 里面的 js 文件，和 paintdom 提供的 API 接口。 上面我们说过，在连接 paintdom 之前，paintweb 程序独立看是完整的，它支持离线创建、编辑以及存储文档到浏览器本地的 localStorage 上。 对接 paintdom 与 paintweb 后我们并不会放弃离线编辑的能力，而是要能够做到： 在断网情况下，表现为上一讲我们达到的效果，可以继续离线编辑和保存； 一旦联网，所有离线编辑的内容可以自动保存到 paintdom 服务器。 计算变更听起来挺简单一件事情？ 其实很复杂。第一件要做的事情是：怎么知道断网后离线编辑过的内容有哪些？ 思路一是不管三七二十一，每次都完整保存整篇文档。这很浪费，因为不单单刚恢复联网的时候我们需要保存文档，平常每一次编辑操作我们也都会自动保存修改的内容。 思路二是记录完整的编辑操作历史，每做一个编辑操作都将其记录到 localStorage。这个思路看似会更节约，但是实际上在很多情况下会更浪费。原因在于： 一个对象编辑多次，会有很多条编辑操作的指令要保存； 断网久了，编辑操作累计下来，其存储空间甚至可能超过文档大小。 所以这种方案缺乏很好的鲁棒性，在 badcase 情况下让人难以接受。 思路三是给对象增加版本号。通过对比整个文档的基版本（baseVer，即上一次同步完成时的版本），与某个对象的版本 ver。如果 ver &gt; baseVer，说明上一次同步完成后，该对象发生了变更。完整的变更信息的计算逻辑如下： prepareSync(baseVer) { let shapeIDs = [] let changes = [] let shapes = this._shapes for (let i in shapes) { let shape = shapes[i] if (shape.ver &gt; baseVer) { changes.push(shape) } shapeIDs.push(shape.id) } let result = { shapes: shapeIDs, changes: changes, ver: this.ver } this.ver++ return result }同步变更有了变更的信息，怎么同步给服务端？ 一个可能的思路是把变更还原为一条条编辑操作发给服务端。但是，这样做问题会很复杂，因为这些编辑操作一部分发送成功，一部分发送失败怎么办？ 这种部分成功的中间态是最挑战我们程序员的编程水平的，很烧脑。 我个人一贯坚持的架构准则是不要烧脑。尤其对大部分非性能敏感的业务代码，简单易于实施为第一原则。 所以我们选择了修改网络协议。增加了同步接口： 这很有趣。在我们讨论相互配合的接口时，我们非常尊重业务逻辑，按照我们对业务的理解，定义了一系列的编辑操作。但是，到最后我们却发现，它们统统不管用，我们要的是一个同步协议。 是最初我们错了吗？ 也不能这么说。最初我们定义协议的逻辑并没有错，只是没有考虑到支持离线编辑这样的需求而已。 复盘这件事情，我们可以这么说： 需求的预见性非常重要。如果我们没有充分预见到需求，大部分情况下就会因为我们缺乏市场洞察而买单； 进一步说明，及早推出 Mock，让前端可以快速迭代，进而及早去发现原先定义网络协议的不足是很有必要的。越晚做出协议调整，事情就越难，也越低效。 有了同步协议，我们就可以把变更信息同步给服务端了。这个事情我们交给了 QSynchronizer 类来完成（详细请看 dom.js#L204）。 加载文档把变更详细推送给服务端后，理论上我们就可以在世界各地看到这篇文档。 怎么做到？ 我们接下来就谈谈怎么来加载文档。这个过程的难点在于怎么根据服务端返回的 json 数据重建整个文档。 上一讲我们已经说过，我们图形（Shape）的网络协议中的数据格式，和 localStorage 中是不同的。这意味着我们需要做两套图形数据的加载工作。 这挺没有必要。 而且，从预测变更的角度，我们很容易预期的一个变化，就是画图程序支持的图形（Shape）的种类会越来越多。 这两个事情我们一起看。为此我们做了一次重构。重构目标是： 统一 localStorage 和网络协议中的图形表示； 增加新的图形种类要很容易，代码非常内聚，不必到处修改代码。 为此我们增加 qshapes: QSerializer 全局变量，允许各种图形类型注册自己的创建方法（creator）进去。示意代码如下： qshapes.register(&quot;rect&quot;, function(json) { return new QRect(json) })为了支持 QSerializer 类（代码参见 dom.js#L89），每个图形需要增加两个方法： interface Shape { constructor(json: Object) toJSON(): Object }这样我们就可以调用 qshapes.create(json) 来创建一个图形实例。 有了这个能力，我们加载文档就水到渠成了，具体代码请参考 QPaintDoc 类的 _loadRemote(displayID) 方法（参见 dom.js#L690）。 完整来说，加载文档的场景分为这样三类： _loadBlank，即加载新文档。在联网情况下，会在服务端创建一个新 drawing。在非联网情况下，会本地创建一个临时文档（displayID 以 t 开头）。 _loadTempDoc，即加载一个临时文档。即该文档从创建之初到目前，一直都处于离线编辑的状态。同样它也分两个情况，如果当前处于联网状态下，会在服务端创建一个新 drawing，并把当前的离线编辑的数据同步过去。如果在非联网的情况下，会加载离线编辑的数据，并可继续离线编辑。 _loadRemote，即加载一个远程文档。该文档在本地有可能编辑过，那么会先加载本地缓存的离线编辑的数据。如果当前处于联网状态，会异步加载远程文档，成功后本地离线编辑的内容会被放弃。 另外，加载文档结束后，QPaintDoc 会发出 onload 消息。这个消息当前会被 QPaintView 响应，用来刷新界面，代码如下： class QPaintView { constructor() { ... let view = this this.doc.onload = function() { view.invalidateRect(null) } ... } }之所以会有 onload 消息，是因为向服务器的 ajax 请求，什么时候完成是比较难预期的，我们加载文档是在异步 ajax 完成之后。这样来看，完成文档加载后发出 onload 事件，就可以避免 Model 层需要去理解 View 层的业务逻辑。 Model 层的厚度介绍到这里，我们基本上把本次迭代的主体内容介绍清楚了。其他有些小细节的变动，我们不再赘述。详细的代码变更请参阅： https://github.com/qiniu/qpaint/compare/v29…v30 下面我想聊的话题是关于 Model 层的厚度问题。我们在 “22 | 桌面程序的架构建议” 中提到： 从界面编程角度看，Model 层越厚越好。为什么这么说？因为这是和操作系统的界面程序框架最为无关的部分，是最容易测试的部分，也同时是跨平台最容易的部分。我们把逻辑更多向 Model 层倾斜，那么 Controller 层就简洁很多，这对跨平台开发将极其有利。 我们秉承的理念是 Model 层越厚越好。事实上在这次 “画图” 程序实战中，我们在一直坚持这一点。让我们来观测两组数据。 其一，不同版本（v26…v30）的 Model 层（dom.js）对比： MVP 版本（v26 版）的 dom.js ，约 120 行。 最新版本（v30 版）的 dom.js ，约 860 行。 Model 层的代码行翻了多少倍？7.x 倍。 其二，不同版本（v26…v30）的变更历史： v27：https://github.com/qiniu/qpaint/compare/v26…v27 v28：https://github.com/qiniu/qpaint/compare/v27…v28 v29：https://github.com/qiniu/qpaint/compare/v28…v29 v30：https://github.com/qiniu/qpaint/compare/v29…v30 不知道你看出什么来了吗？ 一个有趣的事实是，多个版本的迭代，基本上都是以变更 Model 层为多。v29 版本的变更看似比较例外，没有修改 dom.js。但是实际上 v29 整个变更都是 Model 层的变更，因为是增加了服务端的 Model（我们前面把它叫做 Multi-User Model）。 我们深刻思考这个问题的话，我们会有这样一个推论： 如果我们不是让 Model 层代码以内聚的方式放在一起，而是让它自由的散落于各处，那么我们的代码变更质量会非常不受控。 为什么？Model 层总体来说是最容易测试的，因为它的环境依赖最小。如果这些代码被分散到 View、Controller 层中，代码的阅读难度、维护难度、测试的难度都会大幅增加。 通过几轮的功能迭代，我们对 Model 层的认知在不断的加深。我们总结一下它的职责，如下： 业务逻辑，对外暴露业务接口。它也是 Model 的最本职的工作。 实现 View 层委托的 onpaint 事件，完成绘制功能。 实现 Controller 层的 hitTest 接口，用来实现 selection 支持。 实现与服务端 Multi-User Model 层的通讯，View、Controllers 组件都不需要感知服务端。 实现离线编辑 localStorage 的存取。 除了少量 View（onpaint）、Controllers（hitTest）的需求，大部分都是 Model 层的正常业务范畴。 这些职责已经很多，所以 Model 层自然会胖。 结语今天我们完成了画图程序前后端 paintdom、paintweb 的对接。由于考虑支持离线编辑，对接工作有较大的复杂性，你如果不能理解，建议仔细对代码进行研读。当然后面我们还会掰开来细谈这个案例。 这是最新版本的源代码： https://github.com/qiniu/qpaint/tree/v30 到这里我们的实战过程就先告一段落了。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。到现在为止，我们探讨的都是一个完整的桌面应用程序（可能是单机的，也可能是 B/S 结构的）的业务架构。 下一讲我们会谈谈辅助界面元素（自定义控件）的架构设计，它和应用程序的业务架构考虑的问题颇有不同。 话外：按照大纲，当前进度还只有 1/3 的内容。看起来我们最终会比原计划的 58 讲超出不少，可能要往 90 讲去了。关于这一点，我总体还是以说清楚事情为目标，在聊的过程会根据反馈作出适当的调整。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/30  | 实战（五）：怎么设计一个“画图”程序？/"},{"title":"33 | 桌面开发篇：回顾与总结","text":"你好，我是七牛云许式伟。 到今天为止，我们第二章 “桌面开发篇” 就要结束了。今天，让我们对整章的内容做一个回顾与总结。本章我们主要涉及的内容如下。 这一章的内容主要分为三类。 一类是基础平台，也就是上图中的浅绿色背景部分，谈的是 Native 桌面操作系统和浏览器的演变过程。 一类是业务架构，也就是上图中的浅棕色背景部分，谈得是如何开发一个桌面软件。 最后一类是实战，也就是上图浅黄色背景部分，我们以画图程序作为例子谈业务架构，并对需求进行了多次的迭代。 通过本章的内容，我们总结一下桌面开发的特点。 首先从基础平台看。它的特点是：种类多、迭代快、知识有效期短。让桌面开发工程师（大前端）痛苦的是，时不时就有各种新平台、新语言、新框架冒出来，让人应接不暇。 其次从要开发的产品本身看。它的特点是：需求多、迭代快。桌面开发（大前端）负责的是和活生生的个体打交道，我们的开发人员需要为了功能丰富，体验便捷做各种努力。 为了让产品有竞争力，很多团队的发布周期都是至少一个月迭代一个版本，有的甚至是一周发布一个版本。而Web 前端就更夸张了，一些公司甚至没有统一的发版概念，只要某个功能产品经理验收了，测试验收了，就可以发。 最后我们从对程序员的技能要求看。它的特点是门槛极低，但天花板又极高。 桌面开发（大前端）的代码量大，代码变更又很频繁，所以它对程序员的第一要求，不是质量，而是数量上的需求极大。为什么 GitHub 的语言排行榜总是 JavaScript 排名第一？这不是别的原因，是市场需求所致。 与之相对的，服务端开发则非常不同。服务端开发并不是一上来就有的，是互联网出现后产生的新分工。它并不负责用户交互，所以在需求提炼时可以做到极强的可预测性。因而服务端的第一挑战往往不是快速响应，而是性能和稳定性等质量需求。 桌面开发的客观需求量大，这决定了它的门槛要求必须极低。我在描述桌面开发的未来也提到过，桌面开发技术的演进方向，是 7-8 岁的儿童也可以开发生产级的应用。这是门槛低的极致状态。 但是为什么我又说桌面开发的天花板又极高呢？因为桌面开发的团队人数多、人员质量参差不齐、代码量大、迭代变更频繁，这意味着桌面软件工程项目的管理难度极高。所以桌面开发对架构师能力、软件工程的水平要求之高，要远高于服务端开发。 当然，从国内的现状来说，凡是堆人和加班可以解决的，最终都是用堆人和加班解决。架构师能力培养和软件工程能力提升？对大部分公司来说，他们的想法可能是：这太慢了，等不起。 桌面开发篇的内容回顾这一章前面我们讲了些什么？为了让你对第二章内容有个宏观的了解，我画了一幅图，如下。 我们首先从单机软件开发讲起。我们开篇第一讲首先回顾了桌面开发关于交互方式的变更。从最早命令行程序，到 2D/3D GUI 图形界面程序，到智能交互程序的萌芽。 为什么我们从交互变更谈起？因为这是桌面系统迭代的根源。每一次桌面系统大的变更周期，都是由一场新的交互革命所驱动。 随后，我们介绍了今天仍然处于主流地位的图形界面操作系统提供的编程框架。尽管使用接口各不相同，但是今天主流桌面操作系统的框架本质大同小异，都是基于事件分派做输入，GDI 做界面呈现。 互联网的出现，衍生出了浏览器，它支持了一种新的应用形态：Web 应用。这意味着在操作系统之上，产生了一个新操作系统。Web 应用也在演变，从静态页，到以 Gmail 为代表的 AJAX 应用，到 PWA，到小程序。 PC 浏览器之争已经结束，但移动浏览器的竞争才刚开始。 怎么做一个桌面程序？标准的套路是 MVC 架构。无论是单机还是 Web 应用，它都是适用的，只是 Web 程序需要考虑客户端与服务端的分工，需要引入网络协议。 跨平台开发，是桌面程序开发绕不过去的问题。几年前也许不明显，这得益于 Android 和 iOS 的垄断。但是现在又回到了群雄逐鹿的时期。Native 手机操作系统、传统 Web、众多的小程序种类、国际市场的 PWA 等等，需要综合考虑进行取舍。 聊完单机软件和 Web 应用，我们也探讨了桌面开发的未来趋势。桌面开发技术的演进，目标是越来越低的门槛，它和儿童编程教育相向而行，有一天必然汇聚于一点上。 为了让你更好地理解桌面开发的架构逻辑，我们引入了一个长达 5 讲的实战案例。这个案例建议深度消化。 为什么实战是很重要的？ 学架构，我个人强调的理念是 “做中学”。 首先还是要勤动手。然后配合本专栏去思考和梳理背后的道理，如此方能快速进步。 我们不能把架构课学成理论课。计算机科学本身是一门实践科学，架构经验更是一线实战经验的积累和总结。 通过这个实战案例，我们也探讨了辅助界面元素，也就是控件的架构。控件架构没有什么特别的地方，唯一需要注意的是支持多实例。用多实例去思考你的应用程序架构的合理性，会有助于你对架构设计中的一些决策提供帮助。 当然更重要的，其实是让你有机会形成更好的架构设计规范。 作为最后收官，我们聊了架构第二步：系统的概要设计，简称系统设计。我们这个阶段关注的是全局性的风险，怎么保证项目可以按时、按质、高度并行化地被执行。 系统架构打的是地基。 这个阶段需要选择操作系统、选择语言、选择主框架，选择项目所依赖的最核心的基础设施。这就是我说的有关于基础架构的工作。 这个阶段也需要分解业务系统。我们一般以子系统为维度来阐述系统各个角色之间的关系。对于关键的子系统，我们还会进一步分解它，甚至详细到把该子系统的所有模块的职责和接口都确定下来。 这个阶段我们的核心意图并不是确定系统完整的模块列表，我们的焦点是整个系统如何被有效地串联起来。如果某个子系统不作进一步的分解也不会在项目上有什么风险，那么我们并不需要在这个阶段对其细化。 为了降低风险，概要设计阶段也应该有代码产出。 这样做的好处是，一上来我们就关注了全局系统性风险的消除，并且给了每个子系统或模块的负责人一个更具象且确定性的认知。 代码即文档。代码是理解一致性更强的文档。 桌面开发篇的参考资料桌面开发的知识迭代更新非常快，所以很难去列经典书籍。 这里我列一下我认为值得重点关注的技术： JavaScript。毫无疑问，这是当前桌面开发的第一大语言，务必要精通。这方面我推荐程劭非（winter）的极客时间专栏“重学前端”。 微信小程序。这方面资料比较少，我推荐高磊的极客时间视频课“9小时搞定微信小程序开发”。 React 和 Vue。这应该当前比较知名的两大前端框架，可以学习一下。前者可以看下王沛的“React实战进阶45讲”，后者可以看下唐金州的“Vue开发实战”。 Flutter 和 SwiftUI。这两个技术很新，其中 Flutter 已经有一些资料，比如陈航的“Flutter核心技术与实战”。SwiftUI 与 Swift 语言关联很紧，在张杰的“Swift核心技术与实战”中有所涉略。 PWA 和 WebAssembly。这方面图书还比较少，不妨看官方材料结合实战来学习。 当然，经典的 Android、iOS 方面的开发资料，也值得看看。这方面资料非常多，我就不再去提名了。 结语今天我们对本章内容做了概要的回顾，并借此对整个桌面开发的骨架进行了一次梳理。 这一章我们开始聊业务架构。学业务架构最好的方式是：“做中学”。做是最重要的，然后要有做后的反思，去思考并完善自己的理论体系。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们开始进入第三章：服务端开发篇。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/33 | 桌面开发篇：回顾与总结/"},{"title":"32 | 架构：系统的概要设计","text":"你好，我是七牛云许式伟。 我们第二章 “桌面开发篇” 就快要结束了。今天我们把话题重新回到架构上。 基础架构与业务架构桌面开发篇我们主要涉及的内容如下。 对于一位架构师而言，其架构工作的内容可以大体分为两块，一块是基础架构，一块是业务架构。 基础架构，简单来说就是做技术选型。选择要支持的操作系统、选择编程语言、选择技术框架、选择第三方库，这些都可以归结为基础架构方面的工作。 基础架构的能力，考验的是选择能力。背后靠的是技术前瞻性和判断力。这并不简单。大部分架构师往往更容易把关注点放到业务架构上，但实际上基础架构的影响面更广，选错产生的代价更高。 架构师之间的差距，更大的是体现在其对待基础架构的态度和能力构建上。真正牛的架构师，一定会无比重视团队的技术选型，无比重视基础平台的建设。阿里提倡的 “大中台、小前台”，本质上也是在提倡基础平台建设，以此不断降低业务开发的成本，提升企业的创新能力。 业务架构，简单来说就是业务系统的分解能力。基础架构其实也是对业务系统的分解，只不过分解出了与业务属性几乎无关的部分，形成领域无关的基础设施。而业务架构更多的是分解领域问题 。 一旦我们谈业务架构，就避不开领域问题的理解。所谓领域问题，谈的是这个领域的用户群面临的普遍需求。所以我们需要对用户的需求进行分析。 在第一章，我们已经聊了需求分析： 17 | 架构：需求分析（上） 18 | 架构：需求分析（下）- 实战案例 这是我们开始业务架构的第一步。没有需求分析，就没有业务架构。在业务架构过程中，需求分析至少应该花费三分之一以上的精力。 今天，我们聊一聊架构的第二步：系统的概要设计，简称系统设计。 系统设计，简单来说就是 “对系统进行分解” 的能力。这个阶段核心要干的事情，就是明确子系统的职责边界和接口协议，把整个系统的大框架搭起来。 那么怎么分解系统？ 首先我们需要明确的是分解系统优劣的评判标准。也就是说，我们需要知道什么样的系统分解方式是好的，什么样的分解方式是糟糕的。 最朴素的评判依据，是这样两个核心的点： 功能的使用界面（或者叫接口），应尽可能符合业务需求对它的自然预期； 功能的实现要高内聚，功能与功能之间的耦合尽可能低。 在软件系统中有多个层次的组织单元：子系统、模块、类、方法/函数。子系统如何分解模块？模块如何分解到更具体的类或函数？每一层的分解方式，都遵循相同的套路。也就是分解系统的方法论。 接口要自然体现业务需求我们先看功能的使用界面（或者叫接口）。 什么是使用界面？ 对于函数，它的使用界面就是函数原型。 package packageName func FuncName( arg1 ArgType1, ..., argN ArgTypeN ) (ret1 RetType1, ..., retM RetTypeM)它包含三部分信息。 函数名。严谨来说是包含该函数所在的名字空间的函数名全称，比如上例是 packageName.FuncName。 输入参数列表。每个参数包含参数名和参数类型。 输出结果列表。每个输出结果包含结果名和结果类型。当然，很多语言的函数是单返回值的，也就是输出结果只有一个。这种情况下输出结果没有名称，只有一个结果类型，也叫返回值类型。 对于类，它的使用界面是类的公开属性和方法。 package packageName type ClassName struct { Prop1 PropType1 ... PropK PropTypeK } func (receiver *ClassName) MethodName1( arg11 ArgType11, ..., arg1N1 ArgType1N1 ) (ret11 RetType11, ..., ret1M1 RetType1M1) ... func (receiver *ClassName) MethodNameL( argL1 ArgTypeL1, ..., argLNL ArgTypeLNL ) (retL1 RetTypeL1, ..., retLML RetTypeLML)它包含以下内容。 类型名。严谨来说是包含该类型所在的名字空间的类型名全称，比如上例是 packageName.ClassName。 公开属性列表。每个属性包含属性名和属性类型。Go 语言对属性的支持比较有限，直接基于类型的成员变量来表达。而一些语言，比如 JavaScript，对属性的支持比较高级，允许给某个属性设定 get/set 方法。这样就能够做到只读、只写、可读写三种属性。 公开方法列表。 方法和函数本质上是一样的，有的只是细节不同。这表现在下面几点。 名字空间不同。普通函数的函数名全称是 packageName.FuncName，而方法的方法名全称是 packageName.(*ClassName).MethodName 这种形式。 方法相比函数多了一个概念叫 receiver（接受者），也就是方法所作用的对象。在 Go 语言中 receiver 是显式表达的。但大部分语言中 receiver 是隐藏的，通常名字叫 this 或 self。 对于模块，它的使用界面比较多样，需要看模块类型。典型的模块类型有这样一些： 包（package）。一些语言中也叫静态库（static library）。 动态库（dynamic library）。在 Go 语言中有个特殊的名称叫插件（plugin）。 可执行程序（application）。 对于包（package）和动态库（dynamic library），这两者都是代码的一种发布形态，只是标准的制定方不同。包（package）一般是由编程语言定义的，对开发者比较友好。而动态库（dynamic library）一般是操作系统定义的，可以做到跨语言，但是对开发者往往不太友好。为什么不友好？因为它要定义跨语言的符号定义和类型定义的标准。这意味着它只能取多个编程语言之间的共性部分。 对于可执行程序（application），又要分多种情况。最常见的可执行程序有这么几类： 网络服务程序（service）； 命令行程序（command line application）； 桌面程序（GUI application） 对于网络服务程序（service），它的使用界面是网络协议。前面我们在 “画图” 程序实战（四）这一讲中也有定义过画图服务端的网络协议。如下： 对于命令行程序（command line application），它的使用界面包括： 命令行，包括：命令名称、开关列表、参数列表。例如：CommandName -Switch1 … -SwitchN Arg1 … ArgM。 标准输入（stdin）。 标准输出（stdout）。 对于桌面程序（GUI application），它的使用界面就是用户的操作方式。桌面程序的界面外观当然是重要的，但不是最重要的。最重要的是交互范式，即用户如何完成功能的业务流程的定义。为什么我们需要专门引入产品经理这样的角色来定义产品，正是因为使用界面的重要性。 以上这些组织单元都物理上存在，最后我们还剩一个概念：子系统。在实际开发中，并不存在物理的实体与子系统这个概念对应，它只存在于架构设计的文档中。 那么怎么理解子系统？ 子系统是一个逻辑的概念，物理上可能对应一个模块（Module），也可能是多个模块。你可以把子系统理解为一个逻辑上的大模块（Big Module），这个大模块我们同样会去定义它的使用接口。 子系统与模块的对应方式有两种常见的情况。 一种情况，也是最常见的情况，子系统由一个根模块（总控模块）和若干子模块构成。子系统的使用接口，就是根模块的使用接口。 另一种情况，是子系统由多个相似的模块构成。例如对于 Office 程序来说，IO 子系统由很多相似模块构成，例如 Word 文档读写、HTML 文档读写、TXT 文档读写、PDF 文档读写等等，这些模块往往有统一的使用界面。 通过上面对子系统、模块、类、函数的使用界面的解释，你会发现其实它们是有共性的。它们都是在定义完成业务需求的方法，只不过需求满足方式的层次不一样。类和函数是从语言级的函数调用来完成业务，网络服务程序是通过网络 RPC 请求来完成业务，桌面程序是通过用户交互来完成业务。 理解了这一点，你就很容易明白，“功能的使用界面应尽可能符合业务需求对它的自然预期” 这句话背后的含义。 一个程序员的系统分解能力强不强，其实一眼就可以看出来。你都不需要看实现细节，只需要看他定义的模块、类和函数的使用接口。如果存在大量说不清业务意图的函数，或者存在大量职责不清的模块和类，就知道他基本上还处在搬砖阶段。 无论是子系统、模块、类还是函数，都有自己的业务边界。它的职责是否足够单一足够清晰，使用接口是否足够简单明了，是否自然体现业务需求（甚至无需配备额外的说明文档），这些都体现了架构功力。 功能实现准则：高内聚低耦合系统分解的套路中，除了功能自身的使用界面之外，我们还关注功能与功能之间是如何被连接起来的。当然这就涉及了功能的实现。 功能实现的基本准则是：功能自身代码要高内聚，功能与功能之间要低耦合。 什么叫高内聚？简单来说，就是一个功能的代码应该尽可能写在一起，而不是散落在各处。我个人在高内聚这个方向上养成的习惯是： 一个功能的代码尽可能单独一个文件，不要和其他功能混在一起； 一些小功能的代码可能放在一起放在同一个文件中，但是中间也会用“// —————— ”这样的注释行分割成很多逻辑上的 “小文件”，代表这是一段独立的小功能。 代码高内聚的好处是，多大的团队协作都会很顺畅，代码提交基本上不怎么发生冲突。 那么什么叫低耦合？简单来说就是实现某个功能所依赖的外部环境少，易于构建。 功能实现的外部依赖分两种。一种是对业务无关的基础组件依赖，一种是对底层业务模块的依赖。 基础组件可能是开源项目，当然也可能来自公司的基础平台部。关于基础组件的依赖，我们核心的关注点是稳定。稳定体现在如下两个方面。 一方面是组件的成熟度。这个组件已经诞生多久了，使用接口是不是已经不怎么会调整了，功能缺陷（issue）是不是已经比较少了。 另一方面是组件的持久性。组件的维护者是谁，是不是有足够良好的社区信用（credit），这个项目是不是还很活跃，有多少人在参与其中，为其贡献代码。 当然从架构角度，我们关注的重点不是基础组件的依赖，而是对其他业务模块的依赖。它更符合业务系统分解的本来含义。 对底层业务模块的依赖少、耦合低的表现为： 对底层业务的依赖是 “通用” 的，尽量不要出现让底层业务模块专门为我定制接口； 依赖的业务接口的个数少，调用频次低。 怎么做系统分解？有了系统分解的优劣评判标准，那么我们具体怎么去做呢？ 总体来说，系统分解是一个领域性的问题，它依赖你对用户需求的理解，并不存在放之四海皆可用的办法。 系统分解首先要从需求归纳出发。用户需求分析清楚很重要。把需求功能点涉及的数据（对象）、操作接口理清楚，并归纳整理，把每个功能都归于某一类。然后把类与类的关系理清楚，做到逻辑上自洽，那么一个基本的系统框架就形成了。 在系统的概要设计阶段，我们一般以子系统为维度来阐述系统各个角色之间的关系。 对于关键的子系统，我们还会进一步分解它，甚至详细到把该子系统的所有模块的职责和接口都确定下来。但这个阶段我们的核心意图并不是确定系统完整的模块列表，我们的焦点是整个系统如何被有效地串联起来。如果某个子系统不作进一步的分解也不会在项目上有什么风险，那么我们并不需要在这个阶段对其细化。 为了降低风险，系统的概要设计阶段也应该有代码产出。 这个阶段的代码用意是什么？ 有两个方面的目的。其一，系统的初始框架代码。也就是说，系统的大体架子已经搭建起来了。其二，原型性的代码来验证。一些核心子系统在这个阶段提供了 mock 的系统。 这样做的好处是，一上来我们就关注了全局系统性风险的消除，并且给了每个子系统或模块的负责人一个更具象且确定性的认知。 代码即文档。代码是理解一致性更强的文档。 再谈 MVC本章我们主要探讨的是桌面程序开发。虽然不同桌面应用的业务千差万别，但是桌面本身是一个很确定性的领域，因此会形成自己固有的系统分解的套路。 大家已经知道了，桌面程序系统分解的套路就是 MVC 架构。 虽然不同历史时期的桌面程序的交互方式不太一样，有基于键盘+鼠标的、有基于触摸屏的，但是它们的框架结构是非常一致的，都是基于事件分派做输入，GDI 做界面呈现。 那么为什么会形成 Model-View-Controller（简称 MVC）架构？ 我们第一章探讨需求分析时，我们反复强调一点：要分清需求的稳定点和变化点。稳定点是系统的核心能力，而变化点则需要做好开放性设计。 从这个角度来看，我们可以认为，业务的核心逻辑是稳定的，除非出现了新的技术革命导致产品的内在逻辑发生了质的变化。所以我们最底层一般以类和函数的形态来组织业务的核心逻辑，这就是 Model 层。 但用户交互是一个变化点。大家都是一个 “画图” 程序，无论是在 PC 桌面和手机上，Model 层是一样的，但是用户交互方式并不一样，View、Controllers 就有不小的差别。 当然 Model 层也有自己的变化点。它的变化点在于存储和网络。Model 层要考虑持久化，就会和存储打交道，就有自己的 IO 子系统。Model 层要考虑互联网化，就要考虑 B/S 架构，考虑网络协议。 不过无论是存储还是网络，从架构视角来说变化都是可预期的。存储介质会变，网络技术会变，但是变的只是实现，它们的使用接口并没变化。这意味着 Model 层不只是核心逻辑稳定，IO 和网络子系统也都很稳定。当然这也是把它们归于 Model 层的原因。如果它们是易变的，可能就被从 Model 层独立出去了。 用户交互这个变化点，主要体现在两个方面。一方面是屏幕尺寸导致的变化。更小的屏幕意味着界面上的信息需要被更高效地组织起来。另一方面则是交互的变化，鼠标交互和触摸屏的多点触摸交互是完全不同的。 View 层主要承担了界面呈现的工作。当然这也意味着它也承担了屏幕尺寸这个变化点。 Controller 层主要承担的是交互。具体来说就是响应用户的输入事件，把用户的操作转化为对 Model 层的业务请求。 Controller 层有很多 Controller。这些 Controller 通常各自负责不同的业务功能点。 也就是说，Model 层是一个整体，负责的是业务的核心逻辑。View 层也是一个整体，但在不同的屏幕尺寸和平台可能有不同的实现，但数量不会太多。而且现在流行所谓的响应式布局，也是鼓励尽可能在不同屏幕尺寸不同平台下共享同一个 View 的实现。Controller 层并不是一个整体，它是以插件化的形式存在，不同 Controlller 非常独立。 这样做的好处是可以快速适应交互的变化。比如以创建矩形这样一个功能为例，在 PC 鼠标+键盘的交互方式下有一个 RectCreator Controller，在触摸屏的交互方式可以是一个全新的 RectCreator Controller。在不同平台下，我们可以初始化不同的 Controller 实例来适应该平台的交互方式。 当然前面在 “22 | 桌面程序的架构建议” 一讲中，我们也介绍过 MVC 结构的一些变种，比如 MVP（Model-View-Presenter），主要是 Model 的数据更新发出 DataChanged 事件后，由 Controller 负责监听并 Update View，而不是由 View 层响应 DataChanged 事件并 Update View。 这些不同模型的差异其实只是细节的权衡、取舍，并不改变实质。 怎么看待实战？第一章 “基础平台篇”，从架构的角度，我们主要是在学习基础架构。我们总体是从学历史的角度在聊，大家也是以听故事的方式为主。 但是第二章开始，我们话题逐步过渡到业务架构，同时也开始引入实战案例：“画图” 程序。 为什么实战是很重要的？ 学架构，我个人强调的理念是 “做中学”。 首先还是要勤动手。然后配合本专栏去思考和梳理背后的道理，如此方能快速进步。 我们不能把架构课学成理论课。计算机科学本身是一门实践科学，架构经验更是一线实战经验的积累和总结。 为了方便大家进一步看清楚架构演变过程，我给画图程序实现了一个所有代码都揉在一起的非 MVC 版本（分支 v01）： www/index.htm 它的功能对应我们 “26 | 实战(一)：怎么设计一个“画图”程序？” 这一讲中的最小化的画图程序。这是当时给出的源代码（分支 v26）： www/* 可以看到，v01 版本所有代码，包括 HTML+JavaScript，总共也就 470 行左右。所以这是一个非常小的架构实战案例。如果我们进一步减少案例的代码规模的话，可能就不太需要架构思想了。 我们不妨对比一下两个版本的差异。 一个最基础的对比是代码规模。v26 版本我们分拆了多个文件： Model：dom.js（100 行） View：view.js（112 行） Controllers： accel/menu.js（86 行） creator/path.js（90 行） creator/freepath.js（71 行） creator/rect.js（108 行） 总控：index.htm（18 行） 这些文件加起来的代码量大概在 580 行，比 v01 版本多了 110 行。 这说明 MVC 架构的价值并不是给我们降低总代码行数。实际上，它关注的重点是如何让我们团队协同作战，让工作并行。 怎么让工作并行？这就要求我们实现功能的时候，做到功能自身代码要高内聚，功能间的依赖要低耦合。v26 版本我们把功能分拆为 6 个文件（除了总控 index.htm 不算），可以交给 6 个团队成员来做，平均每个人写 100 行左右的代码。 当然，对于总体代码量 500 行不到的一个程序来说，这多多少少显得有点小题大做。但我们在此之后演进迭代了多个版本，功能越来越复杂，分工的必要性也就越来越大。 除了代码规模外，对比 v01 和 v26 版本，我们不妨从这样一些点来看。 功能的高内聚。某个功能代码被分散在多少地方。 功能间的低耦合。当然 v01 版本所有代码都揉在了一起，我们不妨从如何做系统分解的视角来推演 v26 版本用 MVC 架构的意义。 怎么减少全局变量，为控件化做好准备。 结语在我们介绍完第二章 “桌面开发” 篇的所有内容后，今天我们介绍了架构的第二步：系统的概要设计。 在概要设计阶段，我们一般以子系统为维度来阐述系统各个角色之间的关系。对于关键的子系统，我们还会进一步分解它，甚至详细到把该子系统的所有模块的职责和接口都确定下来。 这个阶段我们的核心意图并不是确定系统完整的模块列表，我们的焦点是整个系统如何被有效地串联起来。如果某个子系统不作进一步的分解也不会在项目上有什么风险，那么我们并不需要在这个阶段对其细化。 为了降低风险，概要设计阶段也应该有代码产出。 这样做的好处是，一上来我们就关注了全局系统性风险的消除，并且给了每个子系统或模块的负责人一个更具象且确定性的认知。 代码即文档。代码是理解一致性更强的文档。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们会回顾和总结第二章的内容。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/32 | 架构：系统的概要设计/"},{"title":"31 | 辅助界面元素的架构设计","text":"你好，我是七牛云许式伟。 我们第二章 “桌面软件开发” 今天开始进入尾声。前面我们主要围绕一个完整的桌面应用程序，从单机到 B/S 结构，我们的系统架构应该如何考虑。并且，我们通过五讲的 “画图” 程序实战，来验证我们的架构设计思路。 这个实战有点复杂。对于编码量不多的初学者，理解起来还是有点复杂性的。为了减轻理解的难度，我们从原计划的上下两讲，扩大到了五讲。尽管如此，理解上的难度仍然还是有的，后面我们做总结时，会给出一个不基于 MVC 架构的实现代码。 今天我们不谈桌面应用的架构，而是来谈谈辅助界面元素的架构设计。 辅助界面元素非常常见，它其实就是通用控件，或者我们自定义的控件。例如在我们画图程序中使用了线型选择控件（menu.js#L105），如下： &lt;select id=&quot;lineWidth&quot; onchange=&quot;onIntPropChanged(&apos;lineWidth&apos;)&quot;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;5&lt;/option&gt; &lt;option value=&quot;7&quot;&gt;7&lt;/option&gt; &lt;option value=&quot;9&quot;&gt;9&lt;/option&gt; &lt;option value=&quot;11&quot;&gt;11&lt;/option&gt; &lt;/select&gt;还有颜色选择控件（menu.js#L115），如下： &lt;select id=&quot;lineColor&quot; onchange=&quot;onPropChanged(&apos;lineColor&apos;)&quot;&gt; &lt;option value=&quot;black&quot;&gt;black&lt;/option&gt; &lt;option value=&quot;red&quot;&gt;red&lt;/option&gt; &lt;option value=&quot;blue&quot;&gt;blue&lt;/option&gt; &lt;option value=&quot;green&quot;&gt;green&lt;/option&gt; &lt;option value=&quot;yellow&quot;&gt;yellow&lt;/option&gt; &lt;option value=&quot;gray&quot;&gt;gray&lt;/option&gt; &lt;/select&gt; &lt;select id=&quot;fillColor&quot; onchange=&quot;onPropChanged(&apos;fillColor&apos;)&quot;&gt; &lt;option value=&quot;white&quot;&gt;white&lt;/option&gt; &lt;option value=&quot;null&quot;&gt;transparent&lt;/option&gt; &lt;option value=&quot;black&quot;&gt;black&lt;/option&gt; &lt;option value=&quot;red&quot;&gt;red&lt;/option&gt; &lt;option value=&quot;blue&quot;&gt;blue&lt;/option&gt; &lt;option value=&quot;green&quot;&gt;green&lt;/option&gt; &lt;option value=&quot;yellow&quot;&gt;yellow&lt;/option&gt; &lt;option value=&quot;gray&quot;&gt;gray&lt;/option&gt; &lt;/select&gt;我们统一用通用的 select 控件实现了一个线型选择器、两个颜色选择器的实例。虽然这种方式实现的颜色选择器不够美观，但是它们的确可以正常工作。 不过，产品经理很快就提出反对意见，说我们需要更加用户友好的界面。赶紧换一个更加可视化的颜色选择器吧？比如像下图这样的： 辅助界面元素的框架怎么做到？ 我们不妨把上面基础版本的线型选择器、颜色选择器叫做 BaseLineWidthPicker、BaseColorPicker，我们总结它们在画图程序中的使用接口如下： 我们解释一下这个表格中的各项内容。 id 是控件的 id，通过它可以获取到辅助界面元素的顶层结点。 value 是界面元素的值，其实也就是辅助界面元素的 Model 层的数据。从 MVC 架构角度来说，Model 层的数据一般是一棵 DOM 树。但是对很多辅助界面元素来说，它的 DOM 树比较简单，只是一个数值。比如线型选择器是一个 number，颜色选择器是一个 Color 值。 palette 是颜色选择器的调色板，用来指示颜色选择器可以选择哪些颜色。 blur() 方法是主动让一个界面元素失去焦点。 onchange 事件是在该界面元素的值（value）通过用户界面交互进行改变时发送的事件。需要注意的是，这个事件只在用户交互时发送。直接调用 element.value = xxx 这样的方式来修改界面元素的值是不会触发 onchange 事件的。 为了便于修改辅助界面元素，我们计划引入统一的辅助界面元素的框架。 这个框架长什么样？ 首先，每个界面元素使用的时候，统一以 &lt;div type=&quot;xxx&quot;&gt;来表示。比如上面的一个线型选择器、两个颜色选择器的实例可以这样来表示： &lt;div type=&quot;BaseLineWidthPicker&quot; id=&quot;lineWidth&quot; onchange=&quot;onIntPropChanged(&apos;lineWidth&apos;)&quot;&gt;&lt;/div&gt; &lt;div type=&quot;BaseColorPicker&quot; id=&quot;lineColor&quot; onchange=&quot;onPropChanged(&apos;lineColor&apos;)&quot; palette=&quot;black,red,blue,green,yellow,gray&quot;&gt;&lt;/div&gt; &lt;div type=&quot;BaseColorPicker&quot; id=&quot;fillColor&quot; onchange=&quot;onPropChanged(&apos;fillColor&apos;)&quot; palette=&quot;white,null(transparent),black,red,blue,green,yellow,gray&quot;&gt;&lt;/div&gt;那么它是怎么被替换成前面的界面元素的？ 我们引入一个全局的 qcontrols: QControls 实例，所有我们定义的控件都向它注册（register）自己。注册的代码如下： class QControls { constructor() { this.data = {} } register(type, control) { this.data[type] = control } }可以看出，注册的逻辑基本上没做什么，只是建立了类型（type）和控件的构建函数（control）的关联。有了这个关联表，我们就可以在适当的时候，把所有的 &lt;div type=&quot;xxx&quot;&gt;的div 替换为实际的控件。替换过程如下： class QControls { init() { let divs = document.getElementsByTagName(&quot;div&quot;) let n = divs.length for (let i = n-1; i &gt;= 0; i--) { let div = divs[i] let type = div.getAttribute(&quot;type&quot;) if (type != null) { let control = this.data[type] if (control) { control(div) } } } } }这段代码逻辑很简单，遍历文档中所有的 div，如果带 type 属性，就去查这个 type 有没有注册过，注册过就用注册时指定的构建函数去构建控件实例。 完整的辅助界面元素框架代码如下： controls/base.js 具体构建控件的代码是怎么样的？源代码请参考这两个文件： controls/BaseLineWidthPicker.js controls/BaseColorPicker.js 我们拿 BaseColorPicker 作为例子看下吧： function BaseColorPicker(div) { let id = div.id let onchange = div.onchange let palette = div.getAttribute(&quot;palette&quot;) let colors = palette.split(&quot;,&quot;) let options = [] for (let i in colors) { let color = colors[i] let n = color.length if (color.charAt(n-1) == &quot;)&quot;) { let offset = color.indexOf(&quot;(&quot;) options.push(`&lt;option value=&quot;` + color.substring(0, offset) + `&quot;&gt;` + color.substring(offset+1, n-1) + `&lt;/option&gt;`) } else { options.push(`&lt;option value=&quot;` + color + `&quot;&gt;` + color + `&lt;/option&gt;`) } } div.outerHTML = `&lt;select id=&quot;` + id + `&quot;&gt;` + options.join(&quot;&quot;) + `&lt;/select&gt;` let elem = document.getElementById(id) if (onchange) { elem.onchange = onchange } } qcontrols.register(&quot;BaseColorPicker&quot;, BaseColorPicker)可以看到，构建函数的代码大体分为如下三步。 第一步，从占位的 div 元素中读入所有的输入参数。这里是 id, onchange, palette。 第二步，把占位的 div 元素替换为实际的界面。也就是 div.outerHTML = xxx 这段代码。 第三步，如果用户对 onchange 事件感兴趣，把 onchange 响应函数安装到实际界面的 onchange 事件中。 jQuery 颜色选择器接下来我们就开始考虑替换颜色选择器的实现了。新版本的颜色选择器，我们不妨命名为 ColorPicker。这个新版本的使用姿势必须和 BaseColorPicker 一样，也就是： 从使用的角度来说，我们只需要把之前的 BaseColorPicker 换成 ColorPicker。如下： &lt;div type=&quot;BaseLineWidthPicker&quot; id=&quot;lineWidth&quot; onchange=&quot;onIntPropChanged(&apos;lineWidth&apos;)&quot;&gt;&lt;/div&gt; &lt;div type=&quot;ColorPicker&quot; id=&quot;lineColor&quot; onchange=&quot;onPropChanged(&apos;lineColor&apos;)&quot; palette=&quot;black,red,blue,green,yellow,gray&quot;&gt;&lt;/div&gt; &lt;div type=&quot;ColorPicker&quot; id=&quot;fillColor&quot; onchange=&quot;onPropChanged(&apos;fillColor&apos;)&quot; palette=&quot;white,null(transparent),black,red,blue,green,yellow,gray&quot;&gt;&lt;/div&gt;那么实现方面呢？ 我们决定基于 jQuery 社区的 spectrum 颜色选择器。 我们的画图程序的主体并没有引用任何现成的框架代码。jQuery 是第一个被引入的。 对待 jQuery，我们可以有两种态度。一种是认为 jQuery 设计非常优良，我们很喜欢，决定将其作为团队的编程用的基础框架。 在这种态度下，我们允许 jQuery 风格的代码蔓延得到处都是，典型表现就是满屏皆是 $ 符号。 当然这种选择的风险是不低的。有一天我们不想再基于 jQuery 开发了，这意味着大量的模块需要进行调整，尤其是那些活跃的项目。 另一种态度是，认为 jQuery 并不是我们的主体框架，只是因为我们有些模块用了社区的成果，比如 spectrum 颜色选择器，它是基于 jQuery 实现的。这意味着我们要用 spectrum，就需要引入 jQuery。 这种团队下，我们会尽可能限制 jQuery 的使用范围，尽量不要让它的代码蔓延，而只是限制在颜色选择器等少量场景中。 我们这一讲假设我们的态度是后者。我们有自己的基础开发框架（虽然我们其实基本上接近裸写 JavaScript 的状态），所以不会大面积使用 jQuery。 这样我们需要包装 jQuery 组件。代码如下（参阅 controls/ColorPicker.js）： function ColorPicker(div) { let id = div.id let onchange = div.onchange let palette = div.getAttribute(&quot;palette&quot;) let colors = palette.split(&quot;,&quot;) let value = colors[0] div.outerHTML = `&lt;input type=&quot;button&quot; id=&quot;` + id + `&quot; value=&quot;` + value + `&quot;&gt;` let elem = $(&quot;#&quot; + id) elem.spectrum({ showInitial: true, showInput: true, showButtons: true, preferredFormat: &quot;hex6&quot; }) if (onchange) { elem.change(onchange) } Object.defineProperty(document.getElementById(id), &quot;value&quot;, { get() { return value }, set(x) { if (this.busy) { return } value = x this.busy = true elem.spectrum(&quot;set&quot;, value) this.busy = false } }) } qcontrols.register(&quot;ColorPicker&quot;, ColorPicker)这里大部分代码比较常规，只有 Object.defineProperty 这一段看起来比较古怪一些。这段代码是在改写 document.getElementById(id) 这个界面元素的 value 属性的读写（get/set）函数。 为什么需要改写？ 因为我们希望感知到使用者对 value 的改写。正常我们可能认为接管 onchange 就可以了，但是实际上 element.value = xxx 这样的属性改写是不会触发 onchange 事件的。所以我们只能从改写 value 属性的 set 函数来做。 set 函数收到 value 被改写后，会调用 elem.spectrum(“set”, value) 来改变 spectrum 颜色控件的当前值。 但这里又有个细节问题：elem.spectrum(“set”, value) 内部又会调用 element.value = value 来修改 document.getElementById(id) 这个界面元素的 value 属性，这样就出现了死循环。怎么办？我们通过引入一个 busy 标志来解决：如果当前已经处于 value 属性的 set 函数，就直接返回。 辅助界面元素的架构设计到目前为止，我们实现了三个符合我们定义的控件规范的辅助界面元素。如下： controls/BaseLineWidthPicker.js controls/BaseColorPicker.js controls/ColorPicker.js 观察这些辅助界面元素的代码，你会发现它们都没有基于 MVC 架构。 是因为辅助界面元素不适合用 MVC 架构来编写么？ 当然不是。 更本质的原因是因为它们规模太小了。这些界面元素的特点是 DOM 都是一个 value，并不是一棵树，这样 Model 层就没什么代码了。同样的逻辑，View 层、Control 层代码量都过于短小，就没必要有那么清楚的模块划分。View 负责界面呈现，Control 负责事件响应，只是在心里有谱就好了。 但并不是所有辅助界面元素都这么简单。 举一个简单的例子。让我们给自己设定一个新目标：把我们前面实战的 “画图” 程序，改造成一个标准的辅助界面元素，这可行么？ 答案当然是肯定的。 但是这意味着我们有一些假设需要修正。这些假设通常都和唯一性有关。 比如，全局有唯一的 View 对象实例 qview: QPaintView。如果我们是辅助界面元素，意味着我们可能在同一个界面出现多个实例。在多实例的情况下，View 对象显然就应该有多个。 再比如，我们画图程序的辅助界面元素（参见 accel/menu.js）都是单例，具体表现为这些界面元素的 id 都是固定的。 当然，辅助界面元素的改造方案有多种可能性。一种方案是将辅助界面元素也改造为多例，使得每个 QPaint 实例都有自己的辅助界面元素。 另一种方案是继续保持单例，这意味着多个 QPaint 实例会有一个当前实例的概念。辅助界面元素根据场景，可以是操作全部实例，也可以是操作当前实例。 我们选择继续保持单例。这意味着 qview: QPaintView 这个全局变量可以继续存在，但是和之前的含义有了很大不同。之前 qview 代表的是单例，现在 qview 代表的是当前实例。 有了当前实例当然就有切换。这样就需要增加焦点相关的事件响应。 在画图程序中，很多 Controller 都是 View 实例相关的。比如：PathCreator、ShapeSelector 等。在 View 存在多例的情况下，这些 Controller 之前的 registerController 动作就需要重新考虑。 为了支持多例，我们引入了 onViewAdded、onCurrentViewChanged 事件。当一个新的 View 实例被创建时，会发送 onViewAdded 事件。Controller 可以响应该事件去完成 registerController 动作。如下： onViewAdded(function(view) { view.registerController(&quot;PathCreator&quot;, function() { return new QPathCreator(view, false) }) })原先，当前图形样式是放在 View 中的，通过 qview.style 可以访问到。这会导致多个 View 实例的当前图形样式不一样，但是我们辅助界面元素又是单例的，这就非常让人混淆。最后我们决定把 qview.style 挪到全局，改名叫 defaultStyle（参阅 accel/menu.js#L42）。 做完这些改造，我们的画图程序就有了成为一个标准控件的基础。具体代码如下（参阅 PaintView.js）： function newPaintView(drawingID) { let view = new QPaintView(drawingID) fireViewAdded(view) return view } function initPaintView(drawingID) { let view = newPaintView(drawingID) setCurrentView(view) } function PaintView(div) { let id = div.id let width = div.getAttribute(&quot;width&quot;) let height = div.getAttribute(&quot;height&quot;) div.outerHTML = `&lt;canvas id=&quot;` + id + `&quot; width=&quot;` + width + `&quot; height=&quot;` + height + `&quot;&gt;你的浏览器不支持Canvas！&lt;/canvas&gt;` initPaintView(id) } qcontrols.register(&quot;PaintView&quot;, PaintView)有了这个 PaintView 控件，我们就可以到处引用它了。我们做了一个 PaintView 控件的 DEMO 程序，它效果看起来是这样的（代码参阅 PaintDemo.htm）： 从这个截图看，细心的你可能会留意到，还有一个问题是没有被修改的，那就是 URL 地址。我们的 QPaintView 在 load 文档后会修改 URL，这作为应用程序并没有问题。但是如果是一个控件，整个界面有好多个 PaintView，URL 中应该显示哪个文档的 ID？ 显然谁都不合适。如果非要显示，可能要在 PaintView 实例附近放一个辅助界面元素来显示它。 怎么修改？ 这个问题暂且留给大家。 结语今天探讨了辅助界面元素，或者叫控件的架构设计。从大的实现逻辑来说，它和应用程序不应该有本质的不同。但控件总是要考虑支持多实例，这会带来一些细节上的差异。 支持多实例听起来是一项简单的工作，但是从我的观察看，对很多工程师来说实际上并不简单。不少初级工程师写代码往往容易全局变量满天飞，模块之间相互传递信息不假思索地基于全局变量来完成。这些不良习惯会导致代码极难控件化。 当然我们不见得什么桌面应用程序都要考虑把它控件化。但是我们花一些精力去思考控件化的话，会有助于你对架构设计中的一些决策提供帮助。 当然更重要的，其实是让你有机会形成更好的架构设计规范。 这一讲我们作出的修改如下： https://github.com/qiniu/qpaint/compare/v30…v31 这是最新版本的源代码： https://github.com/qiniu/qpaint/tree/v31 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们会谈谈架构设计的第二步：如何做好系统架构。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/31 | 辅助界面元素的架构设计/"},{"title":"34 | 服务端开发的宏观视角","text":"你好，我是七牛云许式伟。 今天开始，我们进入第三章，谈谈服务端开发。 服务端的发展史服务端开发这个分工，出现的历史极短。短得让人难以想象。 1946 年，第一台电子计算机问世。1954 年，第一门高级语言 Fortran 发布。整个信息科技发展到今天，大约也就 60~70 年的历史。 1974 年，Internet 诞生。1989 年，万维网（WWW）诞生，但刚开始只限于政府和学术研究用途，1993 年才开始进入民用市场。 从这个角度来说，服务端开发这个分工，从互联网诞生算起也就 40 多年的历史。真正活跃的时段，其实只有 20 多年。 但其发展速度是非常惊人的。我们简单罗列下这些年来的标志性事件。 1971 年，电子邮件诞生。 1974 年，Internet 诞生。 1974 年，第一个数据库系统 IBM System R 诞生。SQL 语言诞生。 1989 年，万维网（WWW）诞生。 1993 年，世界上第一个 Web 服务器 NCSA HTTPd 诞生，它也是大名鼎鼎的 Apache 开源 Web 服务器的前身。 1998 年，Akamai 诞生，提供内容分发网络（CDN）服务。这应该算全球第一个企业云服务，虽然当时还没有云计算这样的概念。 2006 年，Amazon 发布弹性计算云（Elastic Compute Cloud），简称 EC2。这被看作云计算诞生的标志性事件。 2007 年，Amazon 发布简单存储服务（Simple Storage Service），简称 S3。这是全球第一个对象存储服务。 2008 年，Google 发布 GAE（Google App Engine）。 2009 年，Go 语言诞生。Derek Collison 曾预言 Go 语言将制霸云计算领域。 2011 年，七牛云诞生，发布了 “对象存储+CDN+多媒体处理” 融合的 PaaS 型云存储，为企业提供一站式的图片、音视频等多媒体内容的托管服务。 2013 年，Docker 诞生。 2013 年，CoreOS 诞生。这是第一个专门面向服务端的操作系统。 2014 年，Kubernetes 诞生。当前被认为是数据中心操作系统（DCOS）的事实标准。 通过回顾服务端的发展历史，我们可以发现，它和桌面开发技术迭代的背后驱动力是完全不同的。 桌面开发技术的迭代，是交互的迭代，是人机交互的革命。而服务端开发技术的迭代，虽然一开始沿用了桌面操作系统的整套体系框架，但它正逐步和桌面操作系统分道而行，转向数据中心操作系统（DCOS）之路。 服务端程序的需求这些演进趋势的根源是什么？ 其一是规模。 桌面程序是为单个用户服务的，所以它关注点是用户交互体验的不断升级。 服务端程序是被所有用户所共享，为所有用户服务的。一台物理的机器资源总归是有限的，能够服务的用户数必然存在上限，所以一个服务端程序在用户规模到达一定程度后，需要分布式化，跑在多台机器上以服务用户。 其二是连续服务时长。 桌面程序是为单个用户服务的，用户在单个桌面程序的连续使用时长通常不会太长。 但是服务端程序不同，它通常都是 7x24 小时不间断服务的。当用户规模达到一定基数后，每一秒都会有用户在使用它，不存在关闭程序这样的概念。 其三是质量要求。 每个桌面程序的实例都是为单个用户服务的，有一亿的用户就有一亿个桌面程序的实例。 但是服务端程序不同，不可能有一亿个用户就跑一亿个，每个用户单独用一个，而是很多用户共享使用一个程序实例。 这意味着两者对程序运行崩溃的容忍度不同。 一个桌面程序实例运行崩溃，它只影响一个用户。 但一个服务端程序实例崩溃，可能影响几十万甚至几百万的用户。 这是不可接受的。 一个服务端程序的实例可以崩溃，但是它的工作必须立刻转交给其他的实例重新做，否则损失太大了。 所以服务端程序必须能够实现用户的自动转移。一个实例崩溃了，或者因为需要功能升级而重启了，它正在服务的用户需要转给其他实例来服务。 所以，服务端程序必须是多实例的。单个程序实例的临时不可用状态，要做到用户无感知。 从用户视角看，服务端程序 7x24 小时持续服务，任何时刻都不应该崩溃。就如同水电煤一样。 服务端开发的体系架构在 “01 | 架构设计的宏观视角” 这一讲中，我们将一个服务端程序完整的体系架构归纳如下： 这个架构体系，是为了方便你和桌面开发的体系架构建立自然的对应关系而画的。 它当然是对的，但它只是从服务端程序的单个实例看的，不是服务端程序体系架构的全部。 在 “15 | 可编程的互联网世界” 这一讲中，我们把 TCP/IP 层比作网络的操作系统，一个网络程序的体系架构如下： 一个服务端程序当然也是一个网络程序，它符合网络程序的体系架构。 但它也不是服务端程序体系架构的全部。 从宏观视角看，一个服务端程序应该首先是一个多实例的分布式程序。其宏观体系架构示意如下： 相比桌面程序而言，服务端程序依赖的基础软件不只是操作系统和编程语言，还多了两类： 负载均衡（Load Balance）； 数据库或其他形式的存储（DB/Storage）。 为什么会需要负载均衡（Load Balance）？为什么会需要数据库或其他形式的存储？你可以留言探讨一下。我们在接下来的几讲将聊聊负载均衡和存储。 结语今天我们从服务端的发展历程、服务端开发的需求谈起，以此方便你理解服务端开发的生态会怎么演化，技术迭代会走向何方。 我们这里探讨的需求和具体业务无关，它属于服务端本身的领域特征。就像桌面的领域特征是强交互，以事件为输入，GDI 为输出一样，服务端的领域特征是大规模的用户请求，以及 24 小时不间断的服务。 这些领域特征直接导致了服务端开发的体系架构和桌面必然是如此的不同。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将聊聊负载均衡（Load Balance）。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/34 | 服务端开发的宏观视角/"},{"title":"35 | 流量调度与负载均衡","text":"你好，我是七牛云许式伟。 相比桌面程序而言，服务端程序依赖的基础软件不只是操作系统和编程语言，还多了两类： 负载均衡（Load Balance）； 数据库或其他形式的存储（DB/Storage）。 为什么会需要负载均衡（Load Balance）？今天我们就聊一下有关于流量调度与负载均衡的那些事情。 上一讲我们画了服务端程序的体系架构图，如下： 什么是 “流量调度”？我们首先要了解这样几个常见的服务端程序运行实例（进程）相关的概念： 连接数； IOPS； 流量，入向流量和出向流量。 我们知道，一个基本的服务端程序的服务请求，通常是由一个请求包（Request）和一个应答包（Response）构成。这样一问一答就是一次完整的服务。 连接数，有时候也会被称为并发数，指的是同时在服务中的请求数。也就是那些已经发送请求（Request），但是还没有收完应答（Response）的请求数量。 IOPS，指的是平均每秒完成的请求（一问一答）的数量。它可以用来判断服务端程序的做事效率。 流量分入向流量和出向流量。入向流量可以这么估算： 平均每秒收到的请求包（Request）数量 * 请求包平均大小。 同样的，出向流量可以这么估算： 平均每秒返回的应答包（Response）数量 * 应答包平均大小。 不考虑存在无效的请求包，也就是存在有问无答的情况（但实际生产环境下肯定是有的）的话，那么平均每秒收到的请求包（Request）数量、平均每秒返回的应答包（Response）数量就是 IOPS。故此： 入向流量 ≈ IOPS * 请求包平均大小 出向流量 ≈ IOPS * 应答包平均大小 所谓流量调度，就是把海量客户并发的请求包按特定策略分派到不同的服务端程序实例的过程。 有很多手段可以做流量调度。 DNS 流量调度最基础的方式，是通过 DNS，如下图所示。 一个域名通过 DNS 解析到多个 IP，每个 IP 对应不同的服务端程序实例。这样就完成了流量调度。这里我们没有用到常规意义的负载均衡（Load Balance）软件，但是我们的确完成了流量调度。 那么这种做法有什么不足？ 第一个问题，是升级不便。 要想升级 IP1 对应的服务端程序实例，必须先把 IP1 从 DNS 解析中去除，等 IP1 这个实例没有流量了，然后我们升级该实例，最后把 IP1 加回 DNS 解析中。 看起来还好，但是我们不要忘记，DNS 解析是有层层缓冲的。我们把 IP1 从 DNS 解析中去除，就算我们写明 TTL 是 15 分钟，但是过了一天可能都还稀稀拉拉有一些用户请求被发送到 IP1 这个实例。 所以通过调整 DNS 解析来实现升级，有极大的不确定性，完成一个实例的升级周期特别长。 假如一个实例升级需要 1 天，我们总共有 10 个实例，那么就需要 10 天。这太夸张了。 第二个问题，是流量调度不均衡。 DNS 服务器是有能力做一定的流量均衡的。比如第一次域名解析返回 IP1 优先，第二次域名解析让 IP2 优先，以此类推，它可以根据域名解析来均衡地返回 IP 列表。 但是域名解析均衡，并不代表真正的流量均衡。 一方面，不是每次用户请求都会对应一次 DNS 解析，客户端自己有缓存。另一方面，DNS 解析本身也有层层缓存，到 DNS 服务器的比例已经很少了。 所以在这样情况下，按域名解析做流量调度均衡，是非常粗糙的，实际结果并不可控。 那么，怎么让流量调度能够做到真正均衡？ 网络层负载均衡第一种做法，是在网络层（IP 层）做负载均衡。 章文嵩博士发起的负载均衡软件 LVS（Linux Virtual Server）就工作在这一层。我们以 LVS 为代表介绍一下工作原理。 LVS 支持三种调度模式。 VS/NAT：通过网络地址转换（NAT）技术做调度。请求和响应都会经过调度器中转，性能最差。 VS/TUN：把请求报文通过 IP 隧道转发至真实服务器，而真实服务器将响应直接返回给客户，所以调度器只处理请求报文。这种做法性能比 VS/NAT 好很多。 VS/DR：通过改写请求报文的MAC地址，将请求发送到真实服务器，真实服务器将响应直接返回给客户。这种做法相比 VS/TUN 少了 IP 隧道的开销，性能最好。 我们重点介绍下 VS/DR 技术。 如上图所示。设客户端的 IP 和 MAC 为 CIP、CMAC。 第 1 步，客户端发起请求，其 IP 报文中，源 IP 为用户的 CIP ，目标 IP 是 VIP；源 MAC 地址为 CMAC ，目标 MAC 地址为 DMAC。 第 2 步，请求包到达 LVS 调度器（Director Server）。我们保持源 IP 和目标 IP 不变，仅仅修改目标 MAC 地址为 RMAC，将请求转发到真实的业务服务器实例 RS（Real Server）。 第 3 步，RS 收到数据包并经过处理，直接响应发送给客户端。 这里面的关键技巧，是 VIP 绑定在多台机器上，所以我们把它叫做虚拟 IP（Virtual IP）。它既绑定在 LVS 调度器（Director Server）上，也绑定在所有的业务服务器实例 RS（Real Server）上。 当然这里有一个很重要的细节是，ARP 广播查询 VIP 对应的 MAC 地址得到什么？答案当然是 LVS 调度器（Director Server）。在真实的业务服务器实例 RS（Real Server）上，我们把 VIP 绑定在 lo 接口上，并对 ARP 请求作了抑制，这样就避免了 IP 冲突。 LVS 这种在网络层底层来做负载均衡，相比其他负载均衡技术来说，其特点是通用性强、性能优势高。 但它也有一些缺点。假如某个业务服务器实例 RS 挂掉，但 LVS 调度器（Director Server）还没有感知到，在这个短周期内转发到该实例的请求都会失败。这样的失败只能依赖客户端重试来解决。 应用层负载均衡有办法避免出现这种请求失败的情况吗？ 可以。答案是：服务端重试。 怎么做服务端重试？应用层负载均衡。有时候我们也把它叫做应用网关。 HTTP 协议是应用最为广泛的应用层协议。当前应用网关，绝大多数都是 HTTP 应用网关。 Nginx 和 Apache 都是大家最为耳熟能详的 HTTP 应用网关。因为知道应用层协议的细节，所以 HTTP 应用网关的能力通常非常强大。这一点我们后面还会进一步进行探讨，今天我们先聊负载均衡（Load Balance）相关的内容。 HTTP 网关收到一个 HTTP 请求（Request）后，根据一定调度算法把请求转发给后端真实的业务服务器实例 RS（Real Server），收到 RS 的应答（Response）后，再把它转发给客户端。 整个过程的逻辑非常简单，而且重试也非常好做。 在发现某个 RS 实例挂了后，HTTP 网关可以将同一个 HTTP 请求（Request）重新发给其他 RS 实例。 当然一个重要的细节是为了能够支持重试，HTTP 请求（Request）需要被保存起来。不保存 HTTP 请求做重试是有可能的，但是只能支持业务实例完全挂掉 HTTP 请求一个字节都没发过去的场景。但在断电或异常崩溃等情况，显然会有很多进行中的请求是不符合这个前提的，它们就没法做重试。 大部分 HTTP 请求不大，直接在内存中存储即可，保存代价不高。但是文件上传型的请求，由于请求包中包含文件内容，可能就需要依赖临时文件或其他手段来保存 HTTP 请求。 优雅升级有了负载均衡，不只是可以实现了流量的均衡调度，连带业务服务器的升级也会方便多了。 对于前端是 LVS 这种网络层负载均衡的场景，升级的核心步骤为： 升级系统通知 LVS 调度器（Director Server）下线要升级的业务服务器（Real Server）实例。 LVS 调度器（Director Server）将该实例从 RS 集合中去除，这样就不再调度新流量到它。 升级系统通知要升级的 RS 实例退出。 要升级的 RS 实例处理完所有处理中的请求，然后主动退出。 升级系统更新 RS 实例到新版本，并重启。 升级系统将 RS 实例重新加回 RS 集合参与调度。 对于前端是 HTTP 应用网关这种负载均衡的场景，升级的过程可以更加简单： 升级系统通知升级的业务服务器（Real Server）实例退出。 要升级的 RS 实例进入退出状态，这时新请求进来直接拒绝（返回一个特殊的 Status Code）；处理完所有处理中的请求后，RS 实例主动退出。 升级系统更新 RS 实例到新版本，并重启。 可以看出，因 HTTP 应用网关支持重试，业务服务器的升级过程就变得简单很多。 结语今天我们从流量调度谈起，聊了几种典型的调度手段和负载均衡的方式。 从流量调度角度来说，负载均衡的最大价值是让多个业务服务器的压力均衡。这里面隐含的一个前提是负载均衡软件的抗压能力往往比业务服务器强很多（为什么？欢迎留言讨论）。 这表现在：其一，负载均衡的实例数/业务服务器的实例数往往大大小于1；其二，DNS 的调度不均衡，所以负载均衡的不同实例的压力不均衡，有的实例可能压力很大。 当然，负载均衡的价值并不只是做流量的均衡调度，它也让我们的业务服务器优雅升级成为可能。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将聊聊存储中间件。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/35 | 流量调度与负载均衡/"},{"title":"加餐 | 我看Facebook发币（上）：区块链、比特币与Libra币","text":"你好，我是七牛云许式伟。 Facebook（脸书）于6月18日发布了其加密数字货币项目白皮书。该数字货币被命名为 Libra（天秤座），象征着平衡与公正。 此前，BBC 报道说这个数字货币叫 GlobalCoin（全球币），但后来被纠正说这只是Facebook员工在内部对其的昵称。 不管是叫 Libra，还是 GlobalCoin，其实都透露出了Facebook的雄心壮志。 今天的Facebook 坐拥 27 亿的活跃用户，相当于全球1/3的人都在用 Facebook，这是一个比微信大得多的数字社群（微信月活为 11 亿，差不多全中国人民都在用微信）。 我之所以叫它“数字社群”，而不叫“数字王国”，是因为用科学的态度来谈，“国家” 这样的称呼没法随便用，“国家”得符合国家需要具备的特征。 国家有哪些特征？ 武装是大家能够很快想得到的，国家得有自己的军队，但是数字世界毕竟是个虚拟世界，军队似乎没啥意义。 发行货币是国家另一个至关重要的权力。现在，拥有 27 亿人口的 Facebook 要发币，这意味着它离真正意义上的 “数字王国” 又靠近了一步，至关重要的一步。 整个世界将因此发生翻天覆地的变化。 今天我想借此机会，谈谈区块链和数字货币背后的社会需求动因、逻辑以及它们将产生的巨大影响。 我们的内容将会分为上下两部分，如下： 我看 FB 发币（上）：区块链、比特币与 Libra 币； 我看 FB 发币（下）：深入浅出理解 Libra 币。 区块链我们先从区块链谈起。 介绍区块链技术的文章已经有很多了，我们今天不谈技术实现的细节。简单说，它是一个分散式防篡改的数字账本。 但是，区块链到底有什么用？它想解决什么样的问题？ 有人说，区块链是为了“去中心化”。 那么“去中心化”是趋势么？互联网的趋势是“中心化”，而不是“去中心化”。 效率为先。如果一个事情可以两个人干更好，那么最终的结果就是应该两个人去干，而不会是十个人去干，这是最朴素的经济学原理。 而微信和 Facebook 的成功，也证明了中心化是趋势。人们之所以向往着去中心化，是因为人天然对垄断有抗拒之心，被人生杀予夺的感觉怎么想都不太美妙。 人们因为效率而中心化，因为垄断而去中心化。所以是一个中心还是几个中心，这是自然平衡的结果。 历史告诉我们，它选择的“去中心化”是开辟疆土。前有哥伦布发现新大陆，今有“钢铁侠”马斯克寻求火星殖民。这才是真正的“去中心化”，找到全新的盐碱地去开拓。 地球相比于整个宇宙，只不过是一粒尘埃。这样的“中心化”，又算得了什么呢？ 当然也有人说，区块链是为了“去中介”。 那么“去中介化”是互联网的趋势么？互联网会减少尽可能多的中间环节，但是不会“去中介”。 每个人有他自己的专长。把自己不擅长的事情交给中介，这是特别自然的一件事情，我们为中介的专业性买单。 互联网让中介可以 24 小时为你服务，远程为你服务。这些都是以前没法完成的。这会导致什么呢？一些中介会茁壮成长，变成行业中的关键节点。它也有可能会顺带合并掉上下游的一些分工，让服务链条更短。 那么，区块链价值到底是什么？ 我认为，区块链本质上是一种“共识机制”，或者说“契约机制”。分散式防篡改的数字账本，保障的核心是事实的不可抵赖。这对双方形成共识是极大的效率提升。在大部分情况下，没有共识往往是因为争议的双方对事实的认定不同。 从这个认知来看，一些鼓吹“区块链是下一个互联网基础设施”的人们可以洗洗睡了。 区块链不会重造一个新互联网底层，但它最有可能重塑金融与供应链。 比特币比特币，数字货币的鼻祖，区块链技术的第一个杀手级应用。 为什么会出现比特币？它希望解决什么样的需求？ 其一，希望能够解决政府动不动就发币，让你手头货币凭空贬值的问题。 这应该是比特币创始人中本聪的本意。所以比特币发币的机制是挖矿，谁挖到就算谁的。成本是购买计算机的成本和运行计算机挖矿所消耗的电费。 从这个角度看，比特币不能类比法币，它没有法币的发行者，国家信用作为背书。它更像是黄金，基于资源本身的稀缺性作为背书。 其二，希望能够解决经济全球化带来的货币跨境流通问题。 这是数字货币的价值投资者们的共同期望。 随着互联网技术在全球范围的不断普及，越来越多的生意被放到了网上。旧的商业文明可以一言以蔽之：一手交钱，一手交货。而建立在互联网之上的新商业文明，我们一手下单付款，一手收钱发货，足不出户，货物就通过便捷的物流服务送到了你手上。 但建立在互联网之上的新商业文明，遭遇了国家与国家之间的边界挑战。这体现在以下两点。 其一，汇率。我们都知道，法币与法币的兑换是有损的。你把钱从 A 币换成 B 币，再把 B 币换回 A 币，钱就少了。 其二，关税。一个商品从一个国家买到另一个国家，成本就变高了。刨除物流成本带来的影响因素外，最大的额外代价就是关税。 物流成本是可以解决的。贸易全球化带来的结果是生产全球化。 以前国与国之间的贸易，主要成分在成品贸易，这个成品的原料和加工的零件都来自于同一个国家，我生产出成品后销往世界各地。 但是现在国与国之间的贸易，主要成分在原料与零部件的交易。这意味着供应链已经越来越全球化，成品的生产很可能就在销售地，或者靠近销售地。 这样的好处，一方面当然是产品品质的需要，可以全球寻求优质供应商。另一方面可以极大程度地降低物流成本。原材料的运输相比成品来说，更易于利用规模化效应降低单位运输成本。 关税问题，也是可以国家之间协调解决的。超低关税，乃至最终零关税是历史发展的必然。 那么汇率问题呢？ 这个问题不好解决。提供兑换货币服务的金融机构不可能是免费服务，他们自身的成本也在那里。只要有跨境交易，就有“用什么结算货币”的问题，随之而来的就有结汇的问题。 除非，有一种世界货币，它能够流通于各个国家，被各个国家的市场所接受。 解决汇率问题最好的办法当然是不用换汇。 比特币能够满足这个需求么？ 不能。比特币有这样一些软肋，我列在了下面。 其一，没法按需增发，价格波动大。货币发行量最理想的情况是按市场需求来。如果市场对货币的需求量暴增，但是又没法增加货币发行量来调节，必然会导致货币增值。 比特币就属于这种情况，它只能靠挖矿来增加，而没有其他手段。那么一旦人们对它的需求增加速度超过挖矿速度，就会出现价格暴涨。 投机性的行为可能会助长这一点。但是从更长远的维度看，比特币的价值与“市场需求量/比特币流通量”成正比。 其二，性能低。比特币基于区块链技术，参与的节点众多。节点多对比特币是有极强的正面价值的，因为参与的节点越多，其被人把控的概率也就越低。 但是，节点越多，比特币交易的性能也就越低。那么现实中，比特币交易到底有多慢？平均每秒2-3笔交易。 这意味着，比特币完全无法满足支持世界货币所需的交易频次。 Libra 币虽然比特币并不满足需求，但数字化的世界货币一定会诞生，只不过是谁的问题，这是贸易全球化决定的。 Libra 币就是冲着成为世界货币去的。在 Facebook 最近发布的《加密货币项目 Libra 白皮书》中提到： 我们的世界真正需要一套可靠的数字货币和金融基础设施，两者结合起来必须能兑现“货币互联网”的承诺。 可见，Libra 币其实不属于 Facebook，只不过是由Facebook 发起的。就像互联网一样，它期望的是一种开放式的架构。 “互联网”连接了世界上的所有人，但是国与国之间边界导致的“汇率”和“关税”问题，让贸易无法做到真正意义的全球化。 Libra 币旨在构建“货币互联网”，让贸易真正无国界，它如何做到？我们将在《我看 FB 发币（下）：深入浅出理解 Libra 币》这篇文章中进行详细的介绍。 今天我们重点聊的是 Libra 币将带来什么。 第一个问题：Libra 币会不会成功？ 我认为它会成功。唯一阻碍它成功的因素是美国政府。毕竟它给世界上任何一个国家的人们都带来了一个巨大的变化： 除了本国的法币，还有一个货币能够用于人们之间的日常交易。 虽然此前已经有比特币也能够做到这一点，但是比特币的低吞吐能力决定了它必然无法成为世界货币。 Libra 币最直接挑战的是美元的地位。某种意义上来说，在它之前，美元在承担着世界货币的作用。 但是我认为美国政府会支持 Libra 币。有两个重要的理由支持他们这样做。 其一，世界货币一定会产生。与其让它发生在其他国家，不如发生在美国，由美国人来主导这件事情的发生。 其二，美元的物理属性，决定了美元对交易的渗透在非美元区（法币不是美元的地区）只能在线下，无法支持线上交易。 但线上交易的比重越来越大，意味着美国需要一个数字货币能够渗透到其他国家。Libra 币刚好满足了这个需求，所以，Libra 币很容易与美元达成结盟。 一旦美国支持 Libra 币，这件事情就成功了一半。欧洲本来就有欧元，相当于已经有一个自己小范围的世界货币了，货币发行本来就已经和国家政权解绑了。改用 Libra 币带来的冲击并不大。 搞定了欧美，Libra 币基本上就算成功了。其他地区的国家很难真正去反抗这一潮流。 为什么？ 不拥抱 Libra 币，意味着放弃由“互联网+Libra币”共同构建的世界自由贸易体系。这对任何一个国家来说，都意味着闭关锁国，放弃经济增长。 另外搞一个世界货币与之对抗？ 难。货币有很强的网络效应。如果一个国家或地区已经被 Libra 币渗透，另一个货币进来就难了。 所以如果非要干，最佳的时机是现在。 假设，另一个世界货币干起来了，全球被分成了两半，一东一西。 它们之间没有贸易么？贸易用哪个世界币？这带来了新的汇率问题。 如果可以让企业自由选择，那么这会是大鱼吃小鱼的故事。因此，第二个世界货币很难真正干起来。 第二个问题：如果 Libra 币成功的话，它会带来什么影响？ 最大的变化，是货币的大一统。就像欧洲已经发生的那样，国家政权和货币脱钩，政府再也无法用货币杠杆来宏观调控市场。 第二个大变化，是交易的透明化。链上的支撑节点都可以看到全球所有的交易往来。虽然 Libra 币是匿名的身份，但是开通 Libra 账户过程在很多国家很可能是实名的。所以某种意义上来说，交易还是会和现实身份对应起来。 第三个问题：中国应该怎么应对？ 这个问题，有点像是中国该不该加入世贸组织（WTO）一样。我的答案是：应该认认真真考虑下如何加入，什么时候加入，加入前应该做好哪些准备。 结语总结一下我对 Facebook 发币这件事情的看法。 世界货币一定会诞生，只不过是谁的问题。这是贸易全球化决定的。 以前大家看好比特币，但是比特币有软肋。其一是波动大，其二是性能低。 Libra 币不属于 Facebook，只不过是由 Facebook 发起而已。它就像互联网一样，是开放式的架构。这也是其他巨头一拍即合，毫不犹豫地去支持的原因。 Libra 币会得到美国政府的支持，并逐步渗透到世界各个地区。它不只是流行于 Facebook 的 27 亿活跃用户，也会流行于其他如 PayPal、Booking 等主流服务。 “互联网 + Libra 币” 将共同构建全新的世界自由贸易体系。 站在未来看现在，Libra 币将会是极其重大的一个历史节点。我倾向于这样来描绘它的影响： 计算机 =&gt; 互联网 =&gt; Libra 币 货币有着巨大的网络效应，留给后来者的时间窗口极短。我想，我们都应该思考怎么面对这件事情了。","link":"/2019/08/31/许世伟的架构课/加餐 | 我看Facebook发币（上）：区块链、比特币与Libra币/"},{"title":"加餐 |  想当架构师，我需要成为“全才”吗？","text":"你好，这里是极客时间编辑部。 不知不觉，“许式伟的架构课”专栏已经更新了3个多月，我们的后台收到了同学们数以千计的留言。许式伟老师每天都在实时关注着留言并回答同学们的问题，同时根据同学们的留言不断优化调整课程的设置。 老师和同学在留言区的互动也十分热闹精彩，今天我们就精选出一批留言，一起来看一看。 精选问答1.老师好，人精力有限，如果什么都懂，那不是不精了？通才还能做架构师吗？还是“一专多能”，先“专”，精通一样；再“多能”，了解其它技术？ 答：挺好的问题。架构师绝对不是要把自己打造为全才。架构师掌控全局的核心思想是打通经络，让自己的内力在全身自然流通，浑然一体。在不影响理解的情况下，你需要放弃很多实现细节的专研，但有一天你需要细节的时候，你能够知道存在这些细节，并且快速钻研进去。 2.许老师，自己现在已经工作快三年了，想往架构师这个方向走，但现在自己有些迷茫，接触到的技术也算挺多了，但不知道该如何入手架构师，之前您也提到过先广度然后深度，但我想问达到什么算广度够了，怎么进行深度学习？ 答：架构师核心是把知识串起来，构建一个完整的认知，不留疑惑。大部分知识是不需要深入细节的，只在你需要的时候深入，但深入的时候要很深。 3.如何来确定需求中哪些是稳定的？对架构角度，关注需求到什么层次？ 答：挺好的问题。需求分析的重要性怎么形容都不过分。准确的需求分析是做出良好架构设计的基础。很多优秀的架构师之所以换到一个新领域一上来并不一定能够设计出好的架构，往往需要经过几次迭代才趋于稳定，原因在于新领域的需求理解需要一个过程。除了心里对需求的反复推敲的严谨态度外，对客户反馈的尊重之心也至关重要。 4.老师好，我有三个问题。 现在运维开发基本上都用Go，Python慢慢变少了，Java也少用了……现在运维开发是要学Go吗？ 架构师要学数据结构和算法吗？很多都说算法是“内功”，中小公司好像学了都基本用不到。 现在不是流行Docker+k8s、微服务、DevOps、AI等，那些主流技术都要了解吗？OpenStack云计算这两年基本不讲了，是否不用学习？ 答：关于你的三个问题，我的意见是下面这样的。 学Go挺好，建议学，生产效率很高的开发工具。 “算法用不到”其实更准确的说法是“想不到”，或者是已经有人实现了你只需要调用，不需要自己实现。但是只有你知道了背后的道理，你才能明白算法对应的限制在哪里，什么情况下应该用什么算法。 高阶的技术可以按需学，按精力学，更根本的还是要打好基础，这也更有助于你判断是否应该深入学习某些技术。 5.“你可以发现，引入了输入输出设备的电脑，不再只能做狭义上的计算（也就是数学意义上的计算），如果我们把交互能力也看做一种计算能力的话，电脑理论上能够解决的计算问题变得无所不包。” 交互能力也看做一种计算能力吗？这句话应该怎么理解呢？这种交互不就是输入和输出？哪有计算？ 答：广义的计算包含有副作用的函数（有IO的函数）。因为数据交换本身也是计算的需求，否则计算没有办法与现实世界相互作用。任何工具都需要解决现实问题才有用。计算器还有交互按钮呢，并不是只有纯正的计算。 6.我要做一个最小机器人系统，需要考虑需求的变化点和稳定点。该怎么考虑呢？ 答：挺典型的问题。这个问法是一种典型的需求陈述误区。 描述需求需要有几个典型的要素： 用户，面向什么人群； 他们有什么要解决的问题； 我解决这个问题的核心系统。 只有满足这几个要素的需求才能进一步讨论变化点和稳定点。最小机器人可能符合上面的第三点，但是用户人群和要解决的问题没有描述，也就无法进一步去思考到底哪些因素是稳定的，哪些是易变的。 7. 编程框架和编程范式具体有什么区别呢？感觉它们都具备约束、规范的作用。 答：最主要的差别是：编程框架通常是领域性的，比如面向消息编程是多核背景下的网络服务器编程框架；编程范式则是普适性的，不管解决什么领域的问题都可以适用。 8.老师提到了如果需要重修数据结构这门课程，大学里面学的数据结构是不顶用了。那应该学习什么呢，您可以给个建议吗？ 答：这方面的资料不太多。可以给你一个我当年翻过的资料： Purely Functional Data Structures https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf 你可以参考看看。 9.老师您好，我不太理解您说的继承是个过度设计的原因，我目前在架构过程中大量使用了继承，而且我也觉得继承功能将我的代码功能高度抽象化，给我带来了很大的方便。我想咨询下您如果不是用继承的话，用什么方法替代继承的功能呢？ 答：建议继承只使用接口继承；正常情况下，优先用组合；当然因为大部分语言的组合功能不够强大，有时候从便捷性的角度继承可以适度使用，但是应当意识到如果过度使用继承对工程来说是有害的。 10.老师授课知识的角度很有深度，更贴切地说是一种思维方式，这种深度思考，从事情的本质重新推演与复盘的思考方式是很值得学习的。因为我们大部分人应该都没有想过自己去重新设计一个计算机的实现。不知道我这么理解的对不对。 答：从无到有到万物，我们这个课的脉络之一就是重新从零构建整个信息世界，这一点在开篇词中提到过，这一点非常非常关键。另一个脉络是架构思维的递进，这一章重点是需求分析。这两个脉络相辅相成，交织在一起。 11.许老师，您好，虽然自己是科班出身，但是对于下面这个问题困扰了我很久。 一般来说程序的运行需要OS的支撑，那么在BIOS之前，选择运行哪个操作系统那一段程序是怎么运行的？再问一句，编译器可以独立于操作系统运行吗？ 可以用C语言去实现很多其他的语言，比如说Python、Go等，那在C语言之前，这么一直追寻下去，会衍生成鸡生蛋的问题。但是编程语言又具有自举的功能，那自举是怎么实现的？比如目前版本的Go核心实现中，很多是用Go本身实现的，它是怎么做到自己编译自己的？ 答：先回答你的第一个问题，程序运行不需要操作系统支持，有BIOS支持就可以（把控制权交给它）。编译器可以独立于操作系统存在，而且它应该先于操作系统产生。 接下来是第二个问题，语言诞生的过程是这样的：机器码 =&gt;汇编 =&gt;C =&gt;C写的汇编、C写的C（自举）。当然这个过程不需要每次新架构的CPU或操作系统都重新来一遍，因为人是聪明的，发明了交叉编译这样的东西，C =&gt;新平台的C，这样就一下子完成整个语言的进化了。 12.许老师：选择某种语言无关的接口表示；能举个例吗？ 答：先看看是网络协议层的接口，还是跨语言的二进制接口。 前者比如protobuf之类就挺好，后者可以了解一下IDL之类的东西，不过我觉得都有点重。如果要跨语言，我的建议在网络协议层跨，或者用操作系统的动态库机制（有点原始但很轻）；如果语言内的接口，就别太复杂了，用语言自己的机制挺好的。 13.请问每个应用的虚拟内存地址是怎么分配的？起始地址都是0吗？函数F可以跨多个虚拟内存页吗？ 答：操作系统会保留一个地址空间，0通常也在保留区间内，因为0开始往往是中断向量表的地址，其他的地址区间怎么分配其实应用自己说了算。函数和数据都可以跨内存页。 14.老师您好，有两个问题希望解答。 淘汰的内存页数据保存在哪里；是保存在外置存储设备中吗； CPU加载对应程序的代码段到内存中，那么CPU是如何知道这个对应程序的代码段在什么位置的呢？ 答：第一个问题：是的，保存在外置存储中。对于unix系的系统往往是swap分区；windows则是一个隐藏属性的.swp文件。 第二个问题：代码段在哪里，是操作系统约定的，因为负责加载的人是操作系统，它设计程序文件的数据格式。 15.使用Java四年了，看到封装，继承，多态的描述，特别精准，又有了更深刻的理解。不了解Go语言，比如有一个表单的基类，里面有基本的处理，子类继承这个基类，有自己特殊的实现。这种情况，如何用组合实现呢？ 答：这是受继承思维的影响了。其实继承实现了代码复用和多态两个东西，揉在一起。在Go里面，组合实现代码复用，接口实现多态，彼此完全独立，非常清晰。 16.请问一下CPU是如何检查是否有中断的。是怎么及时知道发生了中断？每执行完一条指令都去检查一次吗？ 答：挺好的问题。硬件中断和软中断不一样。硬件中断你可以理解为总是会定期检查。软中断本身是一条指令，所以不存在检查这样的概念。 17.交叉编译是什么意思，不是很理解，老师能讲讲吗？ 答：其实理解清楚一个实质：编译器就是把高级语言翻译成为机器码，更抽象说，它其实就是格式转换器。 目标格式是不是编译器正在运行的环境并不重要，只不过如果目标格式刚好是当前机器的CPU+操作系统，那么目标格式就可以直接执行，否则就编译出一个当前环境下无法执行的目标格式，这种情况就叫交叉编译。 18.关于外存管理，有个问题从之前就困扰我。 磁盘的IO是由CPU完成的吗？但之前见到的说法是“CPU只能操作内存”。既然今天又提到了这个问题，文中提到“大量的磁盘 IO 操作，非常占用 CPU 时间”，那这两种说法是否矛盾？ 还想知道磁盘中的数据是怎么被加载到内存上来的呢？另外，更多的文章是说，“CPU的速度远远大于磁盘IO，CPU经常需要‘等待’磁盘IO”，这明显也是一种将CPU和外存割舍开的一种说法，而且按这种说法，CPU不光无需分配很多时间片给IO，而且还有很多“等待”时间。这也和本文中“非常占用CPU时间”相矛盾吧？ 答：所有外设CPU都统一基于数据交换（IO）的方式操作。CPU并不知道数据的含义，但是设备的使用方和设备知道。 这种情况下你可以简单理解CPU只是一根网线，但是很重要的一点是它让设备使用方和设备可以交互。CPU并不负责磁盘IO，但是它要等它结束以接收数据。这方面当然也有一些新技术出现改善这一点，可以想一想可能的优化路径，这里不表。 19.有一个疑问：协程属于用户态的线程，它跟线程之间怎么对应呢？协程之间也需要切换，那线程切换的那些成本它一样有啊，没想明白它的优势在哪。 答：从单位时间成本来说，有一定优势但也不会特别大。主要少掉的代价是从用户态到内核态再回到用户态的成本。 这种差异类似于系统调用和普通函数调用的差异。因为高性能服务器上io次数实在太多了，所以单位成本上能够少一点，积累起来也是很惊人的。 20.这种对需求的前瞻性探索挺重要，但同时感觉也是最难的，应该如何培养呢 答：很多时候是思维方式的转变。首先要尝试去做前瞻，预测错了并不可怕，但可以事后复盘到底是缺失了什么重要的信息让你判断出现了什么偏差。 21.隐隐感觉到架构的主要难点在于对需求的前瞻性判断，这要求的不仅仅是技术能力。目前几乎所有的架构课程，都是基于确定的需求来讲技术架构，例如秒杀系统怎么做高可用高并发。不知道我这么理解对不对。 答：架构在于创造，如果你从事的事情总是重复别人，那这个公司又有何价值？即使有所参考，也应该有自己的精气神，这个精气神是需要架构师把它干出来的。 精选学习留言恭喜@有铭和@Enthusiasm 两位同学，你们的留言被选为精选留言，极客时间将送出价值99元的专栏阅码一份。1个工作日之内，工作人员会与你取得联系。 @有铭 同学留言 对象范式的原始概念其实根本不包括类和继承，只有1.程序由对象组成，2.对象之间互相发送消息，协作完成任务。 最初世界上第一个面向对象语言是 Simula-67，第二个面向对象语言是 Smalltalk-71。 Smalltalk 受到了 Simula-67 的启发，基本出发点相同,但是最大的不同是Smalltalk是通过发消息来实现对象方法调用，而Simula是直接调用目标对象的方法。 Bjarne Stroustrup 在博士期间深入研究过 Simula，非常欣赏其思想，C++的面向对象思路直接受其影响，因为调用目标对象的方法来“传递消息”需要事先知道这个对象有哪些方法，因此，定义对象本身有哪些方法的“类”和“继承”的概念，一下超越了对象本身，而对象只不过是类这个模子里造出来的东西，反而不重要。 随着C++的大行其道，继承和封装变成了面向对象世界的核心概念，OOP 至此被扭曲为 COP （ Class Oriented Programming，面向类程序设计）。 但是COP这套概念本身是有缺陷的：每个程序员似乎都要先成为领域专家，然后成为领域分类学专家，然后构造一个完整的继承树，然后才能 new 出对象，让程序跑起来。 到了 1990 年代中期，问题已经十分明显。UML 中有一个对象活动图，其描述的就是运行时对象之间相互传递消息的模型。1994 年 Robert C. Martin 在《 Object-Oriented C++ Design Using Booch Method 》中，曾建议面向对象设计从对象活动图入手，而不是从类图入手。 而 1995 年出版的经典作品《 Design Patterns 》中，建议优先考虑组合而不是继承，这也是尽人皆知的事情。 这些迹象表明，在那个时候，面向对象社区里的思想领袖们，已经意识到“面向类的设计”并不好用。只可惜他们的革命精神还不够，Delphi 之父在创建.Net Framework 的时候，曾经不想要继承，在微软内部引起了很大的争议，最后是向市场低头，加上了继承。 2000 年后，工程界明确提出：“组合比继承重要，而且更灵活”，Go和Rust也许是第一批明确的对这种思路进行回应的语言，它们的对象根本不需要类本身来参与，也能完成对象范式的多态组合。 历史让 C++走上了舞台，历史也终将让 COP 重新回到 OOP 的本来面目 @Enthusiasm 同学学习笔记 总结：设计系统架构的前提是用户需求分析，用户需求包括分析出稳定需求点和变化需求点。从功能上看，稳定需求点一般是实现偏核心需求的需求点，变化需求点往往是实现偏扩展性需求的需求点。 从层次结构上看，稳定需求点往往在系统层次的底层，而变化需求点往往在更加抽象层（上层）。从从属关系上看，稳定点需要提供功能给变化点使用，变化点调用稳定点提供的功能。从时间顺序看，稳定需求往往先现是变化点实现的基础，变化点通过调用已经实现的稳定点提供的功能来实现更为抽象的功能。 系统架构类似于一个栈的结构，人机交互（变化点）放在栈顶，底层工作（稳定点）置于栈底。 这节课程让我联想到网络中的OSI 7层模型。大概其也体现了这种软件架构思想。好处就是架构清晰，职责明确，功能规范等等。 以往我认为的架构设计类似上面的描述，描述起来类似按自顶向下顺序，采用分治思想完成。但许老师的方法又有些巧：架构好比搭积木，许老师是先有了很多积木（需求点），然后把再确定这些积木放在哪一层次的格子里。这简化了架构设计的难度，好比用市场经济代替计划经济，很有趣。 架构设计博大精深，灵活多变，初学课程的我们，对架构设计的学习，也只能算是盲人摸象。 如果你在课程中有看不懂的地方，有想解答的架构问题，或者想分享的实战经验，都可以在文章下留言，如果你的留言被选中作为精选留言，我们将会为你送出价值99元的阅码一份。欢迎留言，与许式伟老师一起交流讨论，教学相长，共同精进。","link":"/2019/08/31/许世伟的架构课/加餐 |  想当架构师，我需要成为“全才”吗？/"},{"title":"加餐 | 我看Facebook发币（下）：深入浅出理解 Libra 币","text":"你好，我是七牛云许式伟。今天我们接着聊由 Facebook 推动的 Libra 币。 听到一个陌生概念后，人们往往习惯于把它和自己熟悉的东西做一个类比，方便和他人沟通的时候，用以表达自己的理解。 那么，和 Libra 最像的东西是什么呢？ 货币储备有人说，Libra 不就是腾讯的 Q 币么？但是，这种理解仅仅停留在非常表面的层次。两者共同之处，仅仅是因为两者都是一种虚拟币（甚至不能说它们都是数字货币，因为 Q 币是不能称之为数字货币的）。 首先，Q 币可以用货币购买，但是没法反向兑换现金。最关键的是，腾讯可以自由发行 Q 币，它说有多少就可以有多少，不需要被监管。所以如果 Q 币可以以稳定的价格兑换现金的话，相当于腾讯可以自由印钞票，这显然不会被政府所允许。 但是 Libra 并不是这样。Libra 可以自由兑换，另外 Facebook 也不能够自由发行 Libra 币。发行新的 Libra 币时，有两大核心约束。 其一，发行新的 Libra 币需要保值的资产做为抵押，我们称之为 “Libra 储备”。什么样的资产可以作为 Libra 储备？被 Libra 协会认可的，稳定且信誉良好的中央银行发行的货币，或者政府货币证券。也就是说，Libra 币锚定的是它认可的“一篮子货币”，而不是某一种货币。 其二，由 Libra 协会来发行或销毁 Libra 币。目前 Libra 协会执行这个动作完全是被动的。Libra 生态中，会有一些被授权的经销商，他们负责 Libra 币的买卖。 这些授权经销商会按照一定的汇率，以某种被 Libra 协会认可的货币，向 Libra 协会买入 Libra 币。这时，这些用于买入的货币就会成为 Libra 储备。 当然授权经销商也可能卖出 Libra 币，换成他所期望的某种货币。在这种情况下，被卖出的 Libra 币就会被销毁，相应地， Libra 储备就会减少。 所以你可以看到，Libra 并没有自己的货币政策，总共有多少 Libra 币完全是由市场的供需决定的。 关于货币储备更详细的内容，请参阅 “Libra 储备”。 稳定币既然 Libra 不像 Q 币，那么它像什么？比特币吗？ 相比 Q 币来说，Libra 与比特币的确更有比较意义，毕竟它们都是一种数字货币。但是我们在 “我看Facebook发币（上）：区块链、比特币与 Libra 币” 中，也已经谈到过两者一些根本上的不同。 如果我们忽略所有的技术细节，单从货币角度来看，比特币和 Libra 最大的区别是价格的波动性。 通过上面我们对 “Libra 储备” 的介绍，我们很容易知道 Libra 是一种稳定币，它看起来更像是由一些保值资产抵押所形成的 “债券”。而在币圈，大家可能都经常会听到一个词，叫做 “炒币”。 如果我们细想一下这背后的逻辑，就会知道这个词其实挺神奇的。 货币的核心价值是什么？ 货币的价值显然不是增值，而是流通。而流通用的货币，最重要的是价格稳定。而币圈则不同，这些各式各样存在的币，现在它们的核心价值变成了 “炒”，这就完全被扭曲了。 我这么说当然不是认为比特币不好。只不过如果我们真的对比特币好，就应该把关注点放在比特币流通价值的构建上；而不是“喜看币涨”，涨了就奔走相告。 世界货币那么，究竟 Libra 最像什么呢？ 我个人认为，虽然目前的实现机制有所不同，但是 Libra 最像的是欧元。欧元的出现，对欧盟国家之间的自由贸易往来发挥了巨大的贡献。 欧元和 Libra 的初衷是一样的，都是为了构建跨国的自由经济贸易体系。两者不同之处在于，当前 Libra 还没有央行，不能凭空去发行货币。 凡事都有两面，“世界货币” 同样是有缺陷的。欧债危机导致欧元贬值，这个教训大家还记忆犹新。它告诉我们，一个国家经济出现问题，如果它采用的是独立的主权货币，那么只是导致本国的货币贬值。 但是 “世界货币” 意味着大锅饭，它会传导到整个经济体，连带整个经济体的货币贬值。 那么 Libra 会出现自己的央行么？短期当然不会，当前最重要的是流通，是地盘的扩张。但是长远看只要 Libra 成功了，就一定会有。毕竟，没有 Libra 央行，就没有机会解决 “大锅饭” 的问题。 所以站在更长远的未来看，今天的 Libra 协会，有可能就会是未来的 “Libra 央行”。 Libra 协会Libra 协会总部位于瑞士日内瓦，协会成员包括分布在不同地理区域的各种企业、非营利组织、多边组织和学术机构。初始协会成员共有28家（如下图），未来计划达到100家。 加入 Libra 协会，需要支付不低于 1000 万美元来购买 Libra 投资代币，注意，它并不能简单理解为 Libra 币，两者有很大不同，它有很多特殊的权益。 其一，整个 “Libra 储备” 的处置权。比如， Libra 储备到底放在哪里会比较安全靠谱？这是由Libra 协会决定的。但是每个成员是不是都是一票？并不是，票数是由这个成员持有的 Libra 投资代币数量决定的。具体规则，我在下面会讨论。 其二，整个 “Libra 储备” 的利息，会被用来支撑 Libra 协会的日常运转。比如工资和奖金激励，也会用于派发分红。分红会按照持有的 Libra 投资代币的多少来分配。 其三，各类事务决策的投票权。权重按持有的 Libra 投资代币来计算，每 1000 万美元有 1 个投票权，但是为了防止投票权过于集中，任何成员的投票权不能超过总票数的 1%。 超出部分的投票权将由 Libra 协会的董事会重新分配，比如授予具有社会影响力的合作伙伴（称为 SIP）或研究机构，前提是：他们有能力并致力于验证节点的运作，从而参与治理，并且确实无法作出最低 1000 万美元的投资。 其四，运行验证节点。这一点可以被看作义务，但也可以看作权益。义务角度来说，显然这事是需要 IT 成本的，如果连这都做不到，就会被剔除出去。从权益角度来说，那么多的交易数据都被你拿到了，这是多么有价值的数据。 关于 Libra 协会储备更详细的内容，请参阅 “Libra 协会”。 发展目标当前 Libra 的验证节点是有限制的，是许可型的，也就是所谓的 “联盟链”。但是，未来它会向非许可型治理和共识节点运营转变，降低参与的准入门槛，并减少对创始人的依赖。 Libra 将逐步进行网络的开放，变成所谓的 “公链”。这时，新成员也能够通过投资 1000万美元来自动获得验证节点的运行许可，并持有 Libra 投资代币，从而分享网络权益（但是我估计投票权之类是没有的，只有投资收益）。这部分的详细政策，或许未来才会逐步明朗。 Libra 协会致力于尽可能减少协会的干预权。比如完全通过市场机制来调节 Libra 币的供需。所以除了说服更多人加入 Libra 协会，协会最重要的工作是确定 Libra 的技术演进路线。 但这一点真实情况下显然并不会那么理想。货币互联网和互联网不同的是，它管的毕竟是钱。一旦 Libra 网络发展壮大，一些货币相关的治理问题就会暴露出来。 降维打击Libra 的影响面绝对超乎大部分人的想象。我们先看看一些具备技术背景的知名互联网公司 CEO 是怎么看的。具体参见下面的截图。 显然无论王兴还是王小川，都高度重视并反复评估 Libra 带来的影响和自己应该采取的行动。 Libra 带来的打击是全方位的，某种程度上来说甚至是极难抵御的降维打击。我们不妨从以下这些维度看。 弱小国家的货币主权会不会就此被取代？ 中国的汇率管控会不会失效？就算没有失效，会不会变成闭关锁国？ Libra 是否会成为美国取代美元的新货币霸权？ 从企业与企业竞争的角度，这会不会成为 Facebook 对微信、支付宝的降维打击？ 想完影响面想对策。从对策的角度来说无非两种，一是对抗，一是谋求对等权力下的协作。当然，这两条路都不会太容易。 结语今天，我们从分析 Libra 的运行机制重新去理解 Libra 币。这里面的关键是：理解 Libra 协会究竟如何工作的。 我们没有分析 Libra 的技术细节，比如它怎么改变区块链的底层实现机制，又为什么要引入 Move 语言。如王兴所说，评判 Libra 的实现技术好不好，就好比评价美元钞票的印刷技术精细不精细。这事本身是有价值的，但不那么关键。 为什么我会写这两篇文章？ 站在未来看现在，Libra 币将会是极其重大的一个历史节点。我倾向于这样来描绘它的影响： 计算机 =&gt; 互联网 =&gt; Libra 币 货币有着巨大的网络效应，留给后来者的时间窗口极短。我想，我们都应该思考怎么去面对这件事情了。","link":"/2019/08/31/许世伟的架构课/加餐 | 我看Facebook发币（下）：深入浅出理解 Libra 币/"},{"title":"36 | 业务状态与存储中间件","text":"你好，我是七牛云许式伟。 相比桌面程序而言，服务端程序依赖的基础软件不只是操作系统和编程语言，还多了两类： 负载均衡（Load Balance）； 数据库或其他形式的存储（DB/Storage）。 存储在服务端开发中是什么样的一个地位？今天我们就聊一下有关于存储中间件的那些事情。 业务状态让我们从头开始。 首先我们思考一个问题：桌面程序和服务端程序的相似之处在哪里，不同之处又在哪里？对于这样一个开放性的问题，我们不同人可能有非常不同的答案。 今天让我们从数据的视角来看这个问题。 我们知道，一个桌面程序基本上是由一系列的 “用户交互事件” 所驱动。你可以把它理解为一个状态机：假设在** i ** 时刻，该桌面程序的状态为业务状态i ，它收到用户交互事件i后，状态变化为业务状态i+1 。这个过程示意如下： 业务状态i+1 = F( 用户交互事件i ，业务状态i ) 用状态转换图表示如下： 那么，服务端呢？ 仔细考虑你会发现，其实服务端程序可以用一模一样的模型来看待。只不过它不是由 “用户交互事件” 来驱动，而是由 “网络API请求” 所驱动。 你同样可以把它理解为一个状态机：假设在** i ** 时刻，该服务端程序的状态为业务状态i ，它收到网络API请求i **后，状态变化为业务状态i+1 **。这个过程示意如下： 业务状态i+1 = F( 网络API请求i ，业务状态i ) 用状态转换图表示如下： 那么，桌面程序和服务端程序的差别在哪？ 它们最大的差别是业务状态的表示不同。 桌面程序的业务状态是如何表示的？内存中的数据结构。我们在上一章中提到，桌面程序的 Model 层是一棵 DOM 树，根结点通常叫 Document。这棵 DOM 树其实就是桌面程序的业务状态。 服务端程序的业务状态如何表示？用内存中的数据结构可以吗？ 答案当然是不能。如果业务状态在内存中，服务端程序一挂，数据就丢了。 前面我们在 “34 | 服务端开发的宏观视角” 提到过： 服务端的领域特征是大规模的用户请求，以及 24 小时不间断的服务。 这句话是理解服务端体系架构的核心，至关重要。但某种意义上来说更重要的原则是： 坚决不能丢失用户的数据，即他认为已经完成的业务状态。 服务端对用户来说是个黑盒，既然用户收到某个 “网络API请求” 成功的反馈，那么他会认为这个成功是确认的。 所以，服务端必须保证其业务状态的可靠性。这与桌面程序不同，桌面程序往往需要明确的用户交互事件，比如 Ctrl+S 命令，来完成数据的存盘操作，这时业务状态才持久化写入到外存。而且对于大部分桌面程序来说，它并不需要支持持久化。 存储中间件与容灾级别在没有存储中间件的情况下，服务端需要自己在响应完每一个网络 API 请求之后，对业务状态进行持久化。 听起来这好像不复杂？ 其实不然，服务端程序的业务状态持久化难度，比桌面程序要高很多。还是同样的原因，桌面程序是单用户使用的，持久化的时候什么别的事情也不干，看起来用户体验也可以接受。 但是对服务端程序而言，如果我们在某个 API 请求完成并持久化的时候，其他 API 请求如果只能排队等着的话，往轻了说服务的吞吐能力太差了；往严重里说，在持久化执行的那个时段，服务端在用户眼里就停止服务了。所以持久化的时间必须要足够短，短到让人感知不到服务停顿。 服务端程序的业务状态并不简单。这是一个多租户的持久化状态。就算一个用户的业务状态数据只有 100K，有个 100 万用户，那么需要持久化的数据也有 100G。这显然不能用“常规桌面程序每次完全重新生成一个新文件”的持久化思路做到，它需要被设计为一种增量式的存储系统。 如果每一个做服务端程序的开发人员需要自己考虑如何持久化业务状态，这个代价显然过高了。 于是，存储中间件就应运而生了。 从历史上来看，第一个存储中间件是数据库，出现在 1974 年，它就是 IBM System R。 这一年 Internet 刚刚被发明出来。所以数据库的诞生背景，很可能是为工作站服务的，也算网络服务的范畴。 桌面程序很少用数据库。只有一些需要增量持久化业务状态的场景会被采用，比较典型的是微信。微信的本地聊天纪录应该是基于数据库存储的，只不过用的是嵌入式数据库，比如 SQLite。 最早期人们对存储中间件的容灾级别要求并不高。数据库都是单机版本，没有主从。人们对存储中间件的诉求是高性能的、稳定的、经过验证的。数据的可靠性如何保证？晚上选个服务的低峰时期对数据库做个离线备份就完事了。 对服务端开发来说，数据库的出现是革命性的，它大大提升了开发效率。 但在容灾级别这个事情上，随着互联网的普及，我们对它的要求越来越高。 首先，单机数据库是不够的，需要多机相互热备，这就是数据库主从结构的来由。这样我们就不需要担心数据库单机故障会导致服务临时不可访问，甚至出现更严重的数据丢失。 其次，单机数据库是不够的，单机存储量终归有上限，这样我们服务的用户数就有上限。在分布式数据库出现之前，人们的解决方案是手工的分库分表。总之，业务上我们需要做到规模可伸缩，不必担心单机物理存储容量的限制。 最后，单机房的可靠性也是不够的，机房可能会出现网络中断，极端情况下还可能因为自然灾害，比如地震，导致整个机房的数据丢失。于是就出现了“两地三中心”，跨机房容灾的数据灾备方案。 存储即数据结构那么问题来了，数据库能够解决所有服务端程序的业务状态持久化需求吗？ 答案当然是不能。 对比桌面程序我们能够知道，业务状态其实就是数据结构。虽然数据库这个数据结构的确通用性很强，但是它不是银弹，在很多场合下它并不适用。 存储即数据结构。 存储中间件是什么？存储中间件就是 “元数据结构”。 这个结论的逻辑在于下面几个方面。 首先，和桌面开发不同，桌面端的数据结构基本上都是基于内存的，实现难度较低。但是在服务端不同。我们每一次的业务状态改变都需要考虑持久化，所以服务端的核心数据结构都是基于外存的。 其次，服务端的数据结构对稳定性要求、并发性能（IOPS）要求极高。简单分析就可以知道，服务端程序的伸缩能力完全取决于存储的伸缩能力。 业务服务器往往是无状态的，压力大了新增加一台业务服务器非常容易。但是存储压力大了，并不能简单加一台机器了事，可能涉及数据的重新划分和搬迁工作。 这意味着，在服务端实现一个数据结构是非常困难的。我们举一个很简单的例子，在内存中我们实现一个 KV 存储非常容易，很多语言都有 Dictionary 或者 Map 这样的数据结构来做这事。就算不用库，我们自己花上几十分钟或一个小时来实现，也是非常轻松的一件事情。 但是，一个服务端的 KV 存储非常非常复杂，绝非一个人花上一天两天就可以干出来。就算干出来了，也没人敢立刻投入使用，需要经过非常庞大的测试案例进行方方面面的验证，才敢投入生产环境。并且，即使敢投入生产环境了，为了以策万全，刚开始往往也是采用“双写”的方式：同时使用一个成熟存储系统和我们新上线的存储。 存储系统的品控，至关重要。 正因为服务端的数据结构实现如此之难，所以对于服务端来说，所有业务需要涉及的数据结构都需要抽象出来，成为一个存储中间件。 存储中间件会有多少？ 这与服务端开发的模型抽象有关。今天没有比较系统性的理论告诉大家，有了这样一些数据结构就完备了。但是从更长远发展的角度来看，我们很可能需要回答这个问题。 所以，存储中间件是 “元数据结构”。 这里说的 “元数据结构”，是我自己发明的一个词。它表达的含义是，数据结构的种类是非常有限的，并且最好理论可被证明，有了这样一些基本的数据结构，所有的业务需求都可以高效地实现。这些基本的数据结构，就是我说的 “元数据结构”。 今天我们接触的存储中间件有哪些？不完整的列表如下： 键值存储（KV-Storage）； 对象存储（Object Storage）； 数据库（Database）； 消息队列（MQ）； 倒排索引（SearchEngine）； 等等。 目前看，存储中间件的种类是不可枚举的。但它很可能只是受限于我自己的认知，也许有一天我们能够在这个问题上找到更加完美的答案。 结语今天我们从桌面端程序和服务端程序的业务状态开始，探讨了存储中间件的由来。 前面我们在 “34 | 服务端开发的宏观视角” 提到过： 服务端的领域特征是大规模的用户请求，以及 24 小时不间断的服务。 这句话是理解服务端体系架构的核心，至关重要。但某种意义上来说更重要的原则是： 坚决不能丢失用户的数据，即他认为已经完成的业务状态。 存储即数据结构。存储中间件就是 “元数据结构”。 对于服务端来说，存储中间件至关重要。它不只是极大地解放了生产效率，也是服务端的性能瓶颈所在。几乎所有服务端程序扛不住压力，往往都是因为存储没有扛住压力。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将聊聊数据库。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/36 | 业务状态与存储中间件/"},{"title":"37 | 键值存储与数据库","text":"你好，我是七牛云许式伟。 上一讲我们介绍了存储中间件的由来。今天我们就聊一下应用最为广泛的存储中间件：数据库。 数据库的种类从使用界面（接口）的角度来说，通常我们接触的数据库有以下这些。 使用最为广泛的，是关系型数据库（Relational Database），以 MySQL、Oracle、SQLSever 为代表。 这类数据库把数据每个条目（row）的数据分成多个项目（column），如果某个项目比较复杂，从数据结构角度来说是一个结构体，那么就搞一个新的表（table）来存储它，在主表只存储一个 ID 来引用。 这类数据库的特点是强 schema，每个项目（column）有明确的数据类型。从业务状态的角度看，可以把一个表（table）理解为一个结构体，当遇到结构体里面套结构体，那么就定义一个子表。 第二类是文档型数据库（Document Database），以 MongoDB 为代表。这类数据库把数据每个条目（row）称为文档（document），每个文档用 JSON或其他文档描述格式表示。 当前文档型数据库大部分是无 schema 的，也就是在插入文档时并不对文档的数据格式的有效性进行检查。 这有好有坏。好处是使用门槛低，升级数据格式方便。不好之处在于，质量保障体系弱化，数据可能被弄脏而不自知。可以预见的是，未来也会诞生强 schema 的文档型数据库。 第三类是键值存储（KV Storage），以 Cassandra 为代表。 键值存储从使用的角度来说，可以认为是数据库的特例。数据库往往是允许设定多个索引字段的，而键值存储明确只有唯一索引。 从实现角度来说，键值存储是数据库的基础。每一组数据库的索引，往往背后就是一组键值存储。 事务无论是何种数据库，都面临一个重大选择：是否支持事务。这是一个艰难选择。从需求角度来说，事务功能非常强大，没道理不去支持。从实现角度来说，事务支持带来极大的负担，尤其是在分布式数据库的场景。 什么是事务？简单来说，事务就是把一系列数据库操作变成原子操作的能力。展开来说，事务的特性我们往往简称为 ACID，详细如下。 原子性（Atomicity）：在整个事务中的所有操作，要么全部完成，要么全部不做，没有中间状态。对于事务在执行中发生错误，所有的操作都会被回滚，整个事务就像从没被执行过一样。 一致性（Consistency）：事务的执行必须保证系统的一致性。这一点拿转账为例最容易理解。假设 A 有 500 元，B 有 300 元，如果在一个事务里 A 成功转给 B 50元，那么不管并行发生了其他什么事，A 账户一定得是 450 元，B 账户一定得是 350 元。 隔离性（Isolation）：事务与事务之间不会互相影响，一个事务的中间状态不会被其他事务感知。 持久性（Durability）：一旦事务完成了，那么事务对数据所做的变更就完全保存在了数据库中，即使发生停电，系统宕机也是如此。 如果我们忽略性能要求，事务是很好实现的，只需要用一把能够 Lock/Unlock 整个数据库的大锁就够了。 但这显然不现实，一把大锁下来，整个数据库就废了。从 IOPS（IO 吞吐能力）角度来说，为什么分布式数据库很讨厌事务是很容易理解的：如果没有事务，一次数据库操作很容易根据数据的分区特征快速将操作落到某个分区实例，剩下来的事情就纯粹是一个单机数据库的操作了。 一种常见的事务实现方式是乐观锁。 什么是乐观锁？ 常规的锁是先互斥，再修改数据。不管是不是发生了冲突，我们都会先做互斥。 但乐观锁不同，它是先计算出所有修改的数据，然后最后一步统一提交修改。提交时会进行冲突检查，如果没有冲突，也就是说，在我之前没有人提交过新版本，或者虽然有人提交过新版本，但是修改的数据和我所依赖的数据并不相关，那么提交会成功。否则就是发生了冲突，会放弃本次修改。 这意味着，每个数据有可能有多个值。如下： KEYi -&gt; [(VER0, VAL0), (VER1, VAL1), …] 其中，VER0 对应当前已经提交的值 VAL0，VER1 对应事务1 中修改后的值 VAL1，以此类推。 除了修改后的值外，每个事务还需要记录自己读过哪些数据。不幸的是，它并不是记录读过的 KEY 列表那么简单，而是要记录所有的读条件。 例如，对于 SELECT name, age, address WHERE age&gt;17 这样一个查询，我们不是要记录读过哪些 name、age、address，而是认为我们读过所有 age&gt;17 的条目（row）。 在事务提交的时候，锁住整个数据库（前面修改过程事务间不冲突，所以不需要锁数据库），检查所有记录的读条件，如果这些读条件对应的条目（row）的已提交版本都&lt;=基版本（VER0），那么说明不冲突，于是提交该事务所有的修改并释放锁。 如果事务提交的时候发现和其他已提交事务冲突，则放弃该事务，对所有修改进行回滚（其实是删除该事务产生的版本修改记录）。 到这里我们就可以理解为什么要用乐观锁了：至少它让锁数据库的粒度降到最低，判断冲突的逻辑也都是可预期的行为，这就避免了出现死锁的可能。 我们很容易可以推理得知，在所有并行执行的事务中，必然有一个事务的提交会成功。这样就避免了饥饿（永远都没人可以成功）。 主从结构一旦我们考虑数据库的业务可用性和数据持久性，我们就需要考虑多副本存储数据。可用性（Availability）关注的是业务是否正常工作，而持久性（Durability）关注的是数据是否会被异常丢失。 当我们数据存在多个副本时，就有数据一致性的问题。因为不同副本的数据可能值不一样，我们到底应该听谁的。 我们的服务同时存在很多并发的请求，这就可能存在客户端 A 希望值是 VALa ，客户端 B 希望值是 VALb 的情况。 解决这个问题的方法之一是采用主从（Master-Slave）结构。主从结构采用的是一主多从模式，所有写操作都发往主（Master），所有从（Slave）都从主这边同步数据修改的操作。 这样，从（Slave）的数据版本只可能因为同步还没有完成，导致版本会比较旧，而不会出现比主（Master）还新的情况。 从（Slave）可以帮主（Master）分担一定的读压力。但是不是所有的读操作都可以被分担。大部分场景的读操作必须要读到最新的数据，否则就可能会出现逻辑错乱。只有那些纯粹用于界面呈现用途，而不是用于逻辑计算的场景，非敏感场景（比如财务场景是敏感场景）下能够接受读的旧版本数据，可以从从节点读。 从（Slave）最重要的是和主（Master）形成了互备关系。在主挂掉的时候，某个从节点可以替代成为新的主节点。这会发生一次选举行为，系统中超过一半的节点需要同意某个节点成为主，那么选举就会通过。 考虑选举的话，意味着集群的节点数为奇数比较好。比如，假设集群有 2 个节点，只有一主一从，那么在主挂掉后，因为只剩下一个节点参与选举，没有超过半数，选举不出新的主节点。 选择谁成为新的主是有讲究的，因为从的数据有可能不是最新的。一旦我们选择没有最新数据的从作为新的主节点，就意味着版本回退，也就意味着发生了数据丢失。 这是不能接受的事情。为了避免版本回退，写操作应该确保至少有一个从节点收到了最新的数据。这样在主挂掉后才可以确保能够选到一个拥有最新数据的节点成为新的主节点。 分布式多副本让数据库的可用性和持久性有了保障，但是仍然有这样一些问题需要解决： 数据规模大到一定程度后，单个物理节点存放不了那么大的数据量； 主承受的读写压力太大，单台主节点承受不了这样高的 IOPS（吞吐能力）。 从目前存储技术的发展看，单台设备的存储量已经可以非常高，所以上面的第二种情况也会很常见。 怎么解决？ 分布式。简单说，就是把数据分片存储到多台设备上的分片服务器一起构成一个单副本的数据库。分片的方式常见的有两种： 哈希分片（Hash based sharding）； 范围分配（Range based sharding）。 无论哪个分片方式，都会面临因为扩容缩容导致的重新分片过程。重新分片意味着需要做数据的搬迁。 数据迁移阶段对数据访问的持续有不低的挑战，因为这时候对正在迁移的分片来说，有一部分数据在源节点，一部分数据在目标节点。 在分布式存储领域，有一个著名（CAP）理论。其中，C、A、P 分别代表一个我们要追求的目标。 数据一致性(Consistency)：如果系统对一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据。 服务可用性(Availability)：所有读写请求在一定时间内得到响应，可终止、不会一直等待。 分区容错性(Partition-tolerance)：在网络分区的情况下，被分隔的节点仍能正常对外服务。 那么 CAP 理论说的是什么？简单说，就是 C、A、P 三个目标不能兼得，我们只能取其二。 假设我们不会放弃服务的可用性，那么我们决策一个分布式存储基本上在数据一致性（C）和分区容错性（P）之间权衡。 数据一致性（C）的选择基本上是业务特性决定的，业务要求是强一致，我们就不可能用最终一致性模型，相应的，我们只能在分区容错性（P）上去取舍。 结语今天我们概要讨论了数据库相关的核心话题。我们第一关心的，当然还是使用界面（接口）。从使用界面角度，我们要考虑选择关系型数据库还是文档型数据库，以及是否需要事务特性。 确定了我们要使用什么样的数据库后，接着我们从实现角度，考虑主从结构和分布式方面的特性。 数据库是非常专业并且复杂的领域，限于篇幅我们这里不能展开太多，你如果有兴趣可以参考相关的资料。 如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将聊聊对象存储。 如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。","link":"/2019/08/31/许世伟的架构课/37 | 键值存储与数据库/"},{"title":"开篇词 | 怎样成长为优秀的软件架构师？","text":"你好，我是许式伟。从今天起，我想和你一起来聊聊架构的话题。 开始之前，我先来和你简单介绍下我自己。 我是2000年开始工作的，曾经做过WPS的首席架构师，也在盛大从事过技术研究方面的工作，后来在2011年创立了七牛云，现在我是一名创业者、CEO。但不管角色怎么轮换，我觉得我的另一面始终是一名程序员、架构师（如果你想了解更多我的经历，可以观看下面的短视频）。 让我们来想象一下，如果把信息世界看成一座大厦，把程序员看成这个世界的建筑师，那么，现在的你在负责什么样的工作呢？ 当我们把程序员类比成建筑师时，按照能力水平来分，我觉得大体可以分为三个层次：搬砖师、工程师、架构师。 软件搬砖师之名对应到建筑行业的建筑工人，他们的编程能力和业务基本上停留在堆叠代码，按照要求去实现功能需求的层面。 只要能让程序跑起来，能正确地实现业务逻辑，就可以称为“会编程”的人。有时候，我们也会看见程序员自称为“码农”“搬砖的”，虽然二者的工种不同，但从基础工作的相似度来说，确实有可类比的成分。 很多外行的人都会觉得程序员是一个很神秘的职业，但实际上程序员的基础门槛并不算高。我自己从2016年2月开始至今，一直在教几位8~12岁的小朋友学习编程。这个实践经验告诉我：小学生完全有能力学编程。而且，并不是只有部分小学生可以，而是任何一位小学生都可以学会。 然而，只让代码跑起来是不够的。这个世界是不断变化的，作为程序员，我们更多的时间是用来维护代码：增加新的需求，对已有的功能进行调整，修改之前代码遗留下来的问题，优化性能等等。 这是因为一个软件诞生之后，后续就是需要花费大量的代价去维护它，演进它。一个人是完全维护不过来的，需要更多的人，很多的团队一起协作。如果面临了员工离职、岗位调整等情况，还会导致软件代码在不同人之间流转。 所以，一些有追求的程序员会关注代码的质量。代码质量的评判可以有这样一些基本维度：可阅读性（方便代码流转）、可扩展性/可维护性（方便修改功能，添加新功能）、可测试性（质量管理）、可复用性（简化后续功能开发的难度）。 这一类致力于不断提升软件代码的工程质量的程序员，我们可以称他们为软件工程师。 工程师不会简单把写代码看作一门工作，把任务交代过去就完事。他们会有“洁癖”，代码在他们眼里是一种艺术，是自己生命的一部分。 他们会把写出来的代码改了又改，直到让自己满意为止。阅读和维护软件工程师写的代码会有一种赏心悦目的感觉。 但是，大部分商业软件都是一项极其复杂的工程，它们远比很多传统的建筑工程复杂得多，无论是涉及的人力、时间还是业务的变数都要多很多。 人力上，大部分大型的软件系统都有几千甚至几万人的规模，而这几千几万人中，却没有两个人的工作是重复的，他们都是在从事着前所未有的创造性工作。 时间上，只要软件还在服务客户中，程序员们的创造过程便不会停止，软件系统仍然持续迭代更新，以便形成更好的市场竞争力。 这些都与传统建筑工程的模式大相径庭。一幢建筑自它完成之后，所有的变化便主要集中在一些软装的细节上，很少会再发生剧烈的变动，更不会持续地发生变动。但软件却不是这样，它从诞生之初到其生命周期结束，自始至终都在迭代变化，从未停止。 所以，光靠把控软件工程师的水平，依赖他们自觉保障的工程质量，是远远不够的。软件工程是一项非常复杂的系统工程，它需要依赖一个能够掌控整个工程全局的团队，来规划和引导整个系统的演变过程。这个团队就是架构师团队。 软件架构师的职责，并不单单是我们通常理解的，对软件系统进行边界划分和模块规格的定义。 从根本目标来说，软件架构师要对软件工程的执行结果负责，这包括：按时按质进行软件的迭代和发布、敏捷地响应需求变更、防范软件质量风险（避免发生软件质量事故）、降低迭代维护成本。 那怎么才能成长为优秀的软件架构师？软件架构师和软件工程师最根本的差别又在哪里？我认为关键在于四个字：掌控全局。 掌控全局，就是对系统的全貌了然于胸。从传统的建筑工程来说，建筑架构师并不单单要会画建筑图纸，而是要对地基构建、土质、材料、建筑工艺等等所有有可能影响建筑质量的因素都要了然于胸。 掌控全局，并不是无所不能，不是成为全栈，怎么做到掌控全局？核心在于对知识脉络的体系化梳理。这是架构能力构建和全面提升的关键。这种方法不单单是在软件工程中适用。 比如学数学，我个人非常喜欢做的一件事情是自己去推导书上所有的公式。每一个公式我都亲自推导而来。 这样做的核心意义在于，我在尝试从0开始，去构建整个精彩纷呈的数学世界，整个数学发展史在自己的笔下重新演绎了一遍，来龙去脉清清楚楚。有时候你甚至会推导出还没有学到的公式，但是在后面学到了。这种体验非常有趣而又让人满足。 是的，掌控全局的前提是：在自己心中去重新构建出整个世界。在这个过程中，你不需要一上来沉浸在某个技术的实现细节（除非它影响了你对这个世界构建过程的理解），但是你知道整个世界的脉络，知道整个世界的骨架。 这个时候，你对这个世界的感觉是完全不同的，因为，你已经成为了这个世界的构建者。 而架构的本质，不也正是构建和创造么？ 作为一个软件行业的从业人员，我们可能接触各种各样的技术书籍。有讲编程语言的、讲数据结构与算法的、讲操作系统的、讲编译原理的、讲架构设计的，还有领域技术类的（比如数据库、存储、大数据、人工智能之类）。 大部分类别的技术书，多多少少都能够找到几本经典著作。但是，架构设计很可能是个例外，当我想推荐一本经典的架构设计书时，我并不能非常快速地想到应该推荐哪本。 从个人经验来说，我接触过的与架构相关的图书，大概有如下这些分类。 架构思维类。这类图书通常从一些著名的架构理论讲起，比如开闭原则、单一职责原则、依赖倒置原则、接口分离原则，等等。这种图书的问题在于过度理论化。计算机科学归根到底属于工程技术类，实践第一。 设计模式类。这一类图书则一下子进入架构的局部细节，每个模式的来龙去脉并不容易理解。就算理解了某个具体的模式，但是也很难真正做到活学活用，不知道还是不知道。 分布式系统架构设计类。这类图书通常从服务端的通用问题如一致性、高可用、高并发挑战等话题讲起，讲大型业务系统面临的挑战。这些知识是非常有价值的，但无法延伸到通用业务架构，对大部分企业的架构实践并不具备真正的指导意义。 重构类。这类图书主要讲怎么把坏代码一步步改进到好代码。我认为这是最实用的一类。但在没有优秀架构师主导的情况下，大部分公司的代码不可避免地越变越坏，直到不堪重负最后不得不重写。实际上，一个模块最初的地基是最重要的，基本决定了这座大厦能够撑多久，而重构更多侧重于大厦建成之后，在服务于人的前提下怎么去修修补补，延长生命。 这些架构类的图书并没有达到我个人的期望。因为它们都没有揭开架构设计的全貌。 我自己在职业生涯中前后大概做过十几次的架构类演讲，这也是我最为重视、重复次数最多的一类演讲。但同样地，这样零星的演讲对于传递架构设计思想来说，仍然远远不够。 所以一直以来，我就心存着这样一个念头：“要写一本不一样的架构类图书”。这个念想，也正是今天这个专栏的由来。 这个专栏的内容组织算是我的一次尝试。它和今天你看得到的大部分架构书并不太一样。我基本上围绕着两个脉络主线来展开内容： 如何从零开始一步步构建出整个信息世界； 在整个信息世界的构建过程中，都用了哪些重要的架构思维范式，以及这些范式如何去运用于你平常的工程实践中。 这两大脉络相辅相成。首先，我们通过还原信息世界的构建过程，剥离出了整个信息世界的核心骨架，这也是最真实、最宏大的架构实践案例。其次，我们结合这个宏大的架构实践来谈架构思维，避免因对架构思维的阐述过于理论化而让人难以理解。 我想，每个程序员都有一颗成为架构师的心。所以，从内容设计来说，我希望这是一个门槛最低的架构设计专栏，也希望它可以帮助到想成为架构师的初学者，达成自己的目标。 在行文上，我会尽量避免深奥的术语，尽可能以通俗易懂的文字，来描述信息世界构建者们的所思所想。如果你在阅读的过程中遇到了理解上的障碍，非常欢迎你来给我留言，我将尽可能地根据你的反馈，做出必要的调整。 如果你已经成为了架构师，我也希望可以为你规避一些错误的经验。在过去的工作经历里，我看到不少架构师都会倾向于把架构看作一项纯技术性的行为。他们的工作流程是这样的：产品经理根据用户的需求做出产品设计，然后架构师再依据产品设计给出实现，也就是软件的架构设计方案。 在我看来，这其实是个误解。架构关乎的是整个复杂的软件工程，它关乎实现它的人，它又因团队的能力而异。 同时，架构也关乎用户需求，作为架构师，我们不只是要知道当前的用户需求是什么，我们还要预测需求未来可能的变化，预判什么会发生，而什么一定不会发生。预测什么不会发生最为重要，只有做到这一点，才能真正防止架构的过度设计，把简单的事情复杂化。 谈了这么多，那么，应该怎样成长为优秀的软件架构师？我想，一靠匠心，二靠悟心。架构设计并无标准答案，但我仍然希望把我这些年的所思所想分享给你，更希望这些内容能给你一些启发。","link":"/2019/08/31/许世伟的架构课/开篇词 | 怎样成长为优秀的软件架构师？/"},{"title":"CSS Flex排版：为什么垂直居中这么难？","text":"你好，我是winter。今天我们来谈谈Flex排版。 我们在前面多次讲过，正常流排版的设计来源于数百年来出版行业的排版经验，而HTML诞生之初，也确实是作为一种“超文本”存在的。 但是，自上世纪90年代以来，Web标准和各种Web应用蓬勃发展，网页的功能逐渐从“文本信息”向着“软件功能”过渡，这个思路的变化导致了：CSS的正常流逐渐不满足人民群众的需求了。 这是因为文字排版的思路是“改变文字和盒的相对位置，把它放进特定的版面中”，而软件界面的思路则是“改变盒的大小，使得它们的结构保持固定”。 因此，在早年的CSS中，“使盒按照外部尺寸变化”的能力非常弱。在我入行前端的时间（大约2006年），CSS三大经典问题：垂直居中问题，两列等高问题，自适应宽问题。这是在其它UI系统中最为基本的问题，而到了CSS中，却变成了困扰工程师的三座大山。 机智的前端开发者们，曾经创造了各种黑科技来解决问题，包括著名的table布局、负margin、float与clear等等。在这种情况下，Flex布局被随着CSS3一起提出（最初叫box布局），可以说是解决了大问题。 React Native则更为大胆地使用了纯粹的Flex排版，不再支持正常流，最终也很好地支持了大量的应用界面布局，这一点也证明了Flex排版的潜力。 今天，我们就从设计、原理和应用三个方面来学习一下Flex布局，我们先从设计开始。 Flex的设计Flex在英文中是可伸缩的意思，一些翻译会把它译作弹性，我觉得有点不太准确，但是确实中文中没有更好的词。 Flex排版的核心是display:flex和flex属性，它们配合使用。具有display:flex的元素我们称为flex容器，它的子元素或者盒被称作flex项。 flex项如果有flex属性，会根据flex方向代替宽/高属性，形成“填补剩余尺寸”的特性，这是一种典型的“根据外部容器决定内部尺寸”的思路，也是我们最常用的Windows和Apple窗口系统的设计思路。 Flex的原理说完了设计，我们再来看看原理，Flex的实现并不复杂，我曾经写过一个基本实现提交给spritejs项目，代码可以参考这里。 下面我们就来讲解一下，如何实现一个Flex布局。 首先，Flex布局支持横向和纵向，这样我们就需要做一个抽象，我们把Flex延伸的方向称为“主轴”，把跟它垂直的方向称为“交叉轴”。这样，flex项中的width和height就会称为交叉轴尺寸或者主轴尺寸。 而Flex又支持反向排布，这样，我们又需要抽象出交叉轴起点、交叉轴终点、主轴起点、主轴终点，它们可能是top、left、bottom、right。 Flex布局中有一种特殊的情况，那就是flex容器没有被指定主轴尺寸，这个时候，实际上Flex属性完全没有用了，所有Flex尺寸都可以被当做0来处理，Flex容器的主轴尺寸等于其它所有flex项主轴尺寸之和。 接下来我们开始做Flex排版。 第一步是把flex项分行，有flex属性的flex项可以暂且认为主轴尺寸为0，所以，它可以一定放进当前行。 接下来我们把flex项逐个放入行，不允许换行的话，我们就“无脑地”把flex项放进同一行。允许换行的话，我们就先设定主轴剩余空间为Flex容器主轴尺寸，每放入一个就把主轴剩余空间减掉它的主轴尺寸，直到某个flex项放不进去为止，换下一行，重复前面动作。 分行过程中，我们会顺便对每一行计算两个属性：交叉轴尺寸和主轴剩余空间，交叉轴尺寸是本行所有交叉轴尺寸的最大值，而主轴剩余空间前面已经说过。 第二步我们来计算每个flex项主轴尺寸和位置。 如果Flex容器是不允许换行的，并且最后主轴尺寸超出了Flex容器，就要做等比缩放。 如果Flex容器有多行，那么根据我们前面的分行算法，必然有主轴剩余空间，这时候，我们要找出本行所有的带Flex属性的flex项，把剩余空间按Flex比例分给它们即可。 做好之后，我们就可以根据主轴排布方向，确定每个flex项的主轴位置坐标了。 如果本行完全没有带flex属性的flex项，justify-content机制就要生效了，它的几个不同的值会影响剩余空白如何分配，作为实现者，我们只要在计算flex项坐标的时候，加上一个数值即可。 例如，如果是flex-start就要加到第一个flex项身上，如果是center就给第一个flex项加一半的尺寸，如果是space-between，就要给除了第一个以外的每个flex项加上“flex项数减一分之一”。 第三步我们来计算flex项的交叉轴尺寸和位置。 交叉轴的计算首先是根据align-content计算每一行的位置，这部分跟justify-content非常类似。 再根据alignItems和flex项的alignSelf来确定每个元素在行内的位置。 计算完主轴和交叉轴，每个flex项的坐标、尺寸就都确定了，这样我们就完成了整个的Flex布局。 Flex的应用接下来我们来尝试用flex排版来解决一下当年的CSS三大经典问题（简直易如反掌）。 垂直居中： &lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;child&quot;&gt; &lt;/div&gt; &lt;/div&gt; #parent { display:flex; width:300px; height:300px; outline:solid 1px; justify-content:center; align-content:center; align-items:center; } #child { width:100px; height:100px; outline:solid 1px; }思路是创建一个只有一行的flexbox，然后用align-items:center;和align-content:center;来保证行位于容器中，元素位于行中。 两列等高： &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot; style=&quot;height:300px;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;child&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;br/&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot; &gt; &lt;/div&gt; &lt;div class=&quot;child&quot; style=&quot;height:300px;&quot;&gt; &lt;/div&gt; &lt;/div&gt; .parent { display:flex; width:300px; justify-content:center; align-content:center; align-items:stretch; } .child { width:100px; outline:solid 1px; }思路是创建一个只有一行的flexbox，然后用stretch属性让每个元素高度都等于行高。 自适应宽： &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;child2&quot;&gt; &lt;/div&gt; &lt;/div&gt; .parent { display:flex; width:300px; height:200px; background-color:pink; } .child1 { width:100px; background-color:lightblue; } .child2 { width:100px; flex:1; outline:solid 1px; }这个就是Flex设计的基本能力了，给要自适应的元素添加flex属性即可。 总结今天我们从Flex的设计、原理和应用三个方面一起学习了Flex排版。 我们先从感性的角度，介绍了Flex的设计，Flex的设计是一种不同于流布局的，自外而内的设计思路。 接下来我们讲解了Flex的实现原理，也就是具体的排版算法。要想理解Flex排版的原理，主轴和交叉轴是非常重要的抽象，Flex排版三个步骤：分行、计算主轴、计算交叉轴。 最后我们给出了几个例子，解决了旧时代的CSS三大经典问题。 最后，给你留一个小问题，请根据我的代码和文字，编写一段使用“position:absolute”来模拟Flex布局的js。大家可以根据自己的水平，简化需求，比如可以实现一个仅仅支持横向的、单行的所有flex项必须指定高度的Flex布局。","link":"/2019/08/31/重学前端/CSS Flex排版：为什么垂直居中这么难？/"},{"title":"课外阅读 | 从《孙子兵法》看底层的自然法则","text":"你好，我是七牛云许式伟。 近日在读《孙子兵法》，颇有感触。作为我国现存第一部，也是世界最早的军事著作。《孙子兵法》一直为众多政治家、军事家及企业管理者膜拜，被当作军事外交、企业管理的圣典。 时至今日，新经济、科技和社会结构下，很多人认为我们身处一种复杂社会，需要全新的军事、商业和公共策略。然而，不管远古农耕刀兵还是高科技信息社会竞争，时代、人文环境和科学技术的变迁，并不能改变人类社会生存竞争所依赖的基础系统环境和人性思维的规则。 英国空军元帅斯莱瑟曾说过：“孙武的思想有惊人之处——把一些词句稍加变换，他的箴言就像是昨天刚写出来的。” 《孙子兵法》讲的是战争，骨子里包含的却是人类社会生存竞争的底层规则。案例会变迁，背后的道理却很难过时。我们作为架构师，需要做到对世界的认知可宏观、可微观。从对宏观的理解来说，背后所依赖的正是我们对这些底层自然法则的体悟。 明道《孙子兵法》讲的是规则。它通过战争，结合环境和人性探讨竞争中生存的规则；然后，在确定目标下，它又将战争行为分解成为一系列细分的规则。 《始计篇》开端，全书先讲总规则，就是“道”。“道者，令民与上同意也，故可以与之死，可以与之生，而不畏危。”如同国家有纲领，企业必须明确愿景，使命或是价值观一样。明心方能正道，明道方知力之所指。事实上，明白道之所求，术方能有指引，追随者才能有方向、有激情。对国家、企业而言“道”不仅是方向，还是战斗力和吸附力的来源，明道和传播非常重要。 “慎战”。“兵者，国之大事，生死之地，存亡之道，不可不察也。”战争和企业竞争涉及系统存亡关系重大，是管理者每日都要考虑的事情。“自古知兵非好战。”这种行为不是个人名利或得失，而是关系到万户千家，或者全体员工和家庭，必须慎之又慎，不可凭个人好恶，更不可好大喜功和拍脑袋。“上兵伐谋”、“不战而屈人之兵”。要牢记初心，保存敬畏和责任感，求胜同时要避免己方生命和资源的巨大消耗。“善战者，无智名，无勇功。”正如“善弈者通盘无妙手”，或是扁鹊治病于未发，“立于不败之地”非常之关键。 “避害第一”，先考虑失败的后果；“先胜后战”，不打无把握的战争。“因利而战”，考虑成本和结果；“一战而终”，准备要充分，动手要迅捷，毕其功于一役。 “兵无常势，水无常形。”环境、资源条件，心态、优劣势这些都可能随时变化，不能教条主义，须将策略灵活应用于变化的实际。满口教义，如赵括那般纸上谈兵，一棒子打死算了。“君将士卒皆有其道”。公司内也应各司其职，人人满口战略、创新和文化，“所有人都举着旗帜，他们用哪只手来战斗？”这样的公司很危险。 庙算“先胜后战”，就要“未战先算”。战与棋，一样考的算力，所谓政治经济环境人心都要纳入数据输入。 庙算，非治一战或局部。而是知己知彼综合所获数据，依据规则全面分析，很像是系统竞争成败的“大案牍数”。 庙算策略，不是单一事件的静态考量，而是复杂动态的综合考量。五事，道、天、地、将、法；七计，主、将、天地、法令、兵众、士卒、赏罚都要纳入进来。知己还要知彼。内外部环境，天时地形人才人心钱粮规章，所有影响战争胜负的东西，一切可以数据化，能算计的全都计算进去。 依据庙算可确定“势”，依据“势”决断是否有利并采取相应行动。拥有这样的洞察和决断力，知道了什么时候该打什么时候不该打，真正战争行为才会很简单。战争中要“致人而不致于人”。曾说“朕观诸兵书，无出孙武”的李世民，还有林彪都非常擅长集中优势兵力，通过忍耐和调动对手，“多方以误”，引敌人失误而获取最终胜利。 恰如“木桶理论”，庙算还可以消灭己方短板，寻找或者调动对方出现短板。当然，《孙子兵》并不是每战必胜，也不是以弱胜强，化不可能为可能的魔法书。不宜“知其不可而为之”。一系列庙算都在规则下，寻找到可能性，获得相对优势来战胜对手。如集中优势兵力，实现局部优势。“以迂为直，以患为利。”利用天时地形和行军，训练扎营做饭都有明确的目标。速战还是持久战，都是依据各种条件资源推演分析的结果。“故知战之地，知战之日，则可千里而会战。”唯有算胜，方可一战。 庙算为术，战术不能超脱于战略。“将在外君命有所不受”只是指根据实际情况可以灵活战术，正如当年毛主席要求林彪东北战役要服从大局，大战略不容颠覆。不能因一人之利，一地之利，一时之利而改变，只能随整个系统变化而调整。 感知“不可胜在己”，立于不败之地，自己是关键，其他都是辅因；“可胜在敌”，看敌人的软肋和什么时候失误。“内省。知彼，但先要知己。”曾国藩作战，也首先讲明己第一，稳扎稳打立于不败之地，克敌才能实现。胜利也并非都是好事，很多时候当不是自己太强，而是对手太弱或其他因素，造就的胜利只会麻痹自己和埋下根本性失败的伏笔。 “知己知彼”就是自我和对手的感知。“天时地利人和”是对环境的感知。战争错综复杂风云变化，很多时候考较的都是随机应变的感知力和应对能力。“用兵者，合于利而动，不合于利而止。”对是否进行战争的条件的感知。还有对于细节的感知，“汲而先饮者，渴也。”需要通过经验学习感知获取信息，将规则载入情景化和有效利用。感知，可用于内部观察和防患未然，也可以用于判断对手并拟定对策。 “攻其无备，出其不意。”需要重视情报和传播。“兵者，诡道也。”情报和传播，等于数据的输入和输出，很多时候决定战争或组织的成败。依据情报奇兵制胜，如邓艾灭蜀；与对手虚假的情报，像蒋干盗书。更典型的是反间计。李牧、范曾罢黜，赵国、项羽败亡。 法度“五事七计”都提到法令和奖惩。楚汉之争刘邦胜，“约法三章”以及陈平的有效奖惩体系都为功不小，胜在乎法令执行和奖惩公平。另一方面，用兵能“破釜沉舟”的项羽，然“印刓敝,忍不能予”是其失败的重要原因。 “五德，智信仁勇乎。”五德相须，缺一不可。但强调“智”，将人才放第一。而法度是规则，人才必须在法度内。 “主孰有道，将孰有能。” “将之至任，不可不察也。” “将听吾计，用之必胜，留之。将不听吾计，用之必败，去之。” “令行素。”平时一样重视，战时才能发挥作用。 对于复杂系统，内部崩溃往往是其失败的主要原因。当然如前所述，这种内因也可由对手或外因推动演化。对于企业来说，领导者素质和人才队伍，中坚力量的支撑很重要，而成为中坚的标准就是一致的价值观和遵循规范。另外，还要建立适应自身、对手和战争形态的管理架构和组织体系，以及有效的规章和奖惩体系。 辨证“以正合，以奇胜。”《孙子兵法》可能是辨证思维最早期的著作和运用。 《孙子兵法》里，强弱虚实迂直恩仇甚至胜败都是辩证的，是可以对立转化的。 事实上，无论战争或是组织发展，都不是直线的，而是曲线的，或者周期的，充满了变化。胜负也是辩证和变化的，便是拥有《孙子兵法》，吴国后期数战数胜，开始骄傲自负，百姓疲敝，胜负环境逆转，终致败亡。“水因地而制流，兵因敌而制胜”。所有策略必须依据时机、环境、对手、人心变化而变化。 兵法不可能写尽所有情况，任何行为和结果也不是简单对应，而是因果交错。战争和系统竞争要处理的是复杂数据。《孙子兵法》注定“学者生，像者死”，必须根据特定时空、自己和对手的具体情况灵活化用。 《孙子兵法》重规则轻案例，舍事而言理，因而得以破越时空和领域，成为竞争、管理和生存的基础规则。 《大败局》一书中，吴晓波将中国大多数企业失败归结为缺乏道德感和人文关怀，缺乏对规则和秩序的尊重以及系统的职业精神的缺乏，这些因果在《孙子兵法》中都能够找得到对应；相对的，所有基业长青的公司，又都具备一系列适应变化，可以持续指导成长的一般性规则，这些规则在《孙子兵法》中也都能够找到对应。 作为一种超乎教材而更类似于宗教的力量，《孙子兵法》的价值在于其提供了实用性同时引导了对规则的思考。跨域2500年时空岁月，它的思想精髓仍如星辰闪耀。而且随着数据、时代演进、新元素的输入还会不断推动其演进和发展，即便再过100年，1000年，只要人类、系统和竞争存在，它就永不会过时。","link":"/2019/08/31/许世伟的架构课/课外阅读 | 从《孙子兵法》看底层的自然法则/"},{"title":"CSS 选择器：如何选中svg里的a元素？","text":"你好，我是winter。 我们在之前CSS语法课程中，已经介绍了关于选择器的一部分基础知识。在今天的这一课里，我们来系统学习一下CSS选择器。 在CSS语法课程中，我们已经见过一些选择器了，但在进入到具体的选择器介绍之前，我们首先要对选择器有一个整体的认识。 我先来讲讲选择器是什么，选择器是由CSS最先引入的一个机制（但随着document.querySelector等API的加入，选择器已经不仅仅是CSS的一部分了）。我们今天这一课，就重点讲讲CSS选择器的一些机制。 选择器的基本意义是：根据一些特征，选中元素树上的一批元素。 我们把选择器的结构分一下类，那么由简单到复杂可以分成以下几种。 简单选择器：针对某一特征判断是否选中元素。 复合选择器：连续写在一起的简单选择器，针对元素自身特征选择单个元素。 复杂选择器：由“（空格）”“ &gt;”“ ~”“ +”“ ||”等符号连接的复合选择器，根据父元素或者前序元素检查单个元素。 选择器列表：由逗号分隔的复杂选择器，表示“或”的关系。 我们可以看到，选择器是由简单选择器逐级组合而成的结构，那么我们就来首先看一下简单选择器。 简单选择器我们在前面说过，简单选择器是针对某一特征判断是否为选中元素。今天我会为你介绍一系列常见的简单选择器，我们把相似的简单选择器放在一起，这样更易于你去记忆。 类型选择器和全体选择器我们要介绍的第一个简单选择器就是类型选择器，它根据一个元素的标签名来选中元素。 比如： div { }这看上去非常简单，但是实际上，我们还必须要考虑HTML或者XML元素的命名空间问题。 比如我们的svg元素，实际上在： http://www.w3.org/2000/svg 命名空间之下。 svg和HTML中都有a元素，我们若要想区分选择svg中的a和HTML中的a，就必须用带命名空间的类型选择器。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;svg width=&quot;100&quot; height=&quot;28&quot; viewBox=&quot;0 0 100 28&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt; &lt;desc&gt;Example link01 - a link on an ellipse &lt;/desc&gt; &lt;a xlink:href=&quot;http://www.w3.org&quot;&gt; &lt;text y=&quot;100%&quot;&gt;name&lt;/text&gt; &lt;/a&gt; &lt;/svg&gt; &lt;br/&gt; &lt;a href=&quot;javascript:void 0;&quot;&gt;name&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; @namespace svg url(http://www.w3.org/2000/svg); @namespace html url(http://www.w3.org/1999/xhtml); svg|a { stroke:blue; stroke-width:1; } html|a { font-size:40px }这里有一个特殊的选择器，就是“ * ” ，它称为全体选择器，可以选中任意元素。它的用法跟类型选择器是完全一致的，这里就把它们放到一起介绍了。 id选择器与class选择器id选择器和class选择器都是针对特定属性的选择器。id选择器是“#”号后面跟随id名，class选择器是“.”后面跟随class名。我们来看看基本用法： #myid { stroke:blue; stroke-width:1; } .mycls { font-size:40px }这两个选择器都是在属性选择器之前就设计出来的选择器，属性选择器出来了以后，理论上可以一定程度上替代它们。但是要注意，class选择器识别的是：用空格分隔的class语法。 &lt;a class=&quot;a b c&quot;&gt;xxx&lt;/a&gt; .a { color:red; }在这个例子中，我们使用了用空格分隔的class属性，使用“.a”“.b”或者“.c”都能够选中元素，也可以使用多个class选择器来要求元素具有多个类。 属性选择器属性选择器根据HTML元素的属性来选中元素。属性选择器有四种形态。 第一种，[att] 直接在方括号中放入属性名，是检查元素是否具有这个属性，只要元素有这个属性，不论属性是什么值，都可以被选中。 第二种，[att=val] 精确匹配，检查一个元素属性的值是否是val。 第三种，[att~=val] 多种匹配，检查一个元素的值是否是若干值之一，这里的val不是一个单一的值了，可以是用空格分隔的一个序列。 第四种，[att|=val] 开头匹配，检查一个元素的值是否是以val开头，它跟精确匹配的区别是属性只要以val开头即可，后面内容不管。 有些HTML属性含有特殊字符，这个时候，可以把val用引号括起来，形成一个CSS字符串。CSS字符串允许使用单双引号来规避特殊字符，也可以用反斜杠转义，这样，就可以表示出任意属性值啦。 伪类选择器接下来我们开始介绍伪类选择器，伪类选择器是一系列由CSS规定好的选择器，它们以冒号开头。伪类选择器有普通型和函数型两种。 我们首先来介绍一下伪类中最常用的部分：树结构关系伪类。 树结构关系伪类选择器:root 伪类表示树的根元素，在选择器是针对完整的HTML文档情况，我们一般用HTML标签即可选中根元素。但是随着scoped css和shadow root等场景出现，选择器可以针对某一子树来选择，这时候就很需要root伪类了。 :empty 伪类表示没有子节点的元素，这里有个例外就是子节点为空白文本节点的情况。 :nth-child 和 :nth-last-child 这是两个函数型的伪类，CSS的An+B语法设计的是比较复杂的，我们这里仅仅介绍基本用法。我们还是看几个例子： :nth-last-child的区别仅仅是从后往前数。 :first-child :last-child 分别表示第一个和最后一个元素。 :only-child 按字面意思理解即可，选中唯一一个子元素。 of-type系列，是一个变形的语法糖，S:nth-of-type(An+B)是:nth-child(|An+B| of S)的另一种写法。 以此类推，还有nth-last-of-type、first-of-type、last-of-type、only-of-type。 链接与行为伪类选择器链接与行为是第一批设计出来的伪类，也是最常用的一批。 :any-link 表示任意的链接，包括a、area和link标签都可能匹配到这个伪类。 :link 表示未访问过的链接， :visited 表示已经访问过的链接。 :hover 表示鼠标悬停在上的元素。 :active 表示用户正在激活这个元素，如用户按下按钮，鼠标还未抬起时，这个按钮就处于激活状态。 :focus 表示焦点落在这个元素之上。 :target 用于选中浏览器URL的hash部分所指示的元素。 在Selector Level 4草案中，还引入了 target-within、focus-within 等伪类，用于表示target或者focus的父容器。 逻辑伪类选择器我们这里介绍一个逻辑伪类 —— :not 伪类。 这个伪类是个函数型伪类，它的作用时选中内部的简单选择器命中的元素。 *|*:not(:hover)选择器3级标准中，not只支持简单选择器，在选择器4级标准，则允许not接受一个选择器列表，这意味着选择器支持嵌套，仅靠not即可完成选择器的一阶真值逻辑完备，但目前还没有看到浏览器实现它。 在Selector Level 4草案中，还引入了:is :where :has 等逻辑伪类，但是它们有一些违背了选择器匹配DOM树不回溯的原则，所以这部分设计最终的命运如何还不太确定。 其它伪类选择器还有一些草案中或者不常用的选择器，你仅做大概了解即可。 国际化：用于处理国际化和多语言问题。 dir lang 音频/视频：用于区分音视频播放状态。 play pause 时序：用于配合读屏软件等时序性客户端的伪类。 current past future 表格：用于处理table的列的伪类。 nth-col nth-last-col 伪类是很大的一类简单选择器，它是选择器能力的一种补充。在实际使用中，我还是建议你尽量通过合适的id和class来标识元素，约束伪类的使用。最好只在不得不使用伪类的场景使用伪类，这对于CSS代码的性能和可读性都有好处。 结语这一节课程中，我们介绍了CSS选择器的整体结构，并且介绍了一系列简单选择器。它们包括了下面这些内容。 类型选择器：根据一个元素的标签名来选中元素。 全体选择器：与类型选择器类似，选择任意元素。 id选择器：#后面跟随id名。 class选择器：.后面跟随class名。 伪类选择器：一系列由CSS规定好的选择器，它们以冒号开头，伪类有普通型和函数型。 在下一节课，我们开始进入到更复杂的情况，我们将会介绍选择器的组合使用方式和选择器的一些机制。 今天留给你的思考题是：用JavaScript实现一个能够处理所有简单选择器的querySelector（行为伪类除外），你可以把你的答案分享出来，我们一起来探讨吧。","link":"/2019/08/31/重学前端/CSS 选择器：如何选中svg里的a元素？/"},{"title":"CSS动画与交互：为什么动画要用贝塞尔曲线这么奇怪的东西？","text":"你好，我是winter，今天我们来学习一下CSS的动画和交互。 在CSS属性中，有这么一类属性，它负责的不是静态的展现，而是根据用户行为产生交互。这就是今天我们要讲的属性。 首先我们先从属性来讲起。CSS中跟动画相关的属性有两个：animation和transition。 animation属性和transition属性我们先来看下animation的示例，通过示例来了解一下animation属性的基本用法: @keyframes mykf { from {background: red;} to {background: yellow;} } div { animation:mykf 5s infinite; }这里展示了animation的基本用法，实际上animation分成六个部分： animation-name 动画的名称，这是一个keyframes类型的值（我们在第9讲“CSS语法：除了属性和选择器，你还需要知道这些带@的规则”讲到过，keyframes产生一种数据，用于定义动画关键帧）； animation-duration 动画的时长； animation-timing-function 动画的时间曲线； animation-delay 动画开始前的延迟； animation-iteration-count 动画的播放次数； animation-direction 动画的方向。 我们先来看 animation-name，这个是一个keyframes类型，需要配合@规则来使用。 比如，我们前面的示例中，就必须配合定义 mymove 这个 keyframes。keyframes的主体结构是一个名称和花括号中的定义，它按照百分比来规定数值，例如： @keyframes mykf { 0% { top: 0; } 50% { top: 30px; } 75% { top: 10px; } 100% { top: 0; } }这里我们可以规定在开始时把top值设为0，在50%是设为30px，在75%时设为10px，到100%时重新设为0，这样，动画执行时就会按照我们指定的关键帧来变换数值。 这里，0%和100%可以写成from和to，不过一般不会混用，画风会变得很奇怪，比如： @keyframes mykf { from { top: 0; } 50% { top: 30px; } 75% { top: 10px; } to { top: 0; } }这里关键帧之间，是使用 animation-timing-function 作为时间曲线的，稍后我会详细介绍时间曲线。 接下来我们来介绍一下transition。transition与animation相比来说，是简单得多的一个属性。 它有四个部分： transition-property 要变换的属性； transition-duration 变换的时长； transition-timing-function 时间曲线； transition-delay 延迟。 这里的四个部分，可以重复多次，指定多个属性的变换规则。 实际上，有时候我们会把transition和animation组合，抛弃animation的timing-function，以编排不同段用不同的曲线。 @keyframes mykf { from { top: 0; transition:top ease} 50% { top: 30px;transition:top ease-in } 75% { top: 10px;transition:top ease-out } to { top: 0; transition:top linear} }在这个例子中，在keyframes中定义了transition属性，以达到各段曲线都不同的效果。 接下来，我们就来详细讲讲刚才提到的timing-function，动画的时间曲线。 三次贝塞尔曲线我想，你能从很多CSS的资料中都找到了贝塞尔曲线，但是为什么CSS的时间曲线要选用（三次）贝塞尔曲线呢？ 我们在这里首先要了解一下贝塞尔曲线，贝塞尔曲线是一种插值曲线，它描述了两个点之间差值来形成连续的曲线形状的规则。 一个量（可以是任何矢量或者标量）从一个值到变化到另一个值，如果我们希望它按照一定时间平滑地过渡，就必须要对它进行插值。 最基本的情况，我们认为这个变化是按照时间均匀进行的，这个时候，我们称其为线性插值。而实际上，线性插值不大能满足我们的需要，因此数学上出现了很多其它的插值算法，其中贝塞尔插值法是非常典型的一种。它根据一些变换中的控制点来决定值与时间的关系。 贝塞尔曲线是一种被工业生产验证了很多年的曲线，它最大的特点就是“平滑”。时间曲线平滑，意味着较少突兀的变化，这是一般动画设计所追求的。 贝塞尔曲线用于建筑设计和工业设计都有很多年历史了，它最初的应用是汽车工业用贝塞尔曲线来设计车型。 K次贝塞尔插值算法需要k+1个控制点，最简单的一次贝塞尔插值就是线性插值，将时间表示为0到1的区间，一次贝塞尔插值公式是： “二次贝塞尔插值”有3个控制点，相当于对P0和P1，P1和P2分别做贝塞尔插值，再对结果做一次贝塞尔插值计算 “三次贝塞尔插值”则是“两次‘二次贝塞尔插值’的结果，再做一次贝塞尔插值”： 贝塞尔曲线的定义中带有一个参数t，但是这个t并非真正的时间，实际上贝塞尔曲线的一个点(x, y)，这里的x轴才代表时间。 这就造成了一个问题，如果我们使用贝塞尔曲线的直接定义，是没办法直接根据时间来计算出数值的，因此，浏览器中一般都采用了数值算法，其中公认做有效的是牛顿积分，我们可以看下JavaScript版本的代码： function generate(p1x, p1y, p2x, p2y) { const ZERO_LIMIT = 1e-6; // Calculate the polynomial coefficients, // implicit first and last control points are (0,0) and (1,1). const ax = 3 * p1x - 3 * p2x + 1; const bx = 3 * p2x - 6 * p1x; const cx = 3 * p1x; const ay = 3 * p1y - 3 * p2y + 1; const by = 3 * p2y - 6 * p1y; const cy = 3 * p1y; function sampleCurveDerivativeX(t) { // `ax t^3 + bx t^2 + cx t&apos; expanded using Horner &apos;s rule. return (3 * ax * t + 2 * bx) * t + cx; } function sampleCurveX(t) { return ((ax * t + bx) * t + cx ) * t; } function sampleCurveY(t) { return ((ay * t + by) * t + cy ) * t; } // Given an x value, find a parametric value it came from. function solveCurveX(x) { var t2 = x; var derivative; var x2; // https://trac.webkit.org/browser/trunk/Source/WebCore/platform/animation // First try a few iterations of Newton&apos;s method -- normally very fast. // http://en.wikipedia.org/wiki/Newton&apos;s_method for (let i = 0; i &lt; 8; i++) { // f(t)-x=0 x2 = sampleCurveX(t2) - x; if (Math.abs(x2) &lt; ZERO_LIMIT) { return t2; } derivative = sampleCurveDerivativeX(t2); // == 0, failure /* istanbul ignore if */ if (Math.abs(derivative) &lt; ZERO_LIMIT) { break; } t2 -= x2 / derivative; } // Fall back to the bisection method for reliability. // bisection // http://en.wikipedia.org/wiki/Bisection_method var t1 = 1; /* istanbul ignore next */ var t0 = 0; /* istanbul ignore next */ t2 = x; /* istanbul ignore next */ while (t1 &gt; t0) { x2 = sampleCurveX(t2) - x; if (Math.abs(x2) &lt; ZERO_LIMIT) { return t2; } if (x2 &gt; 0) { t1 = t2; } else { t0 = t2; } t2 = (t1 + t0) / 2; } // Failure return t2; } function solve(x) { return sampleCurveY(solveCurveX(x)); } return solve; }这段代码其实完全翻译自WebKit的C++代码，牛顿积分的具体原理请参考相关数学著作，注释中也有相关的链接。 这个JavaScript版本的三次贝塞尔曲线可以用于实现跟CSS一模一样的动画。 贝塞尔曲线拟合理论上，贝塞尔曲线可以通过分段的方式拟合任意曲线，但是有一些特殊的曲线，是可以用贝塞尔曲线完美拟合的，比如抛物线。 这里我做了一个示例，用于模拟抛物线： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; &lt;title&gt;Simulation&lt;/title&gt; &lt;style&gt; .ball { width:10px; height:10px; background-color:black; border-radius:5px; position:absolute; left:0; top:0; transform:translateY(180px); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;label&gt;运动时间：&lt;input value=&quot;3.6&quot; type=&quot;number&quot; id=&quot;t&quot; /&gt;s&lt;/label&gt;&lt;br/&gt; &lt;label&gt;初速度：&lt;input value=&quot;-21&quot; type=&quot;number&quot; id=&quot;vy&quot; /&gt; px/s&lt;/label&gt;&lt;br/&gt; &lt;label&gt;水平速度：&lt;input value=&quot;21&quot; type=&quot;number&quot; id=&quot;vx&quot; /&gt; px/s&lt;/label&gt;&lt;br/&gt; &lt;label&gt;重力：&lt;input value=&quot;10&quot; type=&quot;number&quot; id=&quot;g&quot; /&gt; px/s²&lt;/label&gt;&lt;br/&gt; &lt;button onclick=&quot;createBall()&quot;&gt;来一个球&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; function generateCubicBezier (v, g, t){ var a = v / g; var b = t + v / g; return [[(a / 3 + (a + b) / 3 - a) / (b - a), (a * a / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)], [(b / 3 + (a + b) / 3 - a) / (b - a), (b * b / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)]]; } function createBall() { var ball = document.createElement(&quot;div&quot;); var t = Number(document.getElementById(&quot;t&quot;).value); var vx = Number(document.getElementById(&quot;vx&quot;).value); var vy = Number(document.getElementById(&quot;vy&quot;).value); var g = Number(document.getElementById(&quot;g&quot;).value); ball.className = &quot;ball&quot;; document.body.appendChild(ball) ball.style.transition = `left linear ${t}s, top cubic-bezier(${generateCubicBezier(vy, g, t)}) ${t}s`; setTimeout(function(){ ball.style.left = `${vx * t}px`; ball.style.top = `${vy * t + 0.5 * g * t * t}px`; }, 100); setTimeout(function(){ document.body.removeChild(ball); }, t * 1000); }这段代码中，我实现了抛物线运动的小球，其中核心代码就是 generateCubicBezier 函数。 这个公式完全来自于一篇论文，推理过程我也不清楚，但是不论如何，它确实能够用于模拟抛物线。 实际上，我们日常工作中，如果需要用贝塞尔曲线拟合任何曲线，都可以找到相应的论文，我们只要取它的结论即可。 总结我们今天的课程，重点介绍了动画和它背后的一些机制。 CSS用transition和animation两个属性来实现动画，这两个属性的基本用法很简单，我们今天还介绍了它们背后的原理：贝塞尔曲线。 我们中介绍了贝塞尔曲线的实现原理和贝塞尔曲线的拟合技巧。 最后，留给你一个小问题，请纯粹用JavaScript来实现一个transition函数，用它来跟CSS的transition来做一下对比，看看有哪些区别。","link":"/2019/08/31/重学前端/CSS动画与交互：为什么动画要用贝塞尔曲线这么奇怪的东西？/"},{"title":"CSS小实验：动手做，用代码挖掘CSS属性","text":"你好，我是winter。 我们的课程中已经讲解了一部分CSS属性，但是CSS属性数量繁多，我们的课程只能覆盖其中一小部分，所以我设计了这个小实验，教你用代码挖掘W3C标准中的属性。 浏览器中已经实现的属性首先我们来看看浏览器中实现了哪些属性。我们用一段代码来看一下。 Object.keys(document.body.style).filter(e =&gt; !e.match(/^webkit/))这段代码思路非常简单，就是枚举document.body.style上的所有属性，并且去掉webkit前缀的私有属性。 在我的Chrome中，得到了这样一组属性： alignContent, alignItems, alignSelf, alignmentBaseline, all, animation, animationDelay, animationDirection, animationDuration, animationFillMode, animationIterationCount, animationName, animationPlayState, animationTimingFunction, backfaceVisibility, background, backgroundAttachment, backgroundBlendMode, backgroundClip, backgroundColor, backgroundImage, backgroundOrigin, backgroundPosition, backgroundPositionX, backgroundPositionY, backgroundRepeat, backgroundRepeatX, backgroundRepeatY, backgroundSize, baselineShift, blockSize, border, borderBlockEnd, borderBlockEndColor, borderBlockEndStyle, borderBlockEndWidth, borderBlockStart, borderBlockStartColor, borderBlockStartStyle, borderBlockStartWidth, borderBottom, borderBottomColor, borderBottomLeftRadius, borderBottomRightRadius, borderBottomStyle, borderBottomWidth, borderCollapse, borderColor, borderImage, borderImageOutset, borderImageRepeat, borderImageSlice, borderImageSource, borderImageWidth, borderInlineEnd, borderInlineEndColor, borderInlineEndStyle, borderInlineEndWidth, borderInlineStart, borderInlineStartColor, borderInlineStartStyle, borderInlineStartWidth, borderLeft, borderLeftColor, borderLeftStyle, borderLeftWidth, borderRadius, borderRight, borderRightColor, borderRightStyle, borderRightWidth, borderSpacing, borderStyle, borderTop, borderTopColor, borderTopLeftRadius, borderTopRightRadius, borderTopStyle, borderTopWidth, borderWidth, bottom, boxShadow, boxSizing, breakAfter, breakBefore, breakInside, bufferedRendering, captionSide, caretColor, clear, clip, clipPath, clipRule, color, colorInterpolation, colorInterpolationFilters, colorRendering, columnCount, columnFill, columnGap, columnRule, columnRuleColor, columnRuleStyle, columnRuleWidth, columnSpan, columnWidth, columns, contain, content, counterIncrement, counterReset, cursor, cx, cy, d, direction, display, dominantBaseline, emptyCells, fill, fillOpacity, fillRule, filter, flex, flexBasis, flexDirection, flexFlow, flexGrow, flexShrink, flexWrap, float, floodColor, floodOpacity, font, fontDisplay, fontFamily, fontFeatureSettings, fontKerning, fontSize, fontStretch, fontStyle, fontVariant, fontVariantCaps, fontVariantEastAsian, fontVariantLigatures, fontVariantNumeric, fontVariationSettings, fontWeight, gap, grid, gridArea, gridAutoColumns, gridAutoFlow, gridAutoRows, gridColumn, gridColumnEnd, gridColumnGap, gridColumnStart, gridGap, gridRow, gridRowEnd, gridRowGap, gridRowStart, gridTemplate, gridTemplateAreas, gridTemplateColumns, gridTemplateRows, height, hyphens, imageRendering, inlineSize, isolation, justifyContent, justifyItems, justifySelf, left, letterSpacing, lightingColor, lineBreak, lineHeight, listStyle, listStyleImage, listStylePosition, listStyleType, margin, marginBlockEnd, marginBlockStart, marginBottom, marginInlineEnd, marginInlineStart, marginLeft, marginRight, marginTop, marker, markerEnd, markerMid, markerStart, mask, maskType, maxBlockSize, maxHeight, maxInlineSize, maxWidth, maxZoom, minBlockSize, minHeight, minInlineSize, minWidth, minZoom, mixBlendMode, objectFit, objectPosition, offset, offsetDistance, offsetPath, offsetRotate, opacity, order, orientation, orphans, outline, outlineColor, outlineOffset, outlineStyle, outlineWidth, overflow, overflowAnchor, overflowWrap, overflowX, overflowY, overscrollBehavior, overscrollBehaviorX, overscrollBehaviorY, padding, paddingBlockEnd, paddingBlockStart, paddingBottom, paddingInlineEnd, paddingInlineStart, paddingLeft, paddingRight, paddingTop, page, pageBreakAfter, pageBreakBefore, pageBreakInside, paintOrder, perspective, perspectiveOrigin, placeContent, placeItems, placeSelf, pointerEvents, position, quotes, r, resize, right, rowGap, rx, ry, scrollBehavior, scrollMargin, scrollMarginBlock, scrollMarginBlockEnd, scrollMarginBlockStart, scrollMarginBottom, scrollMarginInline, scrollMarginInlineEnd, scrollMarginInlineStart, scrollMarginLeft, scrollMarginRight, scrollMarginTop, scrollPadding, scrollPaddingBlock, scrollPaddingBlockEnd, scrollPaddingBlockStart, scrollPaddingBottom, scrollPaddingInline, scrollPaddingInlineEnd, scrollPaddingInlineStart, scrollPaddingLeft, scrollPaddingRight, scrollPaddingTop, scrollSnapAlign, scrollSnapStop, scrollSnapType, shapeImageThreshold, shapeMargin, shapeOutside, shapeRendering, size, speak, src, stopColor, stopOpacity, stroke, strokeDasharray, strokeDashoffset, strokeLinecap, strokeLinejoin, strokeMiterlimit, strokeOpacity, strokeWidth, tabSize, tableLayout, textAlign, textAlignLast, textAnchor, textCombineUpright, textDecoration, textDecorationColor, textDecorationLine, textDecorationSkipInk, textDecorationStyle, textIndent, textOrientation, textOverflow, textRendering, textShadow, textSizeAdjust, textTransform, textUnderlinePosition, top, touchAction, transform, transformBox, transformOrigin, transformStyle, transition, transitionDelay, transitionDuration, transitionProperty, transitionTimingFunction, unicodeBidi, unicodeRange, userSelect, userZoom, vectorEffect, verticalAlign, visibility, whiteSpace, widows, width, willChange, wordBreak, wordSpacing, wordWrap, writingMode, x, y, zIndex, zoom数了一下，这里有390个属性，这非常壮观了，要想了解它们可不是一件容易的事情。接下来我们试着找到它们背后对应的标准。 小实验：找出W3C标准中的CSS属性我们知道CSS2.1是一份标准，但是CSS3分布在无数标准中，我们需要用代码把它们整理出来，这就是我们今天的小实验内容了。 为了达到我们的目的，我们需要写一个简单的爬虫，来找一找W3C标准中都覆盖了哪些属性。 我们这个爬虫的思路是：用iframe来加载所有标准的网页，然后用JavaScript找出它们中间定义的属性。 第一步：找到CSS相关的标准。我们来到W3C的TR页面： https://www.w3.org/TR/?tag=css 我们必须从这个页面里抓取所有的标准名称和链接，打开它的代码，我们会发现它是有规律的，这个页面由一个巨大的列表构成，我们只需要根据tag选取需要的标准即可。 document.querySelectorAll(&quot;#container li[data-tag~=css] h2:not(.Retired):not(.GroupNote)&quot;)这段代码可以找到所有CSS相关的标准，我们用代码把从HTML结构中把它们抽取出来。可以得到一个列表。 （图片较大，请等待加载。） 第二步：分析每个标准中的CSS属性得到了这个标准的列表，下一步我们就是分析每个标准中的CSS属性。 我们打开第一个标准，试着找出属性定义： https://www.w3.org/TR/2019/WD-css-lists-3-20190425/ 经过分析，我们会发现，属性总是在一个具有propdef的容器中，有属性data-dfn-type值为property。 这里我不得不感慨，W3C的标准写得真的是十分严谨，这给我们带来了很大的方便。我们用以下代码获取属性： document.querySelectorAll(&quot;.propdef [data-dfn-type=property]&quot;)对于第一个标准 CSS Lists Module Level 3 得到了这个列表： list-style-image list-style-type list-style-position list-style marker-side counter-reset counter-set counter-increment好了，接下来，我们来用iframe打开这些标准，并且用我们分析好的规则，来找出里面的属性就可以了。最终成品代码如下： var iframe = document.createElement(&quot;iframe&quot;); document.body.appendChild(iframe); iframe.src = &quot;https://www.w3.org/TR/2019/WD-css-lists-3-20190425/&quot; function happen(element, type){ return new Promise(resolve =&gt; { element.addEventListener(type, resolve, {once: true}) }) } happen(iframe, &quot;load&quot;).then(function(){ //Array.prototype.map.call(document.querySelectorAll(&quot;#container li[data-tag~=css] h2&quot;), e=&gt; e.children[0].href + &quot; |\\t&quot; + e.children[0].textContent).join(&quot;\\n&quot;) console.log(iframe.contentWindow); }) async function start(){ var output = [] for(let standard of Array.prototype.slice.call(document.querySelectorAll(&quot;#container li[data-tag~=css] h2:not(.Retired):not(.GroupNote)&quot;))) { console.log(standard.children[0].href); iframe.src = standard.children[0].href; await happen(iframe, &quot;load&quot;); var properties = Array.prototype.map.call(iframe.contentWindow.document.querySelectorAll(&quot;.propdef [data-dfn-type=property]&quot;), e =&gt; e.childNodes[0].textContent); if(properties.length) output.push(standard.children[0].textContent + &quot; | &quot; + properties.join(&quot;, &quot;)); } console.log(output.join(&quot;\\n&quot;)) } start();这样，我们就得到了每个属性属于哪个标准，我们来看看最终结果。我把它整理成了一个列表。 （图片较大，请等待加载。） 至此，我们已经找出了标准中讲解的所有属性。 结语今天的这节课我们通过代码对标准做了分析，找出了属性和标准的对应关系。 我们的第一步是找到所有的标准列表，第二步是找到每个标准中的属性。最后得到的这个列表比较全面地覆盖了CSS属性，并根据标准划分好了分类，我觉得这可以作为你后续学习和精研的重要依据。 我在本篇内容的前面还有一份浏览器中已经实现的属性列表，理论上属性列表中的属性应该都出现在了我们的标准中。 那么，这次课后的小任务，就是找出被我们的代码遗漏的属性，和重复出现在多份标准中的属性，让我们的列表更为完善。","link":"/2019/08/31/重学前端/CSS小实验：动手做，用代码挖掘CSS属性/"},{"title":"CSS渲染：CSS是如何绘制颜色的？","text":"你好，我是winter，今天我们来学习一下CSS的渲染相关的属性。 我们在布局篇讲到，CSS的一些属性决定了盒的位置，那么今天我讲到的属性就决定了盒如何被渲染。 按照惯例，还是先从简单得讲起，首先我们来讲讲颜色。 颜色的原理首先我们来讲讲颜色，最常见的颜色相关的属性就是 color 和 background-color。 这两个属性没什么好讲的，它们分别表示文字颜色和背景颜色，我们这里重点讲讲颜色值。 RGB颜色我们在计算机中，最常见的颜色表示法是RGB颜色，它符合光谱三原色理论：红、绿、蓝三种颜色的光可以构成所有的颜色。 为什么是这三种颜色呢？这跟人类的视神经系统相关，人类的视觉神经分别有对红、绿、蓝三种颜色敏感的类型。 顺便提一下，人类对红色的感觉最为敏感，所以危险信号提示一般会选择红色；而红绿色盲的人，就是红和绿两种神经缺失一种。其它的动物视觉跟人可能不太一样，比如皮皮虾拥有16种视锥细胞，所以我猜它们看到的世界一定特别精彩。 现代计算机中多用 0 - 255 的数字表示每一种颜色，这正好占据了一个字节，每一个颜色就占据三个字节。 这个数字远远超过了人体的分辨能力，因此，上世纪90年代刚推出这样的颜色系统的时候，它被称作真彩色。早年间还有更节约空间，但是精度更低的16色、256色、8位色和16位色表示法。 红绿蓝三种颜色的光混合起来就是白光，没有光就是黑暗，所以在RGB表示法中，三色数值最大表示白色，三色数值为0表示黑色。 CMYK颜色如果你上过小学美术课，应该听过“红黄蓝”三原色的说法，这好像跟我们说的不太一样。实际上是这样的，颜料显示颜色的原理是它吸收了所有别的颜色的光，只反射一种颜色，所以颜料三原色其实是红、绿、蓝的补色，也就是：品红、黄、青。因为它们跟红、黄、蓝相近，所以有了这样的说法。 在印刷行业，使用的就是这样的三原色（品红、黄、青）来调配油墨，这种颜色的表示法叫做CMYK，它用一个四元组来表示颜色。 你一定会好奇，为什么它比三原色多了一种，其实答案并不复杂，在印刷行业中，黑色颜料价格最低，而品红、黄、青颜料价格较贵，如果要用三原色调配黑色，经济上是不划算的，所以印刷时会单独指定黑色。 对CMYK颜色表示法来说，同一种颜色会有多种表示方案，但是我们参考印刷行业的习惯，会尽量优先使用黑色。 HSL颜色好了，讲了这么多，其实还没有涉及今天的主角：HSL颜色。接下来我们就讲一讲。 我们刚才讲的颜色是从人类的视觉原理建模，应该说是十分科学了。但是，人类对颜色的认识却并非来自自己的神经系统，当我们把阳光散射，可以得到七色光：红橙黄绿蓝靛紫，实际上，阳光接近白光，它包含了各种颜色的光，它散射之后，应该是个基本连续的。这说明对人的感知来说，颜色远远大于红、绿、蓝。 因此，HSL这样的颜色模型被设计出来了，它用一个值来表示人类认知中的颜色，我们用专业的术语叫做色相（H）。加上颜色的纯度（S）和明度（L），就构成了一种颜色的表示。 在这里，我需要特别推荐HSL颜色，因为它是一种语义化的颜色。当我们对一张图片改变色相时，人们感知到的是“图片的颜色变了”。这里先容我卖个关子，具体的例子待我们讲完了渐变再看。 其它颜色接下来我们讲一讲RGBA，RGBA是代表Red（红色）、Green（绿色）、Blue（蓝色）和Alpha的色彩空间。RGBA颜色被用来表示带透明度的颜色，实际上，Alpha通道类似一种颜色值的保留字。在CSS中，Alpha通道被用于透明度，所以我们的颜色表示被称作 RGBA，而不是RGBO（Opacity）。 为了方便使用，CSS还规定了名称型的颜色，它内置了大量（140种）的颜色名称。不过这里我要挑出两个颜色来讲一讲：金（gold）和银（silver）。 如果你使用过这两个颜色，你会发现，金（gold）和银（silver）的视觉表现跟我们想象中的金色和银色相差甚远。与其被叫做金色和银色，它们看起来更像是难看的暗黄色和浅灰色。 为什么会这样呢？在人类天然的色彩认知中，实际上混杂了很多其它因素，金色和银色不仅仅是一种颜色，它还意味着一定的镜面反光程度，在同样的光照条件下，金属会呈现出更亮的色彩，这并非是用一个色值可以描述的，这就引出了我们接下来要讲的渐变。 渐变在CSS中，background-image这样的属性，可以设为渐变。CSS中支持两种渐变，一种是线性渐变，一种是放射性渐变，我们先了解一下它们的基本用法： 线性渐变的写法是： linear-gradient(direction, color-stop1, color-stop2, ...);这里的direction可以是方向，也可以是具体的角度。例如： to bottom to top to left to right to bottom left to bottom right to top left to top right 120deg 3.14rad 以上这些都是合理的方向取值。 color-stop是一个颜色和一个区段，例如： rgba(255,0,0,0) orange yellow 10% green 20% lime 28px 我们组合一下，产生一个“真正的金色”的背景： &lt;style&gt; #grad1 { height: 200px; background: linear-gradient(45deg, gold 10%, yellow 50%, gold 90%); } &lt;/style&gt; &lt;div id=&quot;grad1&quot;&gt;&lt;/div&gt;放射性渐变需要一个中心点和若干个颜色： radial-gradient(shape size at position, start-color, ..., last-color);当我们应用的每一种颜色都是HSL颜色时，就产生了一些非常有趣的效果，比如，我们可以通过变量来调整一个按钮的风格： &lt;style&gt; .button { display: inline-block; outline: none; cursor: pointer; text-align: center; text-decoration: none; font: 14px/100% Arial, Helvetica, sans-serif; padding: .5em 2em .55em; text-shadow: 0 1px 1px rgba(0,0,0,.3); border-radius: .5em; box-shadow: 0 1px 2px rgba(0,0,0,.2); color: white; border: solid 1px ; } &lt;/style&gt; &lt;div class=&quot;button orange&quot;&gt;123&lt;/div&gt; var btn = document.querySelector(&quot;.button&quot;); var h = 25; setInterval(function(){ h ++; h = h % 360; btn.style.borderColor=`hsl(${h}, 95%, 45%)` btn.style.background=`linear-gradient(to bottom, hsl(${h},95%,54.1%), hsl(${h},95%,84.1%))` },100);形状CSS中的很多属性还会产生形状，比如我们常见的属性： border box-shadow border-radius 这些产生形状的属性非常有趣，我们也能看到很多利用它们来产生的CSS黑魔法。然而，这里我有一个相反的建议，我们仅仅把它们用于基本的用途，把border用于边框、把阴影用于阴影，把圆角用于圆角，所有其它的场景，都有一个更好的替代品：datauri+svg。 总结今天我们介绍了CSS中渲染相关的属性：颜色和形状。 我们重点介绍了CSS的颜色系统，从颜色基本原理讲解了RGB颜色、CMYK颜色和HSV颜色，我们还讲解了Alpha通道。 接下来我们又讲了颜色的一个重要应用：渐变，我们可以把渐变看作是一个更复杂的颜色，它非常实用，能够用渐变绘制很多的图像。 最后我们讲解了形状相关的属性，以及SVG应用的一个小技巧。 思考题 折衷鹦鹉是一种可爱的鸟类，但是雄性折衷鹦鹉居然是跟雌性颜色不一样！你能用JavaScript和canvas，把这只雄性折衷鹦鹉变成跟雌性一样可爱的红色吗？","link":"/2019/08/31/重学前端/CSS渲染：CSS是如何绘制颜色的？/"},{"title":"CSS排版：从毕升开始，我们就开始用正常流了","text":"你好，我是winter。今天我们来聊聊CSS的正常流。 我想，在CSS中，大家最讨厌的大概就是排版部分了。因为早年的CSS设计上不能够很好地支持软件排版需求，导致大家需要使用很多黑科技，让很多新人望而却步。 现在CSS提供了很多种排版方式，我们有很多选项可以选择自己适合的那一种，然而，正常流却是我们绕不开的一种排版。 我们能够在网上看到关于正常流的各种资料，比如：块级格式化上下文、margin折叠等等……这一系列的概念光是听起来就令人非常头痛。 所以我相信很多同学一定会奇怪：正常流到底正常在哪里。事实上，我认为正常流本身是简单和符合直觉的东西。 我们之所以会觉得它奇怪，是因为如果我们从严苛的CSS标准角度去理解正常流，规定排版的算法，就需要引入上述那些复杂的概念。但是，如果我们单纯地从感性认知的层面去理解正常流，它其实是简单的。 下面，就让我们先抛弃掉所有的已知概念，从感性认知的角度出发，一起去理解一下正常流。 正常流的行为首先，我们先从词源来讲一讲排版这件事。 在毕昇发明活字印刷之前，排版这项工作是不存在的，相应的操作叫做“雕版”。人们要想印刷书籍，就需要依靠雕版工人去手工雕刻印版。 活字印刷的出现，将排版这个词引入进来，排版是活字印刷的15道工序之一，不论是古代的木质活字印刷，还是近代的铅质活字印刷，排版的过程是由排版工人一个字一个字从字架捡出，再排入版框中。实际上，这个过程就是一个流式处理的过程。 从古代活字印刷开始，到现代的出版行业，再到今天的Web，排版过程其实并没有什么本质的变化，只不过，今天在我们的CSS中，排版需要处理的内容，不再是简单的大小相同的木字或者铅字，而是有着不同字体和字号的富文本，以及插入在富文本中大小不等的盒。 并且，在这些过程中，都会有一个正常流的存在。那么，正常流是什么样的呢？ 我们可以用一句话来描述正常流的排版行为，那就是：依次排列，排不下了换行。这个操作很简单吧，我想，任何一个不懂排版的人都会将其作为排版时的第一反应。 理解了正常流的基本概念，剩下的功能只需要在它的基础上延伸一下就好。 在正常流基础上，我们有float相关规则，使得一些盒占据了正常流需要的空间，我们可以把float理解为“文字环绕”。 我们还有vertical-align相关规则规定了如何在垂直方向对齐盒。vertical-align相关规则看起来复杂，但是实际上，基线、文字顶/底、行顶/底都是我们正常书写文字时需要用到的概念，只是我们平时不一定会总结它们。 下图展示了在不同的vertical-align设置时，盒与文字是如何混合排版的。为了方便你理解，我们用代码给大家标注了基线、文字顶/底、行顶/底等概念。 （点击大图查看） 除此之外，margin折叠是很多人非常不理解的一种设计，但是实际上我们可以把margin理解为“一个元素规定了自身周围至少需要的空间”，这样，我们就非常容易理解为什么margin需要折叠了。 正常流的原理我们前面描述了正常流的行为，接下来我们要切换一下模式，用比较严谨的姿势来理解一下正常流。 在CSS标准中，规定了如何排布每一个文字或者盒的算法，这个算法依赖一个排版的“当前状态”，CSS把这个当前状态称为“格式化上下文（formatting context）”。 我们可以认为排版过程是这样的： 格式化上下文 + 盒/文字 = 位置 formatting context + boxes/charater = positions 我们需要排版的盒，是分为块级盒和行内级盒的，所以排版需要分别为它们规定了块级格式化上下文和行内级格式化上下文。 与正常流一样，如果我们单纯地看格式化上下文，规则其实是非常简单的。 块级格式化上下文顺次排列元素： 行内级格式化上下文顺次排列元素： 注意，块级和行内级元素的排版，受文字书写方向的影响，这里我们讲上下左右只是为了方便你直观理解。 当我们要把正常流中的一个盒或者文字排版，需要分成三种情况处理。 当遇到块级盒：排入块级格式化上下文。 当遇到行内级盒或者文字：首先尝试排入行内级格式化上下文，如果排不下，那么创建一个行盒，先将行盒排版（行盒是块级，所以到第一种情况），行盒会创建一个行内级格式化上下文。 遇到float盒：把盒的顶部跟当前行内级上下文上边缘对齐，然后根据float的方向把盒的对应边缘对到块级格式化上下文的边缘，之后重排当前行盒。 我们以上讲的都是一个块级格式化上下文中的排版规则，实际上，页面中的布局没有那么简单，一些元素会在其内部创建新的块级格式化上下文，这些元素有： 浮动元素； 绝对定位元素； 非块级但仍能包含块级元素的容器（如inline-blocks, table-cells, table-captions）； 块级的能包含块级元素的容器，且属性overflow不为visible。 这里的最后一条比较绕，实际上，我个人喜欢用另一种思路去理解它： 自身为块级，且overflow为visible的块级元素容器，它的块级格式化上下文和外部的块级格式化上下文发生了融合，也就是说，如果不考虑盒模型相关的属性，这样的元素从排版的角度就好像根本不存在。 好了，到这里我们已经讲完了正常流的排版详细规则，但是理解规则仅仅是基础，我们还需要掌握一些技巧。 正常流的使用技巧现在，我们就一起来动手用实际的例子来研究一下。我们今天来看看等分布局和自适应宽，从这两种经典布局问题入手，一起来探索一下正常流的使用技巧。 等分布局问题横向等分布局是一个很常见的需求，按照一般的思路，我们可以使用百分比宽度来解决，我们参考以下代码： &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; .inner { width:33.33%; height:300px; display:inline-block; outline:solid 1px blue; }在这段HTML代码中，我们放了三个div，用CSS给它们指定了百分比宽度，并且指定为inline-block。 但是这段代码执行之后，效果跟我们预期不同，我们可以发现，每个div并非紧挨，中间有空白，这是因为我们为了代码格式加入的换行和空格被HTML当作空格文本，跟inline盒混排了的缘故。 解决方案是修改HTML代码，去掉空格和换行： &lt;div class=&quot;outer&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;但是这样做影响了源代码的可读性，一个变通的方案是，改变outer中的字号为0。 .inner { width:33.33%; height:300px; display:inline-block; outline:solid 1px blue; font-size:30px; } .outer { font-size:0; }在某些浏览器中，因为像素计算精度问题，还是会出现换行，我们给outer添加一个特定宽度： .inner { width:33.33%; height:300px; display:inline-block; outline:solid 1px blue; } .outer { width:101px }这个代码在某些旧版本浏览器中会出现换行。为了保险起见，我们给最后一个div加上一个负的右margin： .outer { width:101px } .inner { width:33.33%; height:300px; display:inline-block; outline:solid 1px blue; } .inner:last-child { margin-right:-5px; }这样就可以解决旧版本浏览器的问题了。 除了使用inline-block，float也可以实现类似的效果，但是float元素只能做顶对齐，不如inline-block灵活。 自适应宽我们再来说说自适应宽。在IE6统治浏览器市场的旧时代，自适应宽（一个元素固定宽度，另一个元素填满父容器剩余宽度）是个经典的布局问题，我们现在就看一下如何使用正常流来解决。 我们首先来看一下问题。 &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;fixed&quot;&gt;&lt;/div&gt; &lt;div class=&quot;auto&quot;&gt;&lt;/div&gt; &lt;/div&gt; .fixed { width:200px; } .fixed, .auto { height:300px; outline:solid 1px blue; }这里fixed这个div宽度已经被指定好，我们需要添加css代码尝试让.auto填满剩余宽度。 使用正常流解决这个问题的思路是，利用负margin： .fixed { display:inline-block; vertical-align:top; } .auto { margin-left:-200px; width:100%; display:inline-block; vertical-align:top; }但是，这样做会导致auto中的内容位置不对，所以我们还需要使用padding把内容挤出来，最终完整代码如下： .fixed { display:inline-block; vertical-align:top; } .auto { margin-left:-200px; padding-left:200px; box-sizing:border-box; width:100%; display:inline-block; vertical-align:top; }这样就给auto添加了padding-left和box-sizing两个属性。 总的来说，正常流布局主要是使用inline-block来作为内容的容器，利用块级格式化上下文的纵向排布和行内级格式化上下文的横向排布来完成布局的，我们需要根据需求的横向和纵向排布要求，来选择元素的display属性。 结语这次的文章中，我们一起学习了正常流，我们可以用一句话来描述正常流的排版行为，那就是：依次排列，排不下了换行。这也是理解它最简单最源头的方式。 我们将正常流的知识分成了三个部分。 正常流的行为部分，我们从一些感性认知出发，帮助你从思路和源头上理解正常流的行为。 正常流的原理部分，我用更严格的描述方式，给你讲解了CSS标准中规定的正常流排版逻辑。 最后的正常流应用部分，我以两个经典布局问题等分布局和自适应宽为例，为你讲解了正常流实际使用的一些技巧。 最后，留给你一个思考题：用JavaScript写一个仅包含inline-block的正常流布局算法。你写好的话，可以留言给我，我们一起讨论。 猜你喜欢","link":"/2019/08/31/重学前端/CSS排版：从毕升开始，我们就开始用正常流了/"},{"title":"CSS选择器：伪元素是怎么回事儿？","text":"你好，我是winter。 在上一篇文章中，我已经给你介绍了一些简单选择器，这一节课我会继续给你介绍选择器的几个机制：选择器的组合、选择器的优先级和伪元素。 选择器的组合在CSS规则中，选择器部分是一个选择器列表。 选择器列表是用逗号分隔的复杂选择器序列；复杂选择器则是用空格、大于号、波浪线等符号连接的复合选择器；复合选择器则是连写的简单选择器组合。 根据选择器列表的语法，选择器的连接方式可以理解为像四则运算一样有优先级。 第一优先级 无连接符号 第二优先级 “空格” “~” “+” “&gt;” “||” 第三优先级 “,” 例如以下选择器： .c,.a&gt;.b.d { /*......*/ }我们应该理解为这样的结构。 .c,.a&gt;.b.d .c .a&gt;.b.d .a .b.d .b .d 复合选择器表示简单选择器中“且”的关系，例如，例子中的“ .b.d ”，表示选中的元素必须同时具有b和d两个class。 复杂选择器是针对节点关系的选择，它规定了五种连接符号。 “空格”：后代，表示选中所有符合条件的后代节点， 例如“ .a .b ”表示选中所有具有class为a的后代节点中class为b的节点。 “&gt;” ：子代，表示选中符合条件的子节点，例如“ .a&gt;.b ”表示：选中所有“具有class为a的子节点中，class为b的节点”。 *“~” *: 后继，表示选中所有符合条件的后继节点，后继节点即跟当前节点具有同一个父元素，并出现在它之后的节点，例如“ .a~.b ”表示选中所有具有class为a的后继中，class为b的节点。 “+”：直接后继，表示选中符合条件的直接后继节点，直接后继节点即nextSlibling。例如 “.a+.b ”表示选中所有具有class为a的下一个class为b的节点。 “||”：列选择器，表示选中对应列中符合条件的单元格。 我们在实际使用时，比较常用的连接方式是“空格”和“&gt;”。 工程实践中一般会采用设置合理的class的方式，来避免过于复杂的选择器结构，这样更有利于维护和性能。 空格和子代选择器通常用于组件化场景，当组件是独立开发时，很难完全避免class重名的情况，如果为组件的最外层容器元素设置一个特别的class名，生成CSS规则时，则全部使用后代或者子代选择器，这样可以有效避免CSS规则的命名污染问题。 逗号表示“或”的关系，实际上，可以把它理解为“两条内容一样的CSS规则”的一种简写。如我们开头的例子，可以理解成与下面的代码等效： .c { /*......*/ } .a&gt;.b.d { /*......*/ }到这里，我们就讲完了如何用简单选择器组合成复合选择器和复杂选择器，形成选择器列表，这能够帮助我们应对各种复杂的需求。 CSS选择器是基于规则生效的，同一个元素命中多条规则是非常常见的事情。不同规则指定同一个属性为不同值时，就需要一个机制来解决冲突。这个机制，就是接下来我们要讲的选择器优先级。 选择器的优先级CSS标准用一个三元组 (a, b, c) 来构成一个复杂选择器的优先级。 id选择器的数目记为a； 伪类选择器和class选择器的数目记为b； 伪元素选择器和标签选择器数目记为c； “*” 不影响优先级。 CSS标准建议用一个足够大的进制，获取“ a-b-c ”来表示选择器优先级。 即： specificity = base * base * a + base * b + c其中，base是一个“足够大”的正整数。关于base，历史中有些趣闻，早年IE6采用256进制，于是就产生“256个class优先级等于一个id”这样的奇葩问题，后来扩大到65536，基本避免了类似的问题。 现代浏览器多采用了更大的数量，我们正常编写的CSS规则数量不太可能达到数万，因此我们可以认为这样的base就足够大了。 行内属性的优先级永远高于CSS规则，浏览器提供了一个“口子”，就是在选择器前加上“!import”。 这个用法非常危险，因为它相当于一个新的优先级，而且此优先级会高于行内属性。 同一优先级的选择器遵循“后面的覆盖前面的”原则，我们可以看一个例子： &lt;div id=&quot;my&quot; class=&quot;x y&quot;&gt;text&lt;div&gt; .x { background-color:lightblue; } .y { background-color:lightgreen; }调换“.x”和“.y”我们可以得到不同的显示效果。选择器的优先级是针对单条规则的，多条规则的选择器同时命中元素，优先级不会发生叠加。 &lt;div id=&quot;my&quot; class=&quot;x y z&quot;&gt;text&lt;div&gt; .x { background-color:lightblue; } .z { background-color:lightblue; } .y { background-color:lightgreen; }在这个例子中，“.x ”和“.z ”都指定了背景色为浅蓝色，但是因为“.y ”规则在最后，所以最终显示结果为浅绿色。另外一个需要注意的是，选择器的优先级是针对复杂选择器的优先级，选择器列表不会合并计算优先级。 我们看一个例子： &lt;div id=&quot;my&quot; class=&quot;x y z&quot;&gt;text&lt;div&gt; .x, .z { background-color:lightblue; } .y { background-color:lightgreen; }这里选择器列表“ .x, .z”命中了div，但是它的两项分别计算优先级，所以最终优先级仍跟“ .y” 规则相同。 以上就是选择器优先级的相关规则了，虽然我们这里介绍了详细的计算方式，但是我认为选择器的使用上，如果产生复杂的优先级计算，代码的可读性一定是有问题的。 所以实践中，建议你“根据 id 选单个元素”“class和class的组合选成组元素”“tag选择器确定页面风格”这样的简单原则来使用选择器，不要搞出过于复杂的选择器。 伪元素在上一课，我们有意忽略了一种重要的简单选择器：伪元素。 我之所以没有把它放在简单选择器中，是因为伪元素本身不单单是一种选择规则，它还是一种机制。 所以本节课，我就来讲一讲伪元素机制。伪元素的语法跟伪类相似，但是实际产生的效果却是把不存在的元素硬选出来。 目前兼容性达到可用的伪元素有以下几种。 ::first-line ::first-letter ::before ::after 下面我们就来分别讲讲它们。 ::first-line 和 ::first-letter 是比较类似的伪元素，其中一个表示元素的第一行，一个表示元素的第一个字母。 我们可以看一个示例： &lt;p&gt;This is a somewhat long HTML paragraph that will be broken into several lines. The first line will be identified by a fictional tag sequence. The other lines will be treated as ordinary lines in the paragraph.&lt;/p&gt; p::first-line { text-transform: uppercase }这一段代码把段落的第一行字母变为大写。注意这里的第一行指的是排版后显示的第一行，跟HTML代码中的换行无关。 ::first-letter 则指第一个字母。首字母变大并向左浮动是一个非常常见的排版方式。 &lt;p&gt;This is a somewhat long HTML paragraph that will be broken into several lines. The first line will be identified by a fictional tag sequence. The other lines will be treated as ordinary lines in the paragraph.&lt;/p&gt; p::first-letter { text-transform: uppercase; font-size:2em; float:left; }虽然听上去很简单，但是实际上，我们遇到的HTML结构要更为复杂，一旦元素中不是纯文本，规则就变得复杂了。 CSS标准规定了first-line必须出现在最内层的块级元素之内。因此，我们考虑以下代码。 &lt;div&gt; &lt;p id=a&gt;First paragraph&lt;/p&gt; &lt;p&gt;Second paragraph&lt;/p&gt; &lt;/div&gt; div&gt;p#a { color:green; } div::first-line { color:blue; }这段代码最终结果第一行是蓝色，因为p是块级元素，所以伪元素出现在块级元素之内，所以内层的color覆盖了外层的color属性。 如果我们把p换成span，结果就是相反的。 &lt;div&gt; &lt;span id=a&gt;First paragraph&lt;/span&gt;&lt;br/&gt; &lt;span&gt;Second paragraph&lt;/span&gt; &lt;/div&gt; div&gt;span#a { color:green; } div::first-line { color:blue; }这段代码的最终结果是绿色，这说明伪元素在span之外。 ::first-letter的行为又有所不同，它的位置在所有标签之内，我们把前面的代码换成::first-letter。 &lt;div&gt; &lt;span id=a&gt;First paragraph&lt;/span&gt;&lt;br/&gt; &lt;span&gt;Second paragraph&lt;/span&gt; &lt;/div&gt; div&gt;span#a { color:green; } div::first-letter { color:blue; }执行这段代码，我们可以看到，首字母变成了蓝色，这说明伪元素出现在span之内。 CSS标准只要求 ::first-line 和 ::first-letter 实现有限的几个CSS属性，都是文本相关，这些属性是下面这些。 接下来我们说说 ::before 和 ::after 伪元素。 这两个伪元素跟前面两个不同的是，它不是把已有的内容套上一个元素，而是真正的无中生有，造出一个元素。 ::before 表示在元素内容之前插入一个虚拟的元素，::after 则表示在元素内容之后插入。 这两个伪元素所在的CSS规则必须指定content属性才会生效，我们看下例子： &lt;p class=&quot;special&quot;&gt;I&apos;m real element&lt;/p&gt; p.special::before { display: block; content: &quot;pseudo! &quot;; }这里要注意一点，::before 和 ::after 还支持content为counter，如： &lt;p class=&quot;special&quot;&gt;I&apos;m real element&lt;/p&gt; p.special::before { display: block; content: counter(chapno, upper-roman) &quot;. &quot;; }这对于实现一些列表样式是非常有用的。 ::before 和 ::after 中支持所有的CSS属性。实际开发中，这两个伪元素非常有用，有了这两个伪元素，一些修饰性元素，可以使用纯粹的CSS代码添加进去，这能够很好地保持HTML代码中的语义，既完成了显示效果，又不会让DOM中出现很多无语义的空元素。 结语这一课，我们讲了CSS选择器的三种机制：选择器的组合、选择器优先级、以及伪元素。 在选择器组合这一部分，我们讲到了，选择器的连接方式像四则运算一样有优先级。 第一优先级是无连接符号；第二优先级是：“空格”“~”“+”“&gt;”“||”；第三优先级是“,”。 然后我们又介绍了选择器优先级的计算方式。 最后我们介绍了伪元素，我们逐次讲解了： ::first-line ::first-letter ::before ::after 四种伪元素。伪元素的语法跟伪类相似，但是实际产生的效果是把不存在的元素硬选出来。这一点就与伪类不太一样了。 结合上一节课我们讲的简单选择器，对它们灵活运用，就能够满足大部分CSS的使用场景的需求了。 最后，留给你一个问题，你所在的团队，如何规定CSS选择器的编写规范？你觉得它好吗？ 猜你喜欢","link":"/2019/08/31/重学前端/CSS选择器：伪元素是怎么回事儿？/"},{"title":"CSS语法：除了属性和选择器，你还需要知道这些带@的规则","text":"你好，我是winter。 今天我们进入CSS的学习。CSS是前端工程师几乎每天都要用的技术了，不过CSS的学习资料却是最糟糕的，这是因为CSS并没有像HTML和JavaScript那样的一份标准文档。 如果我们到W3C的网站上搜索看看，可以得到一些信息： https://www.w3.org/TR/?title=css 在这里，我们一共看到了98份CSS相关的标准，它们各自从一些角度规定了CSS的特性。 这里我们暂且去掉Working Draft状态的标准，可以得到22份候选标准和6份推荐标准。 既然我们的专栏内容强调去系统性学习CSS，于是，面对这22+6份标准，我们就又需要一条线索，才能把这些离散的标准组织成易于理解和记忆的形式。 在这样的需求下，我找到的线索就是CSS语法，任何CSS的特性都必须通过一定的语法结构表达出来，所以语法可以帮助我们发现大多数CSS特性。 CSS语法的最新标准，你可以戳这里查看： https://www.w3.org/TR/css-syntax-3/ 这篇文档的阅读体验其实是非常糟糕的，它对CSS语法的描述使用了类似LL语法分析的伪代码，而且没有描述任何具体的规则。 这里你就不必自己去阅读了，我来把其中一些有用的关键信息抽取出来描述一下，我们一起来看看。 我们拿到这份标准可以看到，去除空格、HTML注释等无效信息，CSS的顶层样式表由两种规则组成的规则列表构成，一种被称为 at-rule，也就是at 规则，另一种是 qualified rule，也就是普通规则。 at-rule由一个 @ 关键字和后续的一个区块组成，如果没有区块，则以分号结束。这些at-rule在开发中使用机会远远小于普通的规则，所以它的大部分内容，你可能会感觉很陌生。 这些at规则正是掌握CSS的一些高级特性所必须的内容。qualified rule则是指普通的CSS规则，也就是我们所熟识的，由选择器和属性指定构成的规则。 at 规则好了，现在我们已经知道了，CSS语法的整体结构，接下来我们要做的是一个体力活，从所有的CSS标准里找到所有可能的 at-rule（不用谢，我已经帮你找好了，如果页面定位不准，你可以打开页面搜索关键字）。 @charset ： https://www.w3.org/TR/css-syntax-3/ @import ：https://www.w3.org/TR/css-cascade-4/ @media ：https://www.w3.org/TR/css3-conditional/ @page ： https://www.w3.org/TR/css-page-3/ @counter-style ：https://www.w3.org/TR/css-counter-styles-3 @keyframes ：https://www.w3.org/TR/css-animations-1/ @fontface ：https://www.w3.org/TR/css-fonts-3/ @supports ：https://www.w3.org/TR/css3-conditional/ @namespace ：https://www.w3.org/TR/css-namespaces-3/ 这里的每一种@规则背后，都是一组CSS的知识。在我们的课程中，有些会重点介绍，不过，为了先给你建立起一个整体的认知，我们这里会给所有的@规则提供一些简单的例子和介绍。 @charset@charset用于提示CSS文件使用的字符编码方式，它如果被使用，必须出现在最前面。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果。 @charset &quot;utf-8&quot;;@import@import用于引入一个CSS文件，除了@charset规则不会被引入，@import可以引入另一个文件的全部内容。 @import &quot;mystyle.css&quot;; @import url(&quot;mystyle.css&quot;); @import [ &lt;url&gt; | &lt;string&gt; ] [ supports( [ &lt;supports-condition&gt; | &lt;declaration&gt; ] ) ]? &lt;media-query-list&gt;? ;通过代码，我们可以看出，import还支持 supports 和media query形式。 @mediamedia就是大名鼎鼎的media query使用的规则了，它能够对设备的类型进行一些判断。在media的区块内，是普通规则列表。 @media print { body { font-size: 10pt } }@pagepage用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。 @page { size: 8.5in 11in; margin: 10%; @top-left { content: &quot;Hamlet&quot;; } @top-right { content: &quot;Page &quot; counter(page); } }@ counter-stylecounter-style产生一种数据，用于定义列表项的表现。 @counter-style triangle { system: cyclic; symbols: ‣; suffix: &quot; &quot;; }@ key-frameskeyframes产生一种数据，用于定义动画关键帧。 @keyframes diagonal-slide { from { left: 0; top: 0; } to { left: 100px; top: 100px; } }@ fontfacefontface用于定义一种字体，icon font技术就是利用这个特性来实现的。 @font-face { font-family: Gentium; src: url(http://example.com/fonts/Gentium.woff); } p { font-family: Gentium, serif; }@ supportsupport检查环境的特性，它与media比较类似。 @ namespace用于跟XML命名空间配合的一个规则，表示内部的CSS选择器全都带上特定命名空间。 @ viewport用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被HTML的meta代替。 其它除了以上这些，还有些目前不太推荐使用的at规则。 @color-profile 是 SVG1.0 引入的CSS特性，但是实现状况不怎么好。 @document 还没讨论清楚，被推迟到了CSS4中。 @font-feature-values 。 普通规则接下来我们进入qualified rule，也就是普通规则的部分，看看这里有什么需要我们记住的内容。 qualified rule主要是由选择器和声明区块构成。声明区块又由属性和值构成。我在下面的列表中，介绍了这部分语法的组成要点。 普通规则 选择器 声明列表 属性 值 值的类型 函数 选择器我们先来看看选择器，它有一份独立的标准，我们可以参考这个网址： https://www.w3.org/TR/selectors-4/ 这份标准不在我们前面的过滤条件中，它属于CSS和HTML共用的标准。 关于选择器的叠加规则等知识我们后文会专门的一节课程来讲，这里我们就从语法的角度介绍一下选择器。 在选择器标准的最后，附有一张选择器的语法表，从这份语法表，我们可以理清楚记忆选择器的思路。 我们从语法结构可以看出，任何选择器，都是由几个符号结构连接的：空格、大于号、加号、波浪线、双竖线，这里需要注意一下，空格，即为后代选择器的优先级较低。 然后对每一个选择器来说，如果它不是伪元素的话，由几个可选的部分组成，标签类型选择器，id、class、属性和伪类，它们中只要出现一个，就构成了选择器。 如果它是伪元素，则在这个结构之后追加伪元素。只有伪类可以出现在伪元素之后。我在下面用一个列表（不太严谨地）整理了选择器的语法结构： 我们在这里可以参考一个示例图： （语法结构分析示例） 看完了选择器，我们继续来看看声明部分的语法。 声明：属性和值声明部分是一个由“属性:值”组成的序列。 属性是由中划线、下划线、字母等组成的标识符，CSS还支持使用反斜杠转义。我们需要注意的是：属性不允许使用连续的两个中划线开头，这样的属性会被认为是CSS变量。 在CSS Variables标准中，以双中划线开头的属性被当作变量，与之配合的则是 var 函数： :root { --main-color: #06c; --accent-color: #006; } /* The rest of the CSS file */ #foo h1 { color: var(--main-color); }值的部分，主要在标准 CSS Values and Unit，根据每个CSS属性可以取到不同的值，这里的值可能是字符串、标识符。 CSS属性值可能是以下类型。 CSS范围的关键字：initial，unset，inherit，任何属性都可以的关键字。 字符串：比如content属性。 URL：使用url() 函数的URL值。 整数/实数：比如flex属性。 维度：单位的整数/实数，比如width属性。 百分比：大部分维度都支持。 颜色：比如background-color属性。 图片：比如background-image属性。 2D位置：比如background-position属性。 函数：来自函数的值，比如transform属性。 这里我们要重点介绍一下函数。一些属性会要求产生函数类型的值，比如easing-function会要求cubic-bezier()函数的值： CSS支持一批特定的计算型函数： calc() max() min() clamp() toggle() attr() calc()函数是基本的表达式计算，它支持加减乘除四则运算。在针对维度进行计算时，calc()函数允许不同单位混合运算，这非常的有用。 例如： section { float: left; margin: 1em; border: solid 1px; width: calc(100%/3 - 2*1em - 2*1px); }max()、min()和clamp()则是一些比较大小的函数，max()表示取两数中较大的一个，min()表示取两数之中较小的一个，clamp()则是给一个值限定一个范围，超出范围外则使用范围的最大或者最小值。 toggle()函数在规则选中多于一个元素时生效，它会在几个值之间来回切换，比如我们要让一个列表项的样式圆点和方点间隔出现，可以使用下面代码： ul { list-style-type: toggle(circle, square); }attr()函数允许CSS接受属性值的控制。 总结在这一部分，我们介绍了CSS语法的总体结构，CSS的语法总体结构是由两种规则列表构成，一种是at 规则，另一种是普通规则。 在at规则中，我举了13个以上的例子，并逐个进行了简单的介绍。而在普通规则的部分，我介绍了选择器和声明区块是普通规则的主要组成部分。 并且，我给出了一个（不太严谨）的选择器语法结构，声明区块则由属性和值构成，这一部分我们重点介绍了函数。 从整体上去掌握内容，再去定位到单个细节，这对于我们学习CSS有非常重要的提示作用。 最后，给你留一个思考问题，CSS的函数有很多，本文也提到了不少，请你也一起查阅资料，试着总结一下，你能找到多少种CSS函数？","link":"/2019/08/31/重学前端/CSS语法：除了属性和选择器，你还需要知道这些带@的规则/"},{"title":"HTML小实验：用代码分析HTML标准","text":"你好，我是winter。 前面的课程中，我们已经讲解了大部分的HTML标签。 然而，为了突出重点，我们还是会忽略一些标签类型。比如表单类标签和表格类标签，我认为只有少数前端工程师用过，比如我在整个手机淘宝的工作生涯中，一次表格类标签都没有用到，表单类则只用过input，也只有几次。 那么，剩下的标签我们怎么样去了解它们呢？当然是查阅HTML标准。 由于阅读标准有一定门槛，需要了解一些机制，这节课，我为你设计了一个小实验，用JavaScript代码去抽取标准中我们需要的信息。 HTML标准我们采用WHATWG的living standard标准，我们先来看看标准是如何描述一个标签的，这里我们看到，有下面这些内容。 Categories: Flow content. Phrasing content. Embedded content. If the element has a controls attribute: Interactive content. Palpable content. Contexts in which this element can be used: Where embedded content is expected. Content model: If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants. If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants. Tag omission in text/html: Neither tag is omissible. Content attributes: Global attributes src — Address of the resource crossorigin — How the element handles crossorigin requests poster — Poster frame to show prior to video playback preload — Hints how much buffering the media resource will likely need autoplay — Hint that the media resource can be started automatically when the page is loaded playsinline — Encourage the user agent to display video content within the element&apos;s playback area loop — Whether to loop the media resource muted — Whether to mute the media resource by default controls — Show user agent controls width — Horizontal dimension height — Vertical dimension DOM interface: [Exposed=Window, HTMLConstructor] interface HTMLVideoElement : HTMLMediaElement { [CEReactions] attribute unsigned long width; [CEReactions] attribute unsigned long height; readonly attribute unsigned long videoWidth; readonly attribute unsigned long videoHeight; [CEReactions] attribute USVString poster; [CEReactions] attribute boolean playsInline; };我们看到，这里的描述分为6个部分，有下面这些内容。 Categories：标签所属的分类。 Contexts in which this element can be used：标签能够用在哪里。 Content model：标签的内容模型。 Tag omission in text/html：标签是否可以省略。 Content attributes：内容属性。 DOM interface：用WebIDL定义的元素类型接口。 这一节课，我们关注一下Categories、Contexts in which this element can be used、Content model这几个部分。我会带你从标准中抓取数据，做一个小工具，用来检查X标签是否能放入Y标签内。 代码角度分析HTML标准HTML标准描述用词非常的严谨，这给我们抓取数据带来了巨大的方便，首先，我们打开单页面版HTML标准： https://html.spec.whatwg.org/ 在这个页面上，我们执行一下以下代码： Array.prototype.map.call(document.querySelectorAll(&quot;.element&quot;), e=&gt;e.innerText);这样我们就得到了所有元素的定义了，现在有107个元素。 不过，比较尴尬的是，这些文本中并不包含元素名，我们只好从id属性中获取，最后代码类似这样： var elementDefinations = Array.prototype.map.call(document.querySelectorAll(&quot;.element&quot;), e =&gt; ({ text:e.innerText, name:e.childNodes[0].childNodes[0].id.match(/the\\-([\\s\\S]+)\\-element:/)?RegExp.$1:null}));接下来我们用代码理解一下这些文本。首先我们来分析一下这些文本，它分成了6个部分，而且顺序非常固定，这样，我们可以用JavaScript的正则表达式匹配来拆分六个字段。 我们这个小实验的目标是计算元素之间的包含关系，因此，我们先关心一下categories和contentModel两个字段。 for(let defination of elementDefinations) { console.log(defination.name + &quot;:&quot;) let categories = defination.text.match(/Categories:\\n([\\s\\S]+)\\nContexts in which this element can be used:/)[1].split(&quot;\\n&quot;); for(let category of categories) { console.log(category); } /* let contentModel = defination.text.match(/Content model:\\n([\\s\\S]+)\\nTag omission in text\\/html:/)[1].split(&quot;\\n&quot;); for(let line of contentModel) console.log(line); */ }接下来我们来处理category。 首先category的写法中，最基本的就是直接描述了category的句子，我们把这些不带任何条件的category先保存起来，然后打印出来其它的描述看看： for(let defination of elementDefinations) { //console.log(defination.name + &quot;:&quot;) let categories = defination.text.match(/Categories:\\n([\\s\\S]+)\\nContexts in which this element can be used:/)[1].split(&quot;\\n&quot;); defination.categories = []; for(let category of categories) { if(category.match(/^([^ ]+) content./)) defination.categories.push(RegExp.$1); else console.log(category) } /* let contentModel = defination.text.match(/Content model:\\n([\\s\\S]+)\\nTag omission in text\\/html:/)[1].split(&quot;\\n&quot;); for(let line of contentModel) console.log(line); */ }这里我们要处理的第一个逻辑是带if的情况。 然后我们来看看剩下的情况： None. Sectioning root. None. Sectioning root. None. Form-associated element. Listed and submittable form-associated element. None. Sectioning root. None. If the type attribute is not in the Hidden state: Listed, labelable, submittable, resettable, and autocapitalize-inheriting form-associated element. If the type attribute is in the Hidden state: Listed, submittable, resettable, and autocapitalize-inheriting form-associated element. Listed, labelable, submittable, and autocapitalize-inheriting form-associated element. Listed, labelable, submittable, resettable, and autocapitalize-inheriting form-associated element. None. Listed, labelable, submittable, resettable, and autocapitalize-inheriting form-associated element. Listed, labelable, resettable, and autocapitalize-inheriting form-associated element. Labelable element. Sectioning root. Listed and autocapitalize-inheriting form-associated element. None. Sectioning root. None. Sectioning root. Script-supporting element.这里出现了几个概念： None Sectioning root Form-associated element Labelable element Script-supporting element 如果我们要真正完美地实现元素分类，就必须要在代码中加入正则表达式来解析这些规则，这里作为今天的课后问题，留给你自己完成。 接下来我们看看Content Model，我们照例先处理掉最简单点的部分，就是带分类的内容模型： for(let defination of elementDefinations) { //console.log(defination.name + &quot;:&quot;) let categories = defination.text.match(/Categories:\\n([\\s\\S]+)\\nContexts in which this element can be used:/)[1].split(&quot;\\n&quot;); defination.contentModel = []; let contentModel = defination.text.match(/Content model:\\n([\\s\\S]+)\\nTag omission in text\\/html:/)[1].split(&quot;\\n&quot;); for(let line of contentModel) if(line.match(/^([^ ]+) content./)) defination.contentModel.push(RegExp.$1); else console.log(line) }好了，我们照例看看剩下了什么： A head element followed by a body element. If the document is an iframe srcdoc document or if title information is available from a higher-level protocol: Zero or more elements of metadata content, of which no more than one is a title element and no more than one is a base element. Otherwise: One or more elements of metadata content, of which exactly one is a title element and no more than one is a base element. Text that is not inter-element whitespace. Nothing. Text that gives a conformant style sheet. One or more h1, h2, h3, h4, h5, h6 elements, optionally intermixed with script-supporting elements. Nothing. Zero or more li and script-supporting elements. Either: Zero or more groups each consisting of one or more dt elements followed by one or more dd elements, optionally intermixed with script-supporting elements. Or: One or more div elements, optionally intermixed with script-supporting elements. Either: one figcaption element followed by flow content. Or: flow content followed by one figcaption element. Or: flow content. If the element is a child of a dl element: one or more dt elements followed by one or more dd elements, optionally intermixed with script-supporting elements. If the element is not a child of a dl element: flow content. Transparent, but there must be no interactive content or a element descendants. See prose. Text. If the element has a datetime attribute: Phrasing content. Otherwise: Text, but must match requirements described in prose below. Nothing. Transparent. Zero or more source elements, followed by one img element, optionally intermixed with script-supporting elements. Nothing. Zero or more param elements, then, transparent. Nothing. If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants. If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants. If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants. If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants. Nothing. Transparent. Nothing. In this order: optionally a caption element, followed by zero or more colgroup elements, followed optionally by a thead element, followed by either zero or more tbody elements or one or more tr elements, followed optionally by a tfoot element, optionally intermixed with one or more script-supporting elements. If the span attribute is present: Nothing. If the span attribute is absent: Zero or more col and template elements. Nothing. Zero or more tr and script-supporting elements. Zero or more td, th, and script-supporting elements. Nothing. Zero or more option, optgroup, and script-supporting elements. Either: phrasing content. Or: Zero or more option and script-supporting elements. Zero or more option and script-supporting elements. If the element has a label attribute and a value attribute: Nothing. If the element has a label attribute but no value attribute: Text. If the element has no label attribute and is not a child of a datalist element: Text that is not inter-element whitespace. If the element has no label attribute and is a child of a datalist element: Text. Text. Optionally a legend element, followed by flow content. One summary element followed by flow content. Either: phrasing content. Or: one element of heading content. If there is no src attribute, depends on the value of the type attribute, but must match script content restrictions. If there is a src attribute, the element must be either empty or contain only script documentation that also matches script content restrictions. When scripting is disabled, in a head element: in any order, zero or more link elements, zero or more style elements, and zero or more meta elements. When scripting is disabled, not in a head element: transparent, but there must be no noscript element descendants. Otherwise: text that conforms to the requirements given in the prose. Nothing (for clarification, see example). Transparent Transparent, but with no interactive content descendants except for a elements, img elements with usemap attributes, button elements, input elements whose type attribute are in the Checkbox or Radio Button states, input elements that are buttons, select elements with a multiple attribute or a display size greater than 1, and elements that would not be interactive content except for having the tabindex attribute specified.这有点复杂，我们还是把它做一些分类，首先我们过滤掉带If的情况、Text和Transparent。 for(let defination of elementDefinations) { //console.log(defination.name + &quot;:&quot;) let categories = defination.text.match(/Categories:\\n([\\s\\S]+)\\nContexts in which this element can be used:/)[1].split(&quot;\\n&quot;); defination.contentModel = []; let contentModel = defination.text.match(/Content model:\\n([\\s\\S]+)\\nTag omission in text\\/html:/)[1].split(&quot;\\n&quot;); for(let line of contentModel) if(line.match(/([^ ]+) content./)) defination.contentModel.push(RegExp.$1); else if(line.match(/Nothing.|Transparent./)); else if(line.match(/^Text[\\s\\S]*.$/)); else console.log(line) }这时候我们再来执行看看： A head element followed by a body element. One or more h1, h2, h3, h4, h5, h6 elements, optionally intermixed with script-supporting elements. Zero or more li and script-supporting elements. Either: Zero or more groups each consisting of one or more dt elements followed by one or more dd elements, optionally intermixed with script-supporting elements. Or: One or more div elements, optionally intermixed with script-supporting elements. If the element is a child of a dl element: one or more dt elements followed by one or more dd elements, optionally intermixed with script-supporting elements. See prose. Otherwise: Text, but must match requirements described in prose below. Zero or more source elements, followed by one img element, optionally intermixed with script-supporting elements. Zero or more param elements, then, transparent. If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants. If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants. If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants. If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants. In this order: optionally a caption element, followed by zero or more colgroup elements, followed optionally by a thead element, followed by either zero or more tbody elements or one or more tr elements, followed optionally by a tfoot element, optionally intermixed with one or more script-supporting elements. If the span attribute is absent: Zero or more col and template elements. Zero or more tr and script-supporting elements. Zero or more td, th, and script-supporting elements. Zero or more option, optgroup, and script-supporting elements. Or: Zero or more option and script-supporting elements. Zero or more option and script-supporting elements. If the element has a label attribute but no value attribute: Text. If the element has no label attribute and is not a child of a datalist element: Text that is not inter-element whitespace. If the element has no label attribute and is a child of a datalist element: Text. When scripting is disabled, in a head element: in any order, zero or more link elements, zero or more style elements, and zero or more meta elements. When scripting is disabled, not in a head element: transparent, but there must be no noscript element descendants. Otherwise: text that conforms to the requirements given in the prose.这下剩余的就少多了，我们可以看到，基本上剩下的都是直接描述可用的元素了，如果你愿意，还可以用代码进一步解析，不过如果是我的话，会选择手工把它们写成JSON了，毕竟只有三十多行文本。 好了，有了contentModel和category，我们要检查某一元素是否可以作为另一元素的子元素，就可以判断一下两边是否匹配啦，首先，我们要做个索引： var dictionary = Object.create(null); for(let defination of elementDefinations) { dictionary[defination.name] = defination; }然后我们编写一下我们的check函数： function check(parent, child) { for(let category of child.categories) if(parent.contentModel.categories.conatains(category)) return true; if(parent.contentModel.names.conatains(child.name)) return true; return false; }总结这一节课，我们完成了一个小实验：利用工具分析Web标准文本，来获得元素的信息。 通过这个实验，我希望能够传递一种思路，代码能够帮助我们从Web标准中挖掘出来很多想要的信息，编写代码的过程，也是更深入理解标准的契机。 我们前面的课程中把元素分成了几类来讲解，但是这些分类只能大概地覆盖所有的标签，我设置课程的目标也是讲解标签背后的知识，而非每一种标签的细节。具体每一种标签的属性和细节，可以留给大家自己去整理。 这一节课的产出，则是“绝对完整的标签列表”，也是我学习和阅读标准的小技巧，通过代码我们可以从不同的侧面分析标准的内容，挖掘需要注意的点，这是一种非常好的学习方法。","link":"/2019/08/31/重学前端/HTML小实验：用代码分析HTML标准/"},{"title":"HTML·ARIA：可访问性是只给盲人用的特性么？","text":"你好，我是winter。 我们都知道，HTML已经是一个完整的语义系统。在前面的课程中，我们围绕着HTML本身做了讲解，但是在实际应用中，我们还会用到一些它的扩展。今天我们要讲的ARIA就是其中重要的一部分。 ARIA全称为Accessible Rich Internet Applications，它表现为一组属性，是用于可访问性的一份标准。关于可访问性，它被提到最多的，就是它可以为视觉障碍用户服务，但是，这是一个误解。 实际上，可访问性其实是一个相当大的课题，它的定义包含了各种设备访问、各种环境、各种人群访问的友好性。不单单是永久性的残障人士需要用到可访问性，健康的人也可能在特定时刻处于需要可访问性的环境。 我们今天讲的ARIA，是以交互形式来标注各种元素的一类属性，所以，在ARIA属性中，你可以看到很多熟悉的面孔，交互形式往往跟我们直觉中的“控件”非常相似。 所以我们的课程，特意把ARIA加入还有一个原因：ARIA的角色对于我们UI系统的设计有重要的参考意义。 综述我们先整体来看看，ARIA给HTML元素添加的一个核心属性就是role，我们来看一个例子： &lt;span role=&quot;checkbox&quot; aria-checked=&quot;false&quot; tabindex=&quot;0&quot; aria-labelledby=&quot;chk1-label&quot;&gt; &lt;/span&gt; &lt;label id=&quot;chk1-label&quot;&gt;Remember my preferences&lt;/label&gt;这里我们给一个span添加了checkbox角色，这样，表示我们这个span被用于checkbox，这意味着，我们可能已经用JS代码绑定了这个span的click事件，并且以checkbox的交互方式来处理用户操作。 同时，ARIA系统还提供了一系列ARIA属性给checkbox这个role，这意味着，我们可以通过HTML属性变化来理解这个JavaScript组件的状态，读屏软件等三方客户端，就可以理解我们的UI变化，这正是ARIA标准的意义。 role的定义是一个树形的继承关系，我们先来理解一下它的整体结构： 其中，widget表示一些可交互的组件，structure表示文档中的结构，window则代表窗体。 接下来，让我们分类了解一下重要的ARIA角色。 Widget角色我们刚刚已经讲过一个widget role，就是checkbox。 这一类角色跟我们桌面开发中的控件类似，它表示一个可交互的组件，它们有： 我们这里按照继承关系给出一份列表和简要说明： ARIA role允许多继承，这里有些角色我没有重复写。 注意，这些role可以出现在任何一个HTML元素之上，同时要注意，这些ARIA属性，不会真实地改变任何一个元素的行为，比如，我们刚才讲的checkbox，即使我们给一个span添加了Checkbox角色，我们也需要用JavaScript编写相应的逻辑。 这些widget同时还会带来对应的ARIA属性，比如，我们的Checkbox角色，会带来两个属性： aria-checked 表示复选框是否已经被选中； aria-labelledby 表示复选框对应的文字。 而Button角色，则会带来另外两个属性： aria-pressed 按钮是否已经被按下； aria-expanded 按钮控制的目标是否已经被展开。 除了它们本身的属性之外，可交互组件还有继承来的属性，比如，switch角色继承了checkbox，因此，它也可以使用aria-checked属性。 在WAI-ARIA标准中，你可以找到所有的角色和对应的属性，我们这里就不一一列举了。 https://www.w3.org/TR/wai-aria/ 很多这些ARIA属性都是需要在JavaScript中维护的。 如果我们要实现一份组件库，这些widget role和它们对应的aria属性是非常好的参考。 如果你是组件的实现者，也希望你在实现组件时把对应的ARIA属性自动维护好。 除了简单的widget，还有一些比较复杂的角色，需要多个角色一起配合。我们来逐个了解一下。 Combobox 是一个带选项的输入框，我们常见的搜索引擎，一般都会提供这样的输入框，当输入时，它会提供若干提示选项。 Grid 是一个表格，它会分成行、列，行列又有行头和列头表示行、列的意义。 Tablist 是一个可切换的结构，一般被称为选项卡，它包含了tab头和tabpanel，在tab容器中，可能包含各种组件。 Listbox 是一个可选中的列表，它内部具有角色为Option的选项。 Menu 是指菜单，菜单中可以加入嵌套的菜单项（Menuitem角色），除了普通菜单项，还可以有Menuitemcheckbox 带复选框的菜单栏和Menuitemradio 带单选框的菜单栏。 Radiogroup 是一组互斥的单选框的容器，它的内部可以由若干个角色为radio的单选框。 Tree 是树形控件，它的内部含有 Treeitem 树形控件项，它还有一种升级形式是Treegrid。 structure角色结构角色其实跟HTML5中不少新标签作用重合了，这里建议优先使用HTML5标签。 这部分角色的作用类似于语义化标签，但是内容稍微有些不同，我们这里就不详细讲解了，仅仅给出一张图供你参考： 注：separator在允许焦点时属于组件，在不允许焦点时属于文档结构。 这里我们需要特别提出Landmark角色这个概念，Landmark角色直接翻译是地标，它是ARIA标准中总结的Web网页中最常见的8个结构，Landmark角色实际上是section的子类，这些角色在生成页面摘要时有很大可能性需要被保留，它们是： window角色在我们的网页中，有些元素表示“新窗口”，这时候，会用到window角色。window系角色非常少，只有三个角色： window dialog alertdialog dialog可能会产生“焦点陷阱”，也就是说，当这样的角色被激活时，焦点无法离开这个区域。 总结今天我介绍了ARIA相关的知识，我们分几个部分学习了如何使用ARIA属性来提高页面的可访问性。 我们以ARIA角色为中心，讲解了ARIA定义的语义体系。我们可以把ARIA分为三类。 Widget角色：主要是各种可交互的控件。 结构角色：文档的结构。 窗体角色：弹出的窗体。 今天的课后小问题是，请找一个支持图结构可视化的JS库，把所有ARIA的继承关系用可视化的方式展现出来。","link":"/2019/08/31/重学前端/HTML·ARIA：可访问性是只给盲人用的特性么？/"},{"title":"HTML元信息类标签：你知道head里一共能写哪几种标签吗？","text":"你好，我是winter。 我们在前面的HTML部分的课程中，已经学习了语义标签。这些标签涵盖了我们日常开发用到的多数标签，也是我们编写代码时最常用的一批标签。 但是我们今天要讲的标签，重要性丝毫不弱于语义类标签，这就是页面元信息类标签。 我们可以先来了解一下什么是元信息类标签。所谓元信息，是指描述自身的信息，元信息类标签，就是HTML用于描述文档自身的一类标签，它们通常出现在head标签中，一般都不会在页面被显示出来（与此相对，其它标签，如语义类标签，描述的是业务）。 元信息多数情况下是给浏览器、搜索引擎等机器阅读的，有时候这些信息会在页面之外显示给用户，有时候则不会。 元信息类标签数量不多，我在这里就逐一为你介绍一下。 head标签首先我们先来了解一下head标签，head标签本身并不携带任何信息，它主要是作为盛放其它语义类标签的容器使用。 head标签规定了自身必须是html标签中的第一个标签，它的内容必须包含一个title，并且最多只能包含一个base。如果文档作为iframe，或者有其他方式指定了文档标题时，可以允许不包含title标签。 title标签title标签表示文档的标题，从字面上就非常容易理解。这里我就讲讲需要注意的地方。 你还记得吗，我们的语义类标签中也有一组表示标题的标签：h1-h6。 heading 和 title 两个英文单词意义区分十分微妙，在中文中更是找不到对应的词汇来区分。但是实际使用中，两者确实有一定区别。 在HTML标准中，特意讨论了这个问题。我们思考一下，假设有一个介绍蜜蜂跳舞求偶仪式的科普页面，我们试着把以下两个文字分别对应到title和h1。 蜜蜂求偶仪式舞蹈 舞蹈 在听/看正确答案前，你不妨先想想，自己的答案是什么呢？为什么？ 好了，思考之后，我们来看看正确答案。正确答案是“蜜蜂求偶仪式舞蹈”放入title，“舞蹈”放入h1。 我来讲一讲为什么要这样放呢？这主要是考虑到title作为元信息，可能会被用在浏览器收藏夹、微信推送卡片、微博等各种场景，这时侯往往是上下文缺失的，所以title应该是完整地概括整个网页内容的。 而h1则仅仅用于页面展示，它可以默认具有上下文，并且有链接辅助，所以可以简写，即便无法概括全文，也不会有很大的影响。 base标签base标签实际上是个历史遗留标签。它的作用是给页面上所有的URL相对地址提供一个基础。 base标签最多只有一个，它改变全局的链接地址，它是一个非常危险的标签，容易造成跟JavaScript的配合问题，所以在实际开发中，我比较建议你使用JavaScript来代替base标签。 meta标签meta标签是一组键值对，它是一种通用的元信息表示标签。 在head中可以出现任意多个meta标签。一般的meta标签由name和content两个属性来定义。name表示元信息的名，content则用于表示元信息的值。 它基本用法是下面这样的，你也可以自己动手尝试一下： &lt;meta name=application-name content=&quot;lsForums&quot;&gt;这个标签表示页面所在的web-application，名为IsForums。 这里的name是一种比较自由的约定，HTTP标准规定了一些name作为大家使用的共识，也鼓励大家发明自己的name来使用。 除了基本用法，meta标签还有一些变体，主要用于简化书写方式或者声明自动化行为。下面我就挑几种重点的内容来分别讲解一下。 具有charset属性的meta从HTML5开始，为了简化写法，meta标签新增了charset属性。添加了charset属性的meta标签无需再有name和content。 &lt;meta charset=&quot;UTF-8&quot; &gt;charset型meta标签非常关键，它描述了HTML文档自身的编码形式。因此，我建议这个标签放在head的第一个。 &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; ……这样，浏览器读到这个标签之前，处理的所有字符都是ASCII字符，众所周知，ASCII字符是UTF-8和绝大多数字符编码的子集，所以，在读到meta之前，浏览器把文档理解多数编码格式都不会出错，这样可以最大限度地保证不出现乱码。 一般情况下，HTTP服务端会通过http头来指定正确的编码方式，但是有些特殊的情况如使用file协议打开一个HTML文件，则没有http头，这种时候，charset meta就非常重要了。 具有http-equiv属性的meta具有http-equiv属性的meta标签，表示执行一个命令，这样的meta标签可以不需要name属性了。 例如，下面一段代码，相当于添加了content-type这个http头，并且指定了http编码方式。 &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;除了content-type，还有以下几种命令： content-language 指定内容的语言； default-style 指定默认样式表； refresh 刷新； set-cookie 模拟http头set-cookie，设置cookie； x-ua-compatible 模拟http头x-ua-compatible，声明ua兼容性； content-security-policy 模拟http头content-security-policy，声明内容安全策略。 name为viewport的meta实际上，meta标签可以被自由定义，只要写入和读取的双方约定好name和content的格式就可以了。 我们来介绍一个meta类型，它没有在HTML标准中定义，却是移动端开发的事实标准：它就是name为viewport的meta。 这类meta的name属性为viewport，它的content是一个复杂结构，是用逗号分隔的键值对，键值对的格式是key=value。 例如： &lt;meta name=&quot;viewport&quot; content=&quot;width=500, initial-scale=1&quot;&gt;这里只指定了两个属性，宽度和缩放，实际上viewport能控制的更多，它能表示的全部属性如下： width：页面宽度，可以取值具体的数字，也可以是device-width，表示跟设备宽度相等。 height：页面高度，可以取值具体的数字，也可以是device-height，表示跟设备高度相等。 initial-scale：初始缩放比例。 minimum-scale：最小缩放比例。 maximum-scale：最大缩放比例。 user-scalable：是否允许用户缩放。 对于已经做好了移动端适配的网页，应该把用户缩放功能禁止掉，宽度设为设备宽度，一个标准的meta如下： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;&gt;其它预定义的meta在HTML标准中，还定义了一批meta标签的name，可以视为一种有约定的meta，我在这里列出来，你可以简单了解一下。 application-name：如果页面是Web application，用这个标签表示应用名称。 author: 页面作者。 description：页面描述，这个属性可能被用于搜索引擎或者其它场合。 generator: 生成页面所使用的工具，主要用于可视化编辑器，如果是手写HTML的网页，不需要加这个meta。 keywords: 页面关键字，对于SEO场景非常关键。 referrer: 跳转策略，是一种安全考量。 theme-color: 页面风格颜色，实际并不会影响页面，但是浏览器可能据此调整页面之外的UI（如窗口边框或者tab的颜色）。 结语在本课，我们又学习了一批标签，它们是文档用于描述自身的元信息类标签。一些元信息标签可以产生实际的行为，掌握它们对于我们编写代码是必须的。 另一些元信息仅仅是对页面的描述，掌握它们可以使我们编写的页面跟各种浏览器、搜索引擎等结合地更好。 主要包括下面这些内容。 head：元信息的容器。 title：文档标题。 base：页面的基准URL。 meta: 元信息通用标签。 我们还展开介绍了几种重要的meta标签，charset表示页面编码，http-equiv表示命令，还介绍了一些有约定的meta名称。 最后，给你留一个问题，你还见过哪些meta标签的用法？欢迎留言告诉我。","link":"/2019/08/31/重学前端/HTML元信息类标签：你知道head里一共能写哪几种标签吗？/"},{"title":"HTML替换型元素：为什么link一个CSS要用href，而引入js要用src呢？","text":"你好，我是winter。我们今天来讲讲替换型元素。 我们都知道一个常识，一个网页，它是由多个文件构成的，我们在之前的课程中，已经学过了一种引入文件的方案：链接。 这节课我们要讲的替换型元素，就是另一种引入文件的方式了。替换型元素是把文件的内容引入，替换掉自身位置的一类标签。 我们首先来看一种比较熟悉的标签：script标签。 script我们之所以选择先讲解script标签，是因为script标签是为数不多的既可以作为替换型标签，又可以不作为替换型标签的元素。 我们先来看看script标签的两种用法： &lt;script type=&quot;text/javascript&quot;&gt; console.log(&quot;Hello world!&quot;); &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;my.js&quot;&gt;&lt;/script&gt;这个例子中，我们展示了两种script标签的写法，一种是直接把脚本代码写在script标签之间，另一种是把代码放到独立的js文件中，用src属性引入。 这两种写法是等效的。我想这种等效性可以帮助你理解替换型元素的“替换”是怎么一回事。 这里我们就可以回答标题中的问题了：凡是替换型元素，都是使用src属性来引用文件的，而我们之前的课程中已经讲过，链接型元素是使用href标签的。 虽然我不知道当初是怎么设计的，但是style标签并非替换型元素，不能使用src属性，这样，我们用link标签引入CSS文件，当然就是用href标签啦。 接下来我们再看看别的替换型元素，先来了解一下img标签。 img毫无疑问我们最熟悉的替换型标签就是img标签了，几乎每个前端都会日常使用img标签。 img标签的作用是引入一张图片。这个标签是没有办法像script标签那样作为非替换型标签来使用的，它必须有src属性才有意义。 如果一定不想要引入独立文件，可以使用data uri，我们来看个实际的例子： &lt;img src=&apos;data:image/svg+xml;charset=utf8,&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;rect width=&quot;300&quot; height=&quot;100&quot; style=&quot;fill:rgb(0,0,255);stroke-width:1;stroke:rgb(0,0,0)&quot;/&gt;&lt;/svg&gt;&apos;/&gt;这个例子中我们使用了data uri作为图片的src，这样，并没有产生独立的文件，客观上做到了和内联相同的结果，这是一个常用的技巧。 img标签可以使用width和height指定宽度和高度。也可以只指定其中之一。我们看个例子： &lt;img src=&apos;data:image/svg+xml;charset=utf8,&lt;svg width=&quot;600&quot; height=&quot;400&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;ellipse cx=&quot;300&quot; cy=&quot;150&quot; rx=&quot;200&quot; ry=&quot;80&quot; style=&quot;fill:rgb(200,100,50); stroke:rgb(0,0,100);stroke-width:2&quot;/&gt;&lt;/svg&gt;&apos; width=&quot;100&quot;/&gt;这个例子中，为了方便你理解，我们把图片换成了椭圆，我们可以看到，当我们指定了宽度后，图片被等比例缩放了。这个特性非常重要，适用于那种我们既要限制图片尺寸，又要保持图片比例的场景。 如果从性能的角度考虑，建议你同时给出图片的宽高，因为替换型元素加载完文件后，如果尺寸发生变换，会触发重排版（这个概念我们在浏览器原理部分已经讲过，可以复习一下）。 此处要重点提到一个属性，alt属性，这个属性很难被普通用户感知，对于视障用户非常重要，可以毫不夸张地讲，给img加上alt属性，已经做完了可访问性的一半。 img标签还有一组重要的属性，那就是srcset和sizes，它们是src属性的升级版（所以我们前面讲img标签必须有src属性，这是不严谨的说法）。 这两个属性的作用是在不同的屏幕大小和特性下，使用不同的图片源。下面一个例子也来自MDN，它展示了srcset和sizes的用法 &lt;img srcset=&quot;elva-fairy-320w.jpg 320w, elva-fairy-480w.jpg 480w, elva-fairy-800w.jpg 800w&quot; sizes=&quot;(max-width: 320px) 280px, (max-width: 480px) 440px, 800px&quot; src=&quot;elva-fairy-800w.jpg&quot; alt=&quot;Elva dressed as a fairy&quot;&gt;srcset提供了根据屏幕条件选取图片的能力，但是其实更好的做法，是使用picture元素。 picturepicture元素可以根据屏幕的条件为其中的img元素提供不同的源，它的基本用法如下： &lt;picture&gt; &lt;source srcset=&quot;image-wide.png&quot; media=&quot;(min-width: 600px)&quot;&gt; &lt;img src=&quot;image-narrow.png&quot;&gt; &lt;/picture&gt;picture元素的设计跟audio和video保持了一致（稍后我会为你讲解这两个元素），它跟img搭配srcset和sizes不同，它使用source元素来指定图片源，并且支持多个。 这里的media属性是media query，跟CSS的@media规则一致。 video在HTML5早期的设计中，video标签跟img标签类似，也是使用src属性来引入源文件的，不过，我想应该是考虑到了各家浏览器支持的视频格式不同，现在的video标签跟picture元素一样，也是提倡使用source的。 下面例子是一个古典的video用法： &lt;video controls=&quot;controls&quot; src=&quot;movie.ogg&quot;&gt; &lt;/video&gt;这个例子中的代码用src来指定视频的源文件。但是因为一些历史原因，浏览器对视频的编码格式兼容问题分成了几个派系，这样，对于一些兼容性要求高的网站，我们使用单一的视频格式是不合适的。 现在的video标签可以使用source标签来指定接入多个视频源。 &lt;video controls=&quot;controls&quot; &gt; &lt;source src=&quot;movie.webm&quot; type=&quot;video/webm&quot; &gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot; &gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt; You browser does not support video. &lt;/video&gt;从这个例子中，我们可以看到，source标签除了支持media之外，还可以使用type来区分源文件的使用场景。 video标签的内容默认会被当做不支持video的浏览器显示的内容吗，因此，如果要支持更古老的浏览器，还可以在其中加入object或者embed标签，这里就不详细展开了。 video中还支持一种标签：track。 track是一种播放时序相关的标签，它最常见的用途就是字幕。track标签中，必须使用 srclang 来指定语言，此外，track具有kind属性，共有五种。 subtitles：就是字幕了，不一定是翻译，也可能是补充性说明。 captions：报幕内容，可能包含演职员表等元信息，适合听障人士或者没有打开声音的人了解音频内容。 descriptions：视频描述信息，适合视障人士或者没有视频播放功能的终端打开视频时了解视频内容。 chapters：用于浏览器视频内容。 metadata：给代码提供的元信息，对普通用户不可见。 一个完整的video标签可能会包含多种track和多个source，这些共同构成了一个视频播放所需的全部信息。 audio接下来我们来讲讲audio，跟picture和video两种标签一样，audio也可以使用source元素来指定源文件。我们看一下例子： &lt;audio controls&gt; &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mpeg&quot;&gt; &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot;&gt; &lt;p&gt;You browser does not support audio.&lt;/p&gt; &lt;/audio&gt;但比起video，audio元素的历史问题并不严重，所以使用src也是没有问题的。 iframe最后我们来讲一下iframe，这个标签能够嵌入一个完整的网页。 不过，在移动端，iframe受到了相当多的限制，它无法指定大小，里面的内容会被完全平铺到父级页面上。 同时很多网页也会通过http协议头禁止自己被放入iframe中。 iframe标签也是各种安全问题的重灾区。opener、window.name、甚至css的opacity都是黑客可以利用的漏洞。 因此，在2019年，当下这个时间点，任何情况下我都不推荐在实际开发中用以前的iframe。 当然，不推荐使用是一回事，因为没人能保证不遇到历史代码，我们还是应该了解一下iframe的基本用法： &lt;iframe src=&quot;http://time.geekbang.org&quot;&gt;&lt;/iframe&gt;这个例子展示了古典的iframe用法。 在新标准中，为iframe加入了sandbox模式和srcdoc属性，这样，给iframe带来了一定的新场景。我们来看看例子： &lt;iframe sandbox srcdoc=&quot;&lt;p&gt;Yeah, you can see it &lt;a href=&quot;/gallery?mode=cover&amp;amp;amp;page=1&quot;&gt;in my gallery&lt;/a&gt;.&quot;&gt;&lt;/iframe&gt;这个例子中，使用srcdoc属性创建了一个新的文档，嵌入在iframe中展示，并且使用了sandbox来隔离。 这样，这个iframe就不涉及任何跨域问题了。 总结这节课，我们又认识了一组HTML元素：替换型元素。它们的特点是，引入一个外部资源来进入页面，替换掉自身的位置。 我们通过对script、img、picture、audio、video、iframe几个标签的讲解，了解了不同的资源引入方式： src属性； srcset属性； source标签； srcdoc属性。 这中间，我们也介绍了一些小技巧，比如src属性的好朋友：data uri，这在实际开发中非常有用。 最后，留给你一个小问题，请查资料总结一下，在多数现代浏览器兼容的范围内，src属性支持哪些协议的uri（如http和我们提到的data）。","link":"/2019/08/31/重学前端/HTML替换型元素：为什么link一个CSS要用href，而引入js要用src呢？/"},{"title":"HTML语言：DTD到底是什么？","text":"你好，我是winter。今天，我们来聊一聊HTML语言。 我们平时写HTML语言，都习惯把关注点放到各种标签上，很少去深究它的语法。我想你应该会有模糊的感觉，HTML这样的语言，跟JavaScript这样的语言会有一些本质的不同。 实际上，JavaScript语言我们把它称为“编程语言”，它最大的特点是图灵完备的，我们大致可以理解为“包含了表达一切逻辑的能力”。像HTML这样的语言，我们称为“标记语言（mark up language）”，它是纯文本的一种升级，“标记”一词的概念来自：编辑审稿时使用不同颜色笔所做的“标记”。 在上世纪80年代，“富文本”的概念在计算机领域的热门，犹如如今的“AI”和“区块链”，而Tim Berners-Lee当时去设计HTML，也并非是凭空造出来，他使用了当时已有的一种语言：SGML。 SGML是一种古老的标记语言，可以追溯到1969年IBM公司所使用的技术，SGML十分复杂，严格来说，HTML是SGML中规定的一种格式，但是实际的浏览器没有任何一个是通过SGML引擎来解析HTML的。 今天的HTML仍然有SGML的不少影子，那么接下来我们就从SGML的一些特性来学习一下HTML。这里我最想讲的是SGML留给HTML的重要的遗产：基本语法和DTD。 基本语法首先，HTML作为SGML的子集，它遵循SGML的基本语法：包括标签、转义等。 SGML还规定了一些特殊的节点类型，在我们之前的DOM课程中已经讲过几种节点类型，它们都有与之对应的HTML语法，我们这里复习一下： 这里我们从语法的角度，再逐个具体了解一下。 标签语法标签语法产生元素，我们从语法的角度讲，就用“标签”这个术语，我们从运行时的角度讲，就用“元素”这个术语。 HTML中，用于描述一个元素的标签分为开始标签、结束标签和自闭合标签。开始标签和自闭合标签中，又可以有属性。 开始标签：&lt;tagname&gt; 带属性的开始标签： &lt;tagname attributename=&quot;attributevalue&quot;&gt; 结束标签：&lt;/tagname&gt; 自闭合标签：&lt;tagname /&gt; HTML中开始标签的标签名称只能使用英文字母。 这里需要重点讲一讲属性语法，属性可以使用单引号、双引号或者完全不用引号，这三种情况下，需要转义的部分都不太一样。 属性中可以使用文本实体（后文会介绍）来做转义，属性中，一定需要转义的有下面几种。 无引号属性：&lt;tab&gt;``&lt;LF&gt;``&lt;FF&gt;``&lt;SPACE&gt;``&amp;五种字符。 单引号属性：'``&amp;两种字符。 双引号属性：&quot;``&amp;两种字符。 一般来说，灵活运用属性的形式，是不太用到文本实体转义的。 文本语法在HTML中，规定了两种文本语法，一种是普通的文本节点，另一种是CDATA文本节点。 文本节点看似是普通的文本，但是，其中有两种字符是必须做转义的：&lt; 和 &amp;。 如果我们从某处拷贝了一段文本，里面包含了大量的 &lt; 和 &amp;，那么我们就有麻烦了，这时候，就轮到我们的CDATA节点出场了。 CDATA也是一种文本，它存在的意义是语法上的意义：在CDATA节点内，不需要考虑多数的转义情况。 CDATA内，只有字符组合]]&gt;需要处理，这里不能使用转义，只能拆成两个CDATA节点。 注释语法HTML注释语法以&lt;!--开头，以--&gt;结尾，注释的内容非常自由，除了--&gt;都没有问题。 如果注释的内容一定要出现 --&gt;，我们可以拆成多个注释节点。 DTD语法（文档类型定义）SGML的DTD语法十分复杂，但是对HTML来说，其实DTD的选项是有限的，浏览器在解析DTD时，把它当做几种字符串之一，关于DTD，我在本篇文章的后面会详细讲解。 ProcessingInstruction语法（处理信息）ProcessingInstruction多数情况下，是给机器看的。HTML中规定了可以有ProcessingInstruction，但是并没有规定它的具体内容，所以可以把它视为一种保留的扩展机制。对浏览器而言，ProcessingInstruction 的作用类似于注释。 ProcessingInstruction 包含两个部分，紧挨着第一个问号后，空格前的部分被称为“目标”，这个目标一般表示处理 ProcessingInstruction 的程序名。 剩余部分是它的文本信息，没有任何格式上的约定，完全由文档编写者和处理程序的编写者约定。 DTD现在我们来讲一下DTD，DTD的全称是Document Type Defination，也就是文档类型定义。SGML用DTD来定义每一种文档类型，HTML属于SGML，在HTML5出现之前，HTML都是使用符合SGML规定的DTD。 如果你是一个上个时代走过来的前端，一定还记得HTML4.01有三种DTD。分别是严格模式、过渡模式和frameset模式。 &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;严格模式的DTD规定了HTML4.01中需要的标签。 &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;过渡模式的DTD除了html4.01，还包含了一些被贬斥的标签，这些标签已经不再推荐使用了，但是过渡模式中仍保留了它们。 &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;frameset结构的网页如今已经很少见到了，它使用frameset标签把几个网页组合到一起。 众所周知，HTML中允许一些标签不闭合的用法，实际上这些都是符合SGML规定的，并且在DTD中规定好了的。但是，一些程序员喜欢严格遵守XML语法，保证标签闭合性，所以，HTML4.01又规定了XHTML语法，同样有三个版本： 版本一 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;版本二 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot; http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;版本三 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;其实你看看就知道，这些复杂的DTD写法并没有什么实际作用（浏览器根本不会用SGML引擎解析它们），因此，到了HTML5，干脆放弃了SGML子集这项坚持，规定了一个简单的，大家都能记住的DTD： &lt;!DOCTYPE html&gt;但是，HTML5仍然保留了HTML语法和XHTML语法。 文本实体不知道你注意到没有，HTML4.01的DTD里包含了一个长得很像是URL的东西，其实它是真的可以访问的——但是W3C警告说，禁止任何浏览器在解析网页的时候访问这个URL，不然W3C的服务器会被压垮。我相信很多好奇的前端工程师都把它下载下来打开过。 这是符合SGML规范的DTD，我们前面讲过，SGML的规范十分复杂，所以这里我并不打算讲SGML（其实我也不会），但是这不妨碍我们了解一下DTD的内容。这个DTD规定了HTML包含了哪些标签、属性和文本实体。其中文本实体分布在三个文件中：HTMLsymbol.ent HTMLspecial.ent和HTMLlat1.ent。 所谓文本实体定义就是类似以下的代码： &amp;lt; &amp;nbsp; &amp;gt; &amp;amp;每一个文本实体由&amp;开头，由;结束，这属于基本语法的规定，文本实体可以用#后跟一个十进制数字，表示字符Unicode值。除此之外这两个符号之间的内容，则由DTD决定。 我这里数了一下，HTML4.01的DTD中，共规定了255个文本实体，找出这些实体和它们对应的Unicode编码，就作为本次课程的课后小问题吧。 总结今天的课程中我们讲了HTML的语法，HTML语法源自SGML，我们首先介绍了基本语法，包含了五种节点：标签（元素）、文本、注释、文档类型定义（DTD）和处理信息（ProcessingInstruction）。 之后我们又重点介绍了两部分内容：DTD和文本实体。 DTD在HTML4.01和之前都非常的复杂，到了HTML5，抛弃了SGML兼容，变成简单的&lt;!DOCTYPE html&gt;。 文本实体是HTML转义的重要手段，我们讲解了基本用法，HTML4.01中规定的部分，就留给大家作为课后问题了。 今天的课后问题是：HTML4.01的DTD中，共规定了255个文本实体，请你找出这些实体和它们对应的Unicode编码吧。","link":"/2019/08/31/重学前端/HTML语言：DTD到底是什么？/"},{"title":"HTML链接：除了a标签，还有哪些标签叫链接？","text":"你好，我是winter。 在前面的课程中，我讲到了HTML的语义和元信息标签，今天这一课，我们来讲另一类HTML元素：链接。 链接这种元素可以说是占据了整个互联网。也正是因为无处不在的超链接，才让我们的万维网如此繁荣。没有了超链接的HTML，最多可以称为富文本，没法称作超文本（hyper text）。 我想，作为互联网从业者，我们一定对链接都非常熟悉了。链接能够帮助我们从一个网页跳转到另一个网页。 不过，除了肉眼可见的这些链接，其实HTML里面还规定了一些不可见链接的类型，这节课，我就来给你介绍链接家族的全员，让你对它们有一个完整的认识。 链接是HTML中的一种机制，它是HTML文档和其它文档或者资源的连接关系，在HTML中，链接有两种类型。一种是超链接型标签，一种是外部资源链接。 链接的家族中有a标签、area标签和link标签。今天，我会逐一对它们进行介绍。 link 标签提到链接，我们都知道a标签可以成为超链接，但是我们今天的内容，要从一个大家不太熟悉的标签开始，也就是link标签。 我们已经介绍过元信息类标签。实际上，我们并没有介绍完全，有些link标签也是元信息类标签的一种。 我们已经讲过，HTML标准并没有规定浏览器如何使用元信息，我们还讲到了元信息中有不少是被设计成“无需被浏览器识别，而是专门用于搜索引擎看的”。 link标签也是元信息的一种，在很多时候，它也是不会对浏览器产生任何效果的，这也是很多人会忽略link标签学习的原因。 link标签会生成一个链接，它可能生成超链接，也可能生成外部资源链接。 一些link标签会生成超链接，这些超链接又不会像a标签那样显示在网页中。这就是超链接型的link标签。 这意味着多数浏览器中，这些link标签不产生任何作用。但是，这些link标签能够被搜索引擎和一些浏览器插件识别，从而产生关键性作用。 比如，到页面RSS的link标签，能够被浏览器的RSS订阅插件识别，提示用户当前页面是可以RSS订阅的。 另外一些link标签则会把外部的资源链接到文档中，也就是说，会实际下载这些资源，并且做出一些处理，比如我们常见的用link标签引入样式表。 除了元信息的用法之外，多数外部资源型的link标签还能够被放在body中使用，从而起到把外部资源链接进文档的作用。 link标签的链接类型主要通过rel属性来区分，在本篇文章中，我们提到xx型link即表示属性rel为xx的link，其代码类似下面： &lt;link rel=&quot;xx&quot; ...&gt;下面我们先来看看超链接型link标签。 超链接类link标签超链接型link标签是一种被动型链接，在用户不操作的情况下，它们不会被主动下载。 link标签具有特定的rel属性，会成为特定类型的link标签。产生超链接的link标签包括：具有 rel=“canonical” 的link、具有 rel=”alternate”的link、具有rel=“prev” rel=”next”的link等等。 canonical型link这种link的代码写法是这样： &lt;link rel=&quot;canonical&quot; href=&quot;...&quot;&gt;这个标签提示页面它的主URL，在网站中常常有多个URL指向同一页面的情况，搜索引擎访问这类页面时会去掉重复的页面，这个link会提示搜索引擎保留哪一个URL。 alternate型link这种link的代码写法是这样： &lt;link rel=&quot;alternate&quot; href=&quot;...&quot;&gt;这个标签提示页面它的变形形式，这个所谓的变形可能是当前页面内容的不同格式、不同语言或者为不同的设备设计的版本，这种link通常也是提供给搜索引擎来使用的。 alternate型的link的一个典型应用场景是，页面提供rss订阅时，可以用这样的link来引入： &lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;...&quot;&gt;除了搜索引擎外，很多浏览器插件都能识别这样的link。 prev型link和next型link在互联网应用中，很多网页都属于一个序列，比如分页浏览的场景，或者图片展示的场景，每个网页是序列中的一个项。 这种时候，就适合使用prev和next型的link标签，来告诉搜索引擎或者浏览器它的前一项和后一项，这有助于页面的批量展示。 因为next型link告诉浏览器“这是很可能访问的下一个页面”，HTML标准还建议对next型link做预处理，在本课后面的内容，我们会讲到预处理类的link。 其它超链接类的link其它超链接类link标签都表示一个跟当前文档相关联的信息，可以把这样的link标签视为一种带链接功能的meta标签。 rel=“author” 链接到本页面的作者，一般是 mailto:协议 rel=“help” 链接到本页面的帮助页 rel=“license” 链接到本页面的版权信息页 rel=“search” 链接到本页面的搜索页面（一般是站内提供搜索时使用） 到这里，我们已经讲完了所有的超链接类的link标签用法了。接下来我们讲讲外部资源类link标签。 外部资源类link标签外部资源型link标签会被主动下载，并且根据rel类型做不同的处理。外部资源型的标签包括：具有icon型的link、预处理类link、modulepreload型的link、stylesheet、pingback。下面我们来一一介绍它们。 icon型link这类链接表示页面的icon。多数浏览器会读取icon型link，并且把页面的icon展示出来。 icon型link是唯一一个外部资源类的元信息link，其它元信息类link都是超链接，这意味着，icon型link中的图标地址默认会被浏览器下载和使用。 如果没有指定这样的link，多数浏览器会使用域名根目录下的favicon.ico，即使它并不存在，所以从性能的角度考虑，建议一定要保证页面中有icon型的link。 只有icon型link有有效的sizes属性，HTML标准允许一个页面出现多个icon型link，并且用sizes指定它适合的icon尺寸。 预处理类link我们都知道，导航到一个网站需要经过dns查询域名、建立连接、传输数据、加载进内存和渲染等一系列的步骤。 预处理类link标签就是允许我们控制浏览器，提前针对一些资源去做这些操作，以提高性能（当然如果你乱用的话，性能反而更差）。 下面我来列一下这些link类型： dns-prefetch型link 提前对一个域名做dns查询，这样的link里面的href实际上只有域名有意义。 preconnect型link 提前对一个服务器建立tcp连接。 prefetch型link 提前取href指定的url的内容。 preload型link 提前加载href指定的url。 prerender型link 提前渲染href指定的url。 modulepreload型的linkmodulepreload型link的作用是预先加载一个JavaScript的模块。这可以保证JS模块不必等到执行时才加载。 这里的所谓加载，是指完成下载并放入内存，并不会执行对应的JavaScript。 &lt;link rel=&quot;modulepreload&quot; href=&quot;app.js&quot;&gt; &lt;link rel=&quot;modulepreload&quot; href=&quot;helpers.js&quot;&gt; &lt;link rel=&quot;modulepreload&quot; href=&quot;irc.js&quot;&gt; &lt;link rel=&quot;modulepreload&quot; href=&quot;fog-machine.js&quot;&gt; &lt;script type=&quot;module&quot; src=&quot;app.js&quot;&gt;这个例子来自HTML标准，我们假设app.js中有 import “irc” 和 import “fog-machine”, 而 irc.js中有 import “helpers”。这段代码使用moduleload型link来预加载了四个js模块。 尽管，单独使用script标签引用app.js也可以正常工作，但是我们通过加入对四个JS文件的link标签，使得四个JS文件有机会被并行地下载，这样提高了性能。 stylesheet型link样式表大概是所有人最熟悉的link标签用法了。它的样子是下面这样的。 &lt;link rel=&quot;stylesheet&quot; href=&quot;xxx.css&quot; type=&quot;text/css&quot;&gt;基本用法是从一个CSS文件创建一个样式表。这里type属性可以没有，如果有，必须是”text/css”才会生效。 rel前可以加上alternate，成为rel=“alternate stylesheet”，此时必须再指定title属性。 这样可以为页面创建一份变体样式，一些浏览器，如 Firefox 3.0，支持从浏览器菜单中切换这些样式，当然了，大部分浏览器不支持这个功能，所以仅仅从语义的角度了解一下这种用法即可。 pingback型link这样的link表示本网页被引用时，应该使用的pingback地址，这个机制是一份独立的标准，遵守pingback协议的网站在引用本页面时，会向这个pingback url发送一个消息。 以上就是link标签的所有用法了。接下来我们来介绍一下最熟悉的 a 标签，当然了，也可能你学过了本节课以后，觉得自己其实也没那么熟悉。 a 标签a标签是“anchor”的缩写，它是锚点的意思，所谓锚点，实际上也是一种比喻的用法，古代船舶用锚来固定自己的位置，避免停泊时被海浪冲走，所以anchor标签的意思也是标识文档中的特定位置。 a标签其实同时充当了链接和目标点的角色，当a标签有href属性时，它是链接，当它有name时，它是链接的目标。 具有href的a标签跟一些link一样，会产生超链接，也就是在用户不操作的情况下，它们不会被主动下载的被动型链接。 重点的内容是，a标签也可以有rel属性，我们来简单了解一下，首先是跟link相同的一些rel，包括下面的几种。 alternate author help license next prev search 这些跟link语义完全一致，不同的是，a标签产生的链接是会实际显示在网页中的，而link标签仅仅是元信息。 除了这些之外，a标签独有的rel类型： tag 表示本网页所属的标签； bookmark 到上级章节的链接。 a标签还有一些辅助的rel类型，用于提示浏览器或者搜索引擎做一些处理： nofollow 此链接不会被搜索引擎索引； noopener 此链接打开的网页无法使用opener来获得当前页面的窗口； noreferrer 此链接打开的网页无法使用referrer来获得当前页面的url； opener 打开的网页可以使用window.opener来访问当前页面的window对象，这是a标签的默认行为。 a标签基本解决了在页面中插入文字型和整张图片超链接的需要，但是如果我们想要在图片的某个区域产生超链接，那么就要用到另一种标签了——area标签。 area 标签area标签与a标签非常相似，不同的是，它不是文本型的链接，而是区域型的链接。 area标签支持的rel与a完全一样，这里就不多说了。 area是整个html规则中唯一支持非矩形热区的标签，它的shape属性支持三种类型。 圆形：circle或者circ，coords支持三个值，分别表示中心点的x,y坐标和圆形半径r。 矩形：rect或者rectangle，coords支持两个值，分别表示两个对角顶点x1，y1和x2，y2。 多边形：poly或者polygon，coords至少包括6个值，表示多边形的各个顶点。 因为area设计的时间较早，所以不支持含有各种曲线的路径，但是它也是唯一一个支持了非矩形触发区域的元素，所以，对于一些效果而言，area是必不可少的。 area必须跟img和map标签配合使用。使用示例如下（例子来自html标准）。 &lt;p&gt; Please select a shape: &lt;img src=&quot;shapes.png&quot; usemap=&quot;#shapes&quot; alt=&quot;Four shapes are available: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star.&quot;&gt; &lt;map name=&quot;shapes&quot;&gt; &lt;area shape=rect coords=&quot;50,50,100,100&quot;&gt; &lt;!-- the hole in the red box --&gt; &lt;area shape=rect coords=&quot;25,25,125,125&quot; href=&quot;red.html&quot; alt=&quot;Red box.&quot;&gt; &lt;area shape=circle coords=&quot;200,75,50&quot; href=&quot;green.html&quot; alt=&quot;Green circle.&quot;&gt; &lt;area shape=poly coords=&quot;325,25,262,125,388,125&quot; href=&quot;blue.html&quot; alt=&quot;Blue triangle.&quot;&gt; &lt;area shape=poly coords=&quot;450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60&quot; href=&quot;yellow.html&quot; alt=&quot;Yellow star.&quot;&gt; &lt;/map&gt; &lt;/p&gt;这个例子展示了在一张图片上画热区并且产生链接，分别使用了矩形、圆形和多边形三种area。 结语本节课我们介绍了几种链接类型。在HTML中，链接有两种类型。一种是超链接型标签，一种是外部资源链接。 我们逐次讲到了link标签、a标签和area标签，link标签一般用于看不见的链接，它可能产生超链接或者外部资源链接，a和area一般用于页面上显示的链接，它们只能产生超链接。 最后，留给你一个思考问题，你的工作中，是使用过哪些类型的link标签的呢？ 猜你喜欢","link":"/2019/08/31/重学前端/HTML链接：除了a标签，还有哪些标签叫链接？/"},{"title":"JavaScript对象：你知道全部的对象分类吗？","text":"你好，我是winter。 在前面的课程中，我已经讲解了JavaScript对象的一些基础知识。但是，我们所讲解的对象，只是特定的一部分，并不能涵盖全部的JavaScript对象。 比如说，我们不论怎样编写代码，都没法绕开Array，实现一个跟原生的数组行为一模一样的对象，这是由于原生数组的底层实现了一个自动随着下标变化的length属性。 并且，在浏览器环境中，我们也无法单纯依靠JavaScript代码实现div对象，只能靠document.createElement来创建。这也说明了JavaScript的对象机制并非简单的属性集合+原型。 我们日常工作中，接触到的主要API，几乎都是由今天所讲解的这些对象提供的。理解这些对象的性质，我们才能真正理解我们使用的API的一些特性。 JavaScript中的对象分类我们可以把对象分成几类。 宿主对象（host Objects）：由JavaScript宿主环境提供的对象，它们的行为完全由宿主环境决定。 内置对象（Built-in Objects）：由JavaScript语言提供的对象。 固有对象（Intrinsic Objects ）：由标准规定，随着JavaScript运行时创建而自动创建的对象实例。 原生对象（Native Objects）：可以由用户通过Array、RegExp等内置构造器或者特殊语法创建的对象。 普通对象（Ordinary Objects）：由{}语法、Object构造器或者class关键字定义类创建的对象，它能够被原型继承。 下面我会为你一一讲解普通对象之外的对象类型。 宿主对象首先我们来看看宿主对象。 JavaScript宿主对象千奇百怪，但是前端最熟悉的无疑是浏览器环境中的宿主了。 在浏览器环境中，我们都知道全局对象是window，window上又有很多属性，如document。 实际上，这个全局对象window上的属性，一部分来自JavaScript语言，一部分来自浏览器环境。 JavaScript标准中规定了全局对象属性，W3C的各种标准中规定了Window对象的其它属性。 宿主对象也分为固有的和用户可创建的两种，比如document.createElement就可以创建一些DOM对象。 宿主也会提供一些构造器，比如我们可以使用new Image来创建img元素，这些我们会在浏览器的API部分详细讲解。 内置对象·固有对象我们在前面说过，固有对象是由标准规定，随着JavaScript运行时创建而自动创建的对象实例。 固有对象在任何JavaScript代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。我们前面提到的“类”其实就是固有对象的一种。 ECMA标准为我们提供了一份固有对象表，里面含有150+个固有对象。你可以通过这个链接查看。 但是遗憾的是，这个表格并不完整。所以在本篇的末尾，我设计了一个小实验（小实验：获取全部JavaScript固有对象），你可以自己尝试一下，数一数一共有多少个固有对象。 内置对象·原生对象我们把JavaScript中，能够通过语言本身的构造器创建的对象称作原生对象。在JavaScript标准中，提供了30多个构造器。按照我的理解，按照不同应用场景，我把原生对象分成了以下几个种类。 通过这些构造器，我们可以用new运算创建新的对象，所以我们把这些对象称作原生对象。 几乎所有这些构造器的能力都是无法用纯JavaScript代码实现的，它们也无法用class/extend语法来继承。 这些构造器创建的对象多数使用了私有字段,例如： Error: [[ErrorData]] Boolean: [[BooleanData]] Number: [[NumberData]] Date: [[DateValue]] RegExp: [[RegExpMatcher]] Symbol: [[SymbolData]] Map: [[MapData]] 这些字段使得原型继承方法无法正常工作，所以，我们可以认为，所有这些原生对象都是为了特定能力或者性能，而设计出来的“特权对象”。 用对象来模拟函数与构造器：函数对象与构造器对象我在前面介绍了对象的一般分类，在JavaScript中，还有一个看待对象的不同视角，这就是用对象来模拟函数和构造器。 事实上，JavaScript为这一类对象预留了私有字段机制，并规定了抽象的函数对象与构造器对象的概念。 函数对象的定义是：具有[[call]]私有字段的对象，构造器对象的定义是：具有私有字段[[construct]]的对象。 JavaScript用对象模拟函数的设计代替了一般编程语言中的函数，它们可以像其它语言的函数一样被调用、传参。任何宿主只要提供了“具有[[call]]私有字段的对象”，就可以被 JavaScript 函数调用语法支持。 [[call]]私有字段必须是一个引擎中定义的函数，需要接受this值和调用参数，并且会产生域的切换，这些内容，我将会在属性访问和执行过程两个章节详细讲述。 我们可以这样说，任何对象只需要实现[[call]]，它就是一个函数对象，可以去作为函数被调用。而如果它能实现[[construct]]，它就是一个构造器对象，可以作为构造器被调用。 对于为JavaScript提供运行环境的程序员来说，只要字段符合，我们在上文中提到的宿主对象和内置对象（如Symbol函数）可以模拟函数和构造器。 当然了，用户用function关键字创建的函数必定同时是函数和构造器。不过，它们表现出来的行为效果却并不相同。 对于宿主和内置对象来说，它们实现[[call]]（作为函数被调用）和[[construct]]（作为构造器被调用）不总是一致的。比如内置对象 Date 在作为构造器调用时产生新的对象，作为函数时，则产生字符串，见以下代码： console.log(new Date); // 1 console.log(Date())而浏览器宿主环境中，提供的Image构造器，则根本不允许被作为函数调用。 console.log(new Image); console.log(Image());//抛出错误再比如基本类型（String、Number、Boolean），它们的构造器被当作函数调用，则产生类型转换的效果。 值得一提的是，在ES6之后 =&gt; 语法创建的函数仅仅是函数，它们无法被当作构造器使用，见以下代码： new (a =&gt; 0) // error对于用户使用 function 语法或者Function构造器创建的对象来说，[[call]]和[[construct]]行为总是相似的，它们执行同一段代码。 我们看一下示例。 function f(){ return 1; } var v = f(); //把f作为函数调用 var o = new f(); //把f作为构造器调用我们大致可以认为，它们[[construct]]的执行过程如下： 以 Object.protoype 为原型创建一个新对象； 以新对象为 this，执行函数的[[call]]； 如果[[call]]的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。 这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么new创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现“私有”。 function cls(){ this.a = 100; return { getValue:() =&gt; this.a } } var o = new cls; o.getValue(); //100 //a在外面永远无法访问到特殊行为的对象除了上面介绍的对象之外，在固有对象和原生对象中，有一些对象的行为跟正常对象有很大区别。 它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同，这里我简单总结一下。 Array：Array的length属性根据最大的下标自动发生变化。 Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。 String：为了支持下标运算，String的正整数属性访问会去字符串里查找。 Arguments：arguments的非负整数型下标属性跟对应的变量联动。 模块的namespace对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于import吧。 类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。 bind后的function：跟原来的函数相关联。 结语在这篇文章中，我们介绍了一些不那么常规的对象，并且我还介绍了JavaScript中用对象来模拟函数和构造器的机制。 这是一些不那么有规律、不那么优雅的知识，而JavaScript正是通过这些对象，提供了很多基础的能力。 我们这次课程留一个挑战任务：不使用new运算符，尽可能找到获得对象的方法。 例子： var o = {} var o = function(){}请把自己的答案留言给我，我们来比比看谁找到的多。 小实验：获取全部JavaScript固有对象我们从JavaScript标准中可以找到全部的JavaScript对象定义。JavaScript语言规定了全局对象的属性。 三个值： Infinity、NaN、undefined。 九个函数： eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent 一些构造器： Array、Date、RegExp、Promise、Proxy、Map、WeakMap、Set、WeakSet、Function、Boolean、String、Number、Symbol、Object、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError、ArrayBuffer、SharedArrayBuffer、DataView、Typed Array、Float32Array、Float64Array、Int8Array、Int16Array、Int32Array、UInt8Array、UInt16Array、UInt32Array、UInt8ClampedArray。 四个用于当作命名空间的对象： Atomics JSON Math Reflect 我们使用广度优先搜索，查找这些对象所有的属性和Getter/Setter，就可以获得JavaScript中所有的固有对象。 请你试着先不看我的代码，在自己的浏览器中计算出来JavaScript有多少固有对象。 var set = new Set(); var objects = [ eval, isFinite, isNaN, parseFloat, parseInt, decodeURI, decodeURIComponent, encodeURI, encodeURIComponent, Array, Date, RegExp, Promise, Proxy, Map, WeakMap, Set, WeakSet, Function, Boolean, String, Number, Symbol, Object, Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, ArrayBuffer, SharedArrayBuffer, DataView, Float32Array, Float64Array, Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Atomics, JSON, Math, Reflect]; objects.forEach(o =&gt; set.add(o)); for(var i = 0; i &lt; objects.length; i++) { var o = objects[i] for(var p of Object.getOwnPropertyNames(o)) { var d = Object.getOwnPropertyDescriptor(o, p) if( (d.value !== null &amp;&amp; typeof d.value === &quot;object&quot;) || (typeof d.value === &quot;function&quot;)) if(!set.has(d.value)) set.add(d.value), objects.push(d.value); if( d.get ) if(!set.has(d.get)) set.add(d.get), objects.push(d.get); if( d.set ) if(!set.has(d.set)) set.add(d.set), objects.push(d.set); } }","link":"/2019/08/31/重学前端/JavaScript对象：你知道全部的对象分类吗？/"},{"title":"HTML语义：div和span不是够用了吗？","text":"你好，我是winter。 今天这篇是我们正式开篇的第一篇文章，我想和你聊聊HTML。 我猜屏幕那一边的你估计会说：“HTML我很熟悉了，每天写，这不是初级程序员才学的内容么，这我还能不会吗？” 其实在我看来，HTML并不简单，它是典型的“入门容易，精通困难”的一部分知识。深刻理解HTML是成为优秀的前端工程师重要的一步。 我们在上一篇文章中讲到了，HTML的标签可以分为很多种，比如head里面的元信息类标签，又比如img、video、audio之类的替换型媒体标签。我今天要讲的标签是：语义类标签。 语义类标签是什么，使用它有什么好处？语义类标签也是大家工作中经常会用到的一类标签，它们的特点是视觉表现上互相都差不多，主要的区别在于它们表示了不同的语义，比如大家会经常见到的section、nav、p，这些都是语义类的标签。 语义是我们说话表达的意思，多数的语义实际上都是由文字来承载的。语义类标签则是纯文字的补充，比如标题、自然段、章节、列表，这些内容都是纯文字无法表达的，我们需要依靠语义标签代为表达。 在讲语义之前，我们来说说为什么要用语义。 现在我们很多的前端工程师写起代码来，多数都不用复杂的语义标签， 只靠div 和 span 就能走天下了。 这样做行不行呢？毫无疑问答案是行。那这样做好不好呢？按照正确的套路，我应该说不好，但是在很多情况下，答案其实是好。 这是因为在现代互联网产品里，HTML用于描述“软件界面”多过于“富文本”，而软件界面里的东西，实际上几乎是没有语义的。比如说，我们做了一个购物车功能，我们一定要给每个购物车里的商品套上ul吗？比如说，加入购物车这个按钮，我们一定要用Button吗？ 实际上我觉得没必要，因为这个场景里面，跟文本中的列表，以及表单中的Button，其实已经相差很远了，所以，我支持在任何“软件界面”的场景中，直接使用div和span。 不过，在很多工作场景里，语义类标签也有它们自己无可替代的优点。正确地使用语义标签可以带来很多好处。 语义类标签对开发者更为友好，使用语义类标签增强了可读性，即便是在没有CSS的时候，开发者也能够清晰地看出网页的结构，也更为便于团队的开发和维护。 除了对人类友好之外，语义类标签也十分适宜机器阅读。它的文字表现力丰富，更适合搜索引擎检索（SEO），也可以让搜索引擎爬虫更好地获取到更多有效信息，有效提升网页的搜索量，并且语义类还可以支持读屏软件，根据文章可以自动生成目录等等。 不过，不恰当地使用语义标签，反而会造成负面作用。这里我们举一个常见的误区作为例子。我们都知道ul是无序列表，ol是有序列表，所以很多接触过语义这个概念，半懂不懂的前端工程师，特别喜欢给所有并列关系的元素都套上ul。 实际上， ul 是长成下面的这种样子的(以下来自HTML标准)。 I have lived in the following countries: Switzerland Norway United Kingdom United States ul多数出现正在行文中间，它的上文多数在提示：要列举某些项。但是，如果所有并列关系都用ul，会造成大量冗余标签。 错误地使用语义标签，会给机器阅读造成混淆、增加嵌套，给CSS编写加重负担。 所以，对于语义标签，我的态度是：“用对”比“不用”好，“不用”比“用错”好。当然了，我觉得有理想的前端工程师还是应该去追求“用对”它们。 与JavaScript这样严格的编程语言相比，HTML中语义标签的使用更接近我们平常说话用的自然语言。我们说话并没有唯一的标准措辞，语义标签的使用也是一样。下面，我挑选了几种（我认为）比较重要的语义标签使用场景，来为你介绍一下。 作为自然语言延伸的语义类标签其实语义问题不仅仅属于理科，它还是个文科问题。 所以我们这里讲语义标签的使用的第一个场景，也是最自然的使用场景，就是：作为自然语言和纯文本的补充，用来表达一定的结构或者消除歧义。 我们先来看看“表达一定的结构”这个场景。 在日语中，有一个语法现象叫做：ルビ，它的读音是ruby（著名的ruby语言就是据此命名的），它中文的意思大约类似于注音或者意思的注解，它的形式可以看下图： 图中的例子选自动画片《某科学的超电磁炮》第二季第一话。图中把teleport放在空间移动上方的用法，就是日文中ruby的用法。“空间移动”是动画中白井黑子的技能，这里动画字幕上写的是“空间移动”，动画里的台词则用了英文发音“Teleport”，这里就形成了一个使用ruby的场景。 ruby的这个形式，在中国的网友中间最近被玩出了新花样，比如表情包。 有时候微信聊天，不能用ruby这样的东西真的是好急啊，只好用括号代替，效果真是差了不少。 在HTML5中，就引入了这个表示ruby的标签，它由ruby、rt、rp三个标签来实现。 所以说，这些情况里存在的语义，其实原本就存在了，只是我们用纯文字是没法表达的，HTML作为一种“超文本”语言，支持这些文字表达就是必要的了。 还有一种情况是，HTML的有些标签实际上就是必要的，甚至必要的程度可以达到：如果没有这个标签，文字会产生歧义的程度。 这里我们可以介绍一下em标签。 今天我吃了一个苹果.我们看看这句话，看上去它很清楚，但是实际上，这句话放到不同上下文中，可能表达完全不同的意思。 昨天我吃了一个香蕉。 今天我吃了一个苹果。再比如： 昨天我吃了两个苹果。 今天我吃了一个苹果。试着读一读，这两段里面的“今天我吃了一个苹果”，你是不是发现读音不自觉地发生了变化？ 实际上，不仅仅是读音，这里的意思也发生了变化。前一段中，表示我今天吃的是苹果，而不是别的什么东西，后一段中，则表示我今天只吃了一个苹果，没有多吃。 当没有上下文时，如何消除歧义呢？这就要用到我们的em标签了。em表示重音： 今天我吃了一个&lt;em&gt;苹果&lt;/em&gt;。 今天我吃了&lt;em&gt;一个&lt;/em&gt;苹果。通过em标签，我们可以消除这样的歧义。 一些文章常常会拿em和strong做对比，实际上，我们只要理解了em的真正意思，它和strong可谓天差地别，并没有任何混淆的可能。 作为标题摘要的语义类标签介绍完自然语言的语义场景后，我想介绍的另一个语义重要使用场景，就是文章的结构。中国古代小说就形成了“章-回”的概念，西方的戏剧也有幕的区分，所以人类的自然语言作品也是如出一辙。 HTML也应该支持这样的需求。HTML语义标签中，有不少是用于支持这样的结构的标签。 语义化的HTML能够支持自动生成目录结构，HTML标准中还专门规定了生成目录结构的算法，即使我们并不打算深入实践语义，也应该尽量在大的层面上保证这些元素的语义化使用。 首先我们需要形成一个概念，一篇文档会有一个树形的目录结构，它由各个级别的标题组成。这个树形结构可能不会跟HTML元素的嵌套关系一致。 例如： &lt;h1&gt;HTML语义&lt;/h1&gt; &lt;p&gt;balah balah balah balah&lt;/p&gt; &lt;h2&gt;弱语义&lt;/h2&gt; &lt;p&gt;balah balah&lt;/p&gt; &lt;h2&gt;结构性元素&lt;/h2&gt; &lt;p&gt;balah balah&lt;/p&gt; ......这段HTML几乎是平铺的元素，但是它的标题结构是： HTML语义 弱语义 结构性元素 …… h1-h6是最基本的标题，它们表示了文章中不同层级的标题。有些时候，我们会有副标题，为了避免副标题产生额外的一个层级，我们使用hgroup标签。 我们来看下有/无hgroup的对比： &lt;h1&gt;JavaScript对象&lt;/h1&gt; &lt;h2&gt;我们需要模拟类吗？&lt;/h2&gt; &lt;p&gt;balah balah&lt;/p&gt; ......此段生成以下标题结构： JavaScript对象 我们需要模拟类吗？ … JavaScript对象 我们需要模拟类吗？ balah balah ...... 这一段生成以下标题结构： JavaScript对象——我们需要模拟类吗？ … 我们通过两个效果的对比就可以知道，在hgroup中的h1-h6被视为同一标题的不同组成部分。 从HTML 5开始，我们有了section标签，这个标签可不仅仅是一个“有语义的div”，它会改变h1-h6的语义。section的嵌套会使得其中的h1-h6下降一级，因此，在HTML5以后，我们只需要section和h1就足以形成文档的树形结构： &lt;section&gt; &lt;h1&gt;HTML语义&lt;/h1&gt; &lt;p&gt;balah balah balah balah&lt;/p&gt; &lt;section&gt; &lt;h1&gt;弱语义&lt;/h1&gt; &lt;p&gt;balah balah&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h1&gt;结构性元素&lt;/h1&gt; &lt;p&gt;balah balah&lt;/p&gt; &lt;/section&gt; ...... &lt;/section&gt;这段代码同样会形成前面例子的标题结构： HTML语义 弱语义 结构性元素 …… 作为整体结构的语义类标签我们想介绍的最后一个场景是，随着越来越多的浏览器推出“阅读模式”，以及各种非浏览器终端的出现，语义化的HTML适合机器阅读的特性变得越来越重要。 应用了语义化结构的页面，可以明确地提示出页面信息的主次关系，它能让浏览器很好地支持“阅读视图功能”，还可以让搜索引擎的命中率提升，同时，它也对视障用户的读屏软件更友好。 我们正确使用整体结构类的语义标签，可以让页面对机器更友好。比如，这里一个典型的body类似这样： &lt;body&gt; &lt;header&gt; &lt;nav&gt; …… &lt;/nav&gt; &lt;/header&gt; &lt;aside&gt; &lt;nav&gt; …… &lt;/nav&gt; &lt;/aside&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;footer&gt; &lt;address&gt;……&lt;/address&gt; &lt;/footer&gt; &lt;/body&gt;在body下面，有一个header，header里面是一个nav，跟header同级的有一个aside，aside里面也有一个nav。接下来是文章的整体，也就是一个一个的section。section里面可能还有嵌套，但是我们就不管了，最后是一个footer，这个footer里面可能有address这样的内容。 除此之外，还有article，article是一种特别的结构，它表示具有一定独立性质的文章。所以，article和body具有相似的结构，同时，一个HTML页面中，可能有多个article存在。 一个典型的场景是多篇新闻展示在同一个新闻专题页面中，这种类似报纸的多文章结构适合用article来组织。 &lt;body&gt; &lt;header&gt;……&lt;/header&gt; &lt;article&gt; &lt;header&gt;……&lt;/header&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;footer&gt;……&lt;/footer&gt; &lt;/article&gt; &lt;article&gt; …… &lt;/article&gt; &lt;article&gt; …… &lt;/article&gt; &lt;footer&gt; &lt;address&gt;&lt;/address&gt; &lt;/footer&gt; &lt;/body&gt;body里面有自己的header和footer，然后里面是竖篇的article，每一个article里面都有自己的header、section、footer。这是一个典型的多文章结构。 在这个结构里，我们看到了一些新标签，我也来逐个介绍一下。 header，如其名，通常出现在前部，表示导航或者介绍性的内容。 footer，通常出现在尾部，包含一些作者信息、相关链接、版权信息等。 header和footer一般都是放在article或者body的直接子元素，但是标准中并没有明确规定，footer也可以和aside，nav，section相关联（header不存在关联问题）。 aside表示跟文章主体不那么相关的部分，它可能包含导航、广告等工具性质的内容。 aside很容易被理解为侧边栏，实际上二者是包含关系，侧边栏是aside，aside不一定是侧边栏。 aside和header中都可能出现导航（nav标签），二者的区别是，header中的导航多数是到文章自己的目录，而aside中的导航多数是到关联页面或者是整站地图。 最后footer中包含address，这是个非常容易被误用的标签。address并非像date一样，表示一个给机器阅读的地址，而是表示“文章（作者）的联系方式”，address明确地只关联到article和body。 总结本篇中我们介绍了一些基本原则和HTML文档的整体结构，从整体上了解了HTML语义。 至此，我们可以回答是否要语义化的问题：我们应该分开一些场景来看语义，把它用在合适的场景下，可以获得额外的效果。本篇文中，我们至少涉及了三个明确的场景： 自然语言表达能力的补充； 文章标题摘要； 适合机器阅读的整体结构。 下一篇中，我们会继续深入到更细致的结构中，进一步了解语义。你在工作中是否在使用语义化的标签开发？学习过本篇之后，答案有没有变化呢？你可以给我留言，我们一起讨论。 猜你喜欢","link":"/2019/08/31/重学前端/HTML语义：div和span不是够用了吗？/"},{"title":"HTML语义：如何运用语义类标签来呈现Wiki网页？","text":"你好，我是winter，今天我们继续来聊聊HTML模块的语义类标签。 在上一篇文章中，我花了大量的篇幅和你解释了正确使用语义类标签的好处和一些场景。那么，哪些场景适合用到语义类标签呢，又如何运用语义类标签呢？ 不知道你还记不记得在大学时代，你被导师逼着改毕业论文格式的情景，如果你回想一下，你在论文中使用的那些格式，你会发现其实它们都是可以用HTML里的语义标签来表示的。 这正是因为HTML最初的设计场景就是“超文本”，早期HTML工作组的专家都是出版界书籍排版的专家。 所以，在这一部分，我们找了个跟论文很像的案例：Wikipedia文章，这种跟论文相似的网站比较适合用来学习语义类标签。通过分析一篇Wiki的文章用到的语义类标签，来进一步帮你理解语义的概念。 你可以在电脑上，打开这个页面： https://en.wikipedia.org/wiki/World_Wide_Web 为了防止这个页面被修改，我们保存了一个副本： http://static001.geekbang.org/static/time/quote/World_Wide_Web-Wikipedia.html 这是一篇我们选择的Wiki文章，虽然在原本的Wikipedia网站中，也是大量使用了div和span来完成功能。在这里，我们来尝试分析一下，应该如何用语义类标签来呈现这样的一个页面/文章。 我们看一下这个页面。 aside 首先我们来看下，左侧侧边栏，根据上一篇文章中提到的语义定义，这里属于aside内容。是导航性质的工具内容。 article 我们来到文章主体部分，因为主体部分具有明确的独立性，所以可以用article来包裹。 hgroup, h1, h2 在语义的上一篇文章中，我们介绍过hgroup和h1-h6的作用，hgroup是标题组，h1是一级标题，h2是二级标题。这里，World Wide Web 是文章的大标题，适合h1元素。 接下来出现了一个副标题。From Wikipedia, the free encyclopedia。这个地方适合使用h2，跟h1组成一个hgroup，所以代码可能是类似这样的: &lt;hgroup&gt; &lt;h1&gt;World Wide Web &lt;/h1&gt; &lt;h2&gt;From Wikipedia, the free encyclopedia&lt;/h2&gt; &lt;/hgroup&gt;abbr abbr标签表示缩写。考虑到WWW是World Wide Web的缩写，所以文中所有出现的WWW，都应该使用abbr标签。 &lt;abbr title=&quot;World Wide Web&quot;&gt;WWW&lt;/abbr&gt;.hr 细心的同学会发现，在Wiki的界面中，出现了一条很长的横线，大家都知道hr标签表示横向分隔线，那么这个地方是不是应该用hr呢？ 答案是不用。我们读一下标准的定义就知道了，hr表示故事走向的转变或者话题的转变，显然此处两个标题并非这种关系，所以我们应该使用CSS的border来把它当作纯视觉效果来实现，所以这里是不需要用hr的。 p 接下来一段，我们看到了三段“note”，也就是注记。它在文章中用作额外注释。 “WWW” and “The Web” redirect here. For other uses of WWW, see WWW (disambiguation). For other uses of web, see Web (disambiguation). For the first web software, see WorldWideWeb. Not to be confused with the Internet. HTML中并没有note相关的语义，所以，我们用普通的p标签，加上class=&quot;note&quot;来实现。后面的多数自然段都是普通的段落，我们用p标签来实现。 strong 注意，这里 “World Wide Web (WWW)” 和 “the Web” 使用了黑体呈现，从上下文来看，这里表示这个词很重要，所以我们使用strong标签。 &lt;p&gt; A global map of the web index for countries in 2014 &lt;strong&gt;The World Wide Web (WWW)&lt;/strong&gt;, also called &lt;strong&gt;the Web&lt;/strong&gt;, ......blockquote, q, cite 接下来我们看到了一个论文中很常见的用法“引述”。 interlinked by hypertext links, and accessible via the Internet.[1] 注意看这里的[1]，当我们把鼠标放上去的时候，出现了引述的相关信息： “What is the difference between the Web and the Internet?”. W3C Help and FAQ. W3C. 2009. Archived from the original on 9 July 2015. Retrieved 16 July 2015. 在HTML中，有三个跟引述相关的标签blockquote表示段落级引述内容，q表示行内的引述内容，cite表示引述的作品名。 这里的作品名称 “What is the difference between the Web and the Internet?”，应当使用cite标签。 &lt;cite&gt;&quot;What is the difference between the Web and the Internet?&quot;&lt;/cite&gt;. W3C Help and FAQ. W3C. 2009. Archived from the original on 9 July 2015. Retrieved 16 July 2015.在文章的结尾处，有对应的 References 一节，这一节中所有的作品名称也应该加入cite标签。 这里我们看看引用的原文就可以知道，Wiki文章中的信息并非直接引用，如果是直接引用的内容，那么，我们还应该加上blockquote或者q标签。 time 这里除了引用的文章外，还出现了日期，为了让机器阅读更加方便，可以加上time标签： &lt;cite&gt;&quot;What is the difference between the Web and the Internet?&quot;&lt;/cite&gt;. W3C Help and FAQ. W3C. 2009. Archived from the original on &lt;time datetime=&quot;2015-07-09&quot;&gt;9 July 2015&lt;/time&gt;. Retrieved &lt;time datetime=&quot;2015-07-16&quot;&gt;16 July 2015&lt;/time&gt;.figure, figcaption 我们注意一下文章的右侧，出现了几张图片，这种出现在文中的图片，不仅仅是一个img标签，它和下面的文字组成了一个figure的语法现象，figure也是我们的一种标签（用于表示与主文章相关的图像、照片等流内容）。 &lt;figure&gt; &lt;img src=&quot;https://.....440px-NeXTcube_first_webserver.JPG&quot;/&gt; &lt;figcaption&gt;The NeXT Computer used by Tim Berners-Lee at CERN.&lt;/figcaption&gt; &lt;/figure&gt;这种插入文章中的内容，不仅限图片，代码、表格等，只要是具有一定自包含性（类似独立句子）的内容，都可以用figure。这里面，我们用figcaption表示内容的标题，当然，也可以没有标题。 dfn 然后我们继续往下看，来注意这一句： The terms Internet and World Wide Web are often used without much distinction. However, the two are not the same. The Internet is a global system of interconnected computer networks. In contrast, the World Wide Web is a global collection of documents and other resources, linked by hyperlinks and URIs. 这里分别定义了Internet和World Wide Web，我们应该使用dfn标签。 The terms Internet and World Wide Web are often used without much distinction. However, the two are not the same. The &lt;dfn&gt;Internet&lt;/dfn&gt; is a global system of interconnected computer networks. In contrast, the &lt;dfn&gt;World Wide Web&lt;/dfn&gt; is a global collection of documents and other resources, linked by hyperlinks and URIs. 代码中你可以看见，你需要在你要定义的词前后放上dfn标签，所以我们知道了，dfn标签是用来包裹被定义的名词。 nav, ol, ul 接下来，几个普通的段落之后，我们看到了文章的目录。这里的目录链接到文章的各个章节，我们可以使用nav标签。因为这里的目录顺序不可随意变化，所以我们这里使用多级的ol结构。 &lt;nav&gt; &lt;h2&gt;Contents&lt;/h2&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=&quot;...&quot;&gt;History&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;...&quot;&gt;Function&lt;/a&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=&quot;...&quot;&gt;Linking&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;...&quot;&gt;Dynamic updates of web pages&lt;/a&gt;&lt;/li&gt; ... &lt;/ol&gt; &lt;/li&gt; ... &lt;/ol&gt; &lt;/nav&gt;我们这里必须要指出，ol和ul的区分是内容是否有顺序关系，每一项的前面不论是数字还是点，都不会影响语义的判断。所以，你可以注意一下这里，不要因为视觉表现效果，而改变语义的使用。 pre, samp, code 继续往下，我们来到了这里，我们看见这篇文章有一个很重要的特色，文章中嵌入了一些代码和一些预先编写好的段落。我们看到在“Function”小节中有一段背景色是灰色的文字。 GET /home.html HTTP/1.1 Host: www.example.org这是一段HTTP协议的内容描述，因为这段内容的换行是非常严格的，所以我们不需要浏览器帮我们做自动换行，因此我们使用了pre标签，表示这部分内容是预先排版过的，不需要浏览器进行排版。 又因为这是一段计算机程序的示例输出，所以我们可以使用samp标签： &lt;pre&gt;&lt;samp&gt; GET /home.html HTTP/1.1 Host: www.example.org &lt;/samp&gt;&lt;/pre&gt;接下来Wiki中的内容出现了一段HTML代码，我们同样不希望浏览器做自动换行。 &lt;html&gt; &lt;head&gt; &lt;title&gt;Example.org – The World Wide Web&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;The World Wide Web, abbreviated as WWW and commonly known ...&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;因为同时是代码，我们还需要加上code标签。最后的代码是pre标签包裹了code标签，code标签包裹了HTML代码。 &lt;pre&gt;&lt;code&gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Example.org – The World Wide Web&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;The World Wide Web, abbreviated as WWW and commonly known ...&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; &lt;/code&gt;&lt;/pre&gt;在后面的代码中，还有一些在行内的code，比如 title和 p括起来的内容，这些也都应该使用code标签。 总结在这一篇Wiki文章中，已经涉及了大部分语义标签，可见HTML工作组对语义标签的增加是非常谨慎和保守的。 当然了，我们选择的案例不可能刚巧覆盖所有的标签，还有些没讲到的标签，我们这里稍微做一下简要的补充说明。 （长按点击大图查看） 实际上，HTML这种语言，并不像严谨的编程语言一样，有一条非此即彼的线。一些语义的使用其实会带来争议，所以我的建议是：你可以尽量只用自己熟悉的语义标签，并且只在有把握的场景引入语义标签。这样，我们才能保证语义标签不被滥用，造成更多的问题。 你最擅长使用哪些语义标签，会把它们用在哪些场景里呢？欢迎留言告诉我，我们一起讨论。 猜你喜欢","link":"/2019/08/31/重学前端/HTML语义：如何运用语义类标签来呈现Wiki网页？/"},{"title":"JavaScript对象：面向对象还是基于对象？","text":"你好，我是winter。 与其它的语言相比，JavaScript中的“对象”总是显得不那么合群。 一些新人在学习JavaScript面向对象时，往往也会有疑惑： 为什么JavaScript（直到ES6）有对象的概念，但是却没有像其他的语言那样，有类的概念呢； 为什么在JavaScript对象里可以自由添加属性，而其他的语言却不能呢？ 甚至，在一些争论中，有人强调：JavaScript并非“面向对象的语言”，而是“基于对象的语言”。这个说法一度流传甚广，而事实上，我至今遇到的持有这一说法的人中，无一能够回答“如何定义面向对象和基于对象”这个问题。 实际上，基于对象和面向对象两个形容词都出现在了JavaScript标准的各个版本当中。 我们可以先看看JavaScript标准对基于对象的定义，这个定义的具体内容是：“语言和宿主的基础设施由对象来提供，并且JavaScript程序即是一系列互相通讯的对象集合”。 这里的意思根本不是表达弱化的面向对象的意思，反而是表达对象对于语言的重要性。 那么，在本篇文章中，我会尝试让你去理解面向对象和JavaScript中的面向对象究竟是什么。 什么是面向对象？我们先来说说什么是对象，因为翻译的原因，中文语境下我们很难理解“对象”的真正含义。事实上，Object（对象）在英文中，是一切事物的总称，这和面向对象编程的抽象思维有互通之处。 中文的“对象”却没有这样的普适性，我们在学习编程的过程中，更多是把它当作一个专业名词来理解。 但不论如何，我们应该认识到，对象并不是计算机领域凭空造出来的概念，它是顺着人类思维模式产生的一种抽象（于是面向对象编程也被认为是：更接近人类思维模式的一种编程范式）。 那么，我们先来看看在人类思维模式下，对象究竟是什么。 对象这一概念在人类的幼儿期形成，这远远早于我们编程逻辑中常用的值、过程等概念。 在幼年期，我们总是先认识到某一个苹果能吃（这里的某一个苹果就是一个对象），继而认识到所有的苹果都可以吃（这里的所有苹果，就是一个类），再到后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字“3”（值）的概念。 在《面向对象分析与设计》这本书中，Grady Booch替我们做了总结，他认为，从人类的认知角度来说，对象应该是下列事物之一： 一个可以触摸或者可以看见的东西； 人的智力可以理解的东西； 可以指导思考或行动（进行想象或施加动作）的东西。 有了对象的自然定义后，我们就可以描述编程语言中的对象了。在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象，最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java等流行的编程语言。 而 JavaScript 早年却选择了一个更为冷门的方式：原型（关于原型，我在下一篇文章会重点介绍，这里你留个印象就可以了）。这是我在前面说它不合群的原因之一。 然而很不幸，因为一些公司政治原因，JavaScript推出之时受管理层之命被要求模仿Java，所以，JavaScript创始人Brendan Eich在“原型运行时”的基础上引入了new、this等语言特性，使之“看起来更像Java”。 在 ES6 出现之前，大量的 JavaScript 程序员试图在原型体系的基础上，把JavaScript变得更像是基于类的编程，进而产生了很多所谓的“框架”，比如PrototypeJS、Dojo。 事实上，它们成为了某种JavaScript的古怪方言，甚至产生了一系列互不相容的社群，显然这样做的收益是远远小于损失的。 如果我们从运行时角度来谈论对象，就是在讨论JavaScript实际运行中的模型，这是由于任何代码执行都必定绕不开运行时的对象模型。 不过，幸运的是，从运行时的角度看，可以不必受到这些“基于类的设施”的困扰，这是因为任何语言运行时类的概念都是被弱化的。 首先我们来了解一下JavaScript是如何设计对象模型的。 JavaScript 对象的特征在我看来，不论我们使用什么样的编程语言，我们都先应该去理解对象的本质特征（参考Grandy Booch《面向对象分析与设计》）。总结来看，对象有如下几个特点。 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。 对象有状态：对象具有状态，同一对象可能处于不同状态之下。 对象具有行为：即对象的状态，可能因为它的行为产生变迁。 我们先来看第一个特征，对象具有唯一标识性。一般而言，各种语言的对象唯一标识性都是用内存地址来体现的， 对象具有唯一标识的内存地址，所以具有唯一的标识。 所以，JavaScript程序员都知道，任何不同的JavaScript对象其实是互不相等的，我们可以看下面的代码，o1和o2初看是两个一模一样的对象，但是打印出来的结果却是false。 var o1 = { a: 1 }; var o2 = { a: 1 }; console.log(o1 == o2); // false关于对象的第二个和第三个特征“状态和行为”，不同语言会使用不同的术语来抽象描述它们，比如C++中称它们为“成员变量”和“成员函数”，Java中则称它们为“属性”和“方法”。 在 JavaScript中，将状态和行为统一抽象为“属性”，考虑到 JavaScript 中将函数设计成一种特殊对象（关于这点，我会在后面的文章中详细讲解，此处先不用细究），所以 JavaScript中的行为和状态都能用属性来抽象。 下面这段代码其实就展示了普通属性和函数作为属性的一个例子，其中o是对象，d是一个属性，而函数f也是一个属性，尽管写法不太相同，但是对JavaScript来说，d和f就是两个普通属性。 var o = { d: 1, f() { console.log(this.d); } };所以，总结一句话来看，在JavaScript中，对象的状态和行为其实都被抽象为了属性。如果你用过Java，一定不要觉得奇怪，尽管设计思路有一定差别，但是二者都很好地表现了对象的基本特征：标识性、状态和行为。 在实现了对象基本特征的基础上, 我认为，JavaScript中对象独有的特色是：对象具有高度的动态性，这是因为JavaScript赋予了使用者在运行时为对象添改状态和行为的能力。 我来举个例子，比如，JavaScript 允许运行时向对象添加属性，这就跟绝大多数基于类的、静态的对象设计完全不同。如果你用过Java或者其它别的语言，肯定会产生跟我一样的感受。 下面这段代码就展示了运行时如何向一个对象添加属性，一开始我定义了一个对象o，定义完成之后，再添加它的属性b，这样操作是完全没问题的。 var o = { a: 1 }; o.b = 2; console.log(o.a, o.b); //1 2为了提高抽象能力，JavaScript的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter/setter）两类。 JavaScript对象的两类属性对JavaScript来说，属性并非只是简单的名称和值，JavaScript用一组特征（attribute）来描述属性（property）。 先来说第一类属性，数据属性。它比较接近于其它语言的属性概念。数据属性具有四个特征。 value：就是属性的值。 writable：决定属性能否被赋值。 enumerable：决定for in能否枚举该属性。 configurable：决定该属性能否被删除或者改变特征值。 在大多数情况下，我们只关心数据属性的值即可。 第二类属性是访问器（getter/setter）属性，它也有四个特征。 getter：函数或undefined，在取属性值时被调用。 setter：函数或undefined，在设置属性值时被调用。 enumerable：决定for in能否枚举该属性。 configurable：决定该属性能否被删除或者改变特征值。 访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。 我们通常用于定义属性的代码会产生数据属性，其中的writable、enumerable、configurable都默认为true。我们可以使用内置函数 Object.getOwnPropertyDescripter来查看，如以下代码所示： var o = { a: 1 }; o.b = 2; //a和b皆为数据属性 Object.getOwnPropertyDescriptor(o,&quot;a&quot;) // {value: 1, writable: true, enumerable: true, configurable: true} Object.getOwnPropertyDescriptor(o,&quot;b&quot;) // {value: 2, writable: true, enumerable: true, configurable: true}我们在这里使用了两种语法来定义属性，定义完属性后，我们用JavaScript的API来查看这个属性，我们可以发现，这样定义出来的属性都是数据属性，writeable、enumerable、configurable都是默认值为true。 如果我们要想改变属性的特征，或者定义访问器属性，我们可以使用 Object.defineProperty，示例如下： var o = { a: 1 }; Object.defineProperty(o, &quot;b&quot;, {value: 2, writable: false, enumerable: false, configurable: true}); //a和b都是数据属性，但特征值变化了 Object.getOwnPropertyDescriptor(o,&quot;a&quot;); // {value: 1, writable: true, enumerable: true, configurable: true} Object.getOwnPropertyDescriptor(o,&quot;b&quot;); // {value: 2, writable: false, enumerable: false, configurable: true} o.b = 3; console.log(o.b); // 2这里我们使用了Object.defineProperty来定义属性，这样定义属性可以改变属性的writable和enumerable。 我们同样用Object.getOwnPropertyDescriptor来查看，发现确实改变了writable和enumerable特征。因为writable特征为false，所以我们重新对b赋值，b的值不会发生变化。 在创建对象时，也可以使用 get 和 set 关键字来创建访问器属性，代码如下所示： var o = { get a() { return 1 } }; console.log(o.a); // 1访问器属性跟数据属性不同，每次访问属性都会执行getter或者setter函数。这里我们的getter函数返回了1，所以o.a每次都得到1。 这样，我们就理解了，实际上JavaScript 对象的运行时是一个“属性的集合”，属性以字符串或者Symbol为key，以数据属性特征值或者访问器属性特征值为value。 对象是一个属性的索引结构（索引结构是一类常见的数据结构，我们可以把它理解为一个能够以比较快的速度用key来查找value的字典）。我们以上面的对象o为例，你可以想象一下“a”是key。 {writable:true,value:1,configurable:true,enumerable:true}是value。我们在前面的类型课程中，已经介绍了Symbol类型，能够以Symbol为属性名，这是JavaScript对象的一个特色。 讲到了这里，如果你理解了对象的特征，也就不难理解我开篇提出来的问题。 你甚至可以理解为什么会有“JavaScript不是面向对象”这样的说法了。这是由于JavaScript的对象设计跟目前主流基于类的面向对象差异非常大。 可事实上，这样的对象系统设计虽然特别，但是JavaScript提供了完全运行时的对象系统，这使得它可以模仿多数面向对象编程范式（下一节课我们会给你介绍JavaScript中两种面向对象编程的范式：基于类和基于原型），所以它也是正统的面向对象语言。 JavaScript语言标准也已经明确说明，JavaScript是一门面向对象的语言，我想标准中能这样说，正是因为JavaScript的高度动态性的对象系统。 所以，我们应该在理解其设计思想的基础上充分挖掘它的能力，而不是机械地模仿其它语言。 结语要想理解JavaScript对象，必须清空我们脑子里“基于类的面向对象”相关的知识，回到人类对对象的朴素认知和面向对象的语言无关基础理论，我们就能够理解JavaScript面向对象设计的思路。 在这篇文章中，我从对象的基本理论出发，和你理清了关于对象的一些基本概念，分析了JavaScript对象的设计思路。接下来又从运行时的角度，介绍了JavaScript对象的具体设计：具有高度动态性的属性集合。 很多人在思考JavaScript对象时，会带着已有的“对象”观来看问题，最后的结果当然就是“剪不断理还乱”了。 在后面的文章中，我会继续带你探索JavaScript对象的一些机制，看JavaScript如何基于这样的动态对象模型设计自己的原型系统，以及你熟悉的函数、类等基础设施。 你还知道哪些面向对象语言，它们的面向对象系统是怎样的？请留言告诉我吧！ 猜你喜欢","link":"/2019/08/31/重学前端/JavaScript对象：面向对象还是基于对象？/"},{"title":"JavaScript对象：我们真的需要模拟类吗？","text":"早期的JavaScript程序员一般都有过使用JavaScript“模拟面向对象”的经历。 在上一篇文章我们已经讲到，JavaScript本身就是面向对象的，它并不需要模拟，只是它实现面向对象的方式和主流的流派不太一样，所以才让很多人产生了误会。 那么，随着我们理解的思路继续深入，这些“模拟面向对象”，实际上做的事情就是“模拟基于类的面向对象”。 尽管我认为，“类”并非面向对象的全部，但我们不应该责备社区出现这样的方案，事实上，因为一些公司的政治原因，JavaScript推出之时，管理层就要求它去模仿Java。 所以，JavaScript创始人Brendan Eich在“原型运行时”的基础上引入了new、this等语言特性，使之“看起来语法更像Java”，而Java正是基于类的面向对象的代表语言之一。 但是JavaScript这样的半吊子模拟，缺少了继承等关键特性，导致大家试图对它进行修补，进而产生了种种互不相容的解决方案。 庆幸的是，从ES6开始，JavaScript提供了class关键字来定义类，尽管，这样的方案仍然是基于原型运行时系统的模拟，但是它修正了之前的一些常见的“坑”，统一了社区的方案，这对语言的发展有着非常大的好处。 实际上，我认为“基于类”并非面向对象的唯一形态，如果我们把视线从“类”移开，Brendan当年选择的原型系统，就是一个非常优秀的抽象对象的形式。 我们从头讲起。 什么是原型？原型是顺应人类自然思维的产物。中文中有个成语叫做“照猫画虎”，这里的猫看起来就是虎的原型，所以，由此我们可以看出，用原型来描述对象的方法可以说是古已有之。 我们在上一节讲解面向对象的时候提到了：在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象。 最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java等流行的编程语言。这个流派叫做基于类的编程语言。 还有一种就是基于原型的编程语言，它们利用原型来描述对象。我们的JavaScript就是其中代表。 “基于类”的编程提倡使用一个关注分类和类之间关系开发模型。在这类语言中，总是先有类，再从类去实例化一个对象。类与类之间又可能会形成继承、组合等关系。类又往往与语言的类型系统整合，形成一定编译时的能力。 与此相对，“基于原型”的编程看起来更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。 基于原型的面向对象系统通过“复制”的方式来创建新对象。一些语言的实现中，还允许复制一个空对象。这实际上就是创建一个全新的对象。 基于原型和基于类都能够满足基本的复用和抽象需求，但是适用的场景不太相同。 这就像专业人士可能喜欢在看到老虎的时候，喜欢用猫科豹属豹亚种来描述它，但是对一些不那么正式的场合，“大猫”可能更为接近直观的感受一些（插播一个冷知识：比起老虎来，美洲狮在历史上相当长时间都被划分为猫科猫属，所以性格也跟猫更相似，比较亲人）。 我们的JavaScript 并非第一个使用原型的语言，在它之前，self、kevo等语言已经开始使用原型来描述对象了。 事实上，Brendan更是曾透露过，他最初的构想是一个拥有基于原型的面向对象能力的scheme语言（但是函数式的部分是另外的故事，这篇文章里，我暂时不做详细讲述）。 在JavaScript之前，原型系统就更多与高动态性语言配合，并且多数基于原型的语言提倡运行时的原型修改，我想，这应该是Brendan选择原型系统很重要的理由。 原型系统的“复制操作”有两种实现思路： 一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用； 另一个是切实地复制对象，从此两个对象再无关联。 历史上的基于原型语言因此产生了两个流派，显然，JavaScript显然选择了前一种方式。 JavaScript的原型如果我们抛开JavaScript用于模拟Java类的复杂语法设施（如new、Function Object、函数的prototype属性等），原型系统可以说相当简单，我可以用两条概括： 如果所有对象都有私有字段[[prototype]]，就是对象的原型； 读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。 这个模型在ES的各个历史版本中并没有很大改变，但从 ES6 以来，JavaScript提供了一系列内置函数，以便更为直接地访问操纵原型。三个方法分别为： Object.create 根据指定的原型创建新对象，原型可以是null； Object.getPrototypeOf 获得一个对象的原型； Object.setPrototypeOf 设置一个对象的原型。 利用这三个方法，我们可以完全抛开类的思维，利用原型来实现抽象和复用。我用下面的代码展示了用原型来抽象猫和虎的例子。 var cat = { say(){ console.log(&quot;meow~&quot;); }, jump(){ console.log(&quot;jump&quot;); } } var tiger = Object.create(cat, { say:{ writable:true, configurable:true, enumerable:true, value:function(){ console.log(&quot;roar!&quot;); } } }) var anotherCat = Object.create(cat); anotherCat.say(); var anotherTiger = Object.create(tiger); anotherTiger.say();这段代码创建了一个“猫”对象，又根据猫做了一些修改创建了虎，之后我们完全可以用Object.create来创建另外的猫和虎对象，我们可以通过“原始猫对象”和“原始虎对象”来控制所有猫和虎的行为。 但是，在更早的版本中，程序员只能通过Java风格的类接口来操纵原型运行时，可以说非常别扭。 考虑到new和prototype属性等基础设施今天仍然有效，而且被很多代码使用，学习这些知识也有助于我们理解运行时的原型工作原理，下面我们试着回到过去，追溯一下早年的JavaScript中的原型和类。 早期版本中的类与原型在早期版本的JavaScript中，“类”的定义是一个私有属性 [[class]]，语言标准为内置类型诸如Number、String、Date等指定了[[class]]属性，以表示它们的类。语言使用者唯一可以访问[[class]]属性的方式是Object.prototype.toString。 以下代码展示了所有具有内置class属性的对象： var o = new Object; var n = new Number; var s = new String; var b = new Boolean; var d = new Date; var arg = function(){ return arguments }(); var r = new RegExp; var f = new Function; var arr = new Array; var e = new Error; console.log([o, n, s, b, d, arg, r, f, arr, e].map(v =&gt; Object.prototype.toString.call(v))); 因此，在ES3和之前的版本，JS中类的概念是相当弱的，它仅仅是运行时的一个字符串属性。 在ES5开始，[[class]] 私有属性被 Symbol.toStringTag 代替，Object.prototype.toString 的意义从命名上不再跟 class 相关。我们甚至可以自定义 Object.prototype.toString 的行为，以下代码展示了使用Symbol.toStringTag来自定义 Object.prototype.toString 的行为： var o = { [Symbol.toStringTag]: &quot;MyObject&quot; } console.log(o + &quot;&quot;);这里创建了一个新对象，并且给它唯一的一个属性 Symbol.toStringTag，我们用字符串加法触发了Object.prototype.toString的调用，发现这个属性最终对Object.prototype.toString 的结果产生了影响。 但是，考虑到JavaScript语法中跟Java相似的部分，我们对类的讨论不能用“new运算是针对构造器对象，而不是类”来试图回避。 所以，我们仍然要把new理解成JavaScript面向对象的一部分，下面我就来讲一下new操作具体做了哪些事情。 new 运算接受一个构造器和一组调用参数，实际上做了几件事： 以构造器的 prototype 属性（注意与私有字段[[prototype]]的区分）为原型，创建新对象； 将 this 和调用参数传给构造器，执行； 如果构造器返回的是对象，则返回，否则返回第一步创建的对象。 new 这样的行为，试图让函数对象在语法上跟类变得相似，但是，它客观上提供了两种方式，一是在构造器中添加属性，二是在构造器的 prototype 属性上添加属性。 下面代码展示了用构造器模拟类的两种方法: function c1(){ this.p1 = 1; this.p2 = function(){ console.log(this.p1); } } var o1 = new c1; o1.p2(); function c2(){ } c2.prototype.p1 = 1; c2.prototype.p2 = function(){ console.log(this.p1); } var o2 = new c2; o2.p2();第一种方法是直接在构造器中修改this，给this添加属性。 第二种方法是修改构造器的prototype属性指向的对象，它是从这个构造器构造出来的所有对象的原型。 没有Object.create、Object.setPrototypeOf 的早期版本中，new 运算是唯一一个可以指定[[prototype]]的方法（当时的mozilla提供了私有属性proto，但是多数环境并不支持），所以，当时已经有人试图用它来代替后来的 Object.create，我们甚至可以用它来实现一个Object.create的不完整的polyfill，见以下代码： Object.create = function(prototype){ var cls = function(){} cls.prototype = prototype; return new cls; }这段代码创建了一个空函数作为类，并把传入的原型挂在了它的prototype，最后创建了一个它的实例，根据new的行为，这将产生一个以传入的第一个参数为原型的对象。 这个函数无法做到与原生的Object.create一致，一个是不支持第二个参数，另一个是不支持null作为原型，所以放到今天意义已经不大了。 ES6 中的类好在ES6中加入了新特性class，new跟function搭配的怪异行为终于可以退休了（虽然运行时没有改变），在任何场景，我都推荐使用ES6的语法来定义类，而令function回归原本的函数语义。下面我们就来看一下ES6中的类。 ES6中引入了class关键字，并且在标准中删除了所有[[class]]相关的私有属性描述，类的概念正式从属性升级成语言的基础设施，从此，基于类的编程方式成为了JavaScript的官方编程范式。 我们先看下类的基本写法： class Rectangle { constructor(height, width) { this.height = height; this.width = width; } // Getter get area() { return this.calcArea(); } // Method calcArea() { return this.height * this.width; } }在现有的类语法中，getter/setter和method是兼容性最好的。 我们通过get/set关键字来创建getter，通过括号和大括号来创建方法，数据型成员最好写在构造器里面。 类的写法实际上也是由原型运行时来承载的，逻辑上JavaScript认为每个类是有共同原型的一组对象，类中定义的方法和属性则会被写在原型对象之上。 此外，最重要的是，类提供了继承能力。我们来看一下下面的代码。 class Animal { constructor(name) { this.name = name; } speak() { console.log(this.name + &apos; makes a noise.&apos;); } } class Dog extends Animal { constructor(name) { super(name); // call the super class constructor and pass in the name parameter } speak() { console.log(this.name + &apos; barks.&apos;); } } let d = new Dog(&apos;Mitzie&apos;); d.speak(); // Mitzie barks.以上代码创造了Animal类，并且通过extends关键字让Dog继承了它，展示了最终调用子类的speak方法获取了父类的name。 比起早期的原型模拟方式，使用extends关键字自动设置了constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。 所以当我们使用类的思想来设计代码时，应该尽量使用class来声明类，而不是用旧语法，拿函数来模拟对象。 一些激进的观点认为，class关键字和箭头运算符可以完全替代旧的function关键字，它更明确地区分了定义函数和定义类两种意图，我认为这是有一定道理的。 总结在新的ES版本中，我们不再需要模拟类了：我们有了光明正大的新语法。而原型体系同时作为一种编程范式和运行时机制存在。 我们可以自由选择原型或者类作为代码的抽象风格，但是无论我们选择哪种，理解运行时的原型系统都是很有必要的一件事。 在你的工作中，是使用class还是仍然在用function来定义“类”？为什么这么做？如何把使用function定义类的代码改造到class的新语法？ 欢迎给我留言，我们一起讨论。","link":"/2019/08/31/重学前端/JavaScript对象：我们真的需要模拟类吗？/"},{"title":"JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？","text":"你好，我是winter。这一部分我们来讲一讲JavaScript的执行。 首先我们考虑一下，如果我们是浏览器或者Node的开发者，我们该如何使用JavaScript引擎。 当拿到一段JavaScript代码时，浏览器或者Node环境首先要做的就是；传递给JavaScript引擎，并且要求它去执行。 然而，执行JavaScript并非一锤子买卖，宿主环境当遇到一些事件时，会继续把一段代码传递给JavaScript引擎去执行，此外，我们可能还会提供API给JavaScript引擎，比如setTimeout这样的API，它会允许JavaScript在特定的时机执行。 所以，我们首先应该形成一个感性的认知：一个JavaScript引擎会常驻于内存中，它等待着我们（宿主）把JavaScript代码或者函数传递给它执行。 在ES3和更早的版本中，JavaScript本身还没有异步执行代码的能力，这也就意味着，宿主环境传递给JavaScript引擎一段代码，引擎就把代码直接顺次执行了，这个任务也就是宿主发起的任务。 但是，在ES5之后，JavaScript引入了Promise，这样，不需要浏览器的安排，JavaScript引擎本身也可以发起任务了。 由于我们这里主要讲JavaScript语言，那么采纳JSC引擎的术语，我们把宿主发起的任务称为宏观任务，把JavaScript引擎发起的任务称为微观任务。 宏观和微观任务JavaScript引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在Node术语中，也会把这个部分称为事件循环。 不过，术语本身并非我们需要重点讨论的内容，我们在这里把重点放在事件循环的原理上。在底层的C/C++代码中，这个事件循环是一个跑在独立线程中的循环，我们用伪代码来表示，大概是这样的： while(TRUE) { r = wait(); execute(r); }我们可以看到，整个循环做的事情基本上就是反复“等待-执行”。当然，实际的代码中并没有这么简单，还有要判断循环是否结束、宏观任务队列等逻辑，这里为了方便你理解，我就把这些都省略掉了。 这里每次的执行过程，其实都是一个宏观任务。我们可以大概理解：宏观任务的队列就相当于事件循环。 在宏观任务中，JavaScript的Promise还会产生异步代码，JavaScript必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列： 有了宏观任务和微观任务机制，我们就可以实现JavaScript引擎级和宿主级的任务了，例如：Promise永远在队列尾部添加微观任务。setTimeout等宿主API，则会添加宏观任务。 接下来，我们来详细介绍一下Promise。 PromisePromise是JavaScript语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过Promise的then方法的回调）。 Promise的基本用法示例如下： function sleep(duration) { return new Promise(function(resolve, reject) { setTimeout(resolve,duration); }) } sleep(1000).then( ()=&gt; console.log(&quot;finished&quot;));这段代码定义了一个函数sleep，它的作用是等候传入参数指定的时长。 Promise的then回调是一个异步的执行过程，下面我们就来研究一下Promise函数中的执行顺序，我们来看一段代码示例： var r = new Promise(function(resolve, reject){ console.log(&quot;a&quot;); resolve() }); r.then(() =&gt; console.log(&quot;c&quot;)); console.log(&quot;b&quot;)我们执行这段代码后，注意输出的顺序是 a b c。在进入console.log(“b”) 之前，毫无疑问 r 已经得到了resolve，但是Promise的resolve始终是异步操作，所以c无法出现在b之前。 接下来我们试试跟setTimeout混用的Promise。 在这段代码中，我设置了两段互不相干的异步操作：通过setTimeout执行console.log(“d”)，通过Promise执行console.log(“c”)。 var r = new Promise(function(resolve, reject){ console.log(&quot;a&quot;); resolve() }); setTimeout(()=&gt;console.log(&quot;d&quot;), 0) r.then(() =&gt; console.log(&quot;c&quot;)); console.log(&quot;b&quot;)我们发现，不论代码顺序如何，d必定发生在c之后，因为Promise产生的是JavaScript引擎内部的微任务，而setTimeout是浏览器API，它产生宏任务。 为了理解微任务始终先于宏任务，我们设计一个实验：执行一个耗时1秒的Promise。 setTimeout(()=&gt;console.log(&quot;d&quot;), 0) var r = new Promise(function(resolve, reject){ resolve() }); r.then(() =&gt; { var begin = Date.now(); while(Date.now() - begin &lt; 1000); console.log(&quot;c1&quot;) new Promise(function(resolve, reject){ resolve() }).then(() =&gt; console.log(&quot;c2&quot;)) });这里我们强制了1秒的执行耗时，这样，我们可以确保任务c2是在d之后被添加到任务队列。 我们可以看到，即使耗时一秒的c1执行完毕，再enque的c2，仍然先于d执行了，这很好地解释了微任务优先的原理。 通过一系列的实验，我们可以总结一下如何分析异步执行的顺序： 首先我们分析有多少个宏任务； 在每个宏任务中，分析有多少个微任务； 根据调用次序，确定宏任务中的微任务执行次序； 根据宏任务的触发规则和调用次序，确定宏任务的执行次序； 确定整个顺序。 我们再来看一个稍微复杂的例子： function sleep(duration) { return new Promise(function(resolve, reject) { console.log(&quot;b&quot;); setTimeout(resolve,duration); }) } console.log(&quot;a&quot;); sleep(5000).then(()=&gt;console.log(&quot;c&quot;));这是一段非常常用的封装方法，利用Promise把setTimeout封装成可以用于异步的函数。 我们首先来看，setTimeout把整个代码分割成了2个宏观任务，这里不论是5秒还是0秒，都是一样的。 第一个宏观任务中，包含了先后同步执行的 console.log(“a”); 和 console.log(“b”);。 setTimeout后，第二个宏观任务执行调用了resolve，然后then中的代码异步得到执行，所以调用了console.log(“c”)，最终输出的顺序才是： a b c。 Promise是JavaScript中的一个定义，但是实际编写代码时，我们可以发现，它似乎并不比回调的方式书写更简单，但是从ES6开始，我们有了async/await，这个语法改进跟Promise配合，能够有效地改善代码结构。 新特性：async/awaitasync/await是ES2016新加入的特性，它提供了用for、if等代码结构来编写异步的方式。它的运行时基础是Promise，面对这种比较新的特性，我们先来看一下基本用法。 async函数必定返回Promise，我们把所有返回Promise的函数都可以认为是异步函数。 async函数是一种特殊语法，特征是在function关键字之前加上async关键字，这样，就定义了一个async函数，我们可以在其中使用await来等待一个Promise。 function sleep(duration) { return new Promise(function(resolve, reject) { setTimeout(resolve,duration); }) } async function foo(){ console.log(&quot;a&quot;) await sleep(2000) console.log(&quot;b&quot;) }这段代码利用了我们之前定义的sleep函数。在异步函数foo中，我们调用sleep。 async函数强大之处在于，它是可以嵌套的。我们在定义了一批原子操作的情况下，可以利用async函数组合出新的async函数。 function sleep(duration) { return new Promise(function(resolve, reject) { setTimeout(resolve,duration); }) } async function foo(name){ await sleep(2000) console.log(name) } async function foo2(){ await foo(&quot;a&quot;); await foo(&quot;b&quot;); }这里foo2用await调用了两次异步函数foo，可以看到，如果我们把sleep这样的异步操作放入某一个框架或者库中，使用者几乎不需要了解Promise的概念即可进行异步编程了。 此外，generator/iterator也常常被跟异步一起来讲，我们必须说明 generator/iterator 并非异步代码，只是在缺少async/await的时候，一些框架（最著名的要数co）使用这样的特性来模拟async/await。 但是generator并非被设计成实现异步，所以有了async/await之后，generator/iterator来模拟异步的方法应该被废弃。 结语在今天的文章里，我们学习了JavaScript执行部分的知识，首先我们学习了JavaScript的宏观任务和微观任务相关的知识。我们把宿主发起的任务称为宏观任务，把JavaScript引擎发起的任务称为微观任务。许多的微观任务的队列组成了宏观任务。 除此之外，我们还展开介绍了用Promise来添加微观任务的方式，并且介绍了async/await这个语法的改进。 最后，留给你一个小练习：我们现在要实现一个红绿灯，把一个圆形div按照绿色3秒，黄色1秒，红色2秒循环改变背景色，你会怎样编写这个代码呢？欢迎你留言讨论。","link":"/2019/08/31/重学前端/JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？/"},{"title":"JavaScript执行（二）：闭包和执行上下文到底是怎么回事？","text":"你好，我是winter。 在上一课，我们了解了JavaScript执行中最粗粒度的任务：传给引擎执行的代码段。并且，我们还根据“由JavaScript引擎发起”还是“由宿主发起”，分成了宏观任务和微观任务，接下来我们继续去看一看更细的执行粒度。 一段JavaScript代码可能会包含函数调用的相关内容，从今天开始，我们就用两节课的时间来了解一下函数的执行。 我们今天要讲的知识在网上有不同的名字，比较常见的可能有： 闭包； 作用域链； 执行上下文； this值。 实际上，尽管它们是表示不同的意思的术语，所指向的几乎是同一部分知识，那就是函数执行过程相关的知识。我们可以简单看一下图。 看着也许会有点晕，别着急，我会和你共同理一下它们之间的关系。 当然，除了让你理解函数执行过程的知识，理清这些概念也非常重要。所以我们先来讲讲这个有点复杂的概念：闭包。 闭包闭包翻译自英文单词closure，这是个不太好翻译的词，在计算机领域，它就有三个完全不相同的意义：编译原理中，它是处理语法产生式的一个步骤；计算几何中，它表示包裹平面点集的凸多边形（翻译作凸包）；而在编程语言领域，它表示一种函数。 闭包这个概念第一次出现在1964年的《The Computer Journal》上，由P. J. Landin在《The mechanical evaluation of expressions》一文中提出了applicative expression和closure的概念。 在上世纪60年代，主流的编程语言是基于lambda演算的函数式编程语言，所以这个最初的闭包定义，使用了大量的函数式术语。一个不太精确的描述是“带有一系列信息的λ表达式”。对函数式语言而言，λ表达式其实就是函数。 我们可以这样简单理解一下，闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。 这个古典的闭包定义中，闭包包含两个部分。 环境部分 环境 标识符列表 表达式部分 当我们把视角放在JavaScript的标准中，我们发现，标准中并没有出现过closure这个术语，但是，我们却不难根据古典定义，在JavaScript中找到对应的闭包组成部分。 环境部分 环境：函数的词法环境（执行上下文的一部分） 标识符列表：函数中用到的未声明的变量 表达式部分：函数体 至此，我们可以认为，JavaScript中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。 这里我们容易产生一个常见的概念误区，有些人会把JavaScript执行上下文，或者作用域（Scope，ES3中规定的执行上下文的一部分）这个概念当作闭包。 实际上JavaScript中跟闭包对应的概念就是“函数”，可能是这个概念太过于普通，跟闭包看起来又没什么联系，所以大家才不自觉地把这个概念对应到了看起来更特别的“作用域”吧（其实我早年也是这么理解闭包，直到后来被朋友纠正，查了资料才改正过来）。 执行上下文：执行的基础设施相比普通函数，JavaScript函数的主要复杂性来自于它携带的“环境部分”。当然，发展到今天的JavaScript，它所定义的环境部分，已经比当初经典的定义复杂了很多。 JavaScript中与闭包“环境部分”相对应的术语是“词法环境”，但是JavaScript函数比λ函数要复杂得多，我们还要处理this、变量声明、with等等一系列的复杂语法，λ函数中可没有这些东西，所以，在JavaScript的设计中，词法环境只是JavaScript执行上下文的一部分。 JavaScript标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。 因为这部分术语经历了比较多的版本和社区的演绎，所以定义比较混乱，这里我们先来理一下JavaScript中的概念。 执行上下文在ES3中，包含三个部分。 scope：作用域，也常常被叫做作用域链。 variable object：变量对象，用于存储变量的对象。 this value：this值。 在ES5中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子。 lexical environment：词法环境，当获取变量时使用。 variable environment：变量环境，当声明变量时使用。 this value：this值。 在ES2018中，执行上下文又变成了这个样子，this值被归入lexical environment，但是增加了不少内容。 lexical environment：词法环境，当获取变量或者this值时使用。 variable environment：变量环境，当声明变量时使用。 code evaluation state：用于恢复代码执行位置。 Function：执行的任务是函数时使用，表示正在被执行的函数。 ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。 Realm：使用的基础库和内置对象实例。 Generator：仅生成器上下文有这个属性，表示当前生成器。 我们在这里介绍执行上下文的各个版本定义，是考虑到你可能会从各种网上的文章中接触这些概念，如果不把它们理清楚，我们就很难分辨对错。如果是我们自己使用，我建议统一使用最新的ES2018中规定的术语定义。 尽管我们介绍了这些定义，但我并不打算按照JavaScript标准的思路，从实现的角度去介绍函数的执行过程，这是不容易被理解的。 我想试着从代码实例出发，跟你一起推导函数执行过程中需要哪些信息，它们又对应着执行上下文中的哪些部分。 比如，我们看以下的这段JavaScript代码： var b = {} let c = 1 this.a = 2;要想正确执行它，我们需要知道以下信息： var 把 b 声明到哪里； b 表示哪个变量； b 的原型是哪个对象； let 把 c 声明到哪里； this 指向哪个对象。 这些信息就需要执行上下文来给出了，这段代码出现在不同的位置，甚至在每次执行中，会关联到不同的执行上下文，所以，同样的代码会产生不一样的行为。 在这两篇文章中，我会基本覆盖执行上下文的组成部分，本篇我们先讲var声明与赋值，let，realm三个特性来分析上下文提供的信息，分析执行上下文中提供的信息。 var 声明与赋值我们来分析一段代码： var b = 1通常我们认为它声明了b，并且为它赋值为1，var声明作用域函数执行的作用域。也就是说，var会穿透for 、if等语句。 在只有var，没有let的旧JavaScript时代，诞生了一个技巧，叫做：立即执行的函数表达式（IIFE），通过创建一个函数，并且立即执行，来构造一个新的域，从而控制var的范围。 由于语法规定了function关键字开头是函数声明，所以要想让函数变成函数表达式，我们必须得加点东西，最常见的做法是加括号。 (function(){ var a; //code }()); (function(){ var a; //code })();但是，括号有个缺点，那就是如果上一行代码不写分号，括号会被解释为上一行代码最末的函数调用，产生完全不符合预期，并且难以调试的行为，加号等运算符也有类似的问题。所以一些推荐不加分号的代码风格规范，会要求在括号前面加上分号。 ;(function(){ var a; //code }()) ;(function(){ var a; //code })()我比较推荐的写法是使用void关键字。也就是下面的这种形式。 void function(){ var a; //code }();这有效避免了语法问题，同时，语义上void运算表示忽略后面表达式的值，变成undefined，我们确实不关心IIFE的返回值，所以语义也更为合理。 值得特别注意的是，有时候var的特性会导致声明的变量和被赋值的变量是两个b，JavaScript中有特例，那就是使用with的时候： var b; void function(){ var env = {b:1}; b = 2; console.log(&quot;In function b:&quot;, b); with(env) { var b = 3; console.log(&quot;In with b:&quot;, b); } }(); console.log(&quot;Global b:&quot;, b);在这个例子中，我们利用立即执行的函数表达式（IIFE）构造了一个函数的执行环境，并且在里面使用了我们一开头的代码。 可以看到，在Global function with三个环境中，b的值都不一样，而在function环境中，并没有出现var b，这说明with内的var b作用到了function这个环境当中。 var b = {} 这样一句对两个域产生了作用，从语言的角度是个非常糟糕的设计，这也是一些人坚定地反对在任何场景下使用with的原因之一。 letlet是 ES6开始引入的新的变量声明模式，比起var的诸多弊病，let做了非常明确的梳理和规定。 为了实现let，JavaScript在运行时引入了块级作用域。也就是说，在let出现之前，JavaScript的 if for 等语句皆不产生作用域。 我简单统计了下，以下语句会产生let使用的作用域： for； if； switch； try/catch/finally。 Realm在最新的标准（9.0）中，JavaScript引入了一个新概念Realm，它的中文意思是“国度”“领域”“范围”。这个英文的用法就有点比喻的意思，几个翻译都不太适合JavaScript语境，所以这里就不翻译啦。 我们继续来看这段代码： var b = {}在 ES2016 之前的版本中，标准中甚少提及{}的原型问题。但在实际的前端开发中，通过iframe等方式创建多window环境并非罕见的操作，所以，这才促成了新概念Realm的引入。 Realm中包含一组完整的内置对象，而且是复制关系。 对不同Realm中的对象操作，会有一些需要格外注意的问题，比如 instanceOf 几乎是失效的。 以下代码展示了在浏览器环境中获取来自两个Realm的对象，它们跟本土的Object做instanceOf时会产生差异： var iframe = document.createElement(&apos;iframe&apos;) document.documentElement.appendChild(iframe) iframe.src=&quot;javascript:var b = {};&quot; var b1 = iframe.contentWindow.b; var b2 = {}; console.log(typeof b1, typeof b2); //object object console.log(b1 instanceof Object, b2 instanceof Object); //false true可以看到，由于b1、 b2由同样的代码“ {} ”在不同的Realm中执行，所以表现出了不同的行为。 结语在今天的课程中，我帮你梳理了一些概念：有编程语言的概念闭包，也有各个版本中的JavaScript标准中的概念：执行上下文、作用域、this值等等。 之后我们又从代码的角度，分析了一些执行上下文中所需要的信息，并从var、let、对象字面量等语法中，推导出了词法作用域、变量作用域、Realm\b的设计。 最后留给你一个问题：你喜欢使用let还是var？听过今天的课程，你的想法是否有改变呢？为什么？","link":"/2019/08/31/重学前端/JavaScript执行（二）：闭包和执行上下文到底是怎么回事？/"},{"title":"JavaScript执行（三）：你知道现在有多少种函数吗？","text":"在前一篇文章中，我们大致了解了执行上下文是什么，也知道了任何语句的执行都会依赖特定的上下文。 一旦上下文被切换，整个语句的效果可能都会发生改变。那么，切换上下文的时机就显得非常重要了。 在JavaScript，切换上下文最主要的场景是函数调用。在这一课，我们就来讲讲函数调用切换上下文的事情。我们在讲函数调用之前，首先来认识一下函数家族。 函数在ES2018中，函数已经是一个很复杂的体系了，我在这里整理了一下。 第一种，普通函数：用function关键字定义的函数。 示例： function foo(){ // code }第二种，箭头函数：用 =&gt; 运算符定义的函数。 示例: const foo = () =&gt; { // code }第三种，方法：在class中定义的函数。 示例： class C { foo(){ //code } }第四种，生成器函数：用function * 定义的函数。 示例： function* foo(){ // code }第五种，类：用class定义的类，实际上也是函数。 示例： class Foo { constructor(){ //code } }第六/七/八种，异步函数：普通函数、箭头函数和生成器函数加上async关键字。 示例： async function foo(){ // code } const foo = async () =&gt; { // code } async function foo*(){ // code }ES6以来，大量加入的新语法极大地方便了我们编程的同时，也增加了很多我们理解的心智负担。要想认识这些函数的执行上下文切换，我们必须要对它们行为上的区别有所了解。 对普通变量而言，这些函数并没有本质区别，都是遵循了“继承定义时环境”的规则，它们的一个行为差异在于this关键字。 那么，this关键字是什么呢，我们一起来看一看。 this关键字的行为this是JavaScript中的一个关键字，它的使用方法类似于一个变量（但是this跟变量的行为有很多不同，上一节课我们讲了一些普通变量的行为和机制，也就是var声明和赋值、let的内容）。 this是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的this值也不同，我们看一个例子： function showThis(){ console.log(this); } var o = { showThis: showThis } showThis(); // global o.showThis(); // o在这个例子中，我们定义了函数showThis，我们把它赋值给一个对象o的属性，然后尝试分别使用两个引用来调用同一个函数，结果得到了不同的this值。 普通函数的this值由“调用它所使用的引用”决定，其中奥秘就在于：我们获取函数的表达式，它实际上返回的并非函数本身，而是一个Reference类型（记得我们在类型一章讲过七种标准类型吗，正是其中之一）。 Reference类型由两部分组成：一个对象和一个属性值。不难理解 o.showThis 产生的Reference类型，即由对象o和属性“showThis”构成。 当做一些算术运算（或者其他运算时），Reference类型会被解引用，即获取真正的值（被引用的内容）来参与运算，而类似函数调用、delete等操作，都需要用到Reference类型中的对象。 在这个例子中，Reference类型中的对象被当作this值，传入了执行函数时的上下文当中。 至此，我们对this的解释已经非常清晰了：调用函数时使用的引用，决定了函数执行时刻的this值。 实际上从运行时的角度来看，this跟面向对象毫无关联，它是与函数调用时使用的表达式相关。 这个设计来自JavaScript早年，通过这样的方式，巧妙地模仿了Java的语法，但是仍然保持了纯粹的“无类”运行时设施。 如果，我们把这个例子稍作修改，换成箭头函数，结果就不一样了： const showThis = () =&gt; { console.log(this); } var o = { showThis: showThis } showThis(); // global o.showThis(); // global我们看到，改为箭头函数后，不论用什么引用来调用它，都不影响它的this值。 接下来我们看看“方法”，它的行为又不一样了： class C { showThis() { console.log(this); } } var o = new C(); var showThis = o.showThis; showThis(); // undefined o.showThis(); // o这里我们创建了一个类C，并且实例化出对象o，再把o的方法赋值给了变量showThis。 这时候，我们使用showThis这个引用去调用方法时，得到了undefined。 所以，在方法中，我们看到this的行为也不太一样，它得到了undefined的结果。 按照我们上面的方法，不难验证出：生成器函数、异步生成器函数和异步普通函数跟普通函数行为是一致的，异步箭头函数与箭头函数行为是一致的。 this关键字的机制说完了this行为，我们再来简单谈谈在JavaScript内部，实现this这些行为的机制，让你对这部分知识有一个大概的认知。 函数能够引用定义时的变量，如上文分析，函数也能记住定义时的this，因此，函数内部必定有一个机制来保存这些信息。 在JavaScript标准中，为函数规定了用来保存定义时上下文的私有属性[[Environment]]。 当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的[[Environment]]。 这个动作就是切换上下文了，我们假设有这样的代码： var a = 1; foo(); 在别处定义了foo： var b = 2; function foo(){ console.log(b); // 2 console.log(a); // error }这里的foo能够访问b（定义时词法环境），却不能访问a（执行时的词法环境），这就是执行上下文的切换机制了。 JavaScript用一个栈来管理执行上下文，这个栈中的每一项又包含一个链表。如下图所示： 当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈。 而this则是一个更为复杂的机制，JavaScript标准定义了 [[thisMode]] 私有属性。 [[thisMode]] 私有属性有三个取值。 lexical：表示从上下文中找this，这对应了箭头函数。 global：表示当this为undefined时，取全局对象，对应了普通函数。 strict：当严格模式时使用，this严格按照调用时传入的值，可能为null或者undefined。 非常有意思的是，方法的行为跟普通函数有差异，恰恰是因为class设计成了默认按strict模式执行。 我们可以用strict达成与上一节中方法的例子一样的效果: &quot;use strict&quot; function showThis(){ console.log(this); } var o = { showThis: showThis } showThis(); // undefined o.showThis(); // o函数创建新的执行上下文中的词法环境记录时，会根据[[thisMode]]来标记新纪录的[[ThisBindingStatus]]私有属性。 代码执行遇到this时，会逐层检查当前词法环境记录中的[[ThisBindingStatus]]，当找到有this的环境记录时获取this的值。 这样的规则的实际效果是，嵌套的箭头函数中的代码都指向外层this，例如： var o = {} o.foo = function foo(){ console.log(this); return () =&gt; { console.log(this); return () =&gt; console.log(this); } } o.foo()()(); // o, o, o这个例子中，我们定义了三层嵌套的函数，最外层为普通函数，两层都是箭头函数。 这里调用三个函数，获得的this值是一致的，都是对象o。 JavaScript还提供了一系列函数的内置方法来操纵this值，下面我们来了解一下。 操作this的内置函数Function.prototype.call 和 Function.prototype.apply 可以指定函数调用时传入的this值，示例如下： function foo(a, b, c){ console.log(this); console.log(a, b, c); } foo.call({}, 1, 2, 3); foo.apply({}, [1, 2, 3]);这里call和apply作用是一样的，只是传参方式有区别。 此外，还有 Function.prototype.bind 它可以生成一个绑定过的函数，这个函数的this值固定了参数： function foo(a, b, c){ console.log(this); console.log(a, b, c); } foo.bind({}, 1, 2, 3)();有趣的是，call、bind和apply用于不接受this的函数类型如箭头、class都不会报错。 这时候，它们无法实现改变this的能力，但是可以实现传参。 结语在这一节课程中，我们认识了ES2018中规定的各种函数，我一共简单介绍了8种函数。 我们围绕this这个中心，介绍了函数的执行上下文切换机制。同时我们还讲解了this中的一些相关知识。包括了操作this的内置函数。 最后，留给你一个问题，你在日常开发中用过哪些函数类型呢？欢迎给我留言，我们一起讨论。 补充阅读：new与this我们在之前的对象部分已经讲过new的执行过程，我们再来看一下： 以构造器的 prototype 属性（注意与私有字段[[prototype]]的区分）为原型，创建新对象； 将 this 和调用参数传给构造器，执行； 如果构造器返回的是对象，则返回，否则返回第一步创建的对象。 显然，通过new调用函数，跟直接调用的this取值有明显区别。那么我们今天讲的这些函数跟new搭配又会产生什么效果呢？ 这里我整理了一张表： 我们可以看到，仅普通函数和类能够跟new搭配使用，这倒是给我们省去了不少麻烦。","link":"/2019/08/31/重学前端/JavaScript执行（三）：你知道现在有多少种函数吗？/"},{"title":"JavaScript执行（四）：try里面放return，finally还会执行吗？","text":"你好，我是winter。 在前面几篇文章中，我们已经了解了关于执行上下文、作用域、闭包之间的关系。 今天，我们则要说一说更为细节的部分：语句。 语句是任何编程语言的基础结构，与JavaScript对象一样，JavaScript语句同样具有“看起来很像其它语言，但是其实一点都不一样”的特点。 我们比较常见的语句包括变量声明、表达式、条件、循环等，这些都是大家非常熟悉的东西，对于它们的行为，我在这里就不赘述了。 为了了解JavaScript语句有哪些特别之处，首先我们要看一个不太常见的例子，我会通过这个例子，来向你介绍JavaScript语句执行机制涉及的一种基础类型：Completion类型。 Completion类型我们来看一个例子。在函数foo中，使用了一组try语句。我们可以先来做一个小实验，在try中有return语句，finally中的内容还会执行吗？我们来看一段代码。 function foo(){ try{ return 0; } catch(err) { } finally { console.log(&quot;a&quot;) } } console.log(foo());通过实际试验，我们可以看到，finally确实执行了，而且return语句也生效了，foo()返回了结果0。 虽然return执行了，但是函数并没有立即返回，又执行了finally里面的内容，这样的行为违背了很多人的直觉。 如果在这个例子中，我们在finally中加入return语句，会发生什么呢？ function foo(){ try{ return 0; } catch(err) { } finally { return 1; } } console.log(foo());通过实际执行，我们看到，finally中的return “覆盖”了try中的return。在一个函数中执行了两次return，这已经超出了很多人的常识，也是其它语言中不会出现的一种行为。 面对如此怪异的行为，我们当然可以把它作为一个孤立的知识去记忆，但是实际上，这背后有一套机制在运作。 这一机制的基础正是JavaScript语句执行的完成状态，我们用一个标准类型来表示：Completion Record（我在类型一节提到过，Completion Record用于描述异常、跳出等语句执行过程）。 Completion Record 表示一个语句执行完之后的结果，它有三个字段： [[type]] 表示完成的类型，有break continue return throw和normal几种类型； [[value]] 表示语句的返回值，如果语句没有，则是empty； [[target]] 表示语句的目标，通常是一个JavaScript标签（标签在后文会有介绍）。 JavaScript正是依靠语句的 Completion Record类型，方才可以在语句的复杂嵌套结构中，实现各种控制。接下来我们要来了解一下JavaScript使用Completion Record类型，控制语句执行的过程。 首先我们来看看语句有几种分类。 普通的语句在JavaScript中，我们把不带控制能力的语句称为普通语句。普通语句有下面几种。 声明类语句 var声明 const声明 let声明 函数声明 类声明 表达式语句 空语句 debugger语句 这些语句在执行时，从前到后顺次执行（我们这里先忽略var和函数声明的预处理机制），没有任何分支或者重复执行逻辑。 普通语句执行后，会得到 [[type]] 为 normal 的 Completion Record，JavaScript引擎遇到这样的Completion Record，会继续执行下一条语句。 这些语句中，只有表达式语句会产生 [[value]]，当然，从引擎控制的角度，这个value并没有什么用处。 如果你经常使用Chrome自带的调试工具，可以知道，输入一个表达式，在控制台可以得到结果，但是在前面加上var，就变成了undefined。 Chrome控制台显示的正是语句的Completion Record的[[value]]。 语句块介绍完了普通语句，我们再来介绍一个比较特殊的语句：语句块。 语句块就是拿大括号括起来的一组语句，它是一种语句的复合结构，可以嵌套。 语句块本身并不复杂，我们需要注意的是语句块内部的语句的Completion Record的[[type]] 如果不为 normal，会打断语句块后续的语句执行。 比如我们考虑，一个[[type]]为return的语句，出现在一个语句块中的情况。 从语句的这个type中，我们大概可以猜到它由哪些特定语句产生，我们就来说说最开始的例子中的 return。 return语句可能产生return或者throw类型的Completion Record。我们来看一个例子。 先给出一个内部为普通语句的语句块： { var i = 1; // normal, empty, empty i ++; // normal, 1, empty console.log(i) //normal, undefined, empty } // normal, undefined, empty在每一行的注释中，我给出了语句的Completion Record。 我们看到，在一个block中，如果每一个语句都是normal类型，那么它会顺次执行。接下来我们加入return试试看。 { var i = 1; // normal, empty, empty return i; // return, 1, empty i ++; console.log(i) } // return, 1, empty但是假如我们在block中插入了一条return语句，产生了一个非normal记录，那么整个block会成为非normal。这个结构就保证了非normal的完成类型可以穿透复杂的语句嵌套结构，产生控制效果。 接下来我们就具体讲讲控制类语句。 控制型语句控制型语句带有 if、switch关键字，它们会对不同类型的Completion Record产生反应。 控制类语句分成两部分，一类是对其内部造成影响，如if、switch、while/for、try。 另一类是对外部造成影响如break、continue、return、throw，这两类语句的配合，会产生控制代码执行顺序和执行逻辑的效果，这也是我们编程的主要工作。 一般来说， for/while - break/continue 和 try - throw 这样比较符合逻辑的组合，是大家比较熟悉的，但是，实际上，我们需要控制语句跟break 、continue 、return 、throw四种类型与控制语句两两组合产生的效果。 通过这个表，我们不难发现知识的盲点，也就是我们最初的的case中的try和return的组合了。 因为finally中的内容必须保证执行，所以 try/catch执行完毕，即使得到的结果是非normal型的完成记录，也必须要执行finally。 而当finally执行也得到了非normal记录，则会使finally中的记录作为整个try结构的结果。 带标签的语句前文我重点讲了type在语句控制中的作用，接下来我们重点来讲一下最后一个字段：target，这涉及了JavaScript中的一个语法，带标签的语句。 实际上，任何JavaScript语句是可以加标签的，在语句前加冒号即可： firstStatement: var i = 1;大部分时候，这个东西类似于注释，没有任何用处。唯一有作用的时候是：与完成记录类型中的target相配合，用于跳出多层循环。 outer: while(true) { inner: while(true) { break outer; } } console.log(&quot;finished&quot;)break/continue 语句如果后跟了关键字，会产生带target的完成记录。一旦完成记录带了target，那么只有拥有对应label的循环语句会消费它。 结语我们以Completion Record类型为线索，为你讲解了JavaScript语句执行的原理。 因为JavaScript语句存在着嵌套关系，所以执行过程实际上主要在一个树形结构上进行， 树形结构的每一个节点执行后产生Completion Record，根据语句的结构和Completion Record，JavaScript实现了各种分支和跳出逻辑。 你遇到哪些语句中的执行的实际效果，是跟你想象的有所出入呢，你可以给我留言，我们一起讨论。","link":"/2019/08/31/重学前端/JavaScript执行（四）：try里面放return，finally还会执行吗？/"},{"title":"JavaScript语法（一）：在script标签写export为什么会抛错？","text":"你好，我是winter，今天我们进入到语法部分的学习。在讲解具体的语法结构之前，这一堂课我首先要给你介绍一下JavaScript语法的一些基本规则。 脚本和模块首先，JavaScript有两种源文件，一种叫做脚本，一种叫做模块。这个区分是在ES6引入了模块机制开始的，在ES5和之前的版本中，就只有一种源文件类型（就只有脚本）。 脚本是可以由浏览器或者node环境引入执行的，而模块只能由JavaScript代码用import引入执行。 从概念上，我们可以认为脚本具有主动性的JavaScript代码段，是控制宿主完成一定任务的代码；而模块是被动性的JavaScript代码段，是等待被调用的库。 我们对标准中的语法产生式做一些对比，不难发现，实际上模块和脚本之间的区别仅仅在于是否包含import 和 export。 脚本是一种兼容之前的版本的定义，在这个模式下，没有import就不需要处理加载“.js”文件问题。 现代浏览器可以支持用script标签引入模块或者脚本，如果要引入模块，必须给script标签添加type=“module”。如果引入脚本，则不需要type。 &lt;script type=&quot;module&quot; src=&quot;xxxxx.js&quot;&gt;&lt;/script&gt;这样，就回答了我们标题中的问题，script标签如果不加type=“module”，默认认为我们加载的文件是脚本而非模块，如果我们在脚本中写了export，当然会抛错。 脚本中可以包含语句。模块中可以包含三种内容：import声明，export声明和语句。普通语句我们会在下一课专门给你讲解，下面我们就来讲讲import声明和export声明。 import声明我们首先来介绍一下import声明，import声明有两种用法，一个是直接import一个模块，另一个是带from的import，它能引入模块里的一些信息。 import &quot;mod&quot;; //引入一个模块 import v from &quot;mod&quot;; //把模块默认的导出值放入变量v直接import一个模块，只是保证了这个模块代码被执行，引用它的模块是无法获得它的任何信息的。 带from的import意思是引入模块中的一部分信息，可以把它们变成本地的变量。 带from的import细分又有三种用法，我们可以分别看下例子： import x from &quot;./a.js&quot; 引入模块中导出的默认值。 import {a as x, modify} from &quot;./a.js&quot;; 引入模块中的变量。 import * as x from &quot;./a.js&quot; 把模块中所有的变量以类似对象属性的方式引入。 第一种方式还可以跟后两种组合使用。 import d, {a as x, modify} from &quot;./a.js&quot; import d, * as x from &quot;./a.js&quot; 语法要求不带as的默认值永远在最前。注意，这里的变量实际上仍然可以受到原来模块的控制。 我们看一个例子，假设有两个模块a和b。我们在模块a中声明了变量和一个修改变量的函数，并且把它们导出。我们用b模块导入了变量和修改变量的函数。 模块a： export var a = 1; export function modify(){ a = 2; }模块b： import {a, modify} from &quot;./a.js&quot;; console.log(a); modify(); console.log(a);当我们调用修改变量的函数后，b模块变量也跟着发生了改变。这说明导入与一般的赋值不同，导入后的变量只是改变了名字，它仍然与原来的变量是同一个。 export声明我们再来说说export声明。与import相对，export声明承担的是导出的任务。 模块中导出变量的方式有两种，一种是独立使用export声明，另一种是直接在声明型语句前添加export关键字。 独立使用export声明就是一个export关键字加上变量名列表，例如： export {a, b, c};我们也可以直接在声明型语句前添加export关键字，这里的export可以加在任何声明性质的语句之前，整理如下： var function (含async和generator) class let const export还有一种特殊的用法，就是跟default联合使用。export default 表示导出一个默认变量值，它可以用于function和class。这里导出的变量是没有名称的，可以使用import x from &quot;./a.js&quot;这样的语法，在模块中引入。 export default 还支持一种语法，后面跟一个表达式，例如： var a = {}; export default a;但是，这里的行为跟导出变量是不一致的，这里导出的是值，导出的就是普通变量a的值，以后a的变化与导出的值就无关了，修改变量a，不会使得其他模块中引入的default值发生改变。 在import语句前无法加入export，但是我们可以直接使用export from语法。 export a from &quot;a.js&quot;JavaScript引擎除了执行脚本和模块之外，还可以执行函数。而函数体跟脚本和模块有一定的相似之处，所以接下来，给你讲讲函数体的相关知识。 函数体执行函数的行为通常是在JavaScript代码执行时，注册宿主环境的某些事件触发的，而执行的过程，就是执行函数体（函数的花括号中间的部分）。 我们先看一个例子，感性地理解一下： setTimeout(function(){ console.log(&quot;go go go&quot;); }, 10000)这段代码通过setTimeout函数注册了一个函数给宿主，当一定时间之后，宿主就会执行这个函数。 你还记得吗，我们前面已经在运行时这部分讲过，宿主会为这样的函数创建宏任务。 当我们学习了语法之后，我们可以认为，宏任务中可能会执行的代码包括“脚本(script)”“模块（module）”和“函数体（function body）”。正因为这样的相似性，我们把函数体也放到本课来讲解。 函数体其实也是一个语句的列表。跟脚本和模块比起来，函数体中的语句列表中多了return语句可以用。 函数体实际上有四种，下面，我来分别介绍一下。 普通函数体，例如： function foo(){ //Function body } 异步函数体，例如： async function foo(){ //Function body } 生成器函数体，例如： function *foo(){ //Function body } 异步生成器函数体，例如： async function *foo(){ //Function body } 上面四种函数体的区别在于：能否使用await或者yield语句。 关于函数体、模块和脚本能使用的语句，我整理了一个表格，你可以参考一下： 讲完了三种语法结构，我再来介绍两个JavaScript语法的全局机制：预处理和指令序言。 这两个机制对于我们解释一些JavaScript的语法现象非常重要。不理解预处理机制我们就无法理解var等声明类语句的行为，而不理解指令序言，我们就无法解释严格模式。 预处理JavaScript执行前，会对脚本、模块和函数体中的语句进行预处理。预处理过程将会提前处理var、函数声明、class、const和let这些语句，以确定其中变量的意义。 因为一些历史包袱，这一部分内容非常复杂，首先我们看一下var声明。 var声明var声明永远作用于脚本、模块和函数体这个级别，在预处理阶段，不关心赋值的部分，只管在当前作用域声明这个变量。 我们还是从实例来进行学习。 var a = 1; function foo() { console.log(a); var a = 2; } foo();这段代码声明了一个脚本级别的a，又声明了foo函数体级别的a，我们注意到，函数体级的var出现在console.log语句之后。 但是预处理过程在执行之前，所以有函数体级的变量a，就不会去访问外层作用域中的变量a了，而函数体级的变量a此时还没有赋值，所以是undefined。我们再看一个情况： var a = 1; function foo() { console.log(a); if(false) { var a = 2; } } foo();这段代码比上一段代码在var a = 2之外多了一段if，我们知道if(false)中的代码永远不会被执行，但是预处理阶段并不管这个，var的作用能够穿透一切语句结构，它只认脚本、模块和函数体三种语法结构。所以这里结果跟前一段代码完全一样，我们会得到undefined。 我们看下一个例子，我们在运行时部分讲过类似的例子。 var a = 1; function foo() { var o= {a:3} with(o) { var a = 2; } console.log(o.a); console.log(a); } foo();在这个例子中，我们引入了with语句，我们用with(o)创建了一个作用域，并把o对象加入词法环境，在其中使用了var a = 2;语句。 在预处理阶段，只认var中声明的变量，所以同样为foo的作用域创建了a这个变量，但是没有赋值。 在执行阶段，当执行到var a = 2时，作用域变成了with语句内，这时候的a被认为访问到了对象o的属性a，所以最终执行的结果，我们得到了2和undefined。 这个行为是JavaScript公认的设计失误之一，一个语句中的a在预处理阶段和执行阶段被当做两个不同的变量，严重违背了直觉，但是今天，在JavaScript设计原则“don’t break the web”之下，已经无法修正了，所以你需要特别注意。 因为早年JavaScript没有let和const，只能用var，又因为var除了脚本和函数体都会穿透，人民群众发明了“立即执行的函数表达式（IIFE）”这一用法，用来产生作用域，例如： for(var i = 0; i &lt; 20; i ++) { void function(i){ var div = document.createElement(&quot;div&quot;); div.innerHTML = i; div.onclick = function(){ console.log(i); } document.body.appendChild(div); }(i); }这段代码非常经典，常常在实际开发中见到，也经常被用作面试题，为文档添加了20个div元素，并且绑定了点击事件，打印它们的序号。 我们通过IIFE在循环内构造了作用域，每次循环都产生一个新的环境记录，这样，每个div都能访问到环境中的i。 如果我们不用IIFE： for(var i = 0; i &lt; 20; i ++) { var div = document.createElement(&quot;div&quot;); div.innerHTML = i; div.onclick = function(){ console.log(i); } document.body.appendChild(div); }这段代码的结果将会是点每个div都打印20，因为全局只有一个i，执行完循环后，i变成了20。 function声明function声明的行为原本跟var非常相似，但是在最新的JavaScript标准中，对它进行了一定的修改，这让情况变得更加复杂了。 在全局（脚本、模块和函数体），function声明表现跟var相似，不同之处在于，function声明不但在作用域中加入变量，还会给它赋值。 我们看一下function声明的例子： console.log(foo); function foo(){ }这里声明了函数foo，在声明之前，我们用console.log打印函数foo，我们可以发现，已经是函数foo的值了。 function声明出现在if等语句中的情况有点复杂，它仍然作用于脚本、模块和函数体级别，在预处理阶段，仍然会产生变量，它不再被提前赋值： console.log(foo); if(true) { function foo(){ } }这段代码得到undefined。如果没有函数声明，则会抛出错误。 这说明function在预处理阶段仍然发生了作用，在作用域中产生了变量，没有产生赋值，赋值行为发生在了执行阶段。 出现在if等语句中的function，在if创建的作用域中仍然会被提前，产生赋值效果，我们会在下一节课继续讨论。 class声明class声明在全局的行为跟function和var都不一样。 在class声明之前使用class名，会抛错： console.log(c); class c{ }这段代码我们试图在class前打印变量c，我们得到了个错误，这个行为很像是class没有预处理，但是实际上并非如此。 我们看个复杂一点的例子： var c = 1; function foo(){ console.log(c); class c {} } foo();这个例子中，我们把class放进了一个函数体中，在外层作用域中有变量c。然后试图在class之前打印c。 执行后，我们看到，仍然抛出了错误，如果去掉class声明，则会正常打印出1，也就是说，出现在后面的class声明影响了前面语句的结果。 这说明，class声明也是会被预处理的，它会在作用域中创建变量，并且要求访问它时抛出错误。 class的声明作用不会穿透if等语句结构，所以只有写在全局环境才会有声明作用，这部分我们将会在下一节课讲解。 这样的class设计比function和var更符合直觉，而且在遇到一些比较奇怪的用法时，倾向于抛出错误。 按照现代语言设计的评价标准，及早抛错是好事，它能够帮助我们尽量在开发阶段就发现代码的可能问题。 指令序言机制脚本和模块都支持一种特别的语法，叫做指令序言（Directive Prologs）。 这里的指令序言最早是为了use strict设计的，它规定了一种给JavaScript代码添加元信息的方式。 &quot;use strict&quot;; function f(){ console.log(this); }; f.call(null);这段代码展示了严格模式的用法，我这里定义了函数f，f中打印this值，然后用call的方法调用f，传入null作为this值，我们可以看到最终结果是null原封不动地被当做this值打印了出来，这是严格模式的特征。 如果我们去掉严格模式的指令需要，打印的结果将会变成global。 &quot;use strict&quot;是JavaScript标准中规定的唯一一种指令序言，但是设计指令序言的目的是，留给JavaScript的引擎和实现者一些统一的表达方式，在静态扫描时指定JavaScript代码的一些特性。 例如，假设我们要设计一种声明本文件不需要进行lint检查的指令，我们可以这样设计： &quot;no lint&quot;; &quot;use strict&quot;; function doSth(){ //...... } //......JavaScript的指令序言是只有一个字符串直接量的表达式语句，它只能出现在脚本、模块和函数体的最前面。 我们看两个例子： function doSth(){ //...... } &quot;use strict&quot;; var a = 1; //......这个例子中，&quot;use strict&quot;没有出现在最前，所以不是指令序言。 &apos;use strict&apos;; function doSth(){ //...... } var a = 1; //......这个例子中，'use strict'是单引号，这不妨碍它仍然是指令序言。 结语今天，我们一起进入了JavaScript的语法部分，在开始学习之前，我先介绍了一部分语法的基本规则。 我们首先介绍了JavaScript语法的全局结构，JavaScript有两种源文件，一种叫做脚本，一种叫做模块。介绍完脚本和模块的基础概念，我们再来把它们往下分，脚本中可以包含语句。模块中可以包含三种内容：import声明，export声明和语句。 最后，我介绍了两个JavaScript语法的全局机制：预处理和指令序言。 最后，给你留一个小任务，我们试着用babel，分析一段JavaScript的模块代码，并且找出它中间的所有export的变量。","link":"/2019/08/31/重学前端/JavaScript语法（一）：在script标签写export为什么会抛错？/"},{"title":"JavaScript语法（三）：什么是表达式语句？","text":"你好，我是winter。 不知道你有没有注意到，我们在语句部分，讲到了很多种语句类型，但是，其实最终产生执行效果的语句不多。 事实上，真正能干活的就只有表达式语句，其它语句的作用都是产生各种结构，来控制表达式语句执行，或者改变表达式语句的意义。 今天的课程，我们就深入到表达式语句中来学习一下。 什么是表达式语句表达式语句实际上就是一个表达式，它是由运算符连接变量或者直接量构成的（关于直接量我们在下一节详细讲解）。 一般来说，我们的表达式语句要么是函数调用，要么是赋值，要么是自增、自减，否则表达式计算的结果没有任何意义。 但是从语法上，并没有这样的限制，任何合法的表达式都可以当做表达式语句使用。比如我们看下面的例子。 a + b;这句代码计算了a和b相加的值，但是不会显示出来，也不会产生任何执行效果（除非a和b是getter），但是不妨碍它符合语法也能够被执行。 下面我们就一起来了解下都有哪些表达式，我们从粒度最小到粒度最大了解一下。 PrimaryExpression 主要表达式首先我们来给你讲解一下表达式的原子项：Primary Expression。它是表达式的最小单位，它所涉及的语法结构也是优先级最高的。 Primary Expression包含了各种“直接量”，直接量就是直接用某种语法写出来的具有特定类型的值。我们已经知道，在运行时有各种值，比如数字123，字符串Hello world，所以通俗地讲，直接量就是在代码中把它们写出来的语法。 我们在类型部分，已经介绍过一些基本类型的直接量。比如，我们当时用null关键字获取null值，这个用法就是null直接量，这里我们仅仅把它们简单回顾一下： &quot;abc&quot;; 123; null; true; false;除这些之外，JavaScript还能够直接量的形式定义对象，针对函数、类、数组、正则表达式等特殊对象类型，JavaScript提供了语法层面的支持。 ({}); (function(){}); (class{ }); []; /abc/g;需要注意，在语法层面，function、{ 和class开头的表达式语句与声明语句有语法冲突，所以，我们要想使用这样的表达式，必须加上括号来回避语法冲突。 在JavaScript标准中，这些结构有的被称作直接量（Literal），有的被称作表达式（**Expression），在我看来，把它们都理解成直接量比较合适。 Primary Expression还可以是this或者变量，在语法上，把变量称作“标识符引用”。 this; myVar;任何表达式加上圆括号，都被认为是Primary Expression，这个机制使得圆括号成为改变运算优先顺序的手段。 (a + b);这就是Primary Expression的几种形式了，接下来，我们讲讲由Primary Expression构成的更复杂的表达式：Member Expression。 MemberExpression 成员表达式Member Expression通常是用于访问对象成员的。它有几种形式： a.b; a[&quot;b&quot;]; new.target; super.b;前面两种用法都很好理解，就是用标识符的属性访问和用字符串的属性访问。而new.target是个新加入的语法，用于判断函数是否是被new调用，super则是构造函数中，用于访问父类的属性的语法。 从名字就可以看出，Member Expression最初设计是为了属性访问的，不过从语法结构需要，以下两种在JavaScript标准中当做Member Expression： f`a${b}c`;这是一个是带函数的模板，这个带函数名的模板表示把模板的各个部分算好后传递给一个函数。 new Cls();另一个是带参数列表的new运算，注意，不带参数列表的new运算优先级更低，不属于Member Expression。 实际上，这两种被放入Member Expression，仅仅意味着它们跟属性运算属于同一优先级，没有任何语义上的关联。接下来我们看看Member Expression能组成什么。 NewExpression NEW表达式这种非常简单，Member Expression加上new就是New Expression（当然，不加new也可以构成New Expression，JavaScript中默认独立的高优先级表达式都可以构成低优先级表达式）。 注意，这里的New Expression特指没有参数列表的表达式。我们看个稍微复杂的例子： new new Cls(1);直观看上去，它可能有两种意思： new (new Cls(1)); new (new Cls)(1);实际上，它等价于第一种。我们可以用以下代码来验证： class Cls{ constructor(n){ console.log(&quot;cls&quot;, n); return class { constructor(n) { console.log(&quot;returned&quot;, n); } } } } new (new Cls(1));这段代码最后得到了下面这样的结果。 cls 1 returned undefined这里就说明了，1被当做调用Cls时的参数传入了。 CallExpression 函数调用表达式除了New Expression，Member Expression还能构成Call Expression。它的基本形式是Member Expression后加一个括号里的参数列表，或者我们可以用上super关键字代替Member Expression。 a.b(c); super();这看起来很简单，但是它有一些变体。比如： a.b(c)(d)(e); a.b(c)[3]; a.b(c).d; a.b(c)`xyz`;这些变体的形态，跟Member Expression几乎是一一对应的。实际上，我们可以理解为，Member Expression中的某一子结构具有函数调用，那么整个表达式就成为了一个Call Expression。 而Call Expression就失去了比New Expression优先级高的特性，这是一个主要的区分。 LeftHandSideExpression 左值表达式接下来，我们需要理解一个概念：New Expression 和 Call Expression 统称LeftHandSideExpression，左值表达式。 我们直观地讲，左值表达式就是可以放到等号左边的表达式。JavaScript语法则是下面这样。 a() = b;这样的用法其实是符合语法的，只是，原生的JavaScript函数，返回的值都不能被赋值。因此多数时候，我们看到的赋值将会是Call Expression的其它形式，如： a().c = b;另外，根据JavaScript运行时的设计，不排除某些宿主会提供返回引用类型的函数，这时候，赋值就是有效的了。 左值表达式最经典的用法是用于构成赋值表达式，但是其实如果你翻一翻JavaScript标准，你会发现它出现在各种场合，凡是需要“可以被修改的变量”的位置，都能见到它的身影。 那么接下来我们就讲讲 AssignmentExpression 赋值表达式。 AssignmentExpression 赋值表达式AssignmentExpression 赋值表达式也有多种形态，最基本的当然是使用等号赋值： a = b这里需要理解的一个稍微复杂的概念是，这个等号是可以嵌套的： a = b = c = d这样的连续赋值，是右结合的，它等价于下面这种： a = (b = (c = d))也就是说，先把d的结果赋值给c，再把整个表达式的结果赋值给b，再赋值给a。 当然，这并非一个很好的代码风格，我们讲解语法是为了让你理解这样的用法，而不是推荐你这样写代码。 赋值表达式的使用，还可以结合一些运算符，例如： a += b;相当于 a = a + b;能有这样用的运算符有下面这几种： *=、/=、%=、+=、-=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=、&amp;=、^=、|=、**= 我想你已经注意到了，赋值表达式的等号左边和右边能用的表达式类型不一样，在这一课，我们已经关注完了表达式的左边部分（左值表达式）的语法结构，下一节课，我们将会给你重点讲解表达式的右边部分。 Expression 表达式赋值表达式可以构成Expression表达式的一部分。在JavaScript中，表达式就是用逗号运算符连接的赋值表达式。 在JavaScript中，比赋值运算优先级更低的就是逗号运算符了。我们可以把逗号可以理解为一种小型的分号。 a = b, b = 1, null;逗号分隔的表达式会顺次执行，就像不同的表达式语句一样。“整个表达式的结果”就是“最后一个逗号后的表达式结果”。比如我们文中的例子，整个“a = b, b = 1, null;”表达式的结果就是“，”后面的null。 在很多场合，都不允许使用带逗号的表达式，比如我们在前面课程中提到，export后只能跟赋值表达式，意思就是表达式中不能含有逗号。 结语这节课我们开始讲解了运算符和表达式的一些相关知识，这节课上，我们已经学习了赋值表达式和赋值表达式的左边部分。下节课，我们将会讲一讲赋值表达式的右边部分。 最后给你留一个作业，把今天讲到的所有运算符按优先级排列成一个表格，下节课我们会补完剩下的部分。","link":"/2019/08/31/重学前端/JavaScript语法（三）：什么是表达式语句？/"},{"title":"JavaScript词法：为什么12.toString会报错？","text":"你好，我是winter。 在前面的文章中，我们已经从运行时的角度了解过JavaScript的知识内容，在接下来的几节课，我们来了解一下JavaScript的文法部分。 文法是编译原理中对语言的写法的一种规定，一般来说，文法分成词法和语法两种。 词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”，在我的专栏文章中，我统一把token翻译成词。 从字符到词的整个过程是没有结构的，只要符合词的规则，就构成词，一般来说，词法设计不会包含冲突。词法分析技术上可以使用状态机或者正则表达式来进行，我们的课程主要是学习词法，关于它们实现的细节就不多谈了。 概述我们先来看一看JavaScript的词法定义。JavaScript源代码中的输入可以这样分类： WhiteSpace 空白字符 LineTerminator 换行符 Comment 注释 Token 词 IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了。 Punctuator 符号，我们使用的运算符和大括号等符号。 NumericLiteral 数字直接量，就是我们写的数字。 StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量。 Template 字符串模板，用反引号``` 括起来的直接量。 这个设计符合比较通用的编程语言设计方式，不过，JavaScript中有一些特别之处，我下面就来讲讲特别在哪里。 首先是除法和正则表达式冲突问题。我们都知道，JavaScript不但支持除法运算符“ / ”和“ /= ”，还支持用斜杠括起来的正则表达式“ /abc/ ”。 但是，这时候对词法分析来说，其实是没有办法处理的，所以JavaScript的解决方案是定义两组词法，然后靠语法分析传一个标志给词法分析器，让它来决定使用哪一套词法。 JavaScript词法的另一个特别设计是字符串模板，模板语法大概是这样的： `Hello, ${name}`理论上，“ ${ } ”内部可以放任何JavaScript表达式代码，而这些代码是以“ } ” 结尾的，也就是说，这部分词法不允许出现“ } ”运算符。 是否允许“ } ”的两种情况，与除法和正则表达式的两种情况相乘就是四种词法定义，所以你在JavaScript标准中，可以看到四种定义： InputElementDiv； InputElementRegExp； InputElementRegExpOrTemplateTail； InputElementTemplateTail。 为了解决这两个问题，标准中还不得不把除法、正则表达式直接量和“ } ”从token中单独抽出来，用词上，也把原本的 Token 改为 CommonToken。 但是我认为，从理解的角度上出发，我们不应该受到影响，所以在本课，我们依然把它们归类到token来理解。 对一般的语言的词法分析过程来说，都会丢弃除了token之外的输入，但是对JavaScript来说，不太一样，换行符和注释还会影响语法分析过程，这个我们将会在语法部分给你详细讲解（所以要实现JavaScript的解释器，词法分析和语法分析非常麻烦，需要来回传递信息）。 接下来我来给你详细介绍一下。 空白符号 Whitespace说起空白符号，想必给大家留下的印象就是空格，但是实际上，JavaScript可以支持更多空白符号。 &lt;HT&gt;(或称&lt;TAB&gt;)是U+0009，是缩进TAB符，也就是字符串中写的 \\t 。 &lt;VT&gt;是U+000B，也就是垂直方向的TAB符 \\v，这个字符在键盘上很难打出来，所以很少用到。 &lt;FF&gt;是U+000C，Form Feed，分页符，字符串直接量中写作 \\f ，现代已经很少有打印源程序的事情发生了，所以这个字符在JavaScript源代码中很少用到。 &lt;SP&gt;是U+0020，就是最普通的空格了。 &lt;NBSP&gt;是U+00A0，非断行空格，它是SP的一个变体，在文字排版中，可以避免因为空格在此处发生断行，其它方面和普通空格完全一样。多数的JavaScript编辑环境都会把它当做普通空格（因为一般源代码编辑环境根本就不会自动折行……）。HTML中，很多人喜欢用的 &amp;nbsp; 最后生成的就是它了。 &lt;ZWNBSP&gt;(旧称&lt;BOM&gt;)是U+FEFF，这是ES5新加入的空白符，是Unicode中的零宽非断行空格，在以UTF格式编码的文件中，常常在文件首插入一个额外的U+FEFF，解析UTF文件的程序可以根据U+FEFF的表示方法猜测文件采用哪种UTF编码方式。这个字符也叫做“bit order mark”。 此外，JavaScript支持所有的Unicode中的空格分类下的空格，我们可以看下表： 很多公司的编码规范要求JavaScript源代码控制在ASCII范围内，那么，就只有&lt;TAB&gt;``&lt;VT&gt;``&lt;FF&gt;``&lt;SP&gt;``&lt;NBSP&gt;五种空白可用了。 换行符 LineTerminator接下来我们来看看换行符，JavaScript中只提供了4种字符作为换行符。 &lt;LF&gt; &lt;CR&gt; &lt;LS&gt; &lt;PS&gt; 其中，&lt;LF&gt;是U+000A，就是最正常换行符，在字符串中的\\n。 &lt;CR&gt;是U+000D，这个字符真正意义上的“回车”，在字符串中是\\r，在一部分Windows风格文本编辑器中，换行是两个字符\\r\\n。 &lt;LS&gt;是U+2028，是Unicode中的行分隔符。&lt;PS&gt;是U+2029，是Unicode中的段落分隔符。 大部分LineTerminator在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响JavaScript的两个重要语法特性：自动插入分号和“no line terminator”规则。 注释 CommentJavaScript的注释分为单行注释和多行注释两种： /* MultiLineCommentChars */ // SingleLineCommentChars多行注释中允许自由地出现MultiLineNotAsteriskChar，也就是除了*之外的所有字符。而每一个*之后，不能出现正斜杠符/。 除了四种LineTerminator之外，所有字符都可以作为单行注释。 我们需要注意，多行注释中是否包含换行符号，会对JavaScript语法产生影响，对于“no line terminator”规则来说，带换行的多行注释与换行符是等效的。 标识符名称 IdentifierNameIdentifierName可以以美元符“$”、下划线“_”或者Unicode字母开始，除了开始字符以外，IdentifierName中还可以使用Unicode中的连接标记、数字、以及连接符号。 IdentifierName的任意字符可以使用JavaScript的Unicode转义写法，使用Unicode转义写法时，没有任何字符限制。 IdentifierName可以是Identifier、NullLiteral、BooleanLiteral或者keyword，在ObjectLiteral中，IdentifierName还可以被直接当做属性名称使用。 仅当不是保留字的时候，IdentifierName会被解析为Identifier。 注意&lt;ZWNJ&gt;和&lt;ZWJ&gt;是ES5新加入的两个格式控制字符，它们都是0宽的。 我在前面提到了，关键字也属于这个部分，在JavaScript中，关键字有: await break case catch class const continue debugger default delete do else export extends finally for function if import ininstance of new return super switch this throw try typeof var void while with yield除了上述的内容之外，还有1个为了未来使用而保留的关键字: enum在严格模式下,有一些额外的为未来使用而保留的关键字: implements package protected interface private public除了这些之外，NullLiteral（null）和BooleanLiteral（true false）也是保留字，不能用于Identifier。 符号 Punctuator因为前面提到的除法和正则问题, /和/=两个运算符被拆分为DivPunctuator，因为前面提到的字符串模板问题，}也被独立拆分。加在一起，所有符号为： { ( ) [ ] . ... ; , &lt; &gt; &lt;= &gt;= == != === !== + - * % ** ++ -- &lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^ ! ~ &amp;&amp; || ? : = += -= *= %= **= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= |= ^= =&gt; / /= }数字直接量 NumericLiteral我们来看看今天标题提出的问题，JavaScript规范中规定的数字直接量可以支持四种写法：十进制数、二进制整数、八进制整数和十六进制整数。 十进制的Number可以带小数，小数点前后部分都可以省略，但是不能同时省略，我们看几个例子： .01 12. 12.01这都是合法的数字直接量。这里就有一个问题，也是我们标题提出的问题，我们看一段代码： 12.toString()这时候12. 会被当做省略了小数点后面部分的数字而看成一个整体，所以我们要想让点单独成为一个token，就要加入空格，这样写： 12 .toString()数字直接量还支持科学计数法，例如： 10.24E+2 10.24e-2 10.24e2这里e后面的部分，只允许使用整数。当以0x``0b 或者0o 开头时，表示特定进制的整数： 0xFA 0o73 0b10000上面这几种进制都不支持小数，也不支持科学计数法。 字符串直接量 StringLiteralJavaScript中的StringLiteral支持单引号和双引号两种写法。 &quot; DoubleStringCharacters &quot; &apos; SingleStringCharacters &apos;单双引号的区别仅仅在于写法，在双引号字符串直接量中，双引号必须转义，在单引号字符串直接量中，单引号必须转义。字符串中其他必须转义的字符是\\和所有换行符。 JavaScript中支持四种转义形式，还有一种虽然标准没有定义，但是大部分实现都支持的八进制转义。 第一种是单字符转义。 即一个反斜杠\\后面跟一个字符这种形式。 有特别意义的字符包括有SingleEscapeCharacter所定义的9种，见下表： 除了这9种字符、数字、x和u以及所有的换行符之外，其它字符经过\\转义后都是自身。 正则表达式直接量 RegularExpressionLiteral正则表达式由Body和Flags两部分组成，例如： /RegularExpressionBody/g其中Body部分至少有一个字符，第一个字符不能是（因为/跟多行注释有词法冲突）。 正则表达式有自己的语法规则，在词法阶段，仅会对它做简单解析。 正则表达式并非机械地见到/就停止，在正则表达式[ ]中的/就会被认为是普通字符。我们可以看一个例子： /[/]/.test(&quot;/&quot;);除了\\、/ 和[ 三个字符之外，JavaScript正则表达式中的字符都是普通字符。 用\\和一个非换行符可以组成一个转义，[ ]中也支持转义。正则表达式中的flag在词法阶段不会限制字符。 虽然只有ig几个是有效的，但是任何IdentifierPart（Identifier中合法的字符）序列在词法阶段都会被认为是合法的。 字符串模板 Template从语法结构上，Template是个整体，其中的 ${ } 是并列关系。 但是实际上，在JavaScript词法中，包含 ${ } 的 Template，是被拆开分析的，如： `a${b}c${d}e`它在JavaScript中被认为是： `a${ b }c${ d }e`它被拆成了五个部分： ``a${` 这个被称为模板头 }c${ 被称为模板中段 `}e`` 被称为模板尾 b 和 d 都是普通标识符 实际上，这里的词法分析过程已经跟语法分析深度耦合了。 不过我们学习的时候，大可不必按照标准和引擎工程师这样去理解，可以认为模板就是一个由反引号括起来的、可以在中间插入代码的字符串。 模板支持添加处理函数的写法，这时模板的各段会被拆开，传递给函数当参数： function f(){ console.log(arguments); } var a = &quot;world&quot; f`Hello ${a}!`; // [[&quot;Hello&quot;, &quot;!&quot;], world]模板字符串不需要关心大多数字符的转义，但是至少 ${ 和 ``` 还是需要处理的。 模板中的转义跟字符串几乎完全一样，都是使用 \\。 总结今天我们一起学习JavaScript的词法部分，这部分的内容包括了空白符号、换行符、注释、标识符名称、符号、数字直接量、字符串直接量、正则表达式直接量、字符串模板。掌握词法对我们平时调试代码至关重要。 最后，给你留一个问题：用零宽空格和零宽连接符、零宽非连接符，写一段好玩的代码。你可以给我留言，我们一起讨论。 猜你喜欢","link":"/2019/08/31/重学前端/JavaScript词法：为什么12.toString会报错？/"},{"title":"JavaScript类型：关于类型，有哪些你不知道的细节？","text":"你好，我是winter。今天我们来讲讲JavaScript的内容，在这个部分，我首先想跟你聊一聊类型。 JavaScript类型对每个前端程序员来说，几乎都是最为熟悉的概念了。但是你真的很了解它们吗？我们不妨来看看下面的几个问题。 为什么有的编程规范要求用void 0代替undefined？ 字符串有最大长度吗？ 0.1 + 0.2不是等于0.3么？为什么JavaScript里不是这样的？ ES6新加入的Symbol是个什么东西？ 为什么给对象添加的方法能用在基本类型上？ 如果你答起来还有些犹豫的地方，这就说明你对这部分知识点，还是有些遗漏之处的。没关系，今天我来帮你一一补上。 我在前面提到过，我们的JavaScript模块会从运行时、文法和执行过程三个角度去剖析JS的知识体系，本篇我们就从运行时的角度去看JavaScript的类型系统。 运行时类型是代码实际执行过程中我们用到的类型。所有的类型数据都会属于7个类型之一。从变量、参数、返回值到表达式中间结果，任何JavaScript代码运行过程中产生的数据，都具有运行时类型。 类型JavaScript语言的每一个值都属于某一种数据类型。JavaScript语言规定了7种语言类型。语言类型广泛用于变量、函数参数、表达式、函数返回值等场合。根据最新的语言标准，这7种语言类型是： Undefined； Null； Boolean； String； Number； Symbol； Object。 除了ES6中新加入的Symbol类型，剩下6种类型都是我们日常开发中的老朋友了，但是，要想回答文章一开始的问题，我们需要重新认识一下这些老朋友，下面我们就来从简单到复杂，重新学习一下这些类型。 Undefined、Null我们的第一个问题，为什么有的编程规范要求用void 0代替undefined？现在我们就分别来看一下。 Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量undefined（就是名为undefined的这个变量）来表达这个值，或者 void 运算来把任意一个表达式变成 undefined 值。 但是呢，因为JavaScript的代码undefined是一个变量，而并非是一个关键字，这是JavaScript语言公认的设计失误之一，所以，我们为了避免无意中被篡改，我建议使用 void 0 来获取undefined值。 Undefined跟 Null 有一定的表意差别，Null表示的是：“定义了但是为空”。所以，在实际编程时，我们一般不会把变量赋值为 undefined，这样可以保证所有值为 undefined 的变量，都是从未赋值的自然状态。 Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。 BooleanBoolean 类型有两个值， true 和 false，它用于表示逻辑意义上的真和假，同样有关键字 true 和 false 来表示两个值。这个类型很简单，我就不做过多介绍了。 String我们来看看字符串是否有最大长度。 String 用于表示文本数据。String 有最大长度是 2^53 - 1，这在一般开发中都是够用的，但是有趣的是，这个所谓最大长度，并不完全是你理解中的字符数。 因为String 的意义并非“字符串”，而是字符串的 UTF16 编码，我们字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16 编码。所以，字符串的最大长度，实际上是受字符串的编码长度影响的。 Note：现行的字符集国际标准，字符是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符，理论上，Unicode 的范围是无限的。UTF是Unicode的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。 Unicode 的码点通常用 U+??? 来表示，其中 ??? 是十六进制的码点值。 0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）。 JavaScript 中的字符串是永远无法变更的，一旦字符串构造出来，无法用任何方式改变字符串的内容，所以字符串具有值类型的特征。 JavaScript 字符串把每个 UTF16 单元当作一个字符来处理，所以处理非BMP（超出 U+0000 - U+FFFF 范围）的字符时，你应该格外小心。 JavaScript 这个设计继承自 Java，最新标准中是这样解释的，这样设计是为了“性能和尽可能实现起来简单”。因为现实中很少用到 BMP 之外的字符。 Number下面，我们来说说Number类型。Number类型表示我们通常意义上的“数字”。这个数字大致对应数学中的有理数，当然，在计算机中，我们有一定的精度限制。 JavaScript中的Number类型有 18437736874454810627(即2^64-2^53+3) 个值。 JavaScript 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是JavaScript为了表达几个额外的语言场景（比如不让除以0出错，而引入了无穷大的概念），规定了几个例外情况： NaN，占用了 9007199254740990，这原本是符合IEEE规则的数字； Infinity，无穷大； -Infinity，负无穷大。 另外，值得注意的是，JavaScript中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以-0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。 根据双精度浮点数的定义，Number类型中有效的整数范围是-0x1fffffffffffff至0x1fffffffffffff，所以Number无法精确表示此范围外的整数。 同样根据浮点数的定义，非整数的Number类型无法用 ==（===也不行） 来比较，一段著名的代码，这也正是我们第三题的问题，为什么在JavaScript中，0.1+0.2不能=0.3： console.log( 0.1 + 0.2 == 0.3);这里输出的结果是false，说明两边不相等的，这是浮点运算的特点，也是很多同学疑惑的来源，浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。 所以实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用JavaScript提供的最小精度值： console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON);检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。这段代码结果就是 true 了。 SymbolSymbol 是 ES6 中引入的新类型，它是一切非字符串的对象key的集合，在ES6规范中，整个对象系统被用Symbol 重塑。 在后面的文章中，我会详细叙述 Symbol 跟对象系统。这里我们只介绍Symbol类型本身：它有哪些部分，它表示什么意思，以及如何创建Symbol类型。 Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol也不相等。 我们创建 Symbol 的方式是使用全局的 Symbol 函数。例如： var mySymbol = Symbol(&quot;my symbol&quot;);一些标准中提到的 Symbol，可以在全局的 Symbol 函数的属性中找到。例如，我们可以使用 Symbol.iterator 来自定义 for…of 在对象上的行为： var o = new Object o[Symbol.iterator] = function() { var v = 0 return { next: function() { return { value: v++, done: v &gt; 10 } } } }; for(var v of o) console.log(v); // 0 1 2 3 ... 9代码中我们定义了iterator之后，用for(var v of o)就可以调用这个函数，然后我们可以根据函数的行为，产生一个for…of的行为。 这里我们给对象o添加了 Symbol.iterator 属性，并且按照迭代器的要求定义了一个0到10的迭代器，之后我们就可以在for of中愉快地使用这个o对象啦。 这些标准中被称为“众所周知”的 Symbol，也构成了语言的一类接口形式。它们允许编写与语言结合更紧密的 API。 ObjectObject 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。Object表示对象的意思，它是一切有形和无形物体的总称。 下面我们来看一看，为什么给对象添加的方法能用在基本类型上？ 在 JavaScript 中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是key-value结构，key可以是字符串或者 Symbol类型。 关于对象的机制，后面会有单独的一篇来讲述，这里我重点从类型的角度来介绍对象类型。 提到对象，我们必须要提到一个概念：类。 因为 C++ 和 Java 的成功，在这两门语言中，每个类都是一个类型，二者几乎等同，以至于很多人常常会把JavaScript的“类”与类型混淆。 事实上，JavaScript 中的“类”仅仅是运行时对象的一个私有属性，而JavaScript中是无法自定义类型的。 JavaScript中的几个基本类型，都在对象类型中有一个“亲戚”。它们是： Number； String； Boolean； Symbol。 所以，我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。 Number、String和Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。 Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。 JavaScript 语言设计上试图模糊对象和基本类型之间的关系，我们日常代码可以把对象的方法在基本类型上使用，比如： console.log(&quot;abc&quot;.charAt(0)); //a甚至我们在原型上添加方法，都可以应用于基本类型，比如以下代码，在 Symbol 原型上添加了hello方法，在任何 Symbol 类型变量都可以调用。 Symbol.prototype.hello = () =&gt; console.log(&quot;hello&quot;); var a = Symbol(&quot;a&quot;); console.log(typeof a); //symbol，a并非对象 a.hello(); //hello，有效所以我们文章开头的问题，答案就是. 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。 类型转换讲完了基本类型，我们来介绍一个现象：类型转换。 因为JS是弱类型语言，所以类型转换发生非常频繁，大部分我们熟悉的运算都会先进行类型转换。大部分类型转换符合人类的直觉，但是如果我们不去理解类型转换的严格定义，很容易造成一些代码中的判断失误。 其中最为臭名昭著的是JavaScript中的“ == ”运算，因为试图实现跨类型的比较，它的规则复杂到几乎没人可以记住。 这里我们当然也不打算讲解==的规则，它属于设计失误，并非语言中有价值的部分，很多实践中推荐禁止使用“ ==”，而要求程序员进行显式地类型转换后，用 === 比较。 其它运算，如加减乘除大于小于，也都会涉及类型转换。幸好的是，实际上大部分类型转换规则是非常简单的，如下表所示： 在这个里面，较为复杂的部分是Number和String之间的转换，以及对象跟基本类型之间的转换。我们分别来看一看这几种转换的规则。 StringToNumber字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制，比如： 30； 0b111； 0o13； 0xFF。 此外，JavaScript支持的字符串语法还包括正负号科学计数法，可以使用大写或者小写的e来表示： 1e3； -1e-2。 需要注意的是，parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。 在不传入第二个参数的情况下，parseInt只支持16进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。 在一些古老的浏览器环境中，parseInt还支持0开头的数字作为8进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入parseInt的第二个参数，而parseFloat则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。 多数情况下，Number 是比 parseInt 和 parseFloat 更好的选择。 NumberToString在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。当Number绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。这个算法细节繁多，我们从感性的角度认识，它其实就是保证了产生的字符串不会过长。 具体的算法，你可以去参考JavaScript的语言标准。由于这个部分内容，我觉得在日常开发中很少用到，所以这里我就不去详细地讲解了。 装箱转换每一种基本类型Number、String、Boolean、Symbol在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。 前文提到，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的call方法来强迫产生装箱。 我们定义一个函数，函数里面只有return this，然后我们调用函数的call方法到一个Symbol类型的值上，这样就会产生一个symbolObject。 我们可以用console.log看一下这个东西的type of，它的值是object，我们使用symbolObject instanceof 可以看到，它是Symbol这个类的实例，我们找它的constructor也是等于Symbol的，所以我们无论从哪个角度看，它都是Symbol装箱过的对象： var symbolObject = (function(){ return this; }).call(Symbol(&quot;a&quot;)); console.log(typeof symbolObject); //object console.log(symbolObject instanceof Symbol); //true console.log(symbolObject.constructor == Symbol); //true装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。 使用内置的 Object 函数，我们可以在JavaScript代码中显式调用装箱能力。 var symbolObject = Object(Symbol(&quot;a&quot;)); console.log(typeof symbolObject); //object console.log(symbolObject instanceof Symbol); //true console.log(symbolObject.constructor == Symbol); //true每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取： var symbolObject = Object(Symbol(&quot;a&quot;)); console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。 但需要注意的是，call本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。 拆箱转换在JavaScript标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。 对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。 拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。 var o = { valueOf : () =&gt; {console.log(&quot;valueOf&quot;); return {}}, toString : () =&gt; {console.log(&quot;toString&quot;); return {}} } o * 2 // valueOf // toString // TypeError我们定义了一个对象o，o有valueOf和toString两个方法，这两个方法都返回一个对象，然后我们进行o*2这个运算的时候，你会看见先执行了valueOf，接下来是toString，最后抛出了一个TypeError，这就说明了这个拆箱转换失败了。 到 String 的拆箱转换会优先调用 toString。我们把刚才的运算从o*2换成 String(o)，那么你会看到调用顺序就变了。 var o = { valueOf : () =&gt; {console.log(&quot;valueOf&quot;); return {}}, toString : () =&gt; {console.log(&quot;toString&quot;); return {}} } String(o) // toString // valueOf // TypeError在 ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为。 var o = { valueOf : () =&gt; {console.log(&quot;valueOf&quot;); return {}}, toString : () =&gt; {console.log(&quot;toString&quot;); return {}} } o[Symbol.toPrimitive] = () =&gt; {console.log(&quot;toPrimitive&quot;); return &quot;hello&quot;} console.log(o + &quot;&quot;) // toPrimitive // hello结语在本篇文章中，我们介绍了 JavaScript 运行时的类型系统。这里回顾一下今天讲解的知识点。 除了这七种语言类型，还有一些语言的实现者更关心的规范类型。 List 和 Record： 用于描述函数传参过程。 Set：主要用于解释字符集等。 Completion Record：用于描述异常、跳出等语句执行过程。 Reference：用于描述对象属性访问、delete等。 Property Descriptor：用于描述对象的属性。 Lexical Environment 和 Environment Record：用于描述变量和作用域。 Data Block：用于描述二进制数据。 有一个说法是：程序 = 算法 + 数据结构，运行时类型包含了所有 JavaScript 执行时所需要的数据结构的定义，所以我们要对它格外重视。 最后我们留一个实践问题，如果我们不用原生的Number和parseInt，用JavaScript代码实现String到Number的转换，该怎么做呢？请你把自己的代码留言给我吧！ 补充阅读事实上，“类型”在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JavaScript语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。我们可以看下表来对照一下。 在表格中，多数项是对应的，但是请注意object——Null和function——Object是特例，我们理解类型的时候需要特别注意这个区别。 从一般语言使用者的角度来看，毫无疑问，我们应该按照 typeof 的结果去理解语言的类型系统。但JavaScript之父本人也在多个场合表示过，typeof 的设计是有缺陷的，只是现在已经错过了修正它的时机。 猜你喜欢","link":"/2019/08/31/重学前端/JavaScript类型：关于类型，有哪些你不知道的细节？/"},{"title":"JavaScript语法（二）：你知道哪些JavaScript语句？","text":"你好，我是winter。 我们在上一节课中已经讲过了JavaScript语法的顶层设计，接下来我们进入到更具体的内容。 JavaScript遵循了一般编程语言的“语句-表达式”结构，多数编程语言都是这样设计的。我们在上节课讲的脚本，或者模块都是由语句列表构成的，这一节课，我们就来一起了解一下语句。 在JavaScript标准中，把语句分成了两种：声明和语句，不过，这里的区分逻辑比较奇怪，所以，这里我还是按照自己的思路给你整理一下。 普通语句： 声明型语句： 我们根据上面的分类，来遍历学习一下这些语句。 语句块我们可以这样去简单理解，语句块就是一对大括号。 { var x, y; x = 10; y = 20; }语句块的意义和好处在于：让我们可以把多行语句视为同一行语句，这样，if、for等语句定义起来就比较简单了。不过，我们需要注意的是，语句块会产生作用域，我们看一个例子： { let x = 1; } console.log(x); // 报错这里我们的let声明，仅仅对语句块作用域生效，于是我们在语句块外试图访问语句块内的变量x就会报错。 空语句空语句就是一个独立的分号，实际上没什么大用。我们来看一下： ;空语句的存在仅仅是从语言设计完备性的角度考虑，允许插入多个分号而不抛出错误。 if语句if语句是条件语句。我想，对多数人来说，if语句都是熟悉的老朋友了，也没有什么特别需要注意的用法，但是为了我们课程的完备性，这里还是要讲一下。 if语句示例如下： if(a &lt; b) console.log(a);if语句的作用是，在满足条件时执行它的内容语句，这个语句可以是一个语句块，这样就可以实现有条件地执行多个语句了。 if语句还有else结构，用于不满足条件时执行，一种常见的用法是，利用语句的嵌套能力，把if和else连写成多分支条件判断： if(a &lt; 10) { //... } else if(a &lt; 20) { //... } else if(a &lt; 30) { //... } else { //... }这段代码表示四个互斥的分支，分别在满足a&lt;10、a&lt;20、a&lt;30和其它情况时执行。 switch语句switch语句继承自Java，Java中的switch语句继承自C和C++，原本switch语句是跳转的变形，所以我们如果要用它来实现分支，必须要加上break。 其实switch原本的设计是类似goto的思维。我们看一个例子： switch(num) { case 1: print(1); case 2: print 2; case 3: print 3; }这段代码当num为1时输出1 2 3，当num为2时输出2 3，当num为3时输出3。如果我们要把它变成分支型，则需要在每个case后加上break。 switch(num) { case 1: print 1; break; case 2: print 2; break; case 3: print 3; break; }在C时代，switch生成的汇编代码性能是略优于if else的，但是对JavaScript来说，则无本质区别。我个人的看法是，现在switch已经完全没有必要使用了，应该用if else结构代替。 循环语句循环语句应该也是你所熟悉的语句了，这里我们把重点放在一些新用法上。 while循环和do while循环这两个都是历史悠久的JavaScript语法了，示例大概如下： let a = 100 while(a--) { console.log(&quot;*&quot;); } let a = 101; do { console.log(a); } while(a &lt; 100)注意，这里do while循环无论如何至少会执行一次。 普通for循环首先我们来看看普通的for循环。 for(i = 0; i &lt; 100; i++) console.log(i); for(var i = 0; i &lt; 100; i++) console.log(i); for(let i = 0; i &lt; 100; i++) console.log(i); var j = 0; for(const i = 0; j &lt; 100; j++) console.log(i);这里为了配合新语法，加入了允许let和const，实际上，const在这里是非常奇葩的东西，因为这里声明和初始化的变量，按惯例是用于控制循环的，但是它如果是const就没法改了。 我想，这一点可能是从保持let和const一致性的角度考虑的吧。 for in循环for in 循环枚举对象的属性，这里体现了属性的enumerable特征。 let o = { a: 10, b: 20} Object.defineProperty(o, &quot;c&quot;, {enumerable:false, value:30}) for(let p in o) console.log(p);这段代码中，我们定义了一个对象o，给它添加了不可枚举的属性c，之后我们用for in循环枚举它的属性，我们会发现，输出时得到的只有a和b。 如果我们定义c这个属性时，enumerable为true，则for in循环中也能枚举到它。 for of循环和for await of循环for of循环是非常棒的语法特性。 我们先看下基本用法，它可以用于数组： for(let e of [1, 2, 3, 4, 5]) console.log(e);但是实际上，它背后的机制是iterator机制。 我们可以给任何一个对象添加iterator，使它可以用于for of语句，看下示例： let o = { [Symbol.iterator]:() =&gt; ({ _value: 0, next(){ if(this._value == 10) return { done: true } else return { value: this._value++, done: false }; } }) } for(let e of o) console.log(e);这段代码展示了如何为一个对象添加iterator。但是，在实际操作中，我们一般不需要这样定义iterator，我们可以使用generator function。 function* foo(){ yield 0; yield 1; yield 2; yield 3; } for(let e of foo()) console.log(e);这段代码展示了generator function和foo的配合。 此外，JavaScript还为异步生成器函数配备了异步的for of，我们来看一个例子： function sleep(duration) { return new Promise(function(resolve, reject) { setTimeout(resolve,duration); }) } async function* foo(){ i = 0; while(true) { await sleep(1000); yield i++; } } for await(let e of foo()) console.log(e);这段代码定义了一个异步生成器函数，异步生成器函数每隔一秒生成一个数字，这是一个无限的生成器。 接下来，我们使用for await of来访问这个异步生成器函数的结果，我们可以看到，这形成了一个每隔一秒打印一个数字的无限循环。 但是因为我们这个循环是异步的，并且有时间延迟，所以，这个无限循环的代码可以用于显示时钟等有意义的操作。 returnreturn语句用于函数中，它终止函数的执行，并且指定函数的返回值，这是大家非常熟悉语句了，也没有什么特殊之处。 function squre(x){ return x * x; }这段代码展示了return的基本用法。它后面可以跟一个表达式，计算结果就是函数返回值。 break语句和continue语句break语句用于跳出循环语句或者switch语句，continue语句用于结束本次循环并继续循环。 这两个语句都属于控制型语句，用法也比较相似，所以我们就一起讲了。需要注意的是，它们都有带标签的用法。 outer:for(let i = 0; i &lt; 100; i++) inner:for(let j = 0; j &lt; 100; j++) if( i == 50 &amp;&amp; j == 50) break outer; outer:for(let i = 0; i &lt; 100; i++) inner:for(let j = 0; j &lt; 100; j++) if( i &gt;= 50 &amp;&amp; j == 50) continue outer;带标签的break和continue可以控制自己被外层的哪个语句结构消费，这可以跳出复杂的语句结构。 with语句with语句是个非常巧妙的设计，但它把JavaScript的变量引用关系变得不可分析，所以一般都认为这种语句都属于糟粕。 但是历史无法改写，现在已经无法去除with了。我们来了解一下它的基本用法即可。 let o = {a:1, b:2} with(o){ console.log(a, b); }with语句把对象的属性在它内部的作用域内变成变量。 try语句和throw语句try语句和throw语句用于处理异常。它们是配合使用的，所以我们就放在一起讲了。在大型应用中，异常机制非常重要。 try { throw new Error(&quot;error&quot;); } catch(e) { console.log(e); } finally { console.log(&quot;finally&quot;); }一般来说，throw用于抛出异常，但是单纯从语言的角度，我们可以抛出任何值，也不一定是异常逻辑，但是为了保证语义清晰，不建议用throw表达任何非异常逻辑。 try语句用于捕获异常，用throw抛出的异常，可以在try语句的结构中被处理掉：try部分用于标识捕获异常的代码段，catch部分则用于捕获异常后做一些处理，而finally则是用于执行后做一些必须执行的清理工作。 catch结构会创建一个局部的作用域，并且把一个变量写入其中，需要注意，在这个作用域，不能再声明变量e了，否则会出错。 在catch中重新抛出错误的情况非常常见，在设计比较底层的函数时，常常会这样做，保证抛出的错误能被理解。 finally语句一般用于释放资源，它一定会被执行，我们在前面的课程中已经讨论过一些finally的特征，即使在try中出现了return，finally中的语句也一定要被执行。 debugger语句debugger语句的作用是：通知调试器在此断点。在没有调试器挂载时，它不产生任何效果。 介绍完普通语句，我们再来看看声明型语句。声明型语句跟普通语句最大区别就是声明型语句响应预处理过程，普通语句只有执行过程。 varvar声明语句是古典的JavaScript中声明变量的方式。而现在，在绝大多数情况下，let和const都是更好的选择。 我们在上一节课已经讲解了var声明对全局作用域的影响，它是一种预处理机制。 如果我们仍然想要使用var，我的个人建议是，把它当做一种“保障变量是局部”的逻辑，遵循以下三条规则： 声明同时必定初始化； 尽可能在离使用的位置近处声明； 不要在意重复声明。 例如： var x = 1, y = 2; doSth(x, y); for(var x = 0; x &lt; 10; x++) doSth2(x);这个例子中，两次声明了变量x，完成了两段逻辑，这两个x意义上可能不一定相关，这样，不论我们把代码复制粘贴在哪里，都不会出错。 当然，更好的办法是使用let改造，我们看看如何改造： { let x = 1, y = 2; doSth(x, y); } for(let x = 0; x &lt; 10; x++) doSth2(x);这里我用代码块限制了第一个x的作用域，这样就更难发生变量命名冲突引起的错误了。 let和constlet和const是都是变量的声明，它们的特性非常相似，所以我们放在一起讲了。let和const是新设计的语法，所以没有什么硬伤，非常地符合直觉。let和const的作用范围是if、for等结构型语句。 我们看下基本用法： const a = 2; if(true){ const a = 1; console.log(a); } console.log(a);这里的代码先在全局声明了变量a，接下来又在if内声明了a，if内构成了一个独立的作用域。 const和let语句在重复声明时会抛错，这能够有效地避免变量名无意中冲突： let a = 2 const a = 1;这段代码中，先用let声明了a，接下来又试图使用const声明变量a，这时，就会产生错误。 let和const声明虽然看上去是执行到了才会生效，但是实际上，它们还是会被预处理。如果当前作用域内有声明，就无法访问到外部的变量。我们来看这段代码： const a = 2; if(true){ console.log(a); //抛错 const a = 1; }这里在if的作用域中，变量a声明执行到之前，我们访问了变量a，这时会抛出一个错误，这说明const声明仍然是有预处理机制的。 在执行到const语句前，我们的JavaScript引擎就已经知道后面的代码将会声明变量a，从而不允许我们访问外层作用域中的a。 class声明我们在之前的课程中，已经了解过class相关的用法。这里我们再从语法的角度来看一遍： class a { }class最基本的用法只需要class关键字、名称和一对大括号。它的声明特征跟const和let类似，都是作用于块级作用域，预处理阶段则会屏蔽外部变量。 const a = 2; if(true){ console.log(a); //抛错 class a { } }class内部，可以使用constructor关键字来定义构造函数。还能定义getter/setter和方法。 class Rectangle { constructor(height, width) { this.height = height; this.width = width; } // Getter get area() { return this.calcArea(); } // Method calcArea() { return this.height * this.width; } }这个例子来自MDN，它展示了构造函数、getter和方法的定义。 以目前的兼容性，class中的属性只能写在构造函数中，相关标准正在TC39讨论。 需要注意，class默认内部的函数定义都是strict模式的。 函数声明函数声明使用 function 关键字。 在上一节课中，我们已经讨论过函数声明对全局作用域的影响了。这一节课，我们来看看函数声明具体的内容，我们先看一下函数声明的几种类型。 function foo(){ } function* foo(){ yield 1; yield 2; yield 3; } async function foo(){ await sleep(3000); } async function* foo(){ await sleep(3000); yield 1; }带*的函数是generator，我们在前面的部分已经见过它了。生成器函数可以理解为返回一个序列的函数，它的底层是iterator机制。 async函数是可以暂停执行，等待异步操作的函数，它的底层是Promise机制。异步生成器函数则是二者的结合。 函数的参数，可以只写形参名，现在还可以写默认参数和指定多个参数，看下例子： function foo(a = 1, ...other) { console.log(a, other) }这个形式可以代替一些对参数的处理代码，表意会更加清楚。 结语今天我们一起学习了语句家族，语句分成了普通语句和声明型语句。 普通语句部分，建议你把重点放在循环语句上面。声明型语句我觉得都很重要，尤其是它们的行为。熟练掌握了它们，我们就可以在工作中去综合运用它们，从而减少代码中的错误。新特性大多可以帮助我们发现代码中的错误。 最后留一个小作业，请你找出所有具有Symbol.iterator的原生对象，并且看看它们的for of遍历行为。","link":"/2019/08/31/重学前端/JavaScript语法（二）：你知道哪些JavaScript语句？/"},{"title":"列一份前端知识架构图","text":"你好，我是winter。 在上一篇文章中，我们简要地总结了前端的学习路径与方法，我们提到的第一个学习方法就是：建立知识框架。那么，今天我们就一起来列一份前端的知识框架图。 在开始列框架之前，我想先来谈谈我们的目标。实际上，我们在网上可以找到很多参考资料，比如MDN这样的参考手册，又比如一份语言标准，但是我们的课程既不是一本参考手册，也不是一份语言标准。参考手册希望做到便于查阅、便于理解和全面，语言标准的目标是严谨、无遗漏、无歧义。 而我们的课程有什么不同呢？我认为，作为一个课程，有两个目标：一个是把无法通过查阅解决的原理和背景讲清楚，另一个是把不方便查阅和记忆的内容整理好。 我会尽量避免像前面提到的两种文档一样逐条目罗列知识点和细节，当然，这不是在说两种文档没有价值，而是我们各有分工，参考手册和语言标准做的事情，我们没必要重复去做，即使做了也不一定能做得更好。 在这个课程里，我希望能和你一起打造一个前端知识的框架，再把知识点做个遍历，这其中，有原理和背景的部分，我去讲解知识的原理和背景。如果没有的话，我们就去讲整理和记忆这部分知识的方法，这样，即使你遇见无法一下子记住的知识，也可以很容易地查阅参考手册和标准来解决。 如果让我做一个划分，前端的知识在总体上分成基础部分和实践部分，基础部分包含了JavaScript语言（模块一）、CSS和HTML（模块二）以及浏览器的实现原理和API（模块三），这三个模块涵盖了一个前端工程师所需要掌握的全部知识。 学完这三个部分，你再结合基本的编程能力，就可以应对基本的前端开发工作了。实践部分（模块四）重点会介绍我在工作过程中遇到的问题和解决方案，希望这块内容能够帮助你和你的前端团队找到可能的发展方向和着力点。 JavaScript 上面是我整理的JavaScript知识架构图，下面我们来具体解释一下。 在JavaScript的模块中，首先我们可以把语言按照文法、语义和运行时来拆分，这符合编程语言的一般规律：用一定的词法和语法，表达一定语义，从而操作运行时。 接下来，我们又按照程序的一般规律，把运行时分为数据结构和算法部分：数据结构包含类型和实例（JavaScript的类型系统就是它的7种基本类型和7种语言类型，实例就是它的内置对象部分）。所谓的算法，就是JavaScript的执行过程。 类型部分中，对象比其它所有类型加起来都要更为复杂，所以我们会用较长的篇幅来讲解对象，包括它的一些历史和设计思路。 执行过程我们则需要按照从大结构到小结构的角度讲解，从最顶层的程序与模块、事件循环和微任务，到函数、再到语句级的执行。我们从粗到细地了解执行过程。 实例部分，对JavaScript来说类似基础库，JavaScipt的内置对象多达150以上，考虑到我们即使逐次讲解也必定不如MDN更加细致全面，所以我们会从应用和机制的角度，挑选其中几个体系来讲解。 文法中的语法和语义基本是一一对应关系，在JavaScript标准中有一份语法定义表，它同样不适合一一讲解，我们会从JavaScript语法中特别的地方，以及与日常开发比较相关的地方来重点讲解，剩下的内容和词法部分，我们会带领大家做一些数据挖掘工作，从这份表格中找到一些和我们日常开发息息相关的内容。 语义的大部分内容我们会在运行时的讲解中透出，同时它又跟语法有对应的关系，所以我们不再单独拿出来讲解。 HTML 和 CSS 上面是我整理的HTML和CSS的知识架构图，我们来具体解释一下。 在HTML的部分，我们会按照功能和语言来划分它的知识，HTML的功能主要由标签来承担，所以我们首先会把标签做一些分类，并对它们分别进行讲解。 我们都知道HTML的标签可以分为很多种，head里面的我们称为元信息类标签，诸如title、meta、style、link、base这些，它们用来描述文档的一些基本信息。还有一类是一些诸如section、nav的标签，它们在视觉表现上跟div并没有区别，但是各有各的适用场景，我们把它们称作语义类标签。另外一类是img、video、audio之类的替换型媒体类标签，用来引入外部内容，平常开发中你也会经常用到。再有就是表单类的，比如input、button。 所以，基于这样的分类，我把标签分成下面几种。 文档元信息：通常是出现在head标签中的元素，包含了描述文档自身的一些信息； 语义相关：扩展了纯文本，表达文章结构、不同语言要素的标签； 链接：提供到文档内和文档外的链接； 替换型标签：引入声音、图片、视频等外部元素替换自身的一类标签； 表单：用于填写和提交信息的一类标签； 表格：表头、表尾、单元格等表格的结构。 我们的重点会放在前四种标签上，表单和表格较少用到，而且基本以查阅型知识为主，这里就不拿出来讲解了。 除了标签之外，我们还应该把HTML当作一门语言来了解下，当然，标记语言跟编程语言不太一样，没有编程语言那么严谨，所以，我们会简要介绍HTML的语法和几个重要的语言机制：实体、命名空间。 最后我们会介绍下HTML的补充标准：ARIA，它是HTML的扩展，在可访问性领域，它有至关重要的作用。 CSS部分，按照惯例，我们也会从语言和功能两个角度去介绍。在语言部分，我们会从大到小介绍CSS的各种语法结构，比如@rule、选择器、单位等等。功能部分，我们大致可以分为布局、绘制和交互类。 在布局类我们介绍两个最常用的布局：正常流和弹性布局。绘制类我们则会分成图形相关的和文字相关的绘制。最后我们会介绍动画和其它交互。 浏览器的实现原理和API 上面是我整理的浏览器知识架构图，我们来具体看一下。 浏览器部分我们会先介绍下浏览器的实现原理，这是我们深入理解API的基础。 我们会从一般的浏览器设计出发，按照解析、构建DOM树、计算CSS、渲染、合成和绘制的流程来讲解浏览器的工作原理。 在API部分，我们会从W3C零散的标准中挑选几个大块的API来详细讲解，主要有：事件、DOM、CSSOM几个部分，它们分别覆盖了交互、语义和可见效果，这是我们工作中用到的主要内容。 其他的API怎么办呢，别着急，在最后，我会给出一份Chrome已经实现的API跟W3C标准的对应关系和它的生成过程，来覆盖其它部分。 前端工程实践 最后一个模块是前端工程实践。我们在掌握了前面的基础知识之后，也就基本掌握了做一个前端工程师的底层能力。在这个模块中，我选择了性能、工具链、持续集成、搭建系统、架构与基础库这几个方向的前端工程实践案例，来与你一起分享我的经验。 性能首先我们会谈谈性能。对任何一个前端团队而言，性能是它价值的核心指标，从早年“重构”的实践开始，前端有通过性能证明自己价值的传统。 但是性能并非细节的堆砌，也不是默默做优化，所以，我会从团队的角度来跟你一起探讨性能的方法论和技术体系。 工具链下一个案例是工具链。这一部分，我将会探讨企业中工具链的建设思路。对一个高效又合作良好的前端团队来说，一致性的工具链是不可或缺的保障，作为开发阶段的入口，工具链又可以和性能、发布、持续集成等系统链接到一起，成为团队技术管理的基础。 持续集成接下来还会给大家介绍前端的持续集成，持续集成并非一个新概念，但是过去持续集成概念和理论都主要针对软件开发，而对前端来说，持续集成是一个新的课题（当然对持续集成来说，前端也是一个新课题），比如daily build就完全不适用前端，前端代码必须是线上实时可用的。这一部分内容将会针对前端的持续集成提出一些建设的思路。 搭建系统接下来的案例是搭建系统，前端工作往往多而繁杂，针对高重复性、可模块化的业务需求，传统的人工开发不再适用，搭建系统是大部分大型前端团队的选择。这一部分内容我将会介绍什么是搭建系统，以及一些常见的搭建系统类型。 架构与基础库最后一个部分，会给大家介绍前端架构和基础库的知识。软件架构师主要解决功能复杂性的问题，服务端架构师主要解决高流量问题，而前端是页面间天然解耦，分散在用户端运行的系统，但是前端架构也有自己要解决的问题。 前端需求量大、专业人才稀缺，更因为前端本身运行在浏览器中，有大量兼容工作要做。所以前端架构的主要职责是兼容性、复用和能力扩展。这一部分文章我将会介绍前端架构工作的一些思路和切入点。 上面的这些案例来自我在领导手淘前端团队时的经验，和我在阿里巴巴工作参与晋升面试时听到的案例，这些内容几乎是每一个年轻的前端团队成长过程中都会需要的基础设施。 好了，前端的知识体系我们大致列出来了。你可能发现了，知识体系图中的每一个知识点，专栏里都有与之对应的文章，这也是我的初衷：希望借由讲解这40余个知识点，帮你建立起前端的知识框架。 （长按保存高清大图） 讲述形式基于这份知识框架图，我们的课程主要采用两种讲述形式：一种是重点讲解的课程，一种是知识图谱型的课程。 重点讲解的课程我们会从技术的背景、原理和设计出发，把知识的内容呈现出来。这种形式适用于有体系和源流的知识，比较适合系统学习和理解，比如JavaScript中的对象、CSS的排版。 知识图谱型的课程则提供一些方法，用表格或者脑图的形式来整理知识的结构。这种形式适用于零散的知识，比较适合记住大概，用到时去查阅，比如JavaScript的词法、HTML中的所有标签、以及浏览器中的API就十分适合这样的讲解方式。 结语今天我带你一起划分了前端的知识内容，前端的基础知识分成JavaScript、HTML、CSS以及浏览器四大重点模块，每个模块也分别有自己的技术重点。你可以在框架中，挑选你最需要的前端知识，按需学习。 当然，这篇文章最重要的是，我希望能帮你建立一个理解前端的全景图。这样，任何时候，你都能够体系地思考问题，分析问题。 你觉得你的划分跟我一样吗，你还有其他的想法，你觉得是否有想了解的知识不在其中，欢迎给我留言。","link":"/2019/08/31/重学前端/列一份前端知识架构图/"},{"title":"JavaScript语法（预备篇）：到底要不要写分号呢？","text":"你好，我是winter。 在我们介绍JavaScript语法的全局结构之前，我们先要探讨一个语言风格问题：究竟要不要写分号。 这是一个非常经典的口水问题，“加分号”党和“不写分号”党之间的战争，可谓是经久不息。 实际上，行尾使用分号的风格来自于Java，也来自于C语言和C++，这一设计最初是为了降低编译器的工作负担。 但是，从今天的角度来看，行尾使用分号其实是一种语法噪音，恰好JavaScript语言又提供了相对可用的分号自动补全规则，所以，很多JavaScript的程序员都是倾向于不写分号。 这里要特意说一点，在今天的文章中，我并不希望去售卖自己的观点（其实我是属于“加分号”党），而是希望比较中立地给你讲清楚相关的知识，让你具备足够的判断力。 我们首先来了解一下自动插入分号的规则。 自动插入分号规则自动插入分号规则其实独立于所有的语法产生式定义，它的规则说起来非常简单，只有三条。 要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。 有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。 源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。 这样描述是比较难以理解的，我们一起看一些实际的例子进行分析： let a = 1 void function(a){ console.log(a); }(a);在这个例子中，第一行的结尾处有换行符，接下来void关键字接在1之后是不合法的，这命中了我们的第一条规则，因此会在void前插入换行符。 var a = 1, b = 1, c = 1; a ++ b ++ c这也是个著名的例子，我们看第二行的a之后，有换行符，后面遇到了++运算符，a后面跟++是合法的语法，但是我们看看JavaScript标准定义中，有[no LineTerminator here]这个字样，这是一个语法定义中的规则，你可以感受一下这个规则的内容（下一小节，我会给你详细介绍no LineTerminator here ）： UpdateExpression[Yield, Await]: LeftHandSideExpression[?Yield, ?Await] LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]++ LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]-- ++UnaryExpression[?Yield, ?Await] --UnaryExpression[?Yield, ?Await]于是，这里a的后面就要插入一个分号了。所以这段代码最终的结果，b和c都变成了2，而a还是1。 (function(a){ console.log(a); })() (function(a){ console.log(a); })()这个例子是比较有实际价值的例子，这里两个function调用的写法被称作IIFE（立即执行的函数表达式），是个常见技巧。 这段代码意图上显然是形成两个IIFE。 我们来看第三行结束的位置，JavaScript引擎会认为函数返回的可能是个函数，那么，在后面再跟括号形成函数调用就是合理的，因此这里不会自动插入分号。 这是一些鼓励不写分号的编码风格会要求大家写IIFE时必须在行首加分号的原因。 function f(){ return/* This is a return value. */1; } f();在这个例子中，return和1被用注释分隔开了。 根据JavaScript自动插入分号规则，带换行符的注释也被认为是有换行符，而恰好的是，return也有[no LineTerminator here]规则的要求。所以这里会自动插入分号，f执行的返回值是undefined。 no LineTerminator here 规则好了，到这里我们已经讲清楚了分号自动插入的规则，但是我们要想彻底掌握分号的奥秘，就必须要对JavaScript的语法定义做一些数据挖掘工作。 no LineTerminator here规则表示它所在的结构中的这一位置不能插入换行符。 自动插入分号规则的第二条：有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。跟no LineTerminator here规则强相关，那么我们就找出JavaScript语法定义中的这些规则。 为了方便你理解，我把产生式换成了实际的代码。 下面一段代码展示了，带标签的continue语句，不能在continue后插入换行。 outer:for(var j = 0; j &lt; 10; j++) for(var i = 0; i &lt; j; i++) continue /*no LineTerminator here*/ outterbreak跟continue是一样的，break后也不能插入换行： outer:for(var j = 0; j &lt; 10; j++) for(var i = 0; i &lt; j; i++) break /*no LineTerminator here*/ outter我们前面已经提到过return和后自增、后自减运算符。 function f(){ return /*no LineTerminator here*/1; } i/*no LineTerminator here*/++ i/*no LineTerminator here*/--以及，throw和Exception之间也不能插入换行符： throw/*no LineTerminator here*/new Exception(&quot;error&quot;)凡是async关键字，后面都不能插入换行符： async/*no LineTerminator here*/function f(){ } const f = async/*no LineTerminator here*/x =&gt; x*x箭头函数的箭头前，也不能插入换行： const f = x/*no LineTerminator here*/=&gt; x*xyield之后，不能插入换行： function *g(){ var i = 0; while(true) yield/*no LineTerminator here*/i++; }到这里，我已经整理了所有标准中的no LineTerminator here规则，实际上，no LineTerminator here规则的存在，多数情况是为了保证自动插入分号行为是符合预期的，但是令人遗憾的是，JavaScript在设计的最初，遗漏了一些重要的情况，所以有一些不符合预期的情况出现，需要我们格外注意。 不写分号需要注意的情况下面我们来看几种不写分号容易造成错误的情况，你可以稍微注意一下，避免发生同样的问题。 以括号开头的语句我们在前面的案例中，已经展示了一种情况，那就是以括号开头的语句： (function(a){ console.log(a); })()/*这里没有被自动插入分号*/ (function(a){ console.log(a); })()这段代码看似两个独立执行的函数表达式，但是其实第三组括号被理解为传参，导致抛出错误。 以数组开头的语句除了括号，以数组开头的语句也十分危险： var a = [[]]/*这里没有被自动插入分号*/ [3, 2, 1, 0].forEach(e =&gt; console.log(e))这段代码本意是一个变量a赋值，然后对一个数组执行forEach，但是因为没有自动插入分号，被理解为下标运算符和逗号表达式，我这个例子展示的情况，甚至不会抛出错误，这对于代码排查问题是个噩梦。 以正则表达式开头的语句正则表达式开头的语句也值得你去多注意一下。我们来看这个例子。 var x = 1, g = {test:()=&gt;0}, b = 1/*这里没有被自动插入分号*/ /(a)/g.test(&quot;abc&quot;) console.log(RegExp.$1)这段代码本意是声明三个变量，然后测试一个字符串中是否含有字母a，但是因为没有自动插入分号，正则的第一个斜杠被理解成了除号，后面的意思就都变了。 注意，我构造的这个例子跟上面的例子一样，同样不会抛错，凡是这一类情况，都非常致命。 以Template开头的语句以Template开头的语句比较少见，但是跟正则配合时，仍然不是不可能出现： var f = function(){ return &quot;&quot;; } var g = f/*这里没有被自动插入分号*/ `Template`.match(/(a)/); console.log(RegExp.$1)这段代码本意是声明函数f，然后赋值给g，再测试Template中是否含有字母a。但是因为没有自动插入分号，函数f被认为跟Template一体的，进而被莫名其妙地执行了一次。 总结这一节课，我们讨论了要不要加分号的问题。 首先我们介绍了自动插入分号机制，又对JavaScript语法中的no line terminator规则做了个整理，最后，我挑选了几种情况，为你介绍了不写分号需要注意的一些常见的错误。 最后留给你一个问题，请找一些开源项目，看看它们的编码规范是否要求加分号，欢迎留言讨论。","link":"/2019/08/31/重学前端/JavaScript语法（预备篇）：到底要不要写分号呢？/"},{"title":"JavaScript语法（四）：新加入的**运算符，哪里有些不一样呢？","text":"你好，我是winter。 上一节课我们已经给你介绍了表达式的一些结构，其中关于赋值表达式，我们讲完了它的左边部分，而留下了它右边部分，那么，我们这节课一起来详细讲解。 在一些通用的计算机语言设计理论中，能够出现在赋值表达式右边的叫做：右值表达式（RightHandSideExpression），而在JavaScript标准中，规定了在等号右边表达式叫做条件表达式（ConditionalExpression），不过，在JavaScript标准中，从未出现过右值表达式字样。 JavaScript标准也规定了左值表达式同时都是条件表达式（也就是右值表达式），此外，左值表达式也可以通过跟一定的运算符组合，逐级构成更复杂的结构，直到成为右值表达式。 关于这块的知识，我们有时会看到按照运算符来组织的讲解形式。 这样讲解形式是因为：对运算符来说的“优先级”，如果从我们语法的角度来看，那就是“表达式的结构”。讲“乘法运算的优先级高于加法”，从语法的角度看就是“乘法表达式和加号运算符构成加法表达式”。 对于右值表达式来说，我们可以理解为以左值表达式为最小单位开始构成的，接下来我们就来看看左值表达式是如何一步步构成更为复杂的语法结构。 更新表达式 UpdateExpression左值表达式搭配 ++``-- 运算符，可以形成更新表达式。 -- a; ++ a; a -- a ++更新表达式会改变一个左值表达式的值。分为前后自增，前后自减一共四种。 我们要注意一下，这里在ES2018中，跟早期版本有所不同，前后自增自减运算被放到了同一优先级。 一元运算表达式 UnaryExpression更新表达式搭配一元运算符，可以形成一元运算表达式，我们看下例子： delete a.b; void a; typeof a; - a; ~ a; ! a; await a;它的特点就是一个更新表达式搭配了一个一元运算符。 乘方表达式 ExponentiationExpression乘方表达式也是由更新表达式构成的。它使用**号。 ++i ** 30 2 ** 30 //正确 -2 ** 30 //报错我们看一下例子，-2这样的一元运算表达式，是不可以放入乘方表达式的，如果需要表达类似的逻辑，必须加括号。 这里我们需要注意一下结合性，**运算是右结合的，这跟其它正常的运算符（也就是左结合运算符）都不一样。 我们来看一个例子。 4 ** 3 ** 2事实上，它是这样被运算的： 4 ** (3 ** 2)而不是这样被运算的： (4 ** 3) ** 2我们来实际在代码中执行一下试试。最终结果是262144， 而不是4096。 乘法表达式 MultiplicativeExpression到这里，我们进入了比较熟悉的表达式类型，乘方表达式可以构成乘法表达式，用乘号或者除号、取余符号连接就可以了，我们看看例子： x * 2;乘法表达式有三种运算符： * / %它们分别表示乘、除和取余。它们的优先级是一样的，所以统一放在乘法运算表达式中。 加法表达式 AdditiveExpression加法表达式是由乘法表达式用加号或者减号连接构成的。我们看下例子: a + b * c加法表达式有加号和减号两种运算符。 + -这就是我们小学学的加法和减法的意思了。不过要注意，加号还能表示字符串连接，这也比较符合一般的直觉。 移位表达式 ShiftExpression移位表达式由加法表达式构成，移位是一种位运算，分成三种： &lt;&lt; 向左移位 &gt;&gt; 向右移位 &gt;&gt;&gt; 无符号向右移位移位运算把操作数看做二进制表示的整数，然后移动特定位数。所以左移n位相当于乘以2的n次方，右移n位相当于除以2取整n次。 普通移位会保持正负数。无符号移位会把减号视为符号位1，同时参与移位： -1 &gt;&gt;&gt; 1这个会得到2147483647，也就是2的31次方，跟负数的二进制表示法相关，这里就不详细讲解了。 在JavaScript中，二进制操作整数并不能提高性能，移位运算这里也仅仅作为一种数学运算存在，这些运算存在的意义也仅仅是照顾C系语言用户的习惯了。 关系表达式 RelationalExpression移位表达式可以构成关系表达式，这里的关系表达式就是大于、小于、大于等于、小于等于等运算符号连接，统称为关系运算。 &lt;= &gt;= &lt; &gt; instanceof in需要注意，这里的&lt;= 和 &gt;= 关系运算，完全是针对数字的，所以 &lt;= 并不等价于 &lt; 或 ==。例如： null &lt;= undefined //false null == undefined //true请你务必不要用数学上的定义去理解这些运算符。 相等表达式 EqualityExpression在语法上，相等表达式是由关系表达式用相等比较运算符（如 ==）连接构成的。所以我们可以像下面这段代码一样使用，而不需要加括号。 a instanceof &quot;object&quot; == true相等表达式由四种运算符和关系表达式构成，我们来看一下运算符： == != === !== 相等表达式又包含一个JavaScript中著名的设计失误，那就是 == 的行为。 一些编程规范甚至要求完全避免使用 == 运算，我觉得这样规定是比较合理的，但是这里我还是尽量解释一下 == 的行为。 虽然标准中写的==十分复杂，但是归根结底，类型不同的变量比较时==运算只有三条规则： undefined与null相等； 字符串和bool都转为数字再比较； 对象转换成primitive类型再比较。 这样我们就可以理解一些不太符合直觉的例子了，比如： false == '0' true true == 'true' false [] == 0 true [] == false true new Boolean('false') == false false 这里不太符合直觉的有两点： 一个是即使字符串与boolean比较，也都要转换成数字； 另一个是对象如果转换成了primitive类型跟等号另一边类型恰好相同，则不需要转换成数字。 此外，== 的行为也经常跟if的行为（转换为boolean）混淆。总之，我建议，仅在确认 == 发生在Number和String类型之间时使用，比如： document.getElementsByTagName(&apos;input&apos;)[0].value == 100在这个例子中，等号左边必然是string，右边的直接量必然是number，这样使用 == 就没有问题了。 位运算表达式位运算表达式含有三种： 按位与表达式 BitwiseANDExpression 按位异或表达式 BitwiseANDExpression 按位或表达式 BitwiseORExpression。 位运算表达式关系比较紧密，我们这里放到一起来讲。 按位与表达式由按位与运算符（&amp;）连接按位异或表达式构成，按位与表达式把操作数视为二进制整数，然后把两个操作数按位做与运算。 按位异或表达式由按位异或运算符（^）连接按位与表达式构成，按位异或表达式把操作数视为二进制整数，然后把两个操作数按位做异或运算。异或两位相同时得0，两位不同时得1。 异或运算有个特征，那就是两次异或运算相当于取消。所以有一个异或运算的小技巧，就是用异或运算来交换两个整数的值。 let a = 102, b = 324; a = a ^ b; b = a ^ b; a = a ^ b; console.log(a, b);按位或表达式由按位或运算符（|）连接相等表达式构成，按位或表达式把操作数视为二进制整数，然后把两个操作数按位做或运算。 按位或运算常常被用在一种叫做Bitmask的技术上。Bitmask相当于使用一个整数来当做多个布尔型变量，现在已经不太提倡了。不过一些比较老的API还是会这样设计，比如我们在DOM课程中，提到过的Iterator API，我们看下例子： var iterator = document.createNodeIterator(document.body, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_COMMENT, null, false); var node; while(node = iterator.nextNode()) { console.log(node); }这里的第二个参数就是使用了Bitmask技术，所以必须配合位运算表达式才能方便地传参。 逻辑与表达式和逻辑或表达式逻辑与表达式由按位或表达式经过逻辑与运算符连接构成，逻辑或表达式则由逻辑与表达式经逻辑或运算符连接构成。 这里需要注意的是，这两种表达式都不会做类型转换，所以尽管是逻辑运算，但是最终的结果可能是其它类型。 比如： false || 1;这句将会得到结果 1。 false &amp;&amp; undefined;这句将会得到undefined。 另外还有一点，就是逻辑表达式具有短路的特性，例如： true || foo();这里的foo将不会被执行，这种中断后面表达式执行的特性就叫做短路。 条件表达式 ConditionalExpression条件表达式由逻辑或表达式和条件运算符构成，条件运算符又称三目运算符，它有三个部分，由两个运算符?和:配合使用。 condition ? branch1 : branch2这里需要注意，条件表达式也像逻辑表达式一样，可能忽略后面表达式的计算。这一点跟C语言的条件表达式是不一样的。 条件表达式实际上就是JavaScript中的右值表达式了 RightHandSideExpression，是可以放到赋值运算后面的表达式。 总结今天我们讲解了表达式的右边部分，讲到了包括更新表达式、一元运算表达式、乘方表达式、乘法表达式、移位表达式等14种表达式。至此为止，我们已经讲全了表达式。你如果有不熟悉的地方，可以随时回头查阅。 留一个小任务，我们试着总结下JavaScript中所有的运算符优先级和结合性。例如：","link":"/2019/08/31/重学前端/JavaScript语法（四）：新加入的**运算符，哪里有些不一样呢？/"},{"title":"加餐 | 前端与图形学","text":"（点击视频观看完整分享内容。） 主要内容关于前端和图形学，我分成了三个部分来讲解。 第一部分是讲前端和图形学有什么样的关系。我们为什么要在前端里引入图形学，这个也是我的一段心路历程。 第二部分相对来说是比较实用的，就是图形学的应用场景。如何在前端的日常的工作中，把图形学的知识用进去，为我们的工作和业务创造价值。 最后一部分是对图形学基础设施的一些建设，目前还是一个比较初级的阶段，但是对大家来说，应该有些思路还是可以去思考的。 前端和图形学首先讲第一部分前端和图形学，先讲讲缘起。 缘起 2011年我做了一个分享，当时HTML5正火，我讲了这么一个内容叫做gesture animation，我是用HTML5上的TouchEvent，去模拟当时非常惊艳的iOS的操作风格。 2013年我又开始讲一个叫做flexible design的东西，这是针对当时一个非常火的概念提的。那个概念能从最大的屏幕适配到最小的屏幕的一个技术方案，但是从我们当时的实现来看，这个想法是好的，概念也是高大上的，但是从落地上来看非常困难。考虑到现实情况，我提了一个flexible design这样的一个次级概念。 这个就是一个弹性、小范围的适配，我们只把不同的尺寸的安卓机和iPhone做适配，最后解决了适配的问题，并提出来了一系列的设计原则。所以在2013年，我们主要做得还是解决适配问题。 2016到2017，我在各种不同的会议上讲了三场演讲，它们的背后其实都是同一个东西，叫做BindingX。 我是希望提出一个交互领域的通用模型，我把交互抽象成输入、输出和中间的一个表达式。通过三者之间的关系，来建立针对所有交互的领域模型。 我的三场分别是从技术的角度、从架构的角度，和从团队基础设施建设的角度，讲了三次。差不多两年的时间，我一直在研究这个方向。 16年初的时候，我做了一件事，我让团队的一个小伙伴去找当时所有看起来比较先进的设计，他到网上到处去找，总结了这么一份PPT。 然后呢，16年初的时候，我们就对着PPT开始研究说，到底哪个东西还是我们现在的基础设施实现不了的。我们用binding尽量去实现了。但是还是有一部分在2016年是做不到的。 到了2018年，我们又做了一次一样的事情，我们把当时的这个PPT拿出来，说这个效果还有没有我们做不到的，我们发现整个的效果，我们已经全都能做到了。 当时我们觉得作为前端，至少从底层能力上来说，我们已经建设得很好了，市面上能看到的先进的交互，我们都是可以做出来的。 不过，我还是做了一些思考，其实还是能找到一些做不出来的效果，比如说一些光和影的效果，还是我们现在做不出来的。 浏览器的图形学对浏览器来说，图形这一条线下来，它大概会是个这样一个依赖关系。 我发现前面觉得自己做不出来的东西，实际上毫无疑问都可以用OpenGL的API去解决，我觉得它其实除了大家耳熟能详的“做3D”这一能力之外，是不是还可以用来解决我们在渲染方面的一些问题。 设计稿里的图形学除了技术的角度，我们也做了另一个角度的分析，我们考察了一下设计师最常用的这个工具，Photoshop。它有一个工具叫滤镜。Photoshop里能够画出来东西的，都是通过滤镜实现的。 所以，我们做了一些基础渲染型的滤镜，也有一些对图片处理的滤镜，通过对它们的灵活组合，我们可以实现各种各样的图案，比如画个火焰、画个云彩类似的效果。 基于此，我们又做了一些探索。 图形学应用场景我们把Photoshop生成的图片其实分了一些不同的种类。 一种叫做图案，这个它可能是一种重复率比较高的，也可能是不重复，但是它相对来说是一种多用于背景的这样的一种东西。 还有一种，就是Photo图片，图片基本上就是拍照拍出来的，比如说这个图里的一个音箱，这个东西你没法去用技术去代替它，就是真实的图像。 还有一种东西叫做形状，比如三角形、圆形、方形，形状已经在浏览器里用了很成熟的技术去实现。 来自设计稿的图形：云雾那么我们现在重点要去解决的是第一种pattern。比如我们要实现云雾效果。 首先我们要有一个noise，小时候看电视这个出雪花就是这样的，那个就是说来自硬件的噪声，当我们把这个噪声做一些处理，放大，放到最大，它就会变成一个模糊的几个块，再放的小一点，就变成几个不动的模糊的块，一直到最后就变成雪花点，但是我们把几张图以一定的比例做一定的叠加，然后就搞定了。 接下来我们看一下对比图，看我们的结果，我们的这个云彩和Photoshop这个云彩渲染出来它的形状基本上是一模一样的。 我们打开了一扇新的大门，我们仔细研究发现很多内容都是可以用shader去做的，如果这个想法再深入一点，我们不需要用图片了，可以直接用代码去渲染了。 我们可能未来会给设计师提供很多这样的平台、工具，让他直接在我们的这个平台上去做操作，代替原来Photoshop的步骤，或者我们对Photoshop的文件做一定的处理，来生成这种图案，这是我们的一个思路。 来自数学的图形：几何图形与分形除了灵感来自Photoshop之外，还有些其他的来源，比如几何图形，如果大家看一下这个著名的Logo，苹果的图标。 这幅图里面有很多的圆、框和螺旋线，它们总能找到一些数学的依据，设计师们做图标的时候都是要讲道理的，不能是凭空手绘的，尤其是这种著名公司的icon。 大家不要去轻视这个简单的几何图形，简单的几何图形也可以产生一些非常好的效果，除了几何图形之外，来自数学的还有一类，非常著名高端，但是实现起来非常简单的，叫做分形。 很多广告片里面，它会用类似这样的图形做这个背景，分形本来是数学里面的一门学科，分形集合，研究分形图的性质，它的特点是每个部分都是大图的一个相似图形，所以说，它可以无限延伸下去。 分形的代码很简单，就这么多代码，但是它也是画一个像素点的，它可以画成类似雪花这样的东西。 这类的分形图呢，叫Juila Set ，我们作为前端，我们就照着上面的数学公式把它用代码实现就好，所以非常的方便，为什么我要挑出来Juila Set来讲，是因为它有个特点，当你用不同的常数的时候的它会产生非常不一样的图形。 比如说我们要做一个后台的这样的系统，给我们的设计师用，你让它自己调一调这个参数，它可以调出不同的图案。 总之，我们看到了很多的可能性，而Juila Set只是分形里面的一个集合，而数学里面的各种各样，能画出来奇怪花纹的东西，绝对不只分形一个，这里有非常大的想象空间。 来自物理的图形：光的衍射还有一些来自物理的一些灵感，尤其是这种光晕效果，这个光晕效果也是Photoshop里面提供的，用这个光晕效果也可以做很多的设计。 这个代码也惊人的简单，我们也不需要把这个东西搞的特别清楚，你知道理解我们可以有这些灵感的来源，就足够了。 相变相变又是来自于一个新的领域的知识，就是我们可以对图片做一个处理，大家看到这个小人有帽子，作为一个有追求的前端程序员，我们可以用代码去改变它帽子的颜色。这里面涉及一个颜色的知识，叫做hsv。 一般来说，大家只把hsv当作一种写颜色的方式，但我认为它是一个比rgb语义更好的颜色表述的方式，hsv是用了一个色相和明度，和纯度这样的一个概念，我们要想改变一张图的色相，我们就只需要去改变它的色相。 我们把蓝色的色相变到绿色的色相就OK了，这里面有一个很复杂的公式，只是写起来有点吓人，其实都是加加减减就好了，我们在hsv完成一个相变，我们再把它转回rgb，这样就实现了我们的这个色相变化的效果。 我们可以把这一点利用到很多场景上，比如说人民币，你从5元到100元钱，虽然大家觉得它差异很大，但它其实就是一个色相的改变。（我在前面的文章中讲到了同一种鸟颜色的转变，也是如此。） 绿幕 绿幕是电影的技术。如果大家到拍摄现场看拍电影，你会发现他们经常弄一个绿幕在上面，我们也用了一个类似的技术，我们也管它叫做绿幕。 3D图形 最后提一下3D图形，因为这个是业内非常成熟的东西，我就不仔细讲了。就是我们的ThreeJS和BabylonJS提供的3D的效果。3D的领域，现在是个红海竞争，你写一个引擎基本上跟别的引擎差不多，你有的功能别人都有，除非你与一个很厉害的实验室合作做了一些特殊的优化，但是，我觉得对于工程团队来说，这个代价有点高。 图形学的基础设施最后讲一下图形学的基础设施，我们做图形的事情，还有些比较现实的问题。 基础设施：GCanvas 比如说阿里巴巴现在已经不用web view，基本上淘宝里面的页面已经是百分之百weex化了，可能就有一两个页面不是，我们面对的一个非常现实的问题，就是我们在用weex技术，而它里面是没有Canvas的，如果大家没有用weex，用了React Native其实也要面临一样的问题。 没有Canvas怎么办？其实还是很简单的道理，做一个，所以我们做了一个叫做GCanvas的东西。 基础设施：G3D 业界还有一个东西就是G3D，它与ThreeJS一类，没有什么本质的区别。底层它会有些管理的能力，它也可以交互，我们也做了点选，拖拽、顶点变形这样的能力。 如果你对今天的内容有什么样的想法，你可以给我留言，我们一起分享。","link":"/2019/08/31/重学前端/加餐 | 前端与图形学/"},{"title":"前端架构：前端架构有哪些核心问题？","text":"你好，我是winter，今天我们来谈谈架构。 在传统桌面软件开发中，架构师是一种通过设计架构保证团队能够良好分工和有序工作的岗位。 在工程领域，我们凡是要做点什么事儿，都会有明确的目的性，这个目的性，一定是为了完成生产服务业务的。 为什么桌面软件开发需要架构师和架构设计呢？因为桌面软件开发具有高度的复杂性，如果没有架构，就没法分解成互相耦合低的模块来分工。 所以一般来说，架构是为了分工而存在的。但是到了前端领域，这个问题是否还存在呢？答案是，不存在。 前端是个天然按照页面解耦的技术，在多页面架构中，页面的复杂度大约刚好适合一个人的工作量。（所以，我们的结论是，前端根本不需要架构设计。当然，我这句话是开玩笑的。） 前端不存在分工问题，但是在多人协同时，仍然要解决质量和效率的问题，这就需要组件化了。除此之外还有前端特有的兼容性问题，也是需要从架构的角度去解决的。 对于一些追求极致的团队来说，会挑战“单页面应用”，通过单页面应用来提升用户体验，单页面应用的升级版本是谷歌提出的PWA，PWA既是业务方案也是技术方案，在技术层面，它近乎苛刻地规定了网页的各方面的体验标准。 前端领域还有一个特有的生态：框架，第一代前端框架（如jQuery, PrototypeJS）重点解决了兼容问题和API的易用性问题，在现代浏览器普及之后，这些问题逐渐变得不存在或者不重要，所以第二代前端框架（如Vue，Angular，React）重点解决了组件化问题。选择合适的框架，可以节约架构的成本，还能够享受社区资源。 本节课，我会围绕前端架构的几个核心问题，为你介绍前端架构工作。 首先我们来讲讲组件化 组件化组件化讲起来是个非常简单的概念，前端主要的开发工作是UI开发，而把UI上的各种元素分解成组件，规定组件的标准，实现组件运行的环境就是组件化了。 现行的组件化方案，目前有五种主流选择： Web Component； Vue； React； Angular； 自研。 Web Component 是W3C推行的规范，理论上是未来的选项；但是实际上这份标准的状态堪忧，Shadow DOM 的设计比较复杂，一般的前端掌握起来都比较困难。 此外，CSS也比较难以应用，需要依靠CSS Houdini。目前来说，我还没有看到那个前端团队实际在使用Web Component作为组件化方案。当然，它的优势也非常明显：不需要任何额外的运行时支持，就能在现代浏览器环境运行，也可以跟HTML无缝结合。 Vue 是目前最受欢迎的框架（从github star来看），由华人程序员尤小右开发和维护。它有两个主要特点，一个是比较符合原本的JavaScript/CSS/HTML书写习惯；另一个是它绑定了MVVM模式，直接确定了UI架构，通过DSL的支持，数据交互非常简洁。 React 是Facebook推行的新一代Web框架。它利用JSX模式，把HTML、CSS和JavaScript都放进了js文件中，对于不喜欢CSS和HTML的前端工程师来说，是很理想的。它还可以迁移到React Native，直接编写简单的客户端应用。 Angular 是Google推出的Web框架，它是比较标准的MVVM模式。Angular曾经因为大版本兼容性而饱受诟病，目前它的核心竞争力是与TypeScript结合得较好。 上面是我对几种方案的简单介绍。但是实际上，我们做技术选型时的主要依据是团队的现状，开发移动端还是桌面端、是否跟Native结合、团队成员的技能分布都是需要考虑的因素，这些框架本身的特点，目前我认为仅仅是一种偏好选项，而不是关键因素。 兼容性和适配性前端开发的特有问题就是兼容性，到了移动时代，需要面对不同的机型，我们又需要解决适配性问题。 兼容性问题到2011年左右都是前端的主旋律，但是在之后，随着现代浏览器的逐渐普及，兼容性问题逐渐减小，所以我们这里就不多谈兼容性问题了。 适配问题主要适配的是屏幕的三个要素。 单位英寸像素数（Pixel Per Inch，PPI）：现实世界的一英寸内像素数，决定了屏幕的显示质量。 设备像素比率（Device Pixel Ratio，DPR）：物理像素与逻辑像素（px）的对应关系。 分辨率（Resolution）：屏幕区域的宽高所占像素数。 在当前环境下，分辨率适配可以使用vw单位解决，DPR适配则需要用到CSS的viewport规则来控制缩放比例解决，而PPI主要影响的是文字，可以采用media规则来适配。 单页应用前文已经讲过，前端架构的解耦问题不大，因为页面是天然解耦的，但是，大家都知道，浏览器加载HTML时是会有白屏过程的，对追求极致体验的团队来说，希望能够进一步提升体验，于是就有了“单页应用（SPA）”的概念。 单页应用是把多个页面的内容实现在同一个实际页面内的技术，因为失去了页面的天然解耦，所以就要解决耦合问题。也就是说，我们要在一个“物理页面”内，通过架构设计来实现若干个“逻辑页面”。 逻辑页面应该做到独立开发和独立发布，一种思路是，每个逻辑页面一个js，用一个SPA框架加载js文件。 从交互的角度，这并不困难，但是，这里还有一个隐性需求：保持前进后退历史。 一般来说，前进后退历史使用URL的Hash部分来控制，但是onhashchange事件并没有提供前进或者后退信息，目前还没有完美的解决方案，只能牺牲一部分体验。实现单页应用的逻辑页面发布需要改造发布系统，在工程上，这也是一个比较大的挑战。 扩展前端新边界除了解决现实问题，我认为前端架构的职责还包括扩展前端的边界，所以前端架构还包含了很多Native开发任务：如客户端和前端结合的方案 Weex 和 React Native；如前端和图形学结合的方案 GCanvas；如前端的3D框架Three.js，这些都是试图用架构的手段赋予前端新的能力的尝试。 这些具体的尝试涉及很多领域知识，我这里就不做详细介绍了，但是如果你成为了一个前端架构师，我希望你也把“拓展前端边界”当做团队的核心目标之一。 总结今天我从宏观的角度介绍了前端架构相关的知识，我重点介绍了“组件化”“适配性”“单页应用”三个前端架构需要解决的核心问题，组件化在社区有很多现成的方案，我们需要做的主要工作是框架选型。适配性需要用到CSS的几种特性：vw单位、viewport规则和media规则，单页应用重点是逻辑页面解耦、独立开发和发布和保持前进后退历史。 最后留一个思考问题，你所在的团队有前端架构师吗？如果有的话，他的工作职责是什么？","link":"/2019/08/31/重学前端/前端架构：前端架构有哪些核心问题？/"},{"title":"加餐 | 前端交互基础设施的建设","text":"分享内容大纲Vue、React等现代前端框架很好地解决了组件化和数据视图解耦问题。而对前端来说，新交互永远是花费时间最多的工作，新交互也是前端团队的自然价值和核心竞争力之一。 在这次话题中，我会分享在交互的基础设施的建设上的一些思考和实践，包括图形图像基础、事件机制与视图层架构模式、交互管理框架等内容。 首先我们要了解一下历史。在70年代，大概是70年代的尾巴，1979年左右，有了特别有名的，MVC架构。 MVC之后，经过了差不多十几年的发展，到了90年代，准确地说应该是95年左右的时候，这个有一个公司的CTO，叫Mike，Mike在MVC的基础上，提出来了MVP。 到了 2005年，2005年微软的一个架构师，做WPF的，提出了MVVM模式。 2014年左右的时候，出现了FLUX，这个是Facebook为了它的JSX和React提出的一种模式。 后来隔了短短的一年，2015年，同样是在React社区，出现了REDUX。 对于前端来说，我们为用户创造价值才是特别回答的一个问题，这么多年过去了，前端到底为用户创造了什么价值呢？ 这是70年代，施乐公司做的一个软件管理的流程图软件，那个时代，整个的界面就是这个样子，施乐已经算比较先进的了。 再到90年代，当时这个画面还是很惊艳，按钮键是立体的。现在来看这个东西就有不那么美观了。 2006年左右的时候，Vista的界面已经开始有了一个非常大的变化了，这时已经是设计师在主导这个界面的了，但是性能并不佳。 再之后，手机出现了，比如iPhone的界面，这时不但交互模式发生了巨大的改变，而且屏幕也变了，甚至我们熟悉的鼠标不见了，变成了触屏。虽然两者之间操作上有一定的相似，但是变化还是非常的。 视图的职责也在演变，70年代，视图的职责是：任何一个视图，永远不应该知道用户的输入。 我们这个时代的视图则既负责输入，也负责输出，并且与Model之间有一个交互。 计算机的功能也在演变。70年代，计算机主要用来计算。 我们今天计算机主要用来上网，基本上，大家的计算机都是24小时联网的，你的手机也是24小时联网的，所以计算机的职责在发生变化。 这个变化对于UI有很大的影响，1970年的那个MVC那篇论文里的图，model很大，view很小，而到了2018年，今天我们很多的model，都是放在服务端的，而今天model的大小已经不是说一台机器上能去存的，你存在本地的只是视图展现一点点的model，这个是很小的一部分的东西。而同时view却越来越重要了。 我们来看一下视图的技术。 从最底层的有很多人是做显卡和drivers，有这样的大佬人才。 还有现在非常流行的OpenGL等的GL层，做这一层的人非常专业，基本上都集中在各种大公司，最近苹果和安卓还竞争，推出了新一代的这个GL架构。 还有一个这个Draw层，这一层的内容非常多，基本上就爆发了，skia是安卓的底层绘制系统，graphics.h是最早的C语言带的一个图形库，基本上相当于一个基础库，还有很多3D引擎。 UI Framework这一层，它提供了一套基本的UI结构，有了绘制层， 一般人都不会在绘制层直接去工作，需要有些控件，这层有我们比较熟悉的Dom。GJI是Windows的图形系统，WPF也是Windows的图形系统。 最上面其实会有一些DSL，这是描述图形的语言，WPF对应的就是XAML，JSX对应的是React，HTML大家都知道了，想说这个视图技术变得越来越复杂， 那么我们的主战场是怎么样的，我们可以看一下淘宝终端技术在各层上的分布状况。 交互体系其实是这里面的一部分，但它不是这里面的全部，我觉得我们要讲这个交互呢，我们还是要做一下抽象的，我们要认识到，交互的本质是什么。 交互的本质是什么呢，我画了一个手和一个眼睛，其实无非是操作和看。 操作最常见的一个抽象的模式就是事件。这个比如说这个touch-screen事件，陀螺仪事件，或者是时钟芯片触发的持续事件，这些作为输入。 输出一定是通过属性的形式体现的，在任何一个现在的UI框架下，都是通过属性的方式反映出来的。transform是变形，opacity是透明度，color是颜色，这就是一个比较完整的抽象了。你在任意的输入和输出连成一条线后，它都会产生一种效果。 不过直接把陀螺仪得到的参数输入到transform里肯定是不行的，它需要有个关系，我们在这里面选择了Expression。我们可以用JavaScript去做计算。我觉得这是一个完备的抽象。 不过这里还有一个坑是需要迈过去的，对计算机理解的输入跟人类理解的输入有非常大的偏差，对计算机来说呢，有多少种硬件，就有多少种输入。 我们发现输入非常复杂，在做基础设施建设的时候，我们在输入上面其实投入了很大的精力，最后出来的是一个更接近于人脑概念的一系列的输入。 比如说，touch和gesture，我们知道触屏其实是触屏事件，触屏事件其实非常简单，只有四个，touch start，touch move，touch end，touch cancel则不太常用。 比如我想摁或者点一个东西，它都是是touch start，touch move，touch end，如果你要监听这些事件，中间的判断很繁琐，作为交互的基础设施，我们不可能提供这些给我们的前端工程师使用，我们肯定做一些操作。 比如手指移动10px，我们就认为这个touch start到了pan start，这个后面就是pan move，pan end这样， 手指很快离开，那么它就会产生一个tap事件。 如果超过1.5秒那就一个press start，如果手指没移呢，就会产生一个press end，如果手指移了，它还会产生一个pan start。所以gesture已经比touch复杂了很多了。 scroll就在gesture的基础上又复杂了一层，它不但手指在屏幕的时候响应，手指离开屏幕的时候它也响应，比如说轮播，它是一个变形的轮播，它在轮播的过程中，不但产生位移，还会产生大小的变化，这就让用户更舒服一些。 还有一个滚动导航，一边滚动出来一个导航，近年来还有一个交互设计，不是滚动到某个位置导航出来，而是一直再往下滚动的时候它不出来，突然往上滚动一下，导航就出来。这个部分还有更难的设计交互，所以我们还需要在scroll的基础上再做一层。 我们再来看陀螺仪，它只提供了三个分量，并且它是0到360度，所以如果不经过任何处理，前端工程师基本上是没有办法用的，比如在某个角度，它可能会突然从0跳变成360度，这个在数据计算时候非常可怕。 所以我们建立这样一个模型，我们把手机看作这样一个立方体，去计算在空间中对立方体产生的旋转效果，我们拿着立方体上面的一个点呢，去做我们定位的一个依据。 因为我们在用Weex，所以有一个Native跟JS通讯的问题，比如说从gesture事件到gesture handler，这一步就会到JS去执行，图中我们可以看到这个线，跨过中间JS和Native的分界线，跨越地非常频繁。 假如一个Touch move事件或者Pan move事件，你手指每移动一小点它都会触发一次JS跟Native的一个跨语言通讯，所以说整个的性能会非常差，最后基本上会有5毫秒到10毫秒左右的一个延迟，有60帧的话，每一秒钟有300毫秒被占掉了，帧率就下去了。 这就是我们最初开始做Binding模式的原因。我们的Binding模式，expression传递一次给Native，然后它会去做大量的绑定，所有的过程都是由Native来完成的，Native做完了以后，还需要再更新一下VDOM，所以这操作就完全由Native完成，通讯次数就降下来了。除此之外，我们还额外收获了性能上的收益。 我们的结论，其实淘宝一个交互体系是这样的，是以Binding为核心，下面的平台支持了weex，Web，React Native。DSL上面，我们支持了View和Rax两种，在上面，是由我们自己建的Components体系。 最后，还有一个展望，我们用绘制层相结合，会有更多的想象空间，我们通过各种各样的输入、手势、时间、陀螺仪，我们其实可以去控制矢量图，也可以去控制绘制，这些都是前端未来的想象空间。 如果你对今天的内容有所思考，可以给我留言，我们一起讨论。","link":"/2019/08/31/重学前端/加餐 | 前端交互基础设施的建设/"},{"title":"加餐 | 一个前端工程师到底需要掌握哪些技能？","text":"自从开了“重学前端”这门课程，总会遇到同学反复问我这几个问题： 学这门课需要什么样的基础？ 为什么你不讲Vue？ 有必要学习Node.js/Flutter/函数式吗？ 这几个问题看似毫无关联，但是其实它们本质上都是同一个问题，这个问题就是“一个前端工程师到底需要掌握哪些技能？” 其实在行业里面，对前端工程师的能力模型有一个基本的认知，不同公司的定义可能有细微差别，但是它的内核是一致的。 这里我给出一张图，是我自己理解的前端工程师的技能模型。 为了方便你理解，我把这些技能具体放进前端工程师的不同级别里，你可以对照着找到一条符合自己实际情况的前端进阶之路。下面我就一部分一部分地详细讲讲前端技能树是如何发展的。 助理工程师首先来说说助理前端工程师，对标的是阿里的P4级别。它的要求是基本的编程能力。什么叫基本的编程能力呢？我认为就是熟练地用计算机编程语言表达任何逻辑的能力。一般来说，在大学学习过计算机专业的学生应该具备编程能力。 我举一个具体的例子，我们用自然语言说“从1打印到100”，在多数编程语言里的表述，是一个变量从1开始，每次循环加1，每次打印，到变量值为100时循环结束。理论上只要掌握了循环、分支逻辑，能组合出一切逻辑，这是图灵可计算理论决定的。但是理论是一回事，真想要熟练掌握，是需要经过一定训练的。这个训练，就是对助理工程师的要求。 在面试中考察这部分知识的问题往往被称作“算法题”。其实广义上的算法指我们一切完成问题的步骤，而狭义的算法则是指算法课本上几种经典的算法如分治、贪心、动态规划等。面试中考察基本编程能力，其实题目出难了就是所谓的“算法题”，出简单了就是“写段代码看看”，并没有一个明确的分界线。 助理工程师的定义是“能够在辅助下完成工作”，因此不是所有公司都会招聘助理工程师的，因为严格来说，助理工程师不具备独立工作的能力，他的工作产出可能是负数。但是招聘助理工程师的公司，一般都是看重应聘人的潜力，期望能快速成长。 工程师接下来我们说说前端工程师，对标阿里P5级别。它的要求是掌握基本的前端技能，这样说也许有点模糊，但是换个说法就很明白了，基本前端技能就是“综合运用HTML、JavaScript、CSS完成任何界面和交互需求”。这个“任何界面和交互需求”，看似要求很高，但是如果你写过前端就知道，这是任何前端的基本技能——大不了用图片呗。 其实这个级别的工程师，水平跨度非常大，界面写出来了，但是兼容性如何、代码可维护性如何、离了框架能不能写出来、语义表现分离能做到吗、开发过程中能不能做到有效沟通…还会有很多问题。而这些问题，决定了一个前端工程师的潜力，一些好一点的公司招聘这个级别的工程师，除了“基本的前端技能”之外，还会对我上面提到的这些问题有所要求。 关于助理前端工程师和前端工程师，能力方面主要的要求是编程能力，知识方面的要求是一个“可用”的最小集合。 资深工程师我们接着往下讲，资深前端工程师，对标阿里P6级别。到了这个阶段，我们可以看到图上开始出现不同的区块了，这意味着，对资深前端工程师的要求，也是多元化的。 我们用一句话来概括，资深前端工程师，要求开始关注并且解决项目中的问题。什么样的问题呢？可能是别人做不出来的技术难题，也可能是容易出错的代码，或者说无意义的重复劳动，或者是业务上想不出来合适的交互…… 等等。 其实对资深前端工程师的要求是很自由的，我上面的图中给出的仅仅是几个例子，比如组件化可以解决重复劳动问题和开发耦合问题；工具可以解决的问题有很多，生成代码的工具提高效率，代码检查工具提高质量；性能优化则会带来业务价值，这些都是资深前端工程师可以做的事情，并且只要把其中一两项做好，就可以达到资深前端工程师的水平。 再有就是这个级别开始对架构能力和工程能力有所要求了，但还处于萌芽阶段，一些天赋好的同学可以凭感觉达到这个水平。 技术专家下面说说前端专家，对标阿里P7级别。到了这个级别，我们从图上可以看到，要求又不一样了，比如组件变成了组件体系，工具变成了工具链和持续集成体系，性能优化变成了性能体系。这些东西变得不仅仅是称呼，还有工作的内容，这个级别跟资深工程师的主要区别是，从解决单点问题变成系统性方法，从服务自己变成服务团队，从一次性发挥变成持续性输出。 比如，资深工程师可能做一些组件，然后在项目里面用，自己的代码可维护性提升了，复用也做得更好了。但是前端专家要考虑制定组件规范推广到团队，还要做培训，考虑组件如何开发、管理和下线。资深工程师做性能，把自己的页面优化好了就可以了，但是前端专家就需要考虑采集数据、做报表和监控、总结checklist、跟工具结合、定性能指标等等。 由于这个级别对架构能力、工程和软技能要求很高，所以算是比较难以跨越的。 高级技术专家最后来说高级前端专家，对标阿里的P8级别。我们从图上看，这个级别分开的发展方向又聚合到了一起。高级前端专家做事的关键是审时度势，需要在前面讲的前端专家所掌握的各个领域里，组合出一套适合自己所在团队的方案。比如做企业内部系统的前端团队，可能对性能要求就没那么高，但电商前端团队因为运营活动频繁，就需要很好的组件体系，这里很难有一定的规则，全靠人来把握。 到这个级别，对工程能力的要求就很高了，而且即使不带人的高级前端专家，也必定涉及一些管理能力。 前端进阶的核心要素讲完了各个级别的前端技能模型，我们回到最开始的问题“一个前端工程师到底需要掌握哪些技能”。 要回答这个问题，你要先根据自己的情况对号入座。梳理出自己掌握的前端知识程度，定位出自己的级别。再根据更高层级所需的知识，有的放矢，循序渐进，不断精进、完善自己的前端知识水平。 我们现在学习的“重学前端”这门课程，最重要的作用首先是构建出一个完整的前端知识架构，让你可以把自己的前端能力梳理清晰，让你意识到自己“会什么，不会什么”。如果后面再遇见了拿不准的知识点，你也可以定位好属于哪部分的哪个知识点。 有同学会问：自己对照专栏的知识架构后，好多知识点都不会，比较模糊，感觉会影响岗位的晋升，很焦虑，怎么办？ 不要急，我们可以看到，在前端的技能模型里，对“知识”是没有任何硬性要求的，具体到各个公司的不同岗位，可能会有一些特殊要求，但市场是巨大的，所以大家可以不必对学什么知识不学什么知识感到那么焦虑。 现在大部分同学会更为注重前端岗位的晋升，我认为想要真正实现前端岗位的晋升，更多还是要看你的能力，尤其是在工作中非常重要的编程能力、架构能力和工程能力，这些都是前端工程师必备的“内功”。 而且“前端知识”应该是一个垂直的模块，它不能直接帮助你进阶下一个更高的级别，但是它能提升你的潜力，使你未来能走得更远。 我现在也在从教育的视角，结合自己多年的前端一线经验，尝试一种更为直接有效的课程形式“前端训练营”，帮助大家提升能力、实现进阶。在“前端训练营”里，我设计了三个最主要的课程模块： 针对基本编程能力、基本前端技能，我们一起编写一个黑白棋游戏。 针对“组件化”和架构能力，我们一起设计和实现一个轮播组件。 针对“组件化”和工程能力，我们一起实现一个完整的电商项目。 我希望通过3个月的时间，为你打造一个贴近大厂的实战环境，通过刻意练习和有效的监督、反馈机制，让你的编程能力、架构能力和工程能力得到有效提高。 毕业之后，极客大学会在一年内，给优秀毕业生提供两次一线互联网大厂内推服务，并有 TGO 鲲鹏会的 600 家企业推荐通道为你敞开。点击图片，可以了解更多课程详情。 我刚刚在极客时间进行了一期“直播 + 练习 + 实时 code review”的视频公开课，内容就是“前端训练营“的第一课。如果你想看看我是如何当老师，手把手教大家写代码的，请戳此添加学习助理，获取公开课视频和 winter 教学代码、PPT。","link":"/2019/08/31/重学前端/加餐 | 一个前端工程师到底需要掌握哪些技能？/"},{"title":"尾声 | 长风破浪会有时，直挂云帆济沧海","text":"你好，我是winter。 感觉特别长的几个月，忽然间就结束了。对我而言，这是一段奇妙的旅程，对你来说，我希望也是。 去年9月我离开原来的公司，打定主意要做一些程序员教育的事情，10月份在QCon，我遇到了“极客时间”的编辑，收到邀请来做一个专栏，于是就有了“重学前端”。 最初我答应“极客时间”的时候，其实心里想的是：反正我要做程序员教育，做一个专栏就当整理自己的知识也好。 但是从一开始的磨合和存稿阶段，我就发现这个事情没有我想的那么简单，与以前零散地写博客相比，按时按体系去产出课程需要花费成倍的时间和精力。不断查阅资料，整理代码，“重学前端”这个专栏对我自己来说，也是一个自我重塑的过程。 在这个专栏即将结束的时刻，我想借“重学前端”这个课程谈谈我对教育的理解。 教育是知识的展现形式现在有一个特别火爆的概念叫做知识付费，其实我不太喜欢这个说法。 “重学前端”所讲的知识点，没有一条是我发明或原创的知识，这么说的原因是：知识就在那里，每个人都可以获得它。 你可以在各种文档和标准中找到它们或者它们的变体。有一些工程领域相关的知识，来自我工作中的实践，有一些也算是首创，但是我不认为这些知识属于我，我只是发现了它们。 所以我认为，知识是免费的，承载它们的教育产品才是收费的。 在整个课程写作中，我致力于在知识之间建立关系。我不希望把我的课程变成抄写文档。我从排版追溯到活字印刷，我从渲染追溯到中国画的技法，还有面向对象的起源。在这个过程中，我自己也颇有收获。我期望这样的一种组织形式能够帮助你更好地理解和记忆知识。 我有时候会觉得，这个把“知识变成课程”的过程，特别像前端工程师把数据变成可见的页面的过程，所以，从某种意义上讲，我做的事情还是前端。 教育的重点在于能力提升而不是知识积累不过，我也不希望“重学前端”这个课程仅仅是“更容易记忆的知识”。因为在我看来，知识量并非衡量一个工程师优秀与否的因素，能力才是。 我的一点小小的奢望是：“重学前端”这个课程，能给你带来一些建立知识体系的能力。 我在“重学前端”的课程中，穿插了大量的“用代码读标准”的实验。这个小系列，算是我的一种“独门武功”。 我刚开始关注前端的2007年左右，国内还少有程序员知道Web标准这件事，想要找到资料就更难了，我也经历了最初看标准如同天书的过程。 但是我发现，其实标准中佶屈聱牙、晦涩难懂的那些概念，有着内在的联系，又因为标准文本中用词非常严谨，所以尝试用代码去理解，反而是个快捷的路径，还能找出不少边边角角的冷知识。 通过类似这样的线索，我建立了自己最初的知识体系，我开始对前端的体系的全貌有了粗浅的认知，现在，我希望通过“重学前端”课程，让你也来体会一下这个过程。 教育是一种服务，我们做得显然还不够好作为老师，我希望这个课程能够真正帮助到你们每一个人，但是其实我们可以看到，每一节课都有一些放弃的同学。 可能有人会说，对平台方和老师来说并无所谓呀，反正付过钱了。但是在我和“极客时间”看来，这正是我们做得不够好的地方。今天“重学前端”这个课程，可能以这样的产品形态呈现出来，凭学员的自觉性来完成学习，实属一种无奈。 不论对我，还是对“极客时间”而言，培养更多优秀的工程师，潜在的价格远远高于卖一些课程得到收入。 我认为，教育是一种服务，理想的教育产品卖的应该是服务的结果，而不是服务的过程。 在未来，我会跟极客邦一起，探索一个全新的教育形态。我们很快会推出第一期线下的课程。如果你具备基本的前端技能，渴望通过自己的努力和我的指导，快速成长为一名高级前端工程师，欢迎你关注我在极客大学线下开设的前端训练营。 另外，虽然正稿已经结束，“重学前端”将来也不会变成一个“过去式”的专栏，我想把它变成一个“Ask me anything”的栏目，不论是后来购买的同学还是已经学完的同学，你们可以来这里的评论区与我交流，不限于课程内容，只要是技术和职业相关的问题，都可以来问我，我会回复或者更新答疑文章来为你解答。 专栏的课程到此告一段落，但是对我而言，这是一个起点。长风破浪会有时，直挂云帆济沧海，希望未来能与你一起遇见更好的自己。","link":"/2019/08/31/重学前端/尾声 | 长风破浪会有时，直挂云帆济沧海/"},{"title":"工具链：什么样的工具链才能提升团队效率？","text":"你好，我是winter。今天我们的主题是工具。 古语云：“工欲善其事，必先利其器”，程序员群体对工具的爱好和重视是一个悠久的传统。简单趁手的工具是程序员开发的好帮手。 但是在工程方面，工具不仅仅是简单的“趁手”即可，假如一个团队人人都自己发明几个小工具，那么后果将会是灾难性的：同一个团队的同学无法互相配合写代码，一旦有人离职，可能某一个项目就永远无法跑起来了。 所以我们今天从工程的角度谈一谈工具体系的规划。 工具总论跟性能不同，工具体系并非业务结果，所以我们没法用简单的数据指标来衡量工具，它的结果更多程度是一种开发体验：帮助技术团队内的同学提升效率和体验。 作为工程体系，我们考虑工具的时候同样要遵循基本规则：现状与指标、方案、实施、结果和监控。 不过，对工具而言，指标和结果都是一种“软性指标”，也就是团队的开发效率和开发体验。这里我不太推荐把开发效率和开发体验过度数据化，我的经验是：开发效率提升n倍永远是一种臆想或者主观论断。 工具体系的目标前面已经讲到，工具是为技术团队本身服务的工程体系，那么，工具的目标是什么呢？其实每一种工具的出现，必然都有一个非常具体的目标，比如npm帮助我们进行包管理，Yeoman帮助我们初始化项目模板。 但是这些目标是工具的目标，不是工具体系的目标。我们做一个假设，假如你是一个前端团队的工具体系负责人，现在要你来规划团队的工具体系，你会怎么做呢？ 如果你到社区找了一大堆工具，并且把它们要解决的问题都罗列出来，作为工具体系的目标，那就完全走上了错误的道路。 实际上，在考虑具体的工具之前，我们应该解决工具体系的“元问题”，即：我们对工具本身的要求是什么？ 考虑到工程行为都是团队合作，我们对工具最基本的要求就是：版本一致。 只有整个团队的工具版本一致，至少要做到避免大版本差异，才能做到互相接手代码时，团队成员能够正确的使用工具开发。 工具体系的另一个重要需求是：避免冲突，一些工具可能互相没有干扰，比如Yeoman和gulp，有一些工具则由社区设计了配合方案，比如webpack和babel，有一些工具，则存在着根本性冲突，如gulp和grunt。 所以，在谈及具体问题之前，我们必须要有这两个要求的解决方案。这就需要引入一个新的概念：工具链。 工具链是一系列互相配合的工具，能够协作完成开发任务（注：工具链这个词最早是由C/C++程序员引入的概念，一般包含编译、链接、调试等工具）。 下面我们就来谈谈工具链的设计。 工具体系的设计要想设计一个工具链，首先我们需要整理一下，前端开发大约要做哪些事，下面是我的答案： 初始化项目； 运行和调试； 测试（单元测试）； 发布。 那么，一个前端项目的工具链，大约就会包含这些功能。一个典型的社区项目工具链可能就类似下面这样： Yeoman webpack ava/nyc aws-cli 但是，这显然不够，我们还需要一种机制，保证团队使用的工具版本一致。 轻量级的做法是，在项目初始化模板中定义npm script并且在npm dev-dependency中规定它的版本号。 重量级的做法是，开发一个包装工具，在命令行中不直接使用命令，而使用包装过的命令。如在我之前的团队，使用的工具名为def，它规定了一些命令： def init def dev def test def publish 这样，工具链的使用者只需指定工具链名称，就不需要知道项目具体使用了哪些工具，这样只需要专注自己的需求就够了。 同时，统一的命令行入口，意味着整个团队不需要互相学习工具链，就可以接手别人的项目开发。 在稍微大一些的团队内部，往往会需要不止一种开发模式，如移动开发和桌面开发，这样，所需要的工具链也不一样，因此我们需要多条工具链。 要想开发新的工具链，可以使用复制分支的方式来扩展原来的工具链。在我原来的工作中，不同的工具链被称作“套件”，每一种套件对应着一组互相配合的工具。 工具体系的执行因为工具体系服务的是团队内部成员，所以执行非常简单，同时，工具体系的入口是初始化项目，所以只要初始化工具在手，可以控制其它所有工具。 我们在性能的那一课里，已经讲过工程体系的执行分成三个层次：纯管理、制度化和自动化。 工具体系因为其自身特性，可以说是最容易做到自动化的一个体系了。 工具体系的监控工具体系的结果虽然是软性的，也不能完全不做监控。 纯粹的社区方案比较难做到监控，但是如果我们使用了前面提到的统一命令行入口包装，那么就可以做一些简单的统计工作了。 一般来说，以下指标跟开发者体验较为相关： 调试/构建次数； 构建平均时长； 使用的工具版本； 发布次数。 在我之前的工作中，工具团队曾经从构建平均时长数据中发现构建效率问题，对webpack做了大量深度优化来改善开发体验。 同时，工具的相关数据还能够帮助发现一些问题，比如某个项目频繁发布，可能说明它风险很高。工具的相关数据还能帮我们发现老旧的工具，如果某个套件使用频率极低，则可以考虑把它下线。 总之，工具体系的监控不仅仅是衡量工具体系的好帮手，也是非常珍贵的研发数据，里面有很多可挖掘的价值。 总结这一课，我们讲解了工具相关的工程知识。 我们仍然从目标、方案设计、执行和结果四个方面来讲解，工具体系的目标除了单个工具解决具体问题之外，还要注意一致性和配合问题，因此我们需要工具链。 工具链一般会涵盖研发阶段的各个主要操作。工具体系的执行比较简单，很容易就可以做到完全的自动化。工具体系的监控同样非常重要，工具的监控除了帮助我们改进工具体系，对研发体系的其它部分也有帮助。 最后，请你思考下自己所在的团队，是否已经建立了工具体系？听完了今天的课程，你认为它有哪些可改进的部分？","link":"/2019/08/31/重学前端/工具链：什么样的工具链才能提升团队效率？/"},{"title":"开篇词 | 从今天起，重新理解前端","text":"你好，我是winter。接下来的3个月里，我将带你重新认识前端。 前端发展史：从青铜到黄金时代我自己是在2006年开始接触前端的。现在回想起来，那会儿前端还处于史前的“青铜时代”，甚至网页的主要交互都还是依靠切换超链接来完成的。 1.前端的史前记忆：“青铜时代”那时候，谷歌刚刚基于Ajax发布的Gmail也没多久，虽然这项伟大的技术标志着Web 1.0（静态网页）到Web 2.0（动态网页）的迈进，但在国内依然少有人懂，如果当时谁可以对这项技术侃侃而谈，那简直就是大神的级别了。 当时我还是个学生，喜欢前端纯粹是兴趣使然。那时我混黑白棋社区，想着给黑白棋界面写插件，但自己又不懂界面相关的知识，于是开始通过各种方式学习前端。 真想学的时候才发现网络上的前端资料很是稀缺，所以我基本上都是先从图书馆借书，然后再在电脑上跑案例验证这样的方式来学习的，现在想起来，还真是一段艰难的岁月。 当然，这段经历也为我日后的前端生涯悄悄埋下了一颗种子，我逐渐开始把自己的职业规划路线放在了前端上。 这在当时是个不可思议的想法，因为那时的前端岗位不论从收入上还是在职责上，都远落后于其他岗位。但是，我基于对技术发展趋势的判断，认为前端在未来会越来越重要。 2. 进入发展期的前端：“白银时代”2008年，我毕业了，也很幸运地得到了一个既能发挥我的C++长处，又能兼顾前端发展规划的职位：微软北京的软件开发工程师，恰好负责的是Windows CE上的IE浏览器开发，在这里，我接触到了当时最先进的软件工程体系，并且积累了很多UI架构经验。 两年后，我加入了盛大做电子书，负责电子书的文本排版工作，这个工作是一个既写底层又写JavaScript的岗位，同时排版引擎也是浏览器的重要组成部分，也让我对浏览器的工作原理有了更深入的理解。 在盛大后期，我加入了WebOS项目，负责前端框架，我开始基于移动的角度思考前端交互和框架，这份工作让我离前端又近了一步。 但是很遗憾，因为种种原因，我在微软和盛大的几个项目都不算成功，除了电子书实际上市但销量不高，Windows CE 7.0 和盛大的 WebOS 都在公司内部夭折。 自己亲手构建的产品，却因为非技术原因没有服务到最终用户，对我来说，是件非常遗憾的事情。不过，这段时间，也让我更加确信前端技术的价值。 回过来看，那几年，前端技术开始了它的大踏步发展，那一段时间，可以说是前端的“白银时代”。最直观的表现之一就是前端逐步从后端分离了出来，它的代码也变得复杂了起来，还需要保存数据、处理数据、生成视图等等。 悄然之间，我发现前端已经从零散的“工序”逐步发展成为有体系和发展目标的职能，同时，在越来越大的前端团队中，工程化的思想也逐渐萌芽。我深有感触，前端已经不再是别人眼中的“小菜一碟”了。 3. 从前端到“全端”：“黄金时代”在这样的行业背景里，从盛大离职后，我加入了阿里巴巴做手机淘宝开发，这也是我首次从事真正的前端工作。 在手机淘宝，前端团队的各种基础设施也逐渐建立了起来，从最开始的多屏适配方案、基础库、工具链到页面搭建平台和性能体系，最后到客户端融合方案Weex，我随着团队一起经历了业务发展、团队自身成长和行业变革。 与此同时，在我加入阿里巴巴后的这段时间里，随着移动时代的到来，前端也开启了自己的“黄金时代”，它的职责变得更加重要，有了独立的发布权限，技术也变得更加复杂。 一些传统软件开发和互联网服务端的方法论逐步移植到前端开发中，并形成了前端自己的工程体系，诸如持续集成、前后端分离、线上监控…… 架构方面，前端架构的任务也从简单的解决兼容和风格问题，逐步过渡到提倡组件化和UI架构模式，最后形成了新一代的前端框架React、Vue和Angular，他们也在竞争和互相学习中成长。 前端开发之痛：散点自学+基础不牢正当处于“黄金时代”的前端技术在全力以赴极速前行之时，我却发现，前端开发者们的步伐似乎渐渐有些跟不上了。 因为在我职业发展的后半段，面试和培养前端工程师已经成为我的长期工作职责。在这期间，我意识到，目前的前端教育几乎是完全缺失的。 在面试应届生过程中，我会习惯性地问表现比较好的同学“你是如何学习前端的”，而我得到的答案多是“自学”“在社团学习”，却从未听到过“在学校学习过”这样的答案。 而对于工作之后的前端开发者来说，没有系统学习的问题仍然存在，常常有一些具有多年从业经验的工程师，仍然会在看到一些用法时惊呼：“还可以这样！” 在我看来，这些用法都是一些基础的不能再基础的知识点，但是他们却浑然不知。 如果深入进去了解，你会发现，表面上看他们可能是一时忘记了，或者之前没注意，但实际上是他们对于前端的知识体系和底层原理没有真正系统地理解。 在阿里工作的时候，我戏称很多同学学前端的方式是“土法学前端”，他们对于知识的理解基本都停留在点上，从来没有大范围把这些点串成线，形成自己的知识体系，因此才会出现上面说的遗漏和盲点。 这个问题在一些一直在小公司工作的前端工程师身上非常突出。 经常能看到一些案例，一些有技术追求、有热情的工程师，因为技术敏感度和主观能动性都不错，所以工作了五六年之后，逐步开始在自己的公司做一些技术管理相关的事情了。 但是，由于他们所在公司的业务并不复杂，也没有技术积累，所以他们自身的技术水平其实并不高，可以说还处于非常初级的阶段（可能面试连阿里P6都过不了）。 做了管理，技术没跟上，并且还错过了最佳的学习时间，这个境遇可想而知，他们在工作中大概率只能是被动地接受需求解决问题，然后也同时焦虑着自己的未来，焦虑着自己的竞争力。 关于前端工程师成长，我认为需要两个视角。一是立足标准，系统性总结和整理前端知识，建立自己的认知和方法论；二是放眼团队，从业务和工程角度思考前端团队的价值和发展需要。只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足。 这也正是“重学前端”这个专栏的初衷，我希望提供一些视角，带你以完备、体系化的方式理解和思考前端的基础知识和工程实践。 除此之外，前端工程师也是开发工程师的一员，除了前端自身的领域知识和工程特点外，你还需要了解程序员通用的编程能力和架构能力。 所以，想要成为优秀的前端工程师，我觉得你需要通过系统地学习和总结获取知识，通过练习获取编程能力，通过工作经验来获取架构和工程能力。 当然，一个为期3个月的专栏无法穷尽前端庞杂的知识，讲知识点也不是我们的目标。知识点讲的再好再全，也不一定能记得住。 我们专栏的目标是帮助你建立自己的知识体系，根据你自己的理解把前端的领域知识链接起来，形成结构，这样做，不但能帮助你记忆知识，还能在其中发现自己知识的缺失，甚至可以凭借知识体系来判断知识的重要性，来决定是否要深入学习。 在这个专栏里，我将知识分成了四个模块来讲解： JavaScript； CSS和HTML； 浏览器实践； 前端综合应用。 前三个模块是前端的基础知识，是个人的前端能力提升，而模块四则是前端团队发展相关的内容，有助于你和团队的整体提高。 在JavaScript部分中，我主要会从文法和运行时的角度去讨论JavaScript语言。它们是互相关联的，而语义就是文法到运行时之间的桥梁；它们分别又是完备的，任何语言特性都离不开两者，所以从语法和运行时的角度，我们都可以了解完整的JavaScript。 CSS和HTML部分，会侧重从语言和设计思想的角度来讲解，我们同样可以对两者的全貌建立一些认知。 浏览器部分，包含了浏览器工作的原理和一些重要的API，包括BOM、DOM、CSSOM和其他一些内容。了解了这些知识，你才能把JavaScript和HTML、CSS连接起来，用JavaScript来实现功能。 前端综合应用部分，主要是我的一些工作经验，我会选择我在手淘和淘宝工作中的一些案例来辅助讲解。 前面，我说到前端是一个非常年轻的职业，但我仍然认为前端具有很多空间和机会，一些基础设施仍然简陋，前端的能力可以带来更多的业务场景，这些有待于我们去发掘。 前端社区非常活跃，新技术也在不断出现。在这样的环境下，机会和竞争并存，学习也犹如逆水行舟，不进则退，建立自己的知识体系和方法论，你才能够保持领先优势。 我希望从我的经验出发，给你一些启发和帮助，并借由这个专栏帮你建立自己的前端知识体系。同时，我也相信，在你们中间一定会产生更多能够带领前端领域取得突破的、优秀的前端工程师。 最后，也希望你能和我分享你的前端故事和经历，你是怎么走上前端道路的？你希望将来成为怎样的前端工程师？欢迎在留言区与我分享。","link":"/2019/08/31/重学前端/开篇词 | 从今天起，重新理解前端/"},{"title":"性能：前端的性能到底对业务数据有多大的影响？","text":"你好，我是winter。 从今天开始，我们就从前端知识学习的部分，过渡到了实践部分。这节课我来谈谈性能。 性能是个特别有意思的话题，在我之前的工作中，从入门的初级工程师到高级别的技术专家，大家都很喜欢谈性能，我以前参与晋升评审，每年总能听到很多关于性能的晋升述职。 那么，今天我就来谈谈我眼中的性能。 性能总论 while循环快还是for循环快？ |0 是不是比 Math.floor 性能好？ 网上随处可以见到一类对性能的讨论。一些新人也非常热衷此类讨论。但是实际上，它们除了让你写代码的时候纠结之外，毫无意义。 为什么这样讲呢？我想讲一个小故事。 从前有个工程师，特别注重代码细节，有一天他发现系统中的一段代码写的性能很差，因此，他用汇编重写了整段代码，执行效率足足提升了三倍。但是最后，大家发现，用户反馈性能丝毫没有提高，因为他优化的那个进程名字叫“System Idle”。 所以你看，性能优化不能只着眼于局部的代码。这里，我要提出一个我的观点：一切没有profiling的性能都是耍流氓。凡是真正有价值的性能优化，必定是从端到端的业务场景建立体系来考虑的。 在我的认识中，性能体系的建立可以分成以下几部分： 现状评估和建立指标； 技术方案； 执行； 结果评估和监控。 下面，我就来为你一一讲解。 现状评估和建立指标要想做好性能优化，正确地评估现状和建立指标是最关键的一步，它又往往是会被轻视的一步。 作为一个工程师，指标又要考虑两个因素。一方面，对用户来说，什么样的性能指标能更好地评估它的体验？另一方面，对公司来说，什么样的指标会影响业务价值呢？ 在我公布答案之前，我希望你能思考一下，你所负责的业务，是否有前端性能指标？它是否能够满足我上面提到的两个要求？ 在我之前的工作中，整个用了长达一年的时间来探索，才找到了合适的指标，并且回答好了两个问题。 性能问题可以分成很多方面，最重要的几个点是： 页面加载性能； 动画与操作性能； 内存、电量消耗。 注意，这里我们仅仅是对“性能”两个字的分析和解读，在对大量的用户数据分析后，我们发现，其实这三部分中，“页面加载性能”跟用户的流失率有非常强的关联性，而用户流失率，正是公司业务非常看重的指标。 因此，在开始阶段，我们决定把性能优化的重点放在页面加载性能上。 那么，用什么指标来衡量页面加载性能呢？最容易想到的方案是“用户平均加载时间”，事实上，我们在相当长的一段时间，也都是在使用用户平均加载时间作为性能指标。 但是，很快我们发现，这个指标有严重的问题： 当加载时间低于一定数字，用户体感差别不大了，我们经过一定的研究，认为这个数字大约是1秒； 少数超长时间加载的用户（如2G），会极大影响整个指标，即指标不能反映大多数用户的体验。 于是，基于以上分析，我们设计了一个新的指标——秒开率，即一秒之内打开的用户占用户总量的百分比。这个指标后来逐渐推广到整个公司，甚至影响到了一些业内的其它企业，现在，谈秒开率已经是个非常自然的事情了，但是当初的设计确实走了不少弯路。 技术方案有了指标，我们就有了优化的目标，接下来，就到了技术出场的环节了。 我们这里还是以加载过程为例，来讲解一下。 首先我们要简单分析一下，从输入URL后按下回车，到底发生了什么。 我们在浏览器的原理课程中，已经讲解了浏览器大致的工作过程，但是，我们必须理解几件事： 从域名到IP地址，需要用DNS协议查询； HTTP协议是用TCP传输的，所以会有TCP建立连接过程； 如果使用HTTPS，还有有HTTPS交换证书； 每个网页还有图片等请求。 从这个分析和实际试验的结果看，网页的加载时间，不但跟体积有关系，还跟请求数有很大关系，因此，我们最终设计的技术方案大约可以这样划分： 这里仅仅列出了性能优化的一部分技术方案，是我认为比较重要的部分，可以看到，这里涉及的并不仅仅是前端技术，有服务端、客户端、设计师团队，所以要想做好性能优化，绝对不能把自己限制在局部的视角，必须是整个业务一起考虑，才能有良好的收效。 执行技术方案设计好了，它是不会自己变成线上页面的，所以，有了技术方案，我们只完成了一半的工作，接下来我们还需要一个执行过程。 执行也不简单，如果说方案主要靠技术，那么执行就是靠工程实施了。 根据公司的实际情况，工程实施可能有不同的程度，我把工程水平从低到高分成三个阶段： 纯管理； 制度化； 自动化。 纯行政管理，是由经理用纯粹的管理手段来执行方案，比如说，作为前端团队的Leader，我可以组织会议，要求整个团队使用我们前面谈的技术方案。 但是纯行政管理有一些问题，一方面，需要的行政资源不一定有，比如我没法强制让后端团队配合我，另一方面，纯粹的管理方式，团队本身的体验并不好，也不利于团队成长，最重要的是，纯粹管理方式容易造成执行不到位。这样的执行方式多数出现在非技术岗位。 制度化执行方式是用规则代替人的命令，指定责任人，通过培训、checklist、定期review等具体措施来保证实施。制度化执行可以极大地减轻管理工作量，一般现代互联网公司都会采用类似的方式。但是制度化执行方式还有很大成分是依靠人的主动性的，对程序员来说，还有更好的方式：自动化。 自动化的方式是在一些重要的操作路径上设置规则，针对我们的性能优化，有两个点适合做这件事：一个是把开发好的页面发布上线，另一个是开发好的页面URL投放到首页等处的链接。 在我之前的工作中，我们跟测试团队配合，开发了一套页面性能打分系统，它会自动扫面页面上的可优化点，并且跟发布平台和投放平台合作，把它加入日常机制中。现在多数公司都会采用制度化和自动化结合的执行方案。 结果评估和监控执行完了之后，就要向老板汇报争取升职加薪了，还要有一定的结果总结，才是一个完整的工程实施，而且，凡是工程实施，肯定要有一定长效机制，不能优化完了退化，这些都要求有线上监控机制。 要想做线上监控，分两个部分： 数据采集； 数据展现。 数据采集部分，同样需要发布平台或者开发工具来配合，对性能数据来说，Performance API非常好用，它是浏览器记录的性能数据，一般来说，我们用统一的代码把它上传到服务器端就够用了。 数据的展现部分就比较自由了，可以用不同的数据可视化方案来展现性能数据，没有一定之规。一般的数据监控平台，会提供报警机制，对性能来说，报警需求不是特别强烈，但是也可以设置一些条件，针对秒开率特别低的网页报警。 有了监控，再配合一定制度，就可以保障整个团队产出的性能了，要注意，性能不是一个静态的事情，指标需要不断优化，技术方案还需要不断随着技术发展迭代，制度、自动化工具也需要不断改进，最终的监控平台产品也不能不做新需求，所以性能应该成为一个团队的日常工作的一部分，持续进行。 总结今天我们学习了前端团队工程实施中的性能体系，首先我们介绍了总体思想：性能应该是基于业务和实际用户体验需求的一种工程实施，不是纯粹的技术游戏。 接下来我们分成四个步骤介绍了性能工程体系，首先介绍了现状评估和建立指标，建立指标应当从业务的角度考虑，接下来讲了技术方案设计，技术方案应当从整体角度，基于Profiling的结果分析来设计。 之后我们讲了实施，我们讲了工程实施的三个层次：纯管理、制度化、工程化，最后，我们讲了结果评估和线上监控，线上监控需要从数据采集和数据展现两个部分分别实现。 最后，留一个小问题，请你为自己的团队和业务设计一下性能的整体方案，欢迎来留言分享。","link":"/2019/08/31/重学前端/性能：前端的性能到底对业务数据有多大的影响？/"},{"title":"新年彩蛋 | 2019，有哪些前端技术值得关注？","text":"大家好，我是winter，想借这个机会跟大家聊一聊2019年前端会发生的一些事情。 首先呢，我觉得可以谈一谈，我特别关注的图形学领域。 进击吧，图形学！在淘宝工作的后期，我也有很大一部分精力放在了图形学上面，我是深刻地感觉到，在未来，图形学会和前端结合的更紧密。这是由于我觉得图形实际上是UI最重要的一部分计算机科学，同时它也是计算机领域里面的一个非常关键的学科。 我们的前端就是做UI的这样的一个职能，在未来，我觉得随着前端的工作层级逐渐地下沉，前端能够做到越来越多的事情。我们的图形也会逐渐的成为前端的一个基本的技能。 我在2018年已经可以看到很多2D和3D领域的应用了，我们会用2D的东西去做图片的渲染，我们会用3D的东西去做一些3D场景的呈现，在不同的公司我都会看到很多这样的案例。 另外，我觉得图形学也会大量地吸收以前在PS中由设计师做的功能，很多以前我们做得这种效果，包括半透明，包括模糊等等都是在PS里面，用图片来实现的。 但我认为在未来，随着图形学技术逐渐地发展，前端可以用代码来实现这样的效果，这样我们就可以不用设计师产出的图片了，而是设计师告诉我们用什么样的效果，我们来写代码把它实现。 这种下沉其实有个好处，我认为当前端工作层下沉到一定的程度，我们就不会有“做不出来这样的效果”这件事发生了。 这件事是很有意义的，今天你去问一个C++的工程师，这个东西能不能做，他只会说这个东西我不能做，他不会说，C++不能做，那在我们前端这样的情况往往是刚好相反的，所以说，我觉得未来下沉，技术下沉会给我们前端带来更多的职责，也同时是一种责任。 包管理的救赎我觉得前端第二个会非常重要的发展趋势就是：包管理。我们都知道，NPM是一个非常好的包管理。 但是实际上，我们的NPM生态里也有很多的问题，包括安全问题，包括依赖太多造成的性能问题。我觉得目前到了一个重要的时间点了，那么NPM的这种问题，一定会有人解决。 但这种解决方案，到底是NPM的竞争对手会产生一个新的这样的包管理的平台；还是我们的NPM生态里面诞生一些更好的方案，最终把问题解决呢？这个就是我没有办法去预测的事情了。 智能研发，前端有责另一个技术是我比较关注的是AI领域和前端的结合，我们的AI领域，今天虽然炒得非常火热，但是在我看来，真正应用的比较好的场景，就是视觉和推荐这两个领域。 我觉得智能研发的领域是整个学术界非常少关注的，那么我们的前端应该把这个责任背起来。 我在淘宝已经看到很多这个方面的努力了，我觉得在业界，这个东西在2019年产量应该也会越来越成熟，毕竟切图工作是一个机械性的劳动，机械性的劳动最终一定会被机器取代。 所以，我认为未来，我们前端的工作是不应该包含切图这项工作的。我也比较期待这方面能够尽快地产生一些成绩。 最后呢，我觉得其他的技术在2019年，应该会是一个稳定发展的状态，包括大家特别关心的三大框架，Vue、Angular、React。我认为应该是“继续繁荣发展，继续稳定发展，最后生态越来越成熟”这样的一个状态。 以上呢，就是我对2019年的一些预测和预期了。当然了，我非常希望我们今天中国的前端界能够诞生一些新的想法，能够让我大吃一惊，甚至是让我的预测落空，我觉得我也会非常高兴的。 在最后，再次祝大家新年快乐。你对前端的发展有什么样的判断和预测呢，欢迎给我留言，我们一起讨论。","link":"/2019/08/31/重学前端/新年彩蛋 | 2019，有哪些前端技术值得关注？/"},{"title":"持续集成：几十个前端一起工作，如何保证工作质量？","text":"你好，我是winter。今天我们来聊聊持续集成。 持续集成是近现代软件工程中的一个非常重要的概念。它是指在软件开发过程中，以定期或者实时的方式，集成所有人的工作成果，做统一的构建和测试。 与持续集成相对的做法是：独立开发各个模块，在软件开发的最终阶段才做集成。持续集成的优势是及早处理集成阶段的问题，使软件质量和开发进度可控。 现在持续集成还有升级版本：持续交付和持续部署，这些因为需要更为完善的基础设施，目前很少有公司前端团队可以用上，我们暂且不谈。 传统的持续集成概念诞生于桌面客户端开发，在Web前端领域，由于技术和产品形态的差别，我们需要构建的持续集成体系也有一些区别。 持续集成总论传统软件的持续集成主要有以下措施。 daily build：每日构建，开发者每天提交代码到代码仓库，构建一个可运行的版本。 build verification test（BVT）：构建验证测试，每日构建版本出来后，运行一组自动化的测试用例，保证基本功能可用。 对于前端来说，有一些现实的区别： 前端代码按页面自然解耦，大部分页面都是单人开发； 前端构建逻辑简单，一般开发阶段都保证构建成功，不需要构建； 前端代码一般用于开发界面，测试自动化成本极高； 前端页面跳转，是基于url，没有明确的产品边界。 基于以上分析，传统的持续集成方案放在前端，要么不需要，要么不适用，要么实施成本高，因此我们不能套用传统的持续集成理论，而需要重新思考前端领域的持续集成体系。 持续集成的目标前面我们已经分析过，每日构建不需要，前端构建验证测试成本过高难以实施，那么我们是不是可以有一些代替的措施呢？ 首先我们要确定前端持续集成的目标，我们回到持续集成的根本理念，一是要及早集成代码形成可测试的版本，二是通过一定的测试来验证提交的代码的有效性。 持续集成的方案我们进一步思考，前端持续集成如何完成这两个目标呢？ 前端代码不需要构建，或者说只需要单页面构建，但是页面与页面之间的跳转是用url构成的，所以我们的可测试的版本，不可能通过“构建”来获得。 我们只能通过“发布”来获得一个前端代码的可执行版本，在传统语境中，“发布”的目标是线上生产环境，这显然不行。于是，我们就需要一个预览环境，来做一种“虚拟发布”的操作。 我们再来考虑一下，为界面编写自动化测试用例成本很高，那么如何代替构建验证测试呢？ 我们回忆一下，在性能一课，我有讲过，页面的性能可以通过一些自动化工具来分析，还可以通过一些数据采集方案来发现性能问题，对于预览环境前端页面，我们可以采用同样的措施。 除了基于页面结构的分析和数据采集，我们还可以扫描代码。 综上，我认为前端的持续集成的措施应该是这样的： 预览环境，代替每日构建，前端每次（或指定次）提交代码到仓库都同步到预览环境，保证预览环境总是可用； 规则校验，代替构建验证测试，通过数据采集（如前面提到的性能数据）和代码扫描，保证提交的代码满足一定的质量要求。 接下来，让我来详细介绍一下预览环境的设计和规则校验的设计。 预览环境前端代码发布到线上生产环境需要有线上的机器和域名，而预览环境同样需要机器和域名，不过，只需要在公司内网即可。 所以建立预览环境的第一步就是申请机器和域名，我们需要运维协助，在预览环境的机器上部署Web应用服务器。 有了预览环境的机器，下一步就是建立预览环境发布机制。 有些公司使用脚本发布，有些公司使用git hook，有些公司则使用一个Web应用平台，进行白屏操作，因为各个公司的发布机制千差万别，我这里没办法讲解具体的方案。这里我建议，预览环境的机器发布流程应该跟线上发布保持一致，这样可以最大程度降低成本和降低心智负担。 预览环境的部署和发布机制建立是最基本的需求，在实际应用中，情况要复杂的多，可能需要多个预览环境同时存在。 比如，测试工程师可能要求一个相对稳定的环境来测试，这是一个合理的诉求，比如，全公司大部分业务都可能依赖登录页面，一旦登录页面在频繁发布导致一些预览环境的故障，可能全公司都没办法工作了。 又比如，当服务端工程师联调时，会希望前端的预览环境跟服务端的预览环境对接，而当服务端的代码部署到线上生产环境后，可能又需要前端的预览环境跟服务端线上环境对接。 这些问题都是我曾经遇到过的非常现实的问题，如果今天回过头来设计，我认为应该设计一套带参数和版本号的预览环境，为测试提供特定版本的预览环境，用参数解决那些跟服务端API对接问题，但是任何系统都不可能从一开始就设计完善，所以，建议你把重心放到建立预览环境的基本需求上来。 规则校验接下来我们讲讲规则校验，规则校验可以分成三种措施： 页面结构扫描； 运行时数据采集； 代码扫描。 页面结构扫描可以使用无头浏览器（如phantomjs）配合一些JavaScript代码编写的规则来完成。 运行时数据采集，可以通过在页面插入公共js文件的方式来完成，最基本的是用Performance API来采集性能数据，用window.onerror来采集js错误。 代码扫描，社区有一些现成的方案，比如JSHint，你可以根据实际需要，选择社区方案或者自研。 持续集成的实施持续集成的实施，是必须严格做到自动化和制度化的。我们可以通过上节课讲的工具来完成持续集成。其它部分，都可以通过工具和制度来完成，这里需要重点讲的是规则校验中的规则部分。 我们刚刚讲解的规则校验仅仅是搭建好了平台，而规则本身，我们需要先形成一个共识，然后在前端团队内部形成一定的更新机制。 这里，我建议用issue的方式来管理规则的提案，可以在周会或者月会上讨论，充分保证整个团队对校验规则的一致意见。 这里，我们必须警惕三种错误： 少数人拍脑袋决定校验规则； 一成不变的校验规则； 频繁无规律变化的校验规则。 只有经过民主讨论、定期更新的校验规则，才能在团队中起到积极作用。校验规则决定了整个前端团队的开发体验，所以必须非常慎重。 持续集成的结果持续集成机制的建立本身就可以视为一种结果，它能够让整个团队的代码质量有一个基本的保障，提前发现问题，统一代码风格，从而带来开发体验和效率的提升。 此外，持续集成的结果也能够以数据的方式呈现出整个开发团队的健康状态，这是管理者会非常关注的一个点。 总结今天我们讲解了持续集成，持续集成这个概念最早来自桌面客户端软件开发，应用到前端领域，会有一定的变化。这里我提出了一个预览环境+规则校验的前端持续集成体系。 预览环境需要申请机器和域名、部署和建立发布机制，规则校验有三种方法：结构扫描、数据采集和代码扫描。 持续集成的实施需要重点关注校验规则部分，要建立一个民主讨论、定期更新的校验规则。持续集成机制的建立就是其结果本身，此外，系统中产生的数据也可以有一定管理价值。 最后留一个问题，你所在的团队，是否有做持续集成呢？请你设计或者改进这个持续集成方案。","link":"/2019/08/31/重学前端/持续集成：几十个前端一起工作，如何保证工作质量？/"},{"title":"搭建系统：大量的低价值需求应该如何应对？","text":"你好，我是winter。 不知道你在工作中有没有遇到过这样的事情：一个运营找过来说，有一个紧急又简单的临时活动页面要做，希望打断现有的产品开发节奏临时插入。 这类页面技术难度不高，业务上通常属于“紧急不重要”的事情。 这些需求技术上没挑战，线上存在时间短，上线时间紧又没有任何调整空间，它们往往会成为前端团队里人人都不喜欢的“垃圾需求”，谁要是接了这种需求，就只能自认倒霉。 但是，这些真的是垃圾需求吗？换个视角来看，我认为它反而是宝藏。 所谓工程师，就是为了解决这些问题而存在的岗位，我们从工程的视角来看，“大量紧急不重要的页面”，才是真正的需求，现在需求有了，我们就应该按照工程的方式，定目标、设计方案、做实施、拿结果来解决问题。这就是我们今天要讲的搭建系统。 搭建系统的目标搭建系统的目标是解决大量的简单页面生产问题。衡量这个目标的指标应该是生产页面的数量，这部分非常的明确，你如果要做搭建系统，可以根据业务的体量和服务的范围来决定具体的指标要求。 搭建系统的设计搭建系统设计大概有几种流派，这里我介绍几种常见的搭建系统的设计。 第一种，是模板化搭建，由前端工程师生产页面模板，再由运营提供数据来完成页面，可以用以下公式来理解： 模板 + 数据 = 页面 模板化搭建是一种简单的思路，它的优点是整个系统实现简单。 第二种思路是，模块化搭建，由前端工程师生产模块，由运营把模块和数据组织成页面。 第三种思路，是数据驱动界面，这是一种比较新的思路，即数据中包含了展现自身所需要的模块相关的信息，本身决定了界面。 但是不论何种流派，都可以认为是数据、模块、模板、页面几种实体的相互作用，下面我就来详细讲解一下这几样实体。 数据数据是用于展现界面所需要的信息。 我们按照数据用途，可以分成界面配置数据和内容数据。 界面配置数据：决定了页面上颜色、尺寸、位置、图片、文字等展现形式的数据，通常是以页面为单位的配置。 内容数据：页面要展示的信息，如电商活动页面的商品信息、文章的文字信息等。 按照数据来源，我们又可以分成运营人员手工填写的数据和来自API产生的数据。 运营手工填写固定数据：运营人员依靠自己的专业技能决定的数据，可能包含线下招商信息、商品选品、文章等。 来自API的数据： 固定数据，由服务端逻辑到指定存储处获取的数据； 用户相关数据，由算法系统或者服务端逻辑，根据用户信息或者用户喜好推荐的数据。 搭建系统本身是个产品，我们针对数据这个实体，要设计增、删、改、查的能力，根据我们以上的分析，搭建系统的数据部分有两个难点。 第一个难点是数据的手工编辑能力，现在一般的数据都会采用JSON格式，JSON格式中有数字、字符串、数组、对象、布尔等数据类型，我们需要根据数据的格式定义为每一种类型设计编辑器。 但是仅仅是基本类型还不够，我们实际开发中，还需要跟实际业务结合来设计编辑器，下面，我就把我在之前的工作中设计的数据编辑器列一下。 整数：整数编辑器，可用HTML原生输入框&lt;input type=number min=1 max=100/&gt;实现。 数字：数字编辑器，可用&lt;input type=number min=1.0 max=100.0/&gt;实现 字符串：字符串编辑器，可用&lt;input /&gt;实现。 URL：URL编辑器，可用&lt;input /&gt;配合格式校验。 图片：图片编辑器，需要自研图片上传功能。 固定字段对象：对象和字段编辑器，可用多个&lt;input /&gt;和&lt;label&gt;实现。 布尔型：开关，可用&lt;select&gt;或者自研组件实现。 自由字段对象：需要自研KV输入组件。 数组：需要自研列表组件实现。 对象数组：需要自研表格组件或者列表组件实现。 矩形区域：需要自研区域选择组件。 这里要注意JSON是一个级联的格式，所以对象、数组中很可能需要插入各种不同的数据类型的编辑器，这部分技术上有一定挑战。此外，实践中，对象数组很多时候都来自Excel数据，Excel导入也是非常重要的。 第二个难点则是跟服务端API的对接，对于服务端系统统一性较好的公司，这不是什么难事，对服务端系统比较奔放的公司，如果服务端API调用方式不统一，就非常麻烦了。这一块只能根据实际情况见招拆招，我这里没办法详细介绍， 模板模板可以简单得理解成挖了许多坑的页面，它一般是由前端工程师来生产的一种实体。与数据之间的连接是数据的格式，对JSON格式来说，JSON Schema是社区接受度较高的一个方案。 最简单的模板可以用字符串模板来设计，复杂一点的模板则可以由JavaScript进行渲染，通过约定全局变量名称或者约定调用函数入口做到把数据传递给模板，你可以根据实际需求复杂程度选择合适的方案。 需要注意，在产品设计上，模板可不是“增、删、改、查”那么简单，考虑到实际工程需要，模板必须是版本化的，也就是说，前端每发布一个模板，都需要永久性存储一条记录，并且产品设计上必须保持可以回滚，这样，一旦线上发现问题，可以迅速回滚到一个可工作的版本，有效降低不可用时长。 此外，模板设计还有批量更新的需求，一些运营活动可能包含数百个页面，它们使用同一套模板，产品设计上必须要注意提供批量更新机制。 模块模块跟模板非常相似，但是从产品的角度，模块是可组合的。跟模板相似的部分如数据连接、版本化发布、批量更新等，这里就不再赘述。 模块化搭建有额外的技术难点，就是可拖拽的模块编辑器，移动端搭建布局相对简单，可以通过简单的自上而下布局和拖拽改变位置来实现。 桌面的模块拖拽比较复杂，一般都会采用一些变通的思路简化设计，如提供几种固定的布局模板，提供布局容器，或者采用纯绝对定位布局。 在一些产品设计中，会先用模块拼成模板，再指定数据源，这种模式中的“模块”，我们认为是一种开发模板的技术方案，跟我们此处讲的产品上的模块概念不同。因为在我们的认知中，模板应该是由前端工程师产生的，具有复用性的一种实体。 页面不论是模板搭建还是模块搭建，我们的最终生产的目标都是页面。页面同样需要版本化发布，便于回滚。 页面部分实现的难点是跟发布系统的结合，在我们前面讲的所有产品实体中，模板、模块、数据都是存储在搭建系统本身的，但是页面不一样，页面必须要提供线上服务，所以页面是要发布到线上生产环境的。 如我们上一课讲的，假设前端持续集成系统有校验规则，页面也必须经过这个过程。 在我之前的工作中，是通过自建静态Web服务器+CDN回源的方式来支撑搭建系统的线上应用的。 因为服务器上只发布静态内容，并且有CDN挡住用户流量，所以只需要少量几台线上机器即可。 搭建系统的实施在我工作的实践中，搭建系统的实施可以说是所有系统中最容易的了，对多数公司来说搭建系统是一种刚性需求，只要完成了产品开发，立刻会有大量的用户。 所以只要正确识别了需求，搭建系统的推行几乎完全不需要担心。 搭建系统的监控作为一个工具型技术产品，搭建系统同样会产生大量有价值的数据，搭建系统的用户访问和生产页面数量是衡量自身的重要指标。 总结本课我为你讲解了搭建系统，搭建系统是为了应对大量简单页面的生产需求而设计的一种工具型产品，它的目标非常明确，就是快速生产大量的页面。 方案上，它重点和难点在于几个产品实体的设计，数据部分重点在于编辑器和跟服务端API的对接，模板部分则主要是版本化和数据的格式定义，模块除了模板的重点，还有拖拽系统，最终产生的页面主要的难点是跟生产环境的对接。 搭建系统的实施主要是把产品在做出来，一般来讲推广是非常自然的事情，最后，搭建系统产生的数据监控关键的指标是用户访问数和生产页面数。 本课的思考问题是，请你分析一下你们公司是否有搭建系统的需求，尝试用本课的知识来设计或者改进一下你们的搭建系统。","link":"/2019/08/31/重学前端/搭建系统：大量的低价值需求应该如何应对？/"},{"title":"明确你的前端学习路线与方法","text":"你好，我是winter。今天我们一起来聊聊前端的学习路线与方法。 在“开篇词”中，我和你简单回顾了前端行业的发展，到现在为止，前端工程师已经成为研发体系中的重要岗位之一。可是，与此相对的是，我发现极少或者几乎没有大学的计算机专业愿意开设前端课程，更没有系统性的教学方案出现。大部分前端工程师的知识，其实都是来自于实践和工作中零散的学习。 这样的现状就引发了一系列的问题。 首先是前端的基础知识，常常有一些工作多年的工程师，在看到一些我认为很基础的JavaScript语法的时候，还会惊呼“居然可以这样”。是的，基础知识的欠缺会让你束手束脚，更限制你解决问题的思路。 其次，技术上存在短板，就会导致前端开发者的上升通道不甚顺畅。特别是一些小公司的程序员，只能靠自己摸索，这样就很容易陷入重复性劳动的陷阱，最终耽误自己的职业发展。 除此之外，前端工程师也会面临技术发展问题带来的挑战。前端社区高度活跃，前端标准也在快速更新，这样蓬勃发展对技术来说无疑是好事，但是副作用也显而易见，它使得前端工程师的学习压力变得很大。 我们就拿JavaScript标准来说，ES6中引入的新特性超过了过去十年的总和，新特性带来的实践就更多了，仅仅是一个Proxy特性的引入，就支持了VueJS从2.0到3.0的内核原理完全升级。 缺少系统教育+技术快速革新，在这样的大环境下，前端工程师保持自学能力就显得尤其重要了。 那么，前端究竟应该怎么学呢？我想，我可以简单分享一下自己的经验。 学习路径与学习方法首先是0基础入门的同学，你可以读几本经典的前端教材，比如《JavaScript高级程序设计》《精通CSS》等书籍，去阅读一些参考性质的网站也是不错的选项，比如MDN。 如果你至少已经有了1年以上的工作经验，希望在技术上有一定突破，那么，这个专栏就可以是你技术进阶的一个选项了。 在这个专栏中，我希望传达的不仅仅是具体的知识点，还有体系架构和学习方法。我希望达到三个目标： 带你摸索出适合自己的前端学习方法； 帮助你建立起前端技术的知识架构； 让你理解前端技术背后的核心思想。 在开始具体的知识讲解之前，这篇文章中，我想先来谈两个前端学习方法。 第一个方法：建立知识架构第一个方法是建立自己的知识架构，并且在这个架构上，不断地进行优化。 我们先来讲讲什么叫做知识架构？我们可以把它理解为知识的“目录”或者索引，它能够帮助我们把零散的知识组织起来，也能够帮助我们发现一些知识上的盲区。 当然，知识的架构是有优劣之分的，最重要的就是逻辑性和完备性。 我们来思考一个问题，如果我们要给JavaScript知识做一个顶层目录，该怎么做呢？ 如果我们把一些特别流行的术语和问题，拼凑起来，可能会变成这样： 类型转换； this指针； 闭包； 作用域链； 原型链； …… 这其实不是我们想要的结果，因为这些知识点之间，没有任何逻辑关系。它们既不是并列关系，又不是递进关系，合在一起，也就没有任何意义。这样的知识架构，无法帮助我们去发现问题和理解问题。 如果让我来做，我会这样划分： 文法 语义 运行时 为什么这样分呢，因为对于任何计算机语言来说，必定是“用规定的文法，去表达特定语义，最终操作运行时的”一个过程。 这样，JavaScript的任何知识都不会出现在这个范围之外，这是知识架构的完备性。我们再往下细分一个层级，就变成了这个样子： 文法 词法 语法 语义 运行时 类型 执行过程 我来解释一下这个划分。 文法可以分成词法和语法，这来自编译原理的划分，同样是完备的。语义则跟语法具有一一对应关系，这里暂时不区分。 对于运行时部分，这个划分保持了完备性，我们都知道：程序 = 算法 + 数据结构，那么，对运行时来说，类型就是数据结构，执行过程就是算法。 当我们再往下细分的时候，就会看到熟悉的概念了，词法中有各种直接量、关键字、运算符，语法和语义则是表达式、语句、函数、对象、模块，类型则包含了对象、数字、字符串等…… 这样逐层向下细分，知识框架就初见端倪了。在顶层和大结构上，我们通过逻辑来保持完备性。如果继续往下，就需要一些技巧了，我们可以寻找一些线索。 比如在JavaScript标准中，有完整的文法定义，它是具有完备性的，所以我们可以根据它来完成，我们还可以根据语法去建立语义的知识架构。实际上，因为JavaScript有一份统一的标准，所以相对来说不太困难。 如果是浏览器中的API，那就困难了，它们分布在w3c的各种标准当中，非常难找。但是我们要想找到一些具有完备性的线索，也不是没有办法。我喜欢的一个办法，就是用实际的代码去找：for in 遍历window的属性，再去找它的内容。 我想，学习的过程，实际上就是知识架构不断进化的过程，通过知识架构的自然延伸，我们可以更轻松地记忆一些原本难以记住的点，还可以发现被忽视的知识盲点。 建立知识架构，同样有利于面试，没人能够记住所有的知识，当不可避免地谈到一个记不住的知识，如果你能快速定位到它在知识架构中的位置，把一些相关的点讲出来，我想，这也能捞回不少分。（关于前端具体的知识架构，我会在02篇文章中详细讲解。） 第二个方法：追本溯源第二个方法，我把它称作追本溯源。 有一些知识，背后有一个很大的体系，例如，我们对比一下CSS里面的两个属性： opacity； display。 虽然都是“属性”，但是它们背后的知识量完全不同，opacity是个非常单纯的数值，表达的意思也很清楚，而display的每一个取值背后都是一个不同的布局体系。我们要讲清楚display，就必须关注正常流（Normal Flow）、关注弹性布局系统以及grid这些内容。 还有一些知识，涉及的概念本身经历了各种变迁，变得非常复杂和有争议性，比如MVC，从1979年至今，概念变化非常大，MVC的定义几乎已经成了一段公案，我曾经截取了MVC原始论文、MVP原始论文、微软MSDN、Apple开发者文档，这些内容里面，MVC画的图、箭头和解释都完全不同。 这种时候，就是我们做一些考古工作的时候了。追本溯源，其实就是关注技术提出的背景，关注原始的论文或者文章，关注作者说的话。 操作起来也非常简单：翻翻资料（一般wiki上就有）找找历史上的文章和人物，再顺藤摸瓜翻出来历史资料就可以了，如果翻出来的是历史人物（幸亏互联网的历史不算悠久），你也可以试着发封邮件问问。 这个过程，可以帮助我们理解一些看上去不合理的东西，有时候还可以收获一些趣闻，比如JavaScript之父 Brendan Eich 曾经在Wikipedia的讨论页上解释JavaScript最初想设计一个带有prototype的scheme，结果受到管理层命令把它弄成像Java的样子（如果你再挖的深一点，甚至能找到他对某位“尖头老板”的吐槽）。 根据这么一句话，我们再去看看scheme，看看Java，再看看一些别的基于原型的语言，我们就可以理解为什么JavaScript是现在这个样子了：函数是一等公民，却提供了new this instanceof等特性，甚至抄来了Java的getYear这样的Bug。 结语今天我带你探索了前端的学习路径，并提出了两个学习方法：你要试着建立自己的知识架构，除此之外，还要学会追本溯源，找到知识的源头。 这个专栏中，我并不奢望通过短短的40篇专栏，事无巨细地把前端的所有知识都罗列清楚，这本身是MDN这样的参考手册的工作。但是，我希望通过这个专栏，把前端技术背后的设计原理和知识体系讲清楚，让你能对前端技术产生整体认知，这样才能够在未来汹涌而来的新技术中保持领先的状态。 在你的认识中，前端知识的结构是怎样的？欢迎留言告诉我，我们一起讨论。","link":"/2019/08/31/重学前端/明确你的前端学习路线与方法/"},{"title":"期末答疑（二）：前端架构中，每个逻辑页面如何可以做到独立发布呢？","text":"你好，我是winter。 上一期的答疑文章发布之后，同学们的热情很高，我在后台又收到了一批新的问题，今天我们继续来答疑。 1. 请问前端架构中，每个逻辑页面如何可以做到独立发布呢？ 答：首先，我们要知道发布是什么意思，我们平时开发好一个网页，把它放到线上真实对用户服务的机器上，这个过程叫做发布。 正常来讲，前端工程师发布的原材料是HTML，产出是一个线上的URL地址。 各个公司的发布系统差异非常的大，有的是前端发HTML，有的是前端把代码给服务端同学，改成JSP之类的代码，再一起发布。 对于逻辑页面而言，我们需要发布的从HTML变成了JavaScript，这个JavaScript代码的作用就是渲染一个页面的内容。同时我们线上还需要一个公共的HTML文件来运行这些JavaScript。 最后这些JavaScript文件只要能够做到独立发布，我们就可以认为逻辑页面是独立发布了。 2. 对于一个后端开发者来说，前端最困难的东西永远是CSS布局而不是JavaScript，我们对CSS有很大畏惧和恐慌在于：CSS没有很好的调试工具能解决问题，即使chrome dev这样的顶级debug工具，有时候也很难解释诸如“为什么页面上的这个盒子在这个地方”这样的问题。感觉CSS完全不符合编程的思路，老师有没有办法缓解一下这个问题？ 答：其实我在课程中已经解释过了，早期的CSS从思路上来说就很别扭， 任何人都会觉得别扭，现在有了Flex布局，我认为这个问题基本可以算解决了。 3. 最近一直在研究前端性能优化和线上错误收集，收效甚微，老师可以讲解一下大厂是怎么处理的吗？ 答：这一部分，首先你需要一个比较通用的日志服务，能接受前端用HTTP请求的方式打一些日志进去，一般公司都会有这样的系统，如果没有，就需要新建一个，这部分比较麻烦，需要一定的专业知识。 有了这个日志服务，剩下的就是在每个前端页面插入一个JavaScript代码，监听Window.onerror可以得到错误，取window.performance可以得到性能，拿到以后，打日志就行了。 至于后续怎么去展示，展示了以后又怎么去推动执行，这块就需要你自己根据公司实际情况去找到解决方案了。 4. 老师，想问一下用float排版的时候margin值在不同的浏览器中会显示不同，是什么原因导致的呢？ 答：我是从IE6时代过来，我还真没听说过margin值有什么兼容问题，你可以拿具体的案例来，我们一起看一看。不过我建议早日切到flex，我们不要在没价值的事情上浪费生命。 5. 把链接分为超链接类和外部资源类是您自己的理解么，还是官方有这种分类呀，我没找到。老师可以说一下么？ 答：不是，链接这个概念来自HTML标准（4.6.1位置）。 https://html.spec.whatwg.org/ 我在HTML的部分都在讲这个问题，你可以关注一下。 6. 老师，关于线上监控的数据采集和数据显示您有好的插件或者方案推荐？ 这个其实没有现成的，这个东西，如果公司从数据安全的角度考虑，一般都不让用第三方的。 7. 老师提到原生构造器无法继承。而阮一峰老师表示，es6已经可以继承原生构造函数，并且能定义子类。以我的理解来看，阮一峰老师的说法没有问题。不知道老师怎么看？ 答：我查了一下，你说的没错，还真是这样，这块我理解错了，我后面会迭代一下。 8. 活动页面样式风格多变，并且有些活动页面是存在交互和购买流程等交互，这些交互怎么做成模板化？ 答：这个答案很简单，只要能传参数，就能做成模板化。 9. DOM树就是一种嵌套的数据结构吗？然后是渲染引擎将这个数据结构处理成我们看到的网页吗 ？ 答：DOM树是嵌套的树形结构，渲染过程是把它变成位图，绘制过程是把它画到显示器上。关于这部分内容，你可以回顾一下浏览器原理部分的几节课。 10. 浏览器中大多数的对象都原型继承自Object，是否可以根据原型继承关系将Window上面的api绘制成一颗树？有了这些继承关系是否更容易理清这些全局属性呢？ 答：API不止有类，也有很多函数呀。所有的函数API的原型都是Function.prototype，这不就没意义了么。 11. “宿主对象（host Objects）：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。” 但是下面对宿主对象的解释又是：“实际上，这个全局对象 windows上的属性，一部分来自 JavaScript 语言，一部分来自浏览器环境”。这并不像上面说的完全由宿主环境决定，这个怎么理解呢？ 答：请注意看了，我这里讲宿主对象有个“们”字。 所以，这里可不是对宿主对象的解释，这是对Window对象的解释。Window对象比较复杂，这块我没有详细讲，从JavaScript的Global Object的角度可以讲，浏览器部分还有个Window Proxy机制，我是觉得复杂又没什么实际意义就没有讲，你可以这样感性地理解一下：全局对象和Window对象合成了一个东西。 12. winter老师，我看到淘宝用了iframe标签，能给我讲一下这个标签的使用场景和注意点吗？ 答：我可以简单告诉你一个口诀：手机上不要用，PC上除了历史包袱不要用。 13. 请问下，link preload 解析执行时机和构建 CSSOM一样吗，HTML从上往下解析到link preload才会解析执行？还是说并行解析HTML和preload？ 答：从标准来看应该是可以并行，但是具体怎样这块需要看浏览器源代码确定。 14. 老师，在ES5之前版本规范中，会提及JavaScript的可执行代码分为全局、函数、Eval。但是在ES6之后版本规范中，再也不提及可执行代码的概念了，这是为什么呢？ 答：它们还在，只是现在执行过程更复杂了，没法这么简单分类了。 15. winter老师，你提倡多继承吗？还是说尽量用聚合来解决问题？我看着ES6里面要实现多继承的方式也挺别扭的。 答：我不提倡多继承，Java也不支持多继承啊。如果你想抽象可以用接口来代替，想复用可以用Mixin来代替。 16. 我这里还有个问题，使用figureCaption标签后，img标签的alt属性可以缺失么？我一直觉得alt与src情同手足，什么都不应该把彼此拆散的。 答：不可以缺失，这是两个意思，figureCaption可能是“图1”这种东西，可不一定在描述图片内容。 17. 老师，style 既然也可以这么用&lt;style&gt;css 规则&lt;/style&gt;，为什么没有 &lt;style src=“”&gt;&lt;/style&gt;？ 答：你这个设计得不错，但是估计有了link以后，HTML懒得把style改成replacement了吧。 18. 老师好，想请问下，业务场景中需要嵌入公司其他行业线的页面，这种不使用iframe该怎么办？ 答：理论上应该让他们给你做个组件出来，但是如果实在没别的办法，就使用iframe吧。 19. 老师，目前有办法通过脚本反射的方式获取所有JavaScript原生对象吗？还是只能查文档？通过for. in 遍历全局对象是不可以的，因为这些JavaScript原生对象虽然挂到了全局，但是属于不可枚举成员。 答：我们现在可以用Object.getOwnPropertyNames，但是你symbol还是拿不到。 20. 老师，jquery ajax 同步请求的原理是?目前用axios库，不支持同步请求，如果希望执行同步请求有什么解决办法？ 答：原理是XMLHttpRequest这个可以传第三个参数，但是我不建议你用同步请求，会把JS执行线程卡住。 21. 老师您好，把JavaScript代码缓存在 localStorage 中，从 localStorage 取出后怎么执行？ 如果缓存的是 CSS 呢？ 答：执行JavaScript用eval，执行CSS用document.createElement(“style”)。 22. 请问：var,let 和 const 在 babel 中都会被编译为 var, 那怎么区分 const 是常量呢？ 答：如果你用babel的话，就不要管编译后的代码。 23. DOM树构建与CSSOM构建有先后关系吗？CSS计算与DOM树流式构建同步进行是不是意味着DOM树流式构建之前，CSSOM已经构建完成呢？ 答：我这里说的确实有点歧义，我在这里再厘清一下。CSSOM是有rule部分和view部分的，rule部分是在DOM开始之前就构件完成的，而view部分是跟着DOM同步构建的。 24. 老师能解释下这个么？ var b = 10; (function b(){ b = 20; console.log(b); // [Function: b] })();答：这个地方比较特殊，“具有名称的函数表达式”会在外层词法环境和它自己执行产生的词法环境之间，产生一个词法环境，再把自己的名称和值当作变量塞进去。 所以你这里的b = 20 并没有改变外面的b，而是试图改变一个只读的变量b。这块儿的知识有点偏，你仅做理解掌握就好。 25. 关于状态机这一块，我觉得是不是可以先讲一节正则的知识点呢。理解了正则，那么大家对状态机的概念就有了更加直观的理解了。 答：一般正则都是状态机实现的，讲正则对理解它底层的状态机并没有多少意义。 当然了，词法分析也可以用正则来实现，我这里没有这么做而已，我写过一个JavaScript的词法分析是用正则做的，你可以参考这里: https://github.com/wintercn/JSinJS/blob/master/source/LexicalParser.js 好了，今天的答疑就到这里，如果你还有问题，可以继续给我留言。我们一起讨论。","link":"/2019/08/31/重学前端/期末答疑（二）：前端架构中，每个逻辑页面如何可以做到独立发布呢？/"},{"title":"期末答疑（一）：前端代码单元测试怎么做？","text":"你好，我是winter。 我们专栏课程的知识部分已经告一段落了。今天，我来集中解决一下大家在学习中遇到的问题，我争取用快问快答的形式，咱们多回答一些问题。 1. 前端代码单元测试还是非常有必要的，不知道老师这一块是怎么做的，能否分享一下？ 答：关于单元测试这件事，虽然在业务代码我没做成功过，但是它在框架和基础库开发中起到了非常积极的作用。 我们平时写代码也肯定写一部分就要运行一下试试，其实这种行为就是单元测试，只是我们把很多自动化的内容，用人肉执行了，并且没有保存和管理case，也没有统计code coverage。 只要选择一个好的单元测试框架，单元测试成本其实不高，尤其是比较复杂的底层库，引入单元测试不但不会消耗时间，还会提高效率。 所以我认为单元测试要实行，有两个关键点你要格外注意：一是出一套好的单元测试方案，二是在基础库和框架开发中引入单元测试。 2. 关于Undefined ，如果一个变量没有赋值后面又赋值，这个过程就是“变量会被篡改”的意思么？而null 为什么又不会被篡改？一个变量开始定义为 null 然后赋值其他数据这个过程不算篡改吗？ 答：undefined是个全局变量，null是个关键字，在一些版本比较旧的浏览器上，你可以试试： undefined = 1;但是你在任何版本的浏览器上，都不能这么干： null = 1; 这样的话，上面这个代码就会报错了。 3. winter老师你好，我们公司的前端是Node.js写的，如何做性能监控呢，如何做页面加载优化呢，我对您的页面性能打分系统很感兴趣，能详细讲一讲吗？谢谢了。 答：首先，Node.js写的是服务端代码跟前端性能没有任何关系，Node.js的性能监控比前端性能监控复杂得多，你可以了解下alinode。 前端性能打分可能主要包含几个部分。 图片：检查图片数量和图片大小，比如单个超过50k，总量超过400k的图片就要注意了，如果检查到小图片，也可以建议用data uri内联。 请求数：检查请求数，检查是否有独立的JS、CSS请求，这些都是潜在的优化点。 域名：检查域名是否有在http dns的范围内，检查域名数量是否过多，检查资源文件域名是否属于CDN。 实际加载时间：如果测试环境加载时间过程，也可能说明一些问题。 缓存：检查静态资源是否设置了正确的缓存。 你可以自己动手试试。 4. 有一个疑惑是，大小写的两个属性有什么区别呢，比如： Screen，screen Event，event答：这里面大写的是类，小写的是对象。 5. 我还是比较认同，从左往右匹配的规则，这样就像老师讲的可以在构建DOM树的同时来进行匹配CSS规则，相当于同时构建渲染树了，而不必等到DOM构建完毕再进行CSS的规则匹配。 进行构建渲染树，虽然从右向左匹配对于复杂的选择器更优，但是这里面浪费了等待DOM构建完毕，才能使用的CSS匹配规则。而且相对于同为id等单一选择器而言，明显从左向右更具有优势！这是我的一点想法，望老师指正！ 答：其实我在之前的分享中做过一个试验，当时的Chrome确实是从右往左，如果#id在最左，速度会更快，但是那个过程是后添加CSS的情况。 6. 程老师你好。我在很多地方看到的说法是：CSS会阻塞DOM渲染，但不会阻塞DOM的解析，且CSS文件的请求是异步请求。 那么如果按照您所说，DOM的构建和CSS属性的计算是同步的话，head中CSS文件的下载以及CSSOM的rule部分的构建，应该会阻塞HTML的解析和DOM的构建。好像这两种说法之间就有了冲突。麻烦程老师有空的时候可以帮忙解释一下，万分感谢。 答：其实你误解了我的意思，DOM构建的结果到CSS属性计算是个流水线，所以CSS会阻塞CSS计算，不会阻塞DOM构建。 7. 老师，我记得有的书上或者是资料上说超过五次的if else 就最好用 switch case来替换。这样效率更好。您这里为什么说不用这个呢？ 答：我在性能部分讲了，“凡是不做profiling的性能优化都是耍流氓”。 具体的话，你可以看一看“43 | 性能：前端的性能到底对业务数据有多大的影响”这一篇。 8. 函数调用和函数执行有什么区别？ 有没有相应的标准？ 答：我们一般讲“A函数调用了B函数”“浏览器执行了B函数”，所以你看，两者的区别是主语不同，你可以感受一下区别。它们对应的标准都是ECMA262。 9. 请问下老师，为什么flexible布局方案不再维护了呢？这个方案本身存在问题吗？ 答：不存在问题，但是rem计算是个历史方案，现在，我比较推荐大家使用vw。 10. 有的工业软件，3D建模的也可以用浏览器来实现了，用的是ThreeJS WebGL，老师了解这些嘛？怎么看待这个发展前景。 答：挺好的，但是我觉得这件事由本来做3D的工程师转型更方便。 11. 最近出于好奇，我clone了github上chrome的源码仓库，发现竟然有12G多，貌似比linux内核的源码还多。个人特别想探索一下浏览器源码，但面对如此庞大的代码，不禁望而生畏，也不知从何下手。 请问老师，浏览器内核源码该如何去研究，skia渲染引擎是最先进吗，svg，canvas，WebGL该如何选择，怎样深入地学习和掌握它们呢？望老师拨冗答疑，谢谢！ 答：你先编译通过吧，然后试着跑起来打断点这样子，其实这件事没有捷径，多花些时间就可以。 skia引擎是不是最先进，这事我也不好说，其实在工程领域我们一般不追求“最先进”，我们只需要它“足够先进”。 关于如何选择，我收到了很多问题，不过我其实都不做回答，毕竟我没法替你决定你自己的职业发展道路，这个责任实在是有些重大了。 12.看完老师列出的表格更迷茫了，比如，为什么transform属于level 1，transform不是CSS3里的属性么？level4是什么？是CSS4么？为什么color这种常用属性属于level4?不应该属于level1么？好迷茫哦。 答：我先解释一下你的问题，一方面，level4里有不等于level3里没有，另一个是，W3C定level并不是十分严谨，有从1开始，也有从3开始的。 除此之外，我想提醒一下，这个表格并不是给你去看level的，而是告诉你标准在哪里，让你去读标准的。 13. 请问老师，我后台用的是Tomcat服务器，前端用ajax请求静态资源时会间隔会报412，也就是一次成功进入后台，一次报412，这该怎么解决呢？ 答：理论上412意思是你浏览器的问题。从你提供的信息我没法给你解决方案，建议你可以搞一个最小复现环境去Tomcat社区问。 14.老师好，有个疑问： WHATWG 和 W3C 标准以哪个为准，这两个标准有什么区别？是不是相互不认可的。 答：这个问题比较复杂，WHATWG最初是几家不满W3C，出走搞出来的，后来被招安了把HTML5带回了W3C，不过两边出标准的思路还是不太一样，WHATWG是living standard，就是随时更新标准，没有版本的概念，我是个人会倾向于WHATWG版本，因为比较新，而且Chrome跟得比较紧。 15. winter老师好，可以给我讲一下那个presentational attributes ，有些看不懂。 function showThis(){ console.log(this); } var o = { showThis: showThis } showThis(); // global o.showThis(); // o我知道函数中的this是由调用函数的对象决定的，但这种理解总感觉是由结论推原因；老师能不能讲解下。 答：this是由调用函数的对象决定，这完全是个规定，没有什么原因。（你后面的问题我节选掉了，我其实没太理解到你想表述的意思，你看到了可以再给我留言）。 16. 喜欢使用let和const，看很多库里面，他们都喜欢使用const，并且推荐使用const，比如声明一个数组。 老师能讲解下声明一个数组用let和const有什么区别吗？在操作数组时，都是往数组中push值，原先的变量并物理地址并没有发生变化，如果用let，和用const有什么区别，为什么const的性能会好一点？ 答：性能好一些完全是乱说的，用const的话，可以避免你误把数组整个赋值掉，比较有安全感吧。 老师我有几个问题希望你回答： 老师讲到：“注意，我们这里讲的渲染过程，是不会把子元素绘制到渲染的位图上的，这样，当父子元素的相对位置发生变化时，可以保证渲染的结果能够最大程度被缓存，减少重新渲染。” 缓存的是什么东西，位图吗？如何减少重新渲染的？ 是不是所有的元素都有对应的位图？ 文中你举了两个例子，说如果只有一个位图，任何改变都会引起所有重新渲染。这个好理解，一个大位图就是一个单元，任何的改动相当于这个单元被变了，所以要重新创建这个，这样理解对吗？ 但是你下面又说如果不合并，每次还是所有的重新渲染。感觉说的很矛盾啊。希望老师能回答一下我的疑问。 答：缓存的是位图，父子元素位置变化时，因为子元素的位图被缓存，子元素不需要重新渲染，因为父元素的位图也被缓存，父元素也不需要重新渲染，只有父子元素合成起来的位图需要被渲染。 你这样理解是对的，如果不合并，每次改点什么东西，都要重新逐级合成最终的大位图，也相当于重新渲染。 18. 老师，“当没有强制指定文字书写方向时，在左到右文字中插入右到左向文字，会形成一个双向文字盒，反之亦然。”这个能不能给个例子，不明白什么意思。 答：比如你在中文中插入几个阿拉伯语字符，阿拉伯语字符就会形成一个双向文字盒。 19. 看了您的流式数据的解释，是不是可以理解当看到页面渲染的时候，DOM是不是有可能都还没构建完成呢？即使是理论上，有这种可能吗？ 答：渲染不但发生在DOM构建之前，甚至可能发生在你下载网页完成之前，比如你上个XX软件下载站，是不是下载链接还没见到，就看到广告了（你提到的网上的那段是别人写错了。我节选掉了）。 20. footer 也可以和 aside，nav，section 相关联(header不存在关联问题)，不存在关联问题是什么意思啊，不应该在header中使用吗？下面又说header中可以使用nav，老师的“关联”是什么意思啊？ 答：因为footer有自己的语义，footer必须要指明是谁的footer，这样footer中的作者、地址才有意义，所谓的关联就是这个意思了。 21. 子元素的事件委托给父元素时，添加事件监听的第三个参数直接设置为true，在捕获过程就判断父元素上的事件目标会比冒泡好些嘛？ 答：对，但是你需要在捕获阶段想办法知道事件具体发生在哪个子元素上。 22. 老师 如果我想更深入的了解移动端的兼容问题，有没有好的学习路线呢？ 答：兼容问题不是学出来的，你想在山中苦修，自出洞来无敌手？手机早就更新好几代了。所以兼容问题必须靠实践，在一个需要兼容性的业务上，不断积累和更新兼容性知识。 23. 老师，我在理解SICP这本书的过程抽象和数据抽象的时候，代入到前端，比如生命周期、事件处理等更多是过程的抽象，能提出一些公用的过程，而数据抽象更多指的是组件内的数据定义、api的设计、高阶组件等。 请问我这样理解对吗？或者说老师对过程抽象和数据抽象在前端中怎么理解的？如果理解得不对，有什么好的书或者文章帮助理解？ 答：SICP讲的是很实在的编程技巧，在前端中对应的是变量、循环、条件这些东西，SICP是一本好书，你应该更认真地去阅读它。 24. 通过这个课程老师对于前端的划分为JavaScript、HTML和CSS、浏览器、工程实践几个部分。 疑问1：现在前端基本把Node也包括进来了，对于Node的知识应该怎么定位？ 疑问2：Node属于后端的范畴了，是否应该去学习下java相关的后端体系？学习了后端的体系是否会反过来促进前端知识的学习呢。 winter老师对这两个问题怎么看呢？谢谢。 答：Node属于后端，electron属于客户端，不论你学哪个体系，肯定对前端都有促进作用。 但是，你不能认为懂了Node就懂了后端，懂了electron就懂了客户端，每个领域都可以很深入，知识本来就是学不完的，你能掌握多少只跟投入的时间有关，这道理是很简单的，与其困惑，不如把困惑的时间拿来学习，相信你会有所收获的。 25. 老师，CSS是如何依附在DOM树上的?是通过前面讲得Node实例来实现的? 答：在Node实例上添加属性，我在“12 | 浏览器：一个浏览器是如何工作的（阶段三）”讲到了，你可以返回去看看。 26.清楚为什么要使用语义化标签，是否有必要使用之前，很难让自己有动机去应用每个标签。另外标签新推出如何保持实时掌握最新的标签呢，如何解决浏览器兼容的问题？ 答：对语义化标签，我是建议不必追求全部掌握，现有需求再找标签即可。 27. 老师您好，有个疑问想请教一下，为啥基于对象关联风格的面向对象并不是像模拟类的行为的面向对象那么流行呢？原型委托这种的不是应该更符合JavaScript语言本身的设计嘛？类似这种： var father = { a: 1, fn(): { return 123; } } var child = Object.create(father); child.fn(); // 123答：大部分人在学校学的都是C++和Java，我就没见过教原型的，这是现实，没办法。 28. 老师，可否稍加解释一下执行上下文的分类? 网络上的文章说“ JavaScript 中可执行的代码可分为三种类型：全局代码、函数代码、eval 代码，对应三种执行上下文（全局执行上下文、函数执行上下文、eval 执行上下文）。 在 ECMAScript 2018 中没有找到这种说法的依据。我的意思是，我不太清楚这些文章的说法是否正确，是否不够全面。 答：这个说法倒不能说不正确，但是严重过时了。 现在ECMAScript 2018里面执行上下文非常复杂，你可以看看各种Record，重学前端课程里面也没有讲全。 29. 老师，在ES5之前版本规范中，会提及JavaScript的可执行代码分为全局、函数、Eval。但是在ES6之后版本规范中，再也不提及可执行代码的概念了，这是为什么呢？ 答：其实这里是重构了一下表达方式，新加入了模块什么的。 30. 试过好多次，找了很多方法flex兼容IE9以下，每次都失败，有什么好的解决办法吗？ 答：如果真有IE9兼容需求，我想只能单独写一份CSS了。 31. 请问大佬，如何冻结对象，一般什么样的场景可以用到？ 答：Object.freeze函数可以冻结对象。一般都是写底层库，希望避免篡改。 *32. * new Promise(function(resovle, reject) { setTimeout(resovle, duration); }) setTimeout(resovle, duration);和setTimeout(() =&gt; {resovle()}, duration);两者到底有什么区别，想不明白，求教。 答：这个区别不大的，第二种写法一般都是为了给resolve传参数，不过如果你不想给resolve传特定参数，为什么还要多写一个函数呢。 33. 我听JavaScript像听天书，怎么办，是不是要从0重新学起呀？ 答：理论上，我的课程是把JavaScript的内容重新组织了一下，如果平时就在用JavaScript，我认为问题不大。如果这部分完全听不懂，可能说明确实基础薄弱，建议你从0学起。 好了，本期的答疑告一段落，如果你还有其他的问题，或者还是没有弄清楚，你可以继续给我留言，我会继续解答大家的问题，并一起讨论。","link":"/2019/08/31/重学前端/期末答疑（一）：前端代码单元测试怎么做？/"},{"title":"浏览器API（小实验）：动手整理全部API","text":"你好，我是winter。今天我们来讲讲浏览器API。 浏览器的API数目繁多，我们在之前的课程中，已经一起学习了其中几个比较有体系的部分：比如之前讲到过的DOM和CSSOM等等。但是，如果你留意过，会发现我们讲到的API仍然是标准中非常小的一部分。 这里，我们不可能把课程变成一本厚厚的API参考手册，所以这一节课，我设计了一个实验，我们一起来给API分分类。 我们按照每个API所在的标准来分类。所以，我们用代码来反射浏览器环境中全局对象的属性，然后我们用JavaScript的filter方法来逐步过滤掉已知的属性。 接下来，我们整理API的方法如下： 从Window的属性中，找到API名称； 查阅MDN或者Google，找到API所在的标准； 阅读标准，手工或者用代码整理出标准中包含的API； 用代码在Window的属性中过滤掉标准中涉及的API。 重复这个过程，我们可以找到所有的API对应的标准。首先我们先把前面已经讲过的API过滤掉。 ##JavaScript中规定的API 大部分的API属于Window对象（或者说全局对象），我们可以用反射来看一看现行浏览器中已经实现的API，我这里使用Mac下的Chrome 72.0.3626.121版本。 我们首先调用 Object.getOwnPropertyNames(window)。在我的环境中，可以看到，共有821个属性。 这里包含了JavaScript标准规定的属性，我们做一下过滤： { let js = new Set(); let objects = [&quot;BigInt&quot;, &quot;BigInt64Array&quot;, &quot;BigUint64Array&quot;, &quot;Infinity&quot;, &quot;NaN&quot;, &quot;undefined&quot;, &quot;eval&quot;, &quot;isFinite&quot;, &quot;isNaN&quot;, &quot;parseFloat&quot;, &quot;parseInt&quot;, &quot;decodeURI&quot;, &quot;decodeURIComponent&quot;, &quot;encodeURI&quot;, &quot;encodeURIComponent&quot;, &quot;Array&quot;, &quot;Date&quot;, &quot;RegExp&quot;, &quot;Promise&quot;, &quot;Proxy&quot;, &quot;Map&quot;, &quot;WeakMap&quot;, &quot;Set&quot;, &quot;WeakSet&quot;, &quot;Function&quot;, &quot;Boolean&quot;, &quot;String&quot;, &quot;Number&quot;, &quot;Symbol&quot;, &quot;Object&quot;, &quot;Error&quot;, &quot;EvalError&quot;, &quot;RangeError&quot;, &quot;ReferenceError&quot;, &quot;SyntaxError&quot;, &quot;TypeError&quot;, &quot;URIError&quot;, &quot;ArrayBuffer&quot;, &quot;SharedArrayBuffer&quot;, &quot;DataView&quot;, &quot;Float32Array&quot;, &quot;Float64Array&quot;, &quot;Int8Array&quot;, &quot;Int16Array&quot;, &quot;Int32Array&quot;, &quot;Uint8Array&quot;, &quot;Uint16Array&quot;, &quot;Uint32Array&quot;, &quot;Uint8ClampedArray&quot;, &quot;Atomics&quot;, &quot;JSON&quot;, &quot;Math&quot;, &quot;Reflect&quot;, &quot;escape&quot;, &quot;unescape&quot;]; objects.forEach(o =&gt; js.add(o)); let names = Object.getOwnPropertyNames(window) names = names.filter(e =&gt; !js.has(e)); }这一部分我们已经在JavaScript部分讲解过了（JavaScript对象：你知道全部的对象分类吗），所以这里我就采用手工的方式过滤出来。 DOM中的元素构造器接下来我们看看已经讲过的DOM部分，DOM部分包含了document属性和一系列的构造器，我们可以用JavaScript的prototype来过滤构造器。 names = names.filter( e =&gt; { try { return !(window[e].prototype instanceof Node) } catch(err) { return true; } }).filter( e =&gt; e != &quot;Node&quot;)这里我们把所有Node的子类都过滤掉，再把Node本身也过滤掉，这是非常大的一批了。 Window对象上的属性接下来我们要找到Window对象的定义，我们在下面链接中可以找到。 https://html.spec.whatwg.org/#window 这里有一个Window接口，是使用WebIDL定义的，我们手工把其中的函数和属性整理出来，如下： window,self,document,name,location,history,customElements,locationbar,menubar, personalbar,scrollbars,statusbar,toolbar,status,close,closed,stop,focus, blur,frames,length,top,opener,parent,frameElement,open,navigator,applicationCache,alert,confirm,prompt,print,postMessage接下来，我们编写代码，把这些函数和属性，从浏览器Window对象的属性中去掉，JavaScript代码如下： { let names = Object.getOwnPropertyNames(window) let js = new Set(); let objects = [&quot;BigInt&quot;, &quot;BigInt64Array&quot;, &quot;BigUint64Array&quot;, &quot;Infinity&quot;, &quot;NaN&quot;, &quot;undefined&quot;, &quot;eval&quot;, &quot;isFinite&quot;, &quot;isNaN&quot;, &quot;parseFloat&quot;, &quot;parseInt&quot;, &quot;decodeURI&quot;, &quot;decodeURIComponent&quot;, &quot;encodeURI&quot;, &quot;encodeURIComponent&quot;, &quot;Array&quot;, &quot;Date&quot;, &quot;RegExp&quot;, &quot;Promise&quot;, &quot;Proxy&quot;, &quot;Map&quot;, &quot;WeakMap&quot;, &quot;Set&quot;, &quot;WeakSet&quot;, &quot;Function&quot;, &quot;Boolean&quot;, &quot;String&quot;, &quot;Number&quot;, &quot;Symbol&quot;, &quot;Object&quot;, &quot;Error&quot;, &quot;EvalError&quot;, &quot;RangeError&quot;, &quot;ReferenceError&quot;, &quot;SyntaxError&quot;, &quot;TypeError&quot;, &quot;URIError&quot;, &quot;ArrayBuffer&quot;, &quot;SharedArrayBuffer&quot;, &quot;DataView&quot;, &quot;Float32Array&quot;, &quot;Float64Array&quot;, &quot;Int8Array&quot;, &quot;Int16Array&quot;, &quot;Int32Array&quot;, &quot;Uint8Array&quot;, &quot;Uint16Array&quot;, &quot;Uint32Array&quot;, &quot;Uint8ClampedArray&quot;, &quot;Atomics&quot;, &quot;JSON&quot;, &quot;Math&quot;, &quot;Reflect&quot;, &quot;escape&quot;, &quot;unescape&quot;]; objects.forEach(o =&gt; js.add(o)); names = names.filter(e =&gt; !js.has(e)); names = names.filter( e =&gt; { try { return !(window[e].prototype instanceof Node) } catch(err) { return true; } }).filter( e =&gt; e != &quot;Node&quot;) let windowprops = new Set(); objects = [&quot;window&quot;, &quot;self&quot;, &quot;document&quot;, &quot;name&quot;, &quot;location&quot;, &quot;history&quot;, &quot;customElements&quot;, &quot;locationbar&quot;, &quot;menubar&quot;, &quot; personalbar&quot;, &quot;scrollbars&quot;, &quot;statusbar&quot;, &quot;toolbar&quot;, &quot;status&quot;, &quot;close&quot;, &quot;closed&quot;, &quot;stop&quot;, &quot;focus&quot;, &quot; blur&quot;, &quot;frames&quot;, &quot;length&quot;, &quot;top&quot;, &quot;opener&quot;, &quot;parent&quot;, &quot;frameElement&quot;, &quot;open&quot;, &quot;navigator&quot;, &quot;applicationCache&quot;, &quot;alert&quot;, &quot;confirm&quot;, &quot;prompt&quot;, &quot;print&quot;, &quot;postMessage&quot;, &quot;console&quot;]; objects.forEach(o =&gt; windowprops.add(o)); names = names.filter(e =&gt; !windowprops.has(e)); }我们还要过滤掉所有的事件，也就是on开头的属性。 names = names.filter( e =&gt; !e.match(/^on/))webkit前缀的私有属性我们也过滤掉： names = names.filter( e =&gt; !e.match(/^webkit/))除此之外，我们在HTML标准中还能找到所有的接口，这些我们也过滤掉： let interfaces = new Set(); objects = [&quot;ApplicationCache&quot;, &quot;AudioTrack&quot;, &quot;AudioTrackList&quot;, &quot;BarProp&quot;, &quot;BeforeUnloadEvent&quot;, &quot;BroadcastChannel&quot;, &quot;CanvasGradient&quot;, &quot;CanvasPattern&quot;, &quot;CanvasRenderingContext2D&quot;, &quot;CloseEvent&quot;, &quot;CustomElementRegistry&quot;, &quot;DOMStringList&quot;, &quot;DOMStringMap&quot;, &quot;DataTransfer&quot;, &quot;DataTransferItem&quot;, &quot;DataTransferItemList&quot;, &quot;DedicatedWorkerGlobalScope&quot;, &quot;Document&quot;, &quot;DragEvent&quot;, &quot;ErrorEvent&quot;, &quot;EventSource&quot;, &quot;External&quot;, &quot;FormDataEvent&quot;, &quot;HTMLAllCollection&quot;, &quot;HashChangeEvent&quot;, &quot;History&quot;, &quot;ImageBitmap&quot;, &quot;ImageBitmapRenderingContext&quot;, &quot;ImageData&quot;, &quot;Location&quot;, &quot;MediaError&quot;, &quot;MessageChannel&quot;, &quot;MessageEvent&quot;, &quot;MessagePort&quot;, &quot;MimeType&quot;, &quot;MimeTypeArray&quot;, &quot;Navigator&quot;, &quot;OffscreenCanvas&quot;, &quot;OffscreenCanvasRenderingContext2D&quot;, &quot;PageTransitionEvent&quot;, &quot;Path2D&quot;, &quot;Plugin&quot;, &quot;PluginArray&quot;, &quot;PopStateEvent&quot;, &quot;PromiseRejectionEvent&quot;, &quot;RadioNodeList&quot;, &quot;SharedWorker&quot;, &quot;SharedWorkerGlobalScope&quot;, &quot;Storage&quot;, &quot;StorageEvent&quot;, &quot;TextMetrics&quot;, &quot;TextTrack&quot;, &quot;TextTrackCue&quot;, &quot;TextTrackCueList&quot;, &quot;TextTrackList&quot;, &quot;TimeRanges&quot;, &quot;TrackEvent&quot;, &quot;ValidityState&quot;, &quot;VideoTrack&quot;, &quot;VideoTrackList&quot;, &quot;WebSocket&quot;, &quot;Window&quot;, &quot;Worker&quot;, &quot;WorkerGlobalScope&quot;, &quot;WorkerLocation&quot;, &quot;WorkerNavigator&quot;]; objects.forEach(o =&gt; interfaces.add(o)); names = names.filter(e =&gt; !interfaces.has(e));这样过滤之后，我们已经过滤掉了所有的事件、Window对象、JavaScript全局对象和DOM相关的属性，但是，竟然还剩余了很多属性！你是不是很惊讶呢？好了，接下来我们才进入今天的正题。 其它属性这些既不属于Window对象，又不属于JavaScript语言的Global对象的属性，它们究竟是什么呢？ 我们可以一个一个来查看这些属性，来发现一些我们以前没有关注过的标准。 首先，我们要把过滤的代码做一下抽象，写成一个函数： function filterOut(names, props) { let set = new Set(); props.forEach(o =&gt; set.add(o)); return names.filter(e =&gt; !set.has(e)); }每次执行完filter函数，都会剩下一些属性，接下来，我们找到剩下的属性来看一看。 ECMAScript 2018 Internationalization API在我的浏览器环境中，第一个属性是：Intl。 查找这些属性来历的最佳文档是MDN，当然，你也可以使用Google。 总之，经过查阅，我发现，它属于ECMA402标准，这份标准是JavaScript的一个扩展，它包含了国际化相关的内容： http://www.ecma-international.org/ecma-402/5.0/index.html#Title ECMA402中，只有一个全局属性Intl，我们也把它过滤掉： names = names.filter(e =&gt; e != &quot;Intl&quot;)再来看看还有什么属性。 Streams标准接下来我看到的属性是： ByteLengthQueuingStrategy。 同样经过查阅，它来自WHATWG的Streams标准：https://streams.spec.whatwg.org/#blqs-class 不过，跟ECMA402不同，Streams标准中还有一些其它属性，这里我手工查阅了这份标准，并做了整理。 接下来，我们用代码把它们跟 ByteLengthQueuingStrategy 一起过滤掉： names = filterOut(names, [&quot;ReadableStream&quot;, &quot;ReadableStreamDefaultReader&quot;, &quot;ReadableStreamBYOBReader&quot;, &quot;ReadableStreamDefaultController&quot;, &quot;ReadableByteStreamController&quot;, &quot;ReadableStreamBYOBRequest&quot;, &quot;WritableStream&quot;, &quot;WritableStreamDefaultWriter&quot;, &quot;WritableStreamDefaultController&quot;, &quot;TransformStream&quot;, &quot;TransformStreamDefaultController&quot;, &quot;ByteLengthQueuingStrategy&quot;, &quot;CountQueuingStrategy&quot;]);好了，过滤之后，又少了一些属性，我们继续往下看。 WebGL接下来我看到的属性是：WebGLContext​Event。 显然，这个属性来自WebGL标准： https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15 我们在这份标准中找到了一些别的属性，我们把它一起过滤掉： names = filterOut(names, [&quot;WebGLContextEvent&quot;,&quot;WebGLObject&quot;, &quot;WebGLBuffer&quot;, &quot;WebGLFramebuffer&quot;, &quot;WebGLProgram&quot;, &quot;WebGLRenderbuffer&quot;, &quot;WebGLShader&quot;, &quot;WebGLTexture&quot;, &quot;WebGLUniformLocation&quot;, &quot;WebGLActiveInfo&quot;, &quot;WebGLShaderPrecisionFormat&quot;, &quot;WebGLRenderingContext&quot;]);过滤掉WebGL，我们继续往下看。 Web Audio API下一个属性是 WaveShaperNode。这个属性名听起来就跟声音有关，这个属性来自W3C的Web Audio API标准。 我们来看一下标准： https://www.w3.org/TR/webaudio/ Web Audio API中有大量的属性，这里我用代码做了过滤。得到了以下列表： [&quot;AudioContext&quot;, &quot;AudioNode&quot;, &quot;AnalyserNode&quot;, &quot;AudioBuffer&quot;, &quot;AudioBufferSourceNode&quot;, &quot;AudioDestinationNode&quot;, &quot;AudioParam&quot;, &quot;AudioListener&quot;, &quot;AudioWorklet&quot;, &quot;AudioWorkletGlobalScope&quot;, &quot;AudioWorkletNode&quot;, &quot;AudioWorkletProcessor&quot;, &quot;BiquadFilterNode&quot;, &quot;ChannelMergerNode&quot;, &quot;ChannelSplitterNode&quot;, &quot;ConstantSourceNode&quot;, &quot;ConvolverNode&quot;, &quot;DelayNode&quot;, &quot;DynamicsCompressorNode&quot;, &quot;GainNode&quot;, &quot;IIRFilterNode&quot;, &quot;MediaElementAudioSourceNode&quot;, &quot;MediaStreamAudioSourceNode&quot;, &quot;MediaStreamTrackAudioSourceNode&quot;, &quot;MediaStreamAudioDestinationNode&quot;, &quot;PannerNode&quot;, &quot;PeriodicWave&quot;, &quot;OscillatorNode&quot;, &quot;StereoPannerNode&quot;, &quot;WaveShaperNode&quot;, &quot;ScriptProcessorNode&quot;, &quot;AudioProcessingEvent&quot;]于是我们把它们也过滤掉： names = filterOut(names, [&quot;AudioContext&quot;, &quot;AudioNode&quot;, &quot;AnalyserNode&quot;, &quot;AudioBuffer&quot;, &quot;AudioBufferSourceNode&quot;, &quot;AudioDestinationNode&quot;, &quot;AudioParam&quot;, &quot;AudioListener&quot;, &quot;AudioWorklet&quot;, &quot;AudioWorkletGlobalScope&quot;, &quot;AudioWorkletNode&quot;, &quot;AudioWorkletProcessor&quot;, &quot;BiquadFilterNode&quot;, &quot;ChannelMergerNode&quot;, &quot;ChannelSplitterNode&quot;, &quot;ConstantSourceNode&quot;, &quot;ConvolverNode&quot;, &quot;DelayNode&quot;, &quot;DynamicsCompressorNode&quot;, &quot;GainNode&quot;, &quot;IIRFilterNode&quot;, &quot;MediaElementAudioSourceNode&quot;, &quot;MediaStreamAudioSourceNode&quot;, &quot;MediaStreamTrackAudioSourceNode&quot;, &quot;MediaStreamAudioDestinationNode&quot;, &quot;PannerNode&quot;, &quot;PeriodicWave&quot;, &quot;OscillatorNode&quot;, &quot;StereoPannerNode&quot;, &quot;WaveShaperNode&quot;, &quot;ScriptProcessorNode&quot;, &quot;AudioProcessingEvent&quot;]);我们继续看下一个属性。 Encoding标准在我的环境中，下一个属性是 TextDecoder，经过查阅得知，这个属性也来自一份WHATWG的标准，Encoding： https://encoding.spec.whatwg.org/#dom-textencoder 这份标准仅仅包含四个接口，我们把它们过滤掉： names = filterOut(names, [&quot;TextDecoder&quot;, &quot;TextEncoder&quot;, &quot;TextDecoderStream&quot;, &quot;TextEncoderStream&quot;]);我们继续来看下一个属性。 Web Background Synchronization下一个属性是 SyncManager，这个属性比较特殊，它并没有被标准化，但是我们仍然可以找到它的来源文档： https://wicg.github.io/BackgroundSync/spec/#sync-manager-interface 这个属性我们就不多说了，过滤掉就好了。 Web Cryptography API我们继续看下去，下一个属性是 SubtleCrypto，这个属性来自Web Cryptography API，也是W3C的标准。 https://www.w3.org/TR/WebCryptoAPI/ 这份标准中规定了三个Class和一个Window对象的扩展，给Window对象添加了一个属性crypto。 names = filterOut(names, [&quot;CryptoKey&quot;, &quot;SubtleCrypto&quot;, &quot;Crypto&quot;, &quot;crypto&quot;]);我们继续来看。 Media Source Extensions下一个属性是 SourceBufferList，它来自于： https://www.w3.org/TR/media-source/ 这份标准中包含了三个接口，这份标准还扩展了一些接口，但是没有扩展window。 names = filterOut(names, [&quot;MediaSource&quot;, &quot;SourceBuffer&quot;, &quot;SourceBufferList&quot;]);我们继续看下一个属性。 The Screen Orientation API下一个属性是ScreenOrientation，它来自W3C的The Screen Orientation API标准： https://www.w3.org/TR/screen-orientation/ 它里面只有ScreenOrientation一个接口，也是可以过滤掉的。 结语到 Screen Orientation API，我这里看到还剩300余个属性没有处理，剩余部分，我想把它留给大家自己来完成。 我们可以看到，在整理API的过程中，我们可以找到各种不同组织的标准，比如： ECMA402标准来自 ECMA； Encoding标准来自WHATWG； WebGL标准来自 Khronos； Web Cryptography标准来自 W3C； 还有些API，根本没有被标准化。 浏览器环境的API，正是这样复杂的环境。我们平时编程面对的环境也是这样的一个环境。 所以，面对如此繁复的API，我建议在系统掌握DOM、CSSOM的基础上，你可以仅仅做大概的浏览和记忆，根据实际工作需要，选择其中几个来深入学习。 做完这个实验，你对Web API的理解应该会有很大提升。 这一节课的问题就是完成所有的API到标准的归类，不同的浏览器环境应该略有不同，欢迎你把自己的结果留言一起讨论。","link":"/2019/08/31/重学前端/浏览器API（小实验）：动手整理全部API/"},{"title":"浏览器CSSOM：如何获取一个元素的准确位置","text":"你好，我是winter。 在前面的课程中，我们已经学习了DOM相关的API，狭义的DOM API仅仅包含DOM树形结构相关的内容。今天，我们再来学习一类新的API：CSSOM。 我想，你在最初接触浏览器API的时候，应该都有跟我类似的想法：“好想要element.width、element.height这样的API啊”。 这样的API可以直接获取元素的显示相关信息，它们是非常符合人的第一印象直觉的设计，但是，偏偏 DOM API 中没有这样的内容。 随着学习的深入，我才知道，这样的设计是有背后的逻辑的，正如HTML和CSS分别承担了语义和表现的分工，DOM和CSSOM也有语义和表现的分工。 DOM中的所有的属性都是用来表现语义的属性，CSSOM的则都是表现的属性，width和height这类显示相关的属性，都属于我们今天要讲的CSSOM。 顾名思义，CSSOM是CSS的对象模型，在W3C标准中，它包含两个部分：描述样式表和规则等CSS的模型部分（CSSOM），和跟元素视图相关的View部分（CSSOM View）。 在实际使用中，CSSOM View比CSSOM更常用一些，因为我们很少需要用代码去动态地管理样式表。 在今天的文章中，我来分别为你介绍这两部分的API。 CSSOM首先我们来介绍下CSS中样式表的模型，也就是CSSOM的本体。 我们通常创建样式表也都是使用HTML标签来做到的，我们用style标签和link标签创建样式表，例如： &lt;style title=&quot;Hello&quot;&gt; a { color:red; } &lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; title=&quot;x&quot; href=&quot;data:text/css,p%7Bcolor:blue%7D&quot;&gt;我们创建好样式表后，还有可能要对它进行一些操作。如果我们以DOM的角度去理解的话，这些标签在DOM中是一个节点，它们有节点的内容、属性，这两个标签中，CSS代码有的在属性、有的在子节点。这两个标签也遵循DOM节点的操作规则，所以可以使用DOM API去访问。 但是，这样做的后果是我们需要去写很多分支逻辑，并且，要想解析CSS代码结构也不是一件简单的事情，所以，这种情况下，我们直接使用CSSOM API去操作它们生成的样式表，这是一个更好的选择。 我们首先了解一下CSSOM API的基本用法，一般来说，我们需要先获取文档中所有的样式表： document.styleSheetsdocument的styleSheets属性表示文档中的所有样式表，这是一个只读的列表，我们可以用方括号运算符下标访问样式表，也可以使用item方法来访问，它有length属性表示文档中的样式表数量。 样式表只能使用style标签或者link标签创建（对XML来说，还可以使用，咱们暂且不表）。 我们虽然无法用CSSOM API来创建样式表，但是我们可以修改样式表中的内容。 document.styleSheets[0].insertRule(&quot;p { color:pink; }&quot;, 0) document.styleSheets[0].removeRule(0)更进一步，我们可以获取样式表中特定的规则（Rule），并且对它进行一定的操作，具体来说，就是使用它的cssRules属性来实现： document.styleSheets[0].cssRules这里取到的规则列表，同样是支持item、length和下标运算。 不过，这里的Rules可就没那么简单了，它可能是CSS的at-rule，也可能是普通的样式规则。不同的rule类型，具有不同的属性。 我们在CSS语法部分，已经为你整理过at-rule的完整列表，多数at-rule都对应着一个rule类型： CSSStyleRule CSSCharsetRule CSSImportRule CSSMediaRule CSSFontFaceRule CSSPageRule CSSNamespaceRule CSSKeyframesRule CSSKeyframeRule CSSSupportsRule 具体的规则支持的属性，建议你可以用到的时候，再去查阅MDN或者W3C的文档，在我们的文章中，仅为你详细介绍最常用的 CSSStyleRule。 CSSStyleRule有两个属性：selectorText 和 style，分别表示一个规则的选择器部分和样式部分。 selector部分是一个字符串，这里显然偷懒了没有设计进一步的选择器模型，我们按照选择器语法设置即可。 style部分是一个样式表，它跟我们元素的style属性是一样的类型，所以我们可以像修改内联样式一样，直接改变属性修改规则中的具体CSS属性定义，也可以使用cssText这样的工具属性。 此外，CSSOM还提供了一个非常重要的方法，来获取一个元素最终经过CSS计算得到的属性： window.getComputedStyle(elt, pseudoElt);其中第一个参数就是我们要获取属性的元素，第二个参数是可选的，用于选择伪元素。 好了，到此为止，我们可以使用CSSOM API自由地修改页面已经生效的样式表了。接下来，我们来一起关注一下视图的问题。 CSSOM ViewCSSOM View 这一部分的API，可以视为DOM API的扩展，它在原本的Element接口上，添加了显示相关的功能，这些功能，又可以分成三个部分：窗口部分，滚动部分和布局部分，下面我来分别带你了解一下。 窗口 API窗口API用于操作浏览器窗口的位置、尺寸等。 moveTo(x, y) 窗口移动到屏幕的特定坐标； moveBy(x, y) 窗口移动特定距离； resizeTo(x, y) 改变窗口大小到特定尺寸； resizeBy(x, y) 改变窗口大小特定尺寸。 此外，窗口API还规定了 window.open() 的第三个参数： window.open(&quot;about:blank&quot;, &quot;_blank&quot; ,&quot;width=100,height=100,left=100,right=100&quot; )一些浏览器出于安全考虑没有实现，也不适用于移动端浏览器，这部分你仅需简单了解即可。下面我们来了解一下滚动API。 滚动 API要想理解滚动，首先我们必须要建立一个概念，在PC时代，浏览器可视区域的滚动和内部元素的滚动关系是比较模糊的，但是在移动端越来越重要的今天，两者必须分开看待，两者的性能和行为都有区别。 视口滚动API可视区域（视口）滚动行为由window对象上的一组API控制，我们先来了解一下： scrollX 是视口的属性，表示X方向上的当前滚动距离，有别名 pageXOffset； scrollY 是视口的属性，表示Y方向上的当前滚动距离，有别名 pageYOffset； scroll(x, y) 使得页面滚动到特定的位置，有别名scrollTo，支持传入配置型参数 {top, left}； scrollBy(x, y) 使得页面滚动特定的距离，支持传入配置型参数 {top, left}。 通过这些属性和方法，我们可以读取视口的滚动位置和操纵视口滚动。不过，要想监听视口滚动事件，我们需要在document对象上绑定事件监听函数： document.addEventListener(&quot;scroll&quot;, function(event){ //...... })视口滚动API是页面的顶层容器的滚动，大部分移动端浏览器都会采用一些性能优化，它和元素滚动不完全一样，请大家一定建立这个区分的意识。 元素滚动API接下来我们来认识一下元素滚动API，在Element类（参见DOM部分），为了支持滚动，加入了以下API。 scrollTop 元素的属性，表示Y方向上的当前滚动距离。 scrollLeft 元素的属性，表示X方向上的当前滚动距离。 scrollWidth 元素的属性，表示元素内部的滚动内容的宽度，一般来说会大于等于元素宽度。 scrollHeight 元素的属性，表示元素内部的滚动内容的高度，一般来说会大于等于元素高度。 scroll(x, y) 使得元素滚动到特定的位置，有别名scrollTo，支持传入配置型参数 {top, left}。 scrollBy(x, y) 使得元素滚动到特定的位置，支持传入配置型参数 {top, left}。 scrollIntoView(arg) 滚动元素所在的父元素，使得元素滚动到可见区域，可以通过arg来指定滚到中间、开始或者就近。 除此之外，可滚动的元素也支持scroll事件，我们在元素上监听它的事件即可： element.addEventListener(&quot;scroll&quot;, function(event){ //...... })这里你需要注意一点，元素部分的API设计与视口滚动命名风格上略有差异，你在使用的时候不要记混。 布局API最后我们来介绍一下布局API，这是整个CSSOM中最常用到的部分，我们同样要分成全局API和元素上的API。 全局尺寸信息window对象上提供了一些全局的尺寸信息，它是通过属性来提供的，我们一起来了解一下来这些属性。 window.innerHeight, window.innerWidth 这两个属性表示视口的大小。 window.outerWidth, window.outerHeight 这两个属性表示浏览器窗口占据的大小，很多浏览器没有实现，一般来说这两个属性无关紧要。 window.devicePixelRatio 这个属性非常重要，表示物理像素和CSS像素单位的倍率关系，Retina屏这个值是2，后来也出现了一些3倍的Android屏。 window.screen （屏幕尺寸相关的信息） window.screen.width, window.screen.height 设备的屏幕尺寸。 window.screen.availWidth, window.screen.availHeight 设备屏幕的可渲染区域尺寸，一些Android机器会把屏幕的一部分预留做固定按钮，所以有这两个属性，实际上一般浏览器不会实现的这么细致。 window.screen.colorDepth, window.screen.pixelDepth 这两个属性是固定值24，应该是为了以后预留。 虽然window有这么多相关信息，在我看来，我们主要使用的是innerHeight、innerWidth和devicePixelRatio三个属性，因为我们前端开发工作只需要跟视口打交道，其它信息大概了解即可。 元素的布局信息最后我们来到了本节课一开始提到的问题，我们是否能够取到一个元素的宽（width）和高（height）呢？ 实际上，我们首先应该从脑中消除“元素有宽高”这样的概念，我们课程中已经多次提到了，有些元素可能产生多个盒，事实上，只有盒有宽和高，元素是没有的。 所以我们获取宽高的对象应该是“盒”，于是CSSOM View为Element类添加了两个方法： getClientRects(); getBoundingClientRect()。 getClientRects 会返回一个列表，里面包含元素对应的每一个盒所占据的客户端矩形区域，这里每一个矩形区域可以用 x, y, width, height 来获取它的位置和尺寸。 getBoundingClientRect ，这个API的设计更接近我们脑海中的元素盒的概念，它返回元素对应的所有盒的包裹的矩形区域，需要注意，这个API获取的区域会包括当overflow为visible时的子元素区域。 根据实际的精确度需要，我们可以选择何时使用这两个API。 这两个API获取的矩形区域都是相对于视口的坐标，这意味着，这些区域都是受滚动影响的。 如果我们要获取相对坐标，或者包含滚动区域的坐标，需要一点小技巧： var offsetX = document.documentElement.getBoundingClientRect().x - element.getBoundingClientRect().x;如这段代码所示，我们只需要获取文档跟节点的位置，再相减即可得到它们的坐标。 这两个API的兼容性非常好，定义又非常清晰，建议你如果是用JavaScript实现视觉效果时，尽量使用这两个API。 结语今天我们一起学习了CSSOM这一类型的API。我们首先就说到了，就像HTML和CSS分别承担了语义和表现的分工，DOM和CSSOM也有语义和表现的分工。 CSSOM是CSS的对象模型，在W3C标准中，它包含两个部分：描述样式表和规则等CSS的模型部分（CSSOM），和跟元素视图相关的View部分（CSSOM View）。 最后留给你一个问题，写好欢迎留言来讨论，请找一个网页，用我们今天讲的API，把页面上的所有盒的轮廓画到一个canvas元素上。 猜你喜欢","link":"/2019/08/31/重学前端/浏览器CSSOM：如何获取一个元素的准确位置/"},{"title":"浏览器事件：为什么会有捕获过程和冒泡过程？","text":"你好，我是winter。这一节课，我们进入了浏览器的部分，一起来学习一下事件。 事件概述在开始接触具体的API之前，我们要先了解一下事件。一般来说，事件来自输入设备，我们平时的个人设备上，输入设备有三种： 键盘； 鼠标； 触摸屏。 这其中，触摸屏和鼠标又有一定的共性，它们被称作pointer设备，所谓pointer设备，是指它的输入最终会被抽象成屏幕上面的一个点。但是触摸屏和鼠标又有一定区别，它们的精度、反应时间和支持的点的数量都不一样。 我们现代的UI系统，都源自WIMP系统。WIMP即Window Icon Menu Pointer四个要素，它最初由施乐公司研发，后来被微软和苹果两家公司应用在了自己的操作系统上（关于这个还有一段有趣的故事，我附在文末了）。 WIMP是如此成功，以至于今天很多的前端工程师会有一个观点，认为我们能够“点击一个按钮”，实际上并非如此，我们只能够点击鼠标上的按钮或者触摸屏，是操作系统和浏览器把这个信息对应到了一个逻辑上的按钮，再使得它的视图对点击事件有反应。这就引出了我们第一个要讲解的机制：捕获与冒泡。 捕获与冒泡很多文章会讲到捕获过程是从外向内，冒泡过程是从内向外，但是这里我希望讲清楚，为什么会有捕获过程和冒泡过程。 我们刚提到，实际上点击事件来自触摸屏或者鼠标，鼠标点击并没有位置信息，但是一般操作系统会根据位移的累积计算出来，跟触摸屏一样，提供一个坐标给浏览器。 那么，把这个坐标转换为具体的元素上事件的过程，就是捕获过程了。而冒泡过程，则是符合人类理解逻辑的：当你按电视机开关时，你也按到了电视机。 所以我们可以认为，捕获是计算机处理事件的逻辑，而冒泡是人类处理事件的逻辑。 以下代码展示了事件传播顺序： &lt;body&gt; &lt;input id=&quot;i&quot;/&gt; &lt;/body&gt; document.body.addEventListener(&quot;mousedown&quot;, () =&gt; { console.log(&quot;key1&quot;) }, true) document.getElementById(&quot;i&quot;).addEventListener(&quot;mousedown&quot;, () =&gt; { console.log(&quot;key2&quot;) }, true) document.body.addEventListener(&quot;mousedown&quot;, () =&gt; { console.log(&quot;key11&quot;) }, false) document.getElementById(&quot;i&quot;).addEventListener(&quot;mousedown&quot;, () =&gt; { console.log(&quot;key22&quot;) }, false)我们监听了body和一个body的子元素上的鼠标按下事件，捕获和冒泡分别监听，可以看到，最终产生的顺序是： “key1” “key2” “key22” “key11” 这是捕获和冒泡发生的完整顺序。 在一个事件发生时，捕获过程跟冒泡过程总是先后发生，跟你是否监听毫无关联。 在我们实际监听事件时，我建议这样使用冒泡和捕获机制：默认使用冒泡模式，当开发组件时，遇到需要父元素控制子元素的行为，可以使用捕获机制。 理解了冒泡和捕获的过程，我们再看监听事件的API，就非常容易理解了。 addEventListener有三个参数： 事件名称； 事件处理函数； 捕获还是冒泡。 事件处理函数不一定是函数，也可以是个JavaScript具有handleEvent方法的对象，看下例子： var o = { handleEvent: event =&gt; console.log(event) } document.body.addEventListener(&quot;keydown&quot;, o, false);第三个参数不一定是bool值，也可以是个对象，它提供了更多选项。 once：只执行一次。 passive：承诺此事件监听不会调用preventDefault，这有助于性能。 useCapture：是否捕获（否则冒泡）。 实际使用，在现代浏览器中，还可以不传第三个参数，我建议默认不传第三个参数，因为我认为冒泡是符合正常的人类心智模型的，大部分业务开发者不需要关心捕获过程。除非你是组件或者库的使用者，那就总是需要关心冒泡和捕获了。 焦点我们讲完了pointer事件是由坐标控制，而我们还没有讲到键盘事件。 键盘事件是由焦点系统控制的，一般来说，操作系统也会提供一套焦点系统，但是现代浏览器一般都选择在自己的系统内覆盖原本的焦点系统。 焦点系统也是视障用户访问的重要入口，所以设计合理的焦点系统是非常重要的产品需求，尤其是不少国家对可访问性有明确的法律要求。 在旧时代，有一个经典的问题是如何去掉输入框上的虚线框，这个虚线框就是Windows焦点系统附带的UI表现。 现在Windows的焦点已经不是用虚线框表示了，但是焦点系统的设计几十年间没有太大变化。 焦点系统认为整个UI系统中，有且仅有一个“聚焦”的元素，所有的键盘事件的目标元素都是这个聚焦元素。 Tab键被用来切换到下一个可聚焦的元素，焦点系统占用了Tab键，但是可以用JavaScript来阻止这个行为。 浏览器API还提供了API来操作焦点，如： document.body.focus(); document.body.blur();其实原本键盘事件不需要捕获过程，但是为了跟pointer设备保持一致，也规定了从外向内传播的捕获过程。 自定义事件除了来自输入设备的事件，还可以自定义事件，实际上事件也是一种非常好的代码架构，但是DOM API中的事件并不能用于普通对象，所以很遗憾，我们只能在DOM元素上使用自定义事件。 自定义事件的代码示例如下（来自MDN）： var evt = new Event(&quot;look&quot;, {&quot;bubbles&quot;:true, &quot;cancelable&quot;:false}); document.dispatchEvent(evt);这里使用Event构造器来创造了一个新的事件，然后调用dispatchEvent来在特定元素上触发。 我们可以给这个Event添加自定义属性、方法。 注意，这里旧的自定义事件方法（使用document.createEvent和initEvent）已经被废弃。 总结今天这一节课，我们讲了浏览器中的事件。 我们分别介绍了事件的捕获与冒泡机制、焦点机制和自定义事件。 捕获与冒泡机制来自pointer设备输入的处理，捕获是计算机处理输入的逻辑，冒泡是人类理解事件的思维，捕获总是在冒泡之前发生。 焦点机制则来自操作系统的思路，用于处理键盘事件。除了我们讲到的这些，随着输入设备的不断丰富，还有很多新的事件加入，如Geolocation和陀螺仪等。 最后给你留个小问题。请你找出你所知道的所有事件类型，和它们的目标元素类型。 WIMP的小故事WIMP是由Alan Kay主导设计的，这位巨匠，同时也是面向对象之父和Smalltalk语言之父。 乔布斯曾经受邀参观施乐，他见到当时的WIMP界面，认为非常惊艳，不久后就领导苹果研究了新一代麦金塔系统。 后来，在某次当面对话中，乔布斯指责比尔盖茨抄袭了WIMP的设计，盖茨淡定地回答：“史蒂夫，我觉得应该用另一种方式看待这个问题。这就像我们有个叫施乐的有钱邻居，当我闯进去想偷走电视时，却发现你已经这么干了。” 但是不论如何，苹果和微软的数十代操作系统，极大地发展了这个体系，才有了我们今天的UI界面。","link":"/2019/08/31/重学前端/浏览器事件：为什么会有捕获过程和冒泡过程？/"},{"title":"浏览器DOM：你知道HTML的节点有哪几种吗？","text":"你好，我是winter。 今天我们进入浏览器API的学习, 这一节课，我们来学习一下DOM API。 DOM API是最早被设计出来的一批API，也是用途最广的API，所以早年的技术社区，常常用DOM来泛指浏览器中所有的API。不过今天这里我们要介绍的DOM，指的就是狭义的文档对象模型。 DOM API介绍首先我们先来讲一讲什么叫做文档对象模型。 顾名思义，文档对象模型是用来描述文档，这里的文档，是特指HTML文档（也用于XML文档，但是本课不讨论XML）。同时它又是一个“对象模型”，这意味着它使用的是对象这样的概念来描述HTML文档。 说起HTML文档，这是大家最熟悉的东西了，我们都知道，HTML文档是一个由标签嵌套而成的树形结构，因此，DOM也是使用树形的对象模型来描述一个HTML文档。 DOM API大致会包含4个部分。 节点：DOM树形结构中的节点相关API。 事件：触发和监听事件相关API。 Range：操作文字范围相关API。 遍历：遍历DOM需要的API。 事件相关API和事件模型，我们会用单独的课程讲解，所以我们本篇文章重点会为你介绍节点和遍历相关API。 DOM API 数量很多，我希望给你提供一个理解DOM API设计的思路，避免单靠机械的方式去死记硬背。 节点DOM的树形结构所有的节点有统一的接口Node，我们按照继承关系，给你介绍一下节点的类型。 在这些节点中，除了Document和DocumentFrangment，都有与之对应的HTML写法，我们可以看一下。 Element: &lt;tagname&gt;...&lt;/tagname&gt; Text: text Comment: &lt;!-- comments --&gt; DocumentType: &lt;!Doctype html&gt; ProcessingInstruction: &lt;?a 1?&gt;我们在编写HTML代码并且运行后，就会在内存中得到这样一棵DOM树，HTML的写法会被转化成对应的文档模型，而我们则可以通过JavaScript等语言去访问这个文档模型。 这里我们每天都需要用到，要重点掌握的是：Document、Element、Text节点。 DocumentFragment也非常有用，它常常被用来高性能地批量添加节点。因为Comment、DocumentType和ProcessingInstruction很少需要运行时去修改和操作，所以有所了解即可。 NodeNode是DOM树继承关系的根节点，它定义了DOM节点在DOM树上的操作，首先，Node提供了一组属性，来表示它在DOM树中的关系，它们是： parentNode childNodes firstChild lastChild nextSibling previousSibling 从命名上，我们可以很清晰地看出，这一组属性提供了前、后、父、子关系，有了这几个属性，我们可以很方便地根据相对位置获取元素。当然，Node中也提供了操作DOM树的API，主要有下面几种。 appendChild insertBefore removeChild replaceChild 这个命名跟上面一样，我们基本可以知道API的作用。这几个API的设计可以说是饱受诟病。其中最主要的批评是它不对称——只有before，没有after，而jQuery等框架都对其做了补充。 实际上，appendChild和insertBefore的这个设计，是一个“最小原则”的设计，这两个API是满足插入任意位置的必要API，而insertAfter，则可以由这两个API实现出来。 我个人其实不太喜欢这个设计，对我而言，insertAt(pos) 更符合审美一些。当然，不论喜不喜欢，这个标准已经确定，我们还是必须要掌握它。 这里从设计的角度还想要谈一点，那就是，所有这几个修改型的API，全都是在父元素上操作的，比如我们要想实现“删除一个元素的上一个元素”，必须要先用parentNode获取其父元素。 这样的设计是符合面向对象的基本原则的。还记得我们在JavaScript对象部分讲的对象基本特征吗？“拥有哪些子元素”是父元素的一种状态，所以修改状态，应该是父元素的行为。这个设计我认为是DOM API中好的部分。 到此为止，Node提供的API已经可以很方便（大概吧）地对树进行增、删、遍历等操作了。 除此之外，Node还提供了一些高级API，我们来认识一下它们。 compareDocumentPosition 是一个用于比较两个节点中关系的函数。 contains 检查一个节点是否包含另一个节点的函数。 isEqualNode 检查两个节点是否完全相同。 isSameNode 检查两个节点是否是同一个节点，实际上在JavaScript中可以用“===”。 cloneNode 复制一个节点，如果传入参数true，则会连同子元素做深拷贝。 DOM标准规定了节点必须从文档的create方法创建出来，不能够使用原生的JavaScript的new运算。于是document对象有这些方法。 createElement createTextNode createCDATASection createComment createProcessingInstruction createDocumentFragment createDocumentType 上面的这些方法都是用于创建对应的节点类型。你可以自己尝试一下。 Element 与 AttributeNode提供了树形结构上节点相关的操作。而大部分时候，我们比较关注的是元素。Element表示元素，它是Node的子类。 元素对应了HTML中的标签，它既有子节点，又有属性。所以Element子类中，有一系列操作属性的方法。 我们需要注意，对DOM而言，Attribute和Property是完全不同的含义，只有特性场景下，两者才会互相关联（这里在后面我会详细讲解，今天的文章里我就不展开了）。 首先，我们可以把元素的Attribute当作字符串来看待，这样就有以下的API： getAttribute setAttribute removeAttribute hasAttribute 如果你追求极致的性能，还可以把Attribute当作节点： getAttributeNode setAttributeNode 此外，如果你喜欢property一样的访问attribute，还可以使用 attributes 对象，比如 document.body.attributes.class = “a” 等效于 document.body.setAttribute(“class”, “a”)。 查找元素document节点提供了查找元素的能力。比如有下面的几种。 querySelector querySelectorAll getElementById getElementsByName getElementsByTagName getElementsByClassName 我们需要注意，getElementById、getElementsByName、getElementsByTagName、getElementsByClassName，这几个API的性能高于querySelector。 而 getElementsByName、getElementsByTagName、getElementsByClassName 获取的集合并非数组，而是一个能够动态更新的集合。 我们看一个例子： var collection = document.getElementsByClassName(&apos;winter&apos;); console.log(collection.length); var winter = document.createElement(&apos;div&apos;); winter.setAttribute(&apos;class&apos;, &apos;winter&apos;) document.documentElement.appendChild(winter) console.log(collection.length);在这段代码中，我们先获取了页面的className为winter的元素集合，不出意外的话，应该是空。 我们通过console.log可以看到集合的大小为0。之后我们添加了一个class为winter的div，这时候我们再看集合，可以发现，集合中出现了新添加的元素。 这说明浏览器内部是有高速的索引机制，来动态更新这样的集合的。所以，尽管querySelector系列的API非常强大，我们还是应该尽量使用getElement系列的API。 遍历前面已经提到过，通过Node的相关属性，我们可以用JavaScript遍历整个树。实际上，DOM API中还提供了NodeIterator 和 TreeWalker 来遍历树。 比起直接用属性来遍历，NodeIterator 和 TreeWalker 提供了过滤功能，还可以把属性节点也包含在遍历之内。 NodeIterator的基本用法示例如下： var iterator = document.createNodeIterator(document.body, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_COMMENT, null, false); var node; while(node = iterator.nextNode()) { console.log(node); }这个API的设计非常老派，这么讲的原因主要有两点，一是循环并没有类似“hasNext”这样的方法，而是直接以nextNode返回null来标志结束，二是第二个参数是掩码，这两个设计都是传统C语言里比较常见的用法。 放到今天看，这个迭代器无法匹配JavaScript的迭代器语法，而且JavaScript位运算并不高效，掩码的设计就徒增复杂性了。 这里请你注意一下这个例子中的处理方法，通常掩码型参数，我们都是用按位或运算来叠加。而针对这种返回null表示结束的迭代器，我使用了在while循环条件中赋值，来保证循环次数和调用next次数严格一致（但这样写可能违反了某些编码规范）。 我们再来看一下TreeWalker的用法。 var walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, null, false) var node; while(node = walker.nextNode()) { if(node.tagName === &quot;p&quot;) node.nextSibling(); console.log(node); }比起NodeIterator，TreeWalker多了在DOM树上自由移动当前节点的能力，一般来说，这种API用于“跳过”某些节点，或者重复遍历某些节点。 总的来说，我个人不太喜欢TreeWalker和NodeIterator这两个API，建议需要遍历DOM的时候，直接使用递归和Node的属性。 RangeRange API 是一个比较专业的领域，如果不做富文本编辑类的业务，不需要太深入。这里我们就仅介绍概念和给出基本用法的示例，你只要掌握即可。 Range API 表示一个HTML上的范围，这个范围是以文字为最小单位的，所以Range不一定包含完整的节点，它可能是Text节点中的一段，也可以是头尾两个Text的一部分加上中间的元素。 我们通过 Range API 可以比节点 API 更精确地操作 DOM 树，凡是 节点 API 能做到的，Range API都可以做到，而且可以做到更高性能，但是 Range API 使用起来比较麻烦，所以在实际项目中，并不常用，只有做底层框架和富文本编辑对它有强需求。 创建Range一般是通过设置它的起止来实现，我们可以看一个例子： var range = new Range(), firstText = p.childNodes[1], secondText = em.firstChild range.setStart(firstText, 9) // do not forget the leading space range.setEnd(secondText, 4)此外，通过 Range 也可以从用户选中区域创建，这样的Range用于处理用户选中区域: var range = document.getSelection().getRangeAt(0);更改 Range 选中区段内容的方式主要是取出和插入，分别由extractContents和insertNode来实现。 var fragment = range.extractContents() range.insertNode(document.createTextNode(&quot;aaaa&quot;))最后我们看一个完整的例子。 var range = new Range(), firstText = p.childNodes[1], secondText = em.firstChild range.setStart(firstText, 9) // do not forget the leading space range.setEnd(secondText, 4) var fragment = range.extractContents() range.insertNode(document.createTextNode(&quot;aaaa&quot;))这个例子展示了如何使用range来取出元素和在特定位置添加新元素。 总结在今天的文章中，我们一起了解了DOM API的内容。DOM API大致会包含4个部分。 节点：DOM树形结构中的节点相关API。 事件：触发和监听事件相关API。 Range：操作文字范围相关API。 遍历：遍历DOM需要的API。 DOM API中还提供了NodeIterator 和 TreeWalker 来遍历树。比起直接用属性来遍历，NodeIterator 和 TreeWalker 提供了过滤功能，还可以把属性节点也包含在遍历之内。 除此之外，我们还谈到了Range的一些基础知识点，这里你掌握即可。 最后，我给你留了一个题目，请你用DOM API来实现遍历整个DOM树，把所有的元素的tagName打印出来。 补充阅读：命名空间我们本课介绍的所有API，特意忽略了命名空间。 在HTML场景中，需要考虑命名空间的场景不多。最主要的场景是SVG。创建元素和属性相关的API都有带命名空间的版本： document createElementNS createAttributeNS Element getAttributeNS setAttributeNS getAttributeNodeNS setAttributeNodeNS removeAttributeNS hasAttributeNS attributes.setNamedItemNS attributes.getNamedItemNS attributes.removeNamedItemNS 若要创建Document或者Doctype，也必须要考虑命名空间问题。DOM要求从document.implementation来创建。 document.implementation.createDocument document.implementation.createDocumentType 除此之外，还提供了一个快捷方式，你也可以动手尝试一下。 document.implementation.createHTMLDocument 猜你喜欢","link":"/2019/08/31/重学前端/浏览器DOM：你知道HTML的节点有哪几种吗？/"},{"title":"浏览器：一个浏览器是如何工作的（阶段三）","text":"你好，我是winter。 在上一节课中，我已经讲了浏览器的DOM构建过程，但是这个构建的DOM，实际上信息是不全的，它只有节点和属性，不包含任何的样式信息。 我们这一节课就来讲讲：浏览器是如何把CSS规则应用到节点上，并给这棵朴素的DOM树添加上CSS属性的。 整体过程首先我们还是要感性地理解一下这个过程。 首先CSS选择器这个名称，可能会给你带来一定的误解，觉得好像CSS规则是DOM树构建好了以后，再进行选择并给它添加样式的。实际上，这个过程并不是这样的。 我们回忆一下我们在浏览器第一节课讲的内容，浏览器会尽量流式处理整个过程。我们上一节课构建DOM的过程是：从父到子，从先到后，一个一个节点构造，并且挂载到DOM树上的，那么这个过程中，我们是否能同步把CSS属性计算出来呢？ 答案是肯定的。 在这个过程中，我们依次拿到上一步构造好的元素，去检查它匹配到了哪些规则，再根据规则的优先级，做覆盖和调整。所以，从这个角度看，所谓的选择器，应该被理解成“匹配器”才更合适。 我在CSS语法部分，已经总结了选择器的各种符号，这里再把它列出来，我们回顾一下。 空格: 后代，选中它的子节点和所有子节点的后代节点。 : 子代，选中它的子节点。 +：直接后继选择器，选中它的下一个相邻节点。 ~：后继，选中它之后所有的相邻节点。 ||：列，选中表格中的一列。 关于选择器的知识，我会在CSS的部分继续讲解。这里我们主要介绍浏览器是如何实现这些规则的。 不知道你有没有发现，这里的选择器有个特点，那就是选择器的出现顺序，必定跟构建DOM树的顺序一致。这是一个CSS设计的原则，即保证选择器在DOM树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。 也就是说，未来也不可能会出现“父元素选择器”这种东西，因为父元素选择器要求根据当前节点的子节点，来判断当前节点是否被选中，而父节点会先于子节点构建。 理解了CSS构建的大概过程，我们下面来看看具体的操作。 首先，我们必须把CSS规则做一下处理。作为一门语言，CSS需要先经过词法分析和语法分析，变成计算机能够理解的结构。 这部分具体的做法属于编译原理的内容，这里就不做赘述了。我们这里假设CSS已经被解析成了一棵可用的抽象语法树。 我们在之前的CSS课程中已经介绍过 compound-selector 的概念，一个 compound-selector 是检查一个元素的规则，而一个复合型选择器，则是由数个 compound-selector 通过前面讲的符号连接起来的。 后代选择器 “空格”我们先来分析一下后代选择器，我们来一起看一个例子： a#b .cls { width: 100px; }可以把一个CSS选择器按照 compound-selector 来拆成数段，每当满足一段条件的时候，就前进一段。 比如，在上面的例子中，当我们找到了匹配a#b的元素时，我们才会开始检查它所有的子代是否匹配 .cls。 除了前进一段的情况，我们还需要处理后退的情况，比如，我们这样一段代码： &lt;a id=b&gt; &lt;span&gt;1&lt;span&gt; &lt;span class=cls&gt;2&lt;span&gt; &lt;/a&gt; &lt;span class=cls&gt;3&lt;span&gt;当遇到 时，必须使得规则 a#b .cls 回退一步，这样第三个 span 才不会被选中。后代选择器的作用范围是父节点的所有子节点，因此规则是在匹配到本标签的结束标签时回退。 后继选择器“ ~ ”接下来我们看下后继选择器，跟后代选择器不同的地方是，后继选择器只作用于一层，我们来看一个例子： .cls~* { border:solid 1px green; } &lt;div&gt; &lt;span&gt;1&lt;span&gt; &lt;span class=cls&gt;2&lt;span&gt; &lt;span&gt; 3 &lt;span&gt;4&lt;/span&gt; &lt;span&gt; &lt;span&gt;5&lt;/span&gt; &lt;/div&gt;这里 .cls 选中了 span 2 然后 span 3 是它的后继，但是span 3的子节点 span 4 并不应该被选中，而span 5也是它的后继，因此应该被选中。 按照DOM树的构造顺序，4在3和5中间，我们就没有办法像前面讲的后代选择器一样通过激活或者关闭规则来实现匹配。 但是这里有个非常方便的思路，就是给选择器的激活，带上一个条件：父元素。 注意，这里后继选择器，当前半段的 .cls 匹配成功时，后续 * 所匹配的所有元素的父元素都已经确定了（后继节点和当前节点父元素相同是充分必要条件）。在我们的例子中，那个div就是后继节点的父元素。 子代选择器“ &gt;”我们继续看，子代选择器是如何实现的。 实际上，有了前面讲的父元素这个约束思路，我们很容易实现子代选择器。区别仅仅是拿当前节点作为父元素，还是拿当前节点的父元素作为父元素。 div&gt;.cls { border:solid 1px green; } &lt;div&gt; &lt;span&gt;1&lt;span&gt; &lt;span class=cls&gt;2&lt;span&gt; &lt;span&gt; 3 &lt;span&gt;4&lt;/span&gt; &lt;span&gt; &lt;span&gt;5&lt;/span&gt; &lt;/div&gt;我们看这段代码，当DOM树构造到div时，匹配了CSS规则的第一段，因为是子代选择器，我们激活后面的 .cls选择条件，并且指定父元素必须是当前div。于是后续的构建DOM树构建过程中，span 2 就被选中了。 直接后继选择器“ +”直接后继选择器的实现是上述中最为简单的了，因为它只对唯一一个元素生效，所以不需要像前面几种一样反复激活和关闭规则。 一个最简单的思路是，我们可以把它当作检查元素自身的选择器来处理。即我们把#id+.cls都当做检查某一个元素的选择器。 另外的一种思路是：给后继选择器加上一个flag，使它匹配一次后失效。你可以尝试一下，告诉我结果。 列选择器“ || ”列选择器比较特别，它是专门针对表格的选择器，跟表格的模型建立相关，我们这里不详细讲了。 其它我们不要忘记，CSS选择器还支持逗号分隔，表示“或”的关系。这里最简单的实现是把逗号视为两条规则的一种简易写法。 比如： a#b, .cls { }我们当作两条规则来处理： a#b { } .cls { }还有一个情况，就是选择器可能有重合，这样，我们可以使用树形结构来进行一些合并，来提高效率： #a .cls { } #a span { } #a&gt;span { }这里实际上可以把选择器构造成一棵树： #a &lt;空格&gt;.cls &lt;空格&gt;span span 需要注意的是，这里的树，必须要带上连接符。 结语这一节我们讲解了CSS计算的过程。CSS计算是把CSS规则应用到DOM树上，为DOM结构添加显示相关属性的过程。在这一节中，我们主要介绍了选择器的几种复合结构应该如何实现。 在这一步骤之后，我们得到了一棵带有CSS属性的树，为我们后续打下了基础。 最后留一个问题，你认为CSS语法解析成什么结构，最适合我们进行CSS计算。","link":"/2019/08/31/重学前端/浏览器：一个浏览器是如何工作的（阶段三）/"},{"title":"浏览器：一个浏览器是如何工作的？（阶段二）","text":"你好，我是winter，今天我们继续来看浏览器的相关内容。 我在上一篇文章中，简要介绍了浏览器的工作大致可以分为6个阶段，我们昨天讲完了第一个阶段，也就是通讯的部分：浏览器使用HTTP协议或者HTTPS协议，向服务端请求页面的过程。 今天我们主要来看两个过程：如何解析请求回来的HTML代码，DOM树又是如何构建的。 解析代码我们在前面讲到了HTTP的构成，但是我们有一部分没有详细讲解，那就是Response的body部分，这正是因为HTTP的Response的body，就要交给我们今天学习的内容去处理了。 HTML的结构不算太复杂，我们日常开发需要的90%的“词”（指编译原理的术语token，表示最小的有意义的单元），种类大约只有标签开始、属性、标签结束、注释、CDATA节点几种。 实际上有点麻烦的是，由于HTML跟SGML的千丝万缕的联系，我们需要做不少容错处理。“&lt;?”和“&lt;%”什么的也是必须要支持好的，报了错也不能吭声。 1.词（token）是如何被拆分的首先我们来看看一个非常标准的标签，会被如何拆分： &lt;p class=&quot;a&quot;&gt;text text text&lt;/p&gt;如果我们从最小有意义单元的定义来拆分，第一个词（token）是什么呢？显然，作为一个词（token），整个p标签肯定是过大了（它甚至可以嵌套）。 那么，只用p标签的开头是不是合适吗？我们考虑到起始标签也是会包含属性的，最小的意义单元其实是“&lt;p” ，所以“ &lt;p” 就是我们的第一个词（token）。 我们继续拆分，可以把这段代码依次拆成词（token）： &lt;p“标签开始”的开始； class=“a” 属性； “标签开始”的结束； text text text 文本； 标签结束。 这是一段最简单的例子，类似的还有什么呢？现在我们可以来来看看这些词（token）长成啥样子： 根据这样的分析，现在我们讲讲浏览器是如何用代码实现，我们设想，代码开始从HTTP协议收到的字符流读取字符。 在接受第一个字符之前，我们完全无法判断这是哪一个词（token），不过，随着我们接受的字符越来越多，拼出其他的内容可能性就越来越少。 比如，假设我们接受了一个字符“ &lt; ” 我们一下子就知道这不是一个文本节点啦。 之后我们再读一个字符，比如就是 x，那么我们一下子就知道这不是注释和CDATA了，接下来我们就一直读，直到遇到“&gt;”或者空格，这样就得到了一个完整的词（token）了。 实际上，我们每读入一个字符，其实都要做一次决策，而且这些决定是跟“当前状态”有关的。在这样的条件下，浏览器工程师要想实现把字符流解析成词（token），最常见的方案就是使用状态机。 2.状态机绝大多数语言的词法部分都是用状态机实现的。那么我们来把部分词（token）的解析画成一个状态机看看： 当然了，我们这里的分析比较粗略，真正完整的HTML词法状态机，比我们描述的要复杂的多。更详细的内容，你可以参考HTML官方文档，HTML官方文档规定了80个状态（顺便一说，HTML是我见过唯一一个标准中规定了状态机实现的语言，对大部分语言来说，状态机是一种实现而非定义）。 这里我们为了理解原理，用这个简单的状态机就足够说明问题了。 状态机的初始状态，我们仅仅区分 “&lt; ”和 “非&lt;”： 如果获得的是一个非&lt;字符，那么可以认为进入了一个文本节点； 如果获得的是一个&lt;字符，那么进入一个标签状态。 不过当我们在标签状态时，则会面临着一些可能性。 比如下一个字符是“ ! ” ，那么很可能是进入了注释节点或者CDATA节点。 如果下一个字符是 “/ ”，那么可以确定进入了一个结束标签。 如果下一个字符是字母，那么可以确定进入了一个开始标签。 如果我们要完整处理各种HTML标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。 我们可以看到，用状态机做词法分析，其实正是把每个词的“特征字符”逐个拆开成独立状态，然后再把所有词的特征字符链合并起来，形成一个联通图结构。 由于状态机设计属于编译原理的基本知识，这里我们仅作一个简要的介绍。 接下来就是代码实现的事情了，在C/C++和JavaScript中，实现状态机的方式大同小异：我们把每个函数当做一个状态，参数是接受的字符，返回值是下一个状态函数。（这里我希望再次强调下，状态机真的是一种没有办法封装的东西，所以我们永远不要试图封装状态机。） 为了方便理解和试验，我们这里用JavaScript来讲解，图上的data状态大概就像下面这样的： var data = function(c){ if(c==&quot;&amp;&quot;) { return characterReferenceInData; } if(c==&quot;&lt;&quot;) { return tagOpen; } else if(c==&quot;\\0&quot;) { error(); emitToken(c); return data; } else if(c==EOF) { emitToken(EOF); return data; } else { emitToken(c); return data; } }; var tagOpenState = function tagOpenState(c){ if(c==&quot;/&quot;) { return endTagOpenState; } if(c.match(/[A-Z]/)) { token = new StartTagToken(); token.name = c.toLowerCase(); return tagNameState; } if(c.match(/[a-z]/)) { token = new StartTagToken(); token.name = c; return tagNameState; } if(c==&quot;?&quot;) { return bogusCommentState; } else { error(); return dataState; } }; //……这段代码给出了状态机的两个状态示例：data即为初始状态，tagOpenState是接受了一个“ &lt; ” 字符，来判断标签类型的状态。 这里的状态机，每一个状态是一个函数，通过“if else”来区分下一个字符做状态迁移。这里所谓的状态迁移，就是当前状态函数返回下一个状态函数。 这样，我们的状态迁移代码非常的简单： var state = data; var char while(char = getInput()) state = state(char);这段代码的关键一句是“ state = state(char) ”，不论我们用何种方式来读取字符串流，我们都可以通过state来处理输入的字符流，这里用循环是一个示例，真实场景中，可能是来自TCP的输出流。 状态函数通过代码中的 emitToken 函数来输出解析好的token（词），我们只需要覆盖 emitToken，即可指定对解析结果的处理方式。 词法分析器接受字符的方式很简单，就像下面这样： function HTMLLexicalParser(){ //状态函数们…… function data() { // …… } function tagOpen() { // …… } // …… var state = data; this.receiveInput = function(char) { state = state(char); } }至此，我们就把字符流拆成了词（token）了。 构建DOM树接下来我们要把这些简单的词变成DOM树，这个过程我们是使用栈来实现的，任何语言几乎都有栈，为了给你跑着玩，我们还是用JavaScript来实现吧，毕竟JavaScript中的栈只要用数组就好了。 function HTMLSyntaticalParser(){ var stack = [new HTMLDocument]; this.receiveInput = function(token) { //…… } this.getOutput = function(){ return stack[0]; } }我们这样来设计HTML的语法分析器，receiveInput负责接收词法部分产生的词（token），通常可以由emitToken来调用。 在接收的同时，即开始构建DOM树，所以我们的主要构建DOM树的算法，就写在receiveInput当中。当接收完所有输入，栈顶就是最后的根节点，我们DOM树的产出，就是这个stack的第一项。 为了构建DOM树，我们需要一个Node类，接下来我们所有的节点都会是这个Node类的实例。 在完全符合标准的浏览器中，不一样的HTML节点对应了不同的Node的子类，我们为了简化，就不完整实现这个继承体系了。我们仅仅把Node分为Element和Text（如果是基于类的OOP的话，我们还需要抽象工厂来创建对象）， function Element(){ this.childNodes = []; } function Text(value){ this.value = value || &quot;&quot;; }前面我们的词（token）中，以下两个是需要成对匹配的： tag start tag end 根据一些编译原理中常见的技巧，我们使用的栈正是用于匹配开始和结束标签的方案。 对于Text节点，我们则需要把相邻的Text节点合并起来，我们的做法是当词（token）入栈时，检查栈顶是否是Text节点，如果是的话就合并Text节点。 同样我们来看看直观的解析过程： &lt;html maaa=a &gt; &lt;head&gt; &lt;title&gt;cool&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;a&quot; /&gt; &lt;/body&gt; &lt;/html&gt;通过这个栈，我们可以构建DOM树： 栈顶元素就是当前节点； 遇到属性，就添加到当前节点； 遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点； 遇到注释节点，作为当前节点的子节点； 遇到tag start就入栈一个节点，当前节点就是这个节点的父节点； 遇到tag end就出栈一个节点（还可以检查是否匹配）。 我在文章里面放了一个视频，你可以点击查看用栈构造DOM树的全过程。 当我们的源代码完全遵循XHTML（这是一种比较严谨的HTML语法）时，这非常简单问题，然而HTML具有很强的容错能力，奥妙在于当tag end跟栈顶的start tag不匹配的时候如何处理。 于是，这又有一个极其复杂的规则，幸好W3C又一次很贴心地把全部规则都整理地很好，我们只要翻译成对应的代码就好了，以下这个网站呈现了全部规则。你可以点击查看。 http://www.w3.org/html/wg/drafts/html/master/syntax.html#tree-construction 结语好了，总结一下。在今天的文章中，我带你继续探索了浏览器的工作原理，我们主要研究了解析代码和构建DOM树两个步骤。在解析代码的环节里，我们一起详细地分析了一个词（token）被拆分的过程，并且给出了实现它所需要的一个简单的状态机。 在构建DOM树的环节中，基本思路是使用栈来构建DOM树为了方便你动手实践，我用JavaScript实现了这一过程。 今天给你留的题目是：在语法和词法的代码，我已经给出了大体的结构，请你试着把内容补充完整吧。","link":"/2019/08/31/重学前端/浏览器：一个浏览器是如何工作的？（阶段二）/"},{"title":"浏览器：一个浏览器是如何工作的？（阶段一）","text":"对于前端开发来说，我们平时与浏览器打交道的时间是最多的。可浏览器对前端同学来说更多像一个神秘黑盒子的存在。我们仅仅知道它能做什么，而不知道它是如何做到的。 在我面试和接触过的前端开发者中，70%的前端同学对这部分的知识内容只能达到“一知半解”的程度。甚至还有一部分同学会质疑这部分知识是否重要：这与我们的工作相关吗，学多了会不会偏移前端工作的方向？ 事实上，我们这里所需要了解的浏览器工作原理只是它的大致过程，这部分浏览器工作原理不但是前端面试的常考知识点，它还会辅助你的实际工作，学习浏览器的内部工作原理和个中缘由，对于我们做性能优化、排查错误都有很大的好处。 在我们的课程中，我也会控制浏览器相关知识的粒度，把它保持在“给前端工程师了解浏览器”的水准，而不是详细到“给浏览器开发工程师实现浏览器”的水准。 那么，我们今天开始，来共同思考一下。一个浏览器到底是如何工作的。 实际上，对浏览器的实现者来说，他们做的事情，就是把一个URL变成一个屏幕上显示的网页。 这个过程是这样的： 浏览器首先使用HTTP协议或者HTTPS协议，向服务端请求页面； 把请求回来的HTML代码经过解析，构建成DOM树； 计算DOM树上的CSS属性； 最后根据CSS属性对元素逐个进行渲染，得到内存中的位图； 一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度； 合成之后，再绘制到界面上。 我们在开始详细介绍之前，要建立一个感性认识。我们从HTTP请求回来开始，这个过程并非一般想象中的一步做完再做下一步，而是一条流水线。 从HTTP请求回来，就产生了流式的数据，后续的DOM树构建、CSS计算、渲染、合成、绘制，都是尽可能地流式处理前一步的产出：即不需要等到上一步骤完全结束，就开始处理上一步的输出，这样我们在浏览网页时，才会看到逐步出现的页面。 首先我们来介绍下网络通讯的部分。 HTTP协议浏览器首先要做的事就是根据URL把数据取回来，取回数据使用的是HTTP协议，实际上这个过程之前还有DNS查询，不过这里就不详细展开了。 我先来了解下HTTP的标准。 HTTP标准由IETF组织制定，跟它相关的标准主要有两份： HTTP1.1 https://tools.ietf.org/html/rfc2616 HTTP1.1 https://tools.ietf.org/html/rfc7234 HTTP协议是基于TCP协议出现的，对TCP协议来说，TCP协议是一条双向的通讯通道，HTTP在TCP的基础上，规定了Request-Response的模式。这个模式决定了通讯必定是由浏览器端首先发起的。 大部分情况下，浏览器的实现者只需要用一个TCP库，甚至一个现成的HTTP库就可以搞定浏览器的网络通讯部分。HTTP是纯粹的文本协议，它是规定了使用TCP协议来传输文本格式的一个应用层协议。 下面，我们试着用一个纯粹的TCP客户端来手工实现HTTP一下： 实验我们的实验需要使用telnet客户端，这个客户端是一个纯粹的TCP连接工具（安装方法）。 首先我们运行telnet，连接到极客时间主机，在命令行里输入以下内容： telnet time.geekbang.org 80这个时候，TCP连接已经建立，我们输入以下字符作为请求： GET / HTTP/1.1 Host: time.geekbang.org按下两次回车，我们收到了服务端的回复： HTTP/1.1 301 Moved Permanently Date: Fri, 25 Jan 2019 13:28:12 GMT Content-Type: text/html Content-Length: 182 Connection: keep-alive Location: https://time.geekbang.org/ Strict-Transport-Security: max-age=15768000 &lt;html&gt; &lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt; &lt;body bgcolor=&quot;white&quot;&gt; &lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt; &lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt; &lt;/body&gt; &lt;/html&gt;这就是一次完整的HTTP请求的过程了，我们可以看到，在TCP通道中传输的，完全是文本。 在请求部分，第一行被称作 request line，它分为三个部分，HTTP Method，也就是请求的“方法”，请求的路径和请求的协议和版本。 在响应部分，第一行被称作 response line，它也分为三个部分，协议和版本、状态码和状态文本。 紧随在request line或者response line之后，是请求头/响应头，这些头由若干行组成，每行是用冒号分隔的名称和值。 在头之后，以一个空行（两个换行符）为分隔，是请求体/响应体，请求体可能包含文件或者表单数据，响应体则是HTML代码。 HTTP协议格式根据上面的分析，我们可以知道HTTP协议，大概可以划分成如下部分。 我们简单看一下，在这些部分中，path是请求的路径完全由服务端来定义，没有很多的特别内容；而version几乎都是固定字符串；response body是我们最熟悉的HTML，我在后面会有专门的课程介绍，这里也就不多讲了。 下面我们就来逐个给你介绍其它部分。 HTTP Method（方法）我们首先来介绍一下request line里面的方法部分。这里的方法跟我们编程中的方法意义类似，表示我们此次HTTP请求希望执行的操作类型。方法有以下几种定义： GET POST HEAD PUT DELETE CONNECT OPTIONS TRACE 浏览器通过地址栏访问页面都是GET方法。表单提交产生POST方法。 HEAD则是跟GET类似，只返回请求头，多数由JavaScript发起 PUT和DELETE分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。 CONNECT现在多用于HTTPS和WebSocket。 OPTIONS和TRACE一般用于调试，多数线上服务都不支持。 HTTP Status code（状态码）和 Status text（状态文本）接下来我们看看response line的状态码和状态文本。常见的状态码有以下几种。 1xx：临时回应，表示客户端请继续。 2xx：请求成功。 200：请求成功。 3xx: 表示请求的目标有变化，希望客户端进一步处理。 301&amp;302：永久性与临时性跳转。 304：跟客户端缓存没有更新。 4xx：客户端请求错误。 403：无权限。 404：表示请求的页面不存在。 418：It’s a teapot. 这是一个彩蛋，来自ietf的一个愚人节玩笑。（超文本咖啡壶控制协议） 5xx：服务端请求错误。 500：服务端错误。 503：服务端暂时性错误，可以一会再试。 对我们前端来说，1xx系列的状态码是非常陌生的，原因是1xx的状态被浏览器HTTP库直接处理掉了，不会让上层应用知晓。 2xx系列的状态最熟悉的就是200，这通常是网页请求成功的标志，也是大家最喜欢的状态码。 3xx系列比较复杂，301和302两个状态表示当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移。实际上301更接近于一种报错，提示客户端下次别来了。 304又是一个每个前端必知必会的状态，产生这个状态的前提是：客户端本地已经有缓存的版本，并且在Request中告诉了服务端，当服务端通过时间或者tag，发现没有更新的时候，就会返回一个不含body的304状态。 HTTP Head (HTTP头)HTTP头可以看作一个键值对。原则上，HTTP头也是一种数据，我们可以自由定义HTTP头和值。不过在HTTP规范中，规定了一些特殊的HTTP头，我们现在就来了解一下它们。 在HTTP标准中，有完整的请求/响应头规定，这里我们挑几个重点的说一下： 我们先来看看Request Header。 接下来看一下Response Header。 这里仅仅列出了我认为比较常见的HTTP头，这些头是我认为前端工程师应该做到不需要查阅，看到就可以知道意思的HTTP头。完整的列表还是请你参考我给出的rfc2616标准。 HTTP Request BodyHTTP请求的body主要用于提交表单场景。实际上，HTTP请求的body是比较自由的，只要浏览器端发送的body服务端认可就可以了。一些常见的body格式是： application/json application/x-www-form-urlencoded multipart/form-data text/xml 我们使用HTML的form标签提交产生的HTML请求，默认会产生 application/x-www-form-urlencoded 的数据格式，当有文件上传时，则会使用multipart/form-data。 HTTPS在HTTP协议的基础上，HTTPS和HTTP2规定了更复杂的内容，但是它基本保持了HTTP的设计思想，即：使用上的Request-Response模式。 我们首先来了解下HTTPS。HTTPS有两个作用，一是确定请求的目标服务端身份，二是保证传输的数据不会被网络中间节点窃听或者篡改。 HTTPS的标准也是由RFC规定的，你可以查看它的详情链接： https://tools.ietf.org/html/rfc2818 HTTPS是使用加密通道来传输HTTP的内容。但是HTTPS首先与服务端建立一条TLS加密通道。TLS构建于TCP协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS跟HTTP没有任何区别。 HTTP 2HTTP 2是HTTP 1.1的升级版本，你可以查看它的详情链接。 https://tools.ietf.org/html/rfc7540 HTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持TCP连接复用。 服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中，这可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题。 TCP连接复用，则使用同一个TCP连接来传输多个HTTP请求，避免了TCP连接建立时的三次握手开销，和初建TCP连接时传输窗口小的问题。 Note: 其实很多优化涉及更下层的协议。IP层的分包情况，和物理层的建连时间是需要被考虑的。 结语在这一节内容中，我们一起学习了浏览器的第一步工作，也就是“浏览器首先使用HTTP协议或HTTPS协议，向服务端请求页面”的这一过程。 在这个过程中，掌握HTTP协议是重中之重。我从一个小实验开始，带你体验了一次完整的HTTP请求过程。我们一起先分析了HTTP协议的结构。接下来，我分别介绍了HTTP方法、HTTP状态码和状态文本、HTTP Head和HTTP Request Body几个重点需要注意的部分。 最后，我还介绍了HTTPS和HTTP 2这两个补充版本，以便你可以更好地熟悉并理解新的特性。 你在工作中，是否已经开始使用HTTPS和HTTP 2协议了呢？用到了它们的哪些特性，请留言告诉我吧。","link":"/2019/08/31/重学前端/浏览器：一个浏览器是如何工作的？（阶段一）/"},{"title":"答疑加餐 | 学了这么多前端的“小众”知识，到底对我有什么帮助？","text":"你好，我是winter。这一期我想跟你谈谈前端知识的学习姿势。 课程进展至今，我已经把大部分困难的知识点都讲完了。我在后台收到了一些留言，有的同学针对前端专栏的学习方法和学习方向提出了一些问题，在本期文章中，为了让同学们更好地理解我们专栏的重点，最大程度地吸收知识，在今天的文章中，我会逐一回答同学们在学习方法上的困惑。 1.老师讲的内容是不是工作中用不到的，对掌握前端的实际工作有什么帮助呢，我们有必要掌握这些比较偏的内容吗？我自己一直奉行着一个观点，不要执着于知识的“临时”实用性。因为我总是感觉，掌握知识越多的人，更喜欢花费时间学习一些暂时可能无法变现的知识，原因有两点：一是其实学知识花费的时间比想象中的要少，这边在纠结它有没有用，那边可能都学完了；二是知识的实用性其实不怎么好判定，比如当年黎曼搞出非欧几何的时候，全世界都觉得纯粹是数学的思维游戏，直到黎曼死了很多年后，相对论出世，黎曼几何有了实际用途。 不过，这里我还是希望讲清楚，我想通过我们的课程传达一些什么样知识内容。 我们的每一节课标题中，都会带一个有点“小众”的问题，但是，实际上，这个标题主要是引起你学习兴趣的一个引子，解决问题只是我们学习课程的一个自然结果。 我希望的是，通过这个有点偏的问题，引起你对这部分知识领域的关注，知道这部分知识的边界在哪里，从而形成一个完备的知识网络。让你在遇见不会的问题时候，可以快速定位到知识点，达成有效学习。并且，你也可以通过自己之前没有关注过的不同视角，来重新学习一遍这部分的知识。 比如在JavaScript课程中，我提供了几个不同的视角来讲解JavaScript语言，每一个视角下，都是完整的JavaScript知识。 比如说，当我们写下 1+1 的时候，我们从词法的角度看，这是两个数字直接量和一个加法符号，我们从类型的角度看，两个Number类型相加得到的也是Number类型，我们从语法的角度看，这是一个加法表达式。 我们从不同的维度去认识了JavaScript语言，这些视角，远比你记住我们课上讲的细节更重要。如果你记住了“数字直接量可以用科学计数法，E还可以小写”，却没有学会从词法的角度去分析JavaScript语言，那可谓是“入宝山空手而归了”。 2.我从业时间不长，文章看得迷迷糊糊，是我的基础不够吗？该怎么办？有一种说法，世界上的知识分成“我知道的”“我知道自己不知道的”和“我不知道自己不知道的”。 重学前端定位是有一定经验的前端工程师，所以它最重要的作用之一，就是帮助前端工程师发现问题，找出知识盲点。 课程设计上，我的主要思路也是“帮助”大家形成自己的体系，而不是“替”大家形成自己的体系。我在前言部分就讲到过，若论丰富全面，有MDN文档；若论准确权威，有标准文本，但是，我们课程的作用是传达思路，如果有知识上的缺失，你其实可以通过阅读MDN来补全。 3.如果阅读文章时候有的内容看不懂，该如何学习，如何定位这块的知识呢？这个问题比较抽象，我认为这个课程设计其实也是一种定位了。 比如，对JavaScript问题，先搞清楚看不懂的是词法问题、语法问题、还是运行时问题？定位清楚了问题，你已经距离解决问题前进了一大步。 在这里，我想跟大家说一下：如果你看不懂文章里的某一块知识，你可以给我留言，把具体的位置和知识点告诉我，这样我们可以进行更好的沟通和反馈，从而解决这个问题。如果你只是说不懂，我可能会一头雾水，也无从下手去帮助你解决问题。多做实时、有效的反馈，会让知识吸收的效果更好。 4.为什么文章里有那么多的术语和英文呢，为什么不换成更通俗的名字呢？其实，在我们的课程中，有很多次讨论到术语问题，比如“排版”，我们讲了中国古代的活字印刷，比如“渲染”，我们讲到了国画的技法。恰当地使用术语，对于传达知识是非常关键的。 翻译是一项很专业的工作，文学类的翻译讲究信、达、雅，对于技术类的名词，或许“雅”这方面可以稍微打点折扣，但是表意清晰，字句通达仍然是必须的。 很多术语有约定俗成的翻译，当我们阅读不同的文档时，可以快速地通过术语建立联系。并且，有的时候翻译本身也会造成一部分信息的丢失，所以，我有时会直接把英文也写出来，这样有助于你通过原文去理解和对照。 而为什么我不把术语换成更通俗的名字呢？ 我们所讲的多数技术，跟现实生活联系不大，这种情况下，“通俗”的名字往往意味着误导。有时候，我们确定术语时，反而会尽量使它远离已有的概念。当然，确定术语并非是我的工作与专长，我们课程中的绝大多数术语，都不是我的发明创造。 5.标准里有些东西还是看不太懂，如果可以的话，希望老师可以稍微讲解一下如何看懂标准？我并不推荐每一个前端工程师都去阅读标准，标准一半是写给实现者，一半是写给使用者，这里本来就有很多知识上的落差，多数时候，MDN是更好的选择。 如果一定要阅读标准，建议从自己做一个极简实现开始，我在浏览器部分，有讲解浏览器相关的知识，在JavaScript部分，我还设计了编译原理实验。我想，把它们落到代码上会是一个很好的开始。 6.接手了一个新项目, 怎么对前端合理规划, 老师能不能提供一些这方面的指导和建议？这个问题其实跟前端学习关系不大，但是我可以讲讲。 任何规划其实都差不多，得有背景、目标、方案、计划、预期结果。其实在我看来，“项目”是规划的最小单位，在项目中拆出前端来做规划，是不太合适的。 背景和目标通常来自公司的业务，方案跟具体的技术相关，计划是项目管理的领域，最后根据这些来给出预期结果。 再往下细说，一个完整的方案可能包括产品、运营、市场、技术，不同的项目，各个职能的难度不一样，有些项目可能干脆不需要某些方案——比如多数淘宝的产品，首页开个入口就有访问量了，不需要独立去做市场。 具体到技术方案，前端、后端和公司的基础设施都有一定影响，有些公司会找一个架构师来做整体方案，有些公司则是哥几个商量一下边做边出，其实因地制宜最重要，能达到目标的方案都是好方案。 有了整体方案，到前端的一亩三分地上，技术选型、工程规范是绕不开的，有些公司有统一的前端团队，框架和工具都定好了，那么项目里面，就剩下分工和代码设计问题了，也有些公司有些项目具有特殊性，需要特别定制。 实际上，我很难给出具体的“框架选Vue”，工具用“webpack”这样的建议，因为工程领域本来就是需要很多妥协和权衡的。 不过，在我们课程的最后一部分，我选择了几个典型的基础设施和体系来讲，会给你分享这几个领域中我的认知。 在本篇文章中，我主要针对一些同学在学习上的疑问，给出了我的答案。你对前端的学习方法有什么样的困惑，欢迎给我留言，我们一起讨论。","link":"/2019/08/31/重学前端/答疑加餐 | 学了这么多前端的“小众”知识，到底对我有什么帮助？/"},{"title":"浏览器：一个浏览器是如何工作的？（阶段五）","text":"你好，我是winter。我们的浏览器系列已经进行到最后一篇。 在之前的几篇文章中，我们已经经历了把URL变成字符流，把字符流变成词（token）流，把词（token）流构造成DOM树，把不含样式信息的DOM树应用CSS规则，变成包含样式信息的DOM树，并且根据样式信息，计算了每个元素的位置和大小。 那么，我们最后的步骤，就是根据这些样式信息和大小信息，为每个元素在内存中渲染它的图形，并且把它绘制到对应的位置。 渲染首先我们来谈谈渲染这个词，渲染也是个外来词，它是英文词render的翻译，render这个词在英文里面，有“导致”“变成”的意思，也有“粉刷墙壁”的意思。 在计算机图形学领域里，英文render这个词是一个简写，它是特指把模型变成位图的过程。我们把render翻译成“渲染”，是个非常有意思的翻译，中文里“渲染”这个词是一种绘画技法，是指沾清水把墨涂开的意思。 所以，render翻译成“渲染”，我认为是非常高明的，对render这个过程，用国画的渲染手法来概括，是颇有神似的。 我们现在的一些框架，也会把“从数据变成HTML代码的过程”称为render，其实我觉得这是非常具有误导性的，我个人是非常不喜欢这种命名方式，当然了，所谓“文无第一”，在自然语言的范围里，我们很难彻底否定这种用法的合理性。 不过，在本篇文章中，我们可以约定一下，本文中出现的“渲染”一词，统一指的是它在图形学的意义，也就是把模型变成位图的过程。 这里的位图就是在内存里建立一张二维表格，把一张图片的每个像素对应的颜色保存进去（位图信息也是DOM树中占据浏览器内存最多的信息，我们在做内存占用优化时，主要就是考虑这一部分）。 浏览器中渲染这个过程，就是把每一个元素对应的盒变成位图。这里的元素包括HTML元素和伪元素，一个元素可能对应多个盒（比如inline元素，可能会分成多行）。每一个盒对应着一张位图。 这个渲染过程是非常复杂的，但是总体来说，可以分成两个大类：图形和文字。 盒的背景、边框、SVG元素、阴影等特性，都是需要绘制的图形类。这就像我们实现HTTP协议必须要基于TCP库一样，这一部分，我们需要一个底层库来支持。 一般的操作系统会提供一个底层库，比如在Android中，有大名鼎鼎的Skia，而Windows平台则有GDI，一般的浏览器会做一个兼容层来处理掉平台差异。 这些盒的特性如何绘制，每一个都有对应的标准规定，而每一个的实现都可以作为一个独立的课题来研究，当年圆角+虚线边框，可是难倒了各个浏览器的工程师。考虑到这些知识互相都比较独立，对前端工程师来说也不是特别重要的细节，我们这里就不详细探究了。 盒中的文字，也需要用底层库来支持，叫做字体库。字体库提供读取字体文件的基本能力，它能根据字符的码点抽取出字形。 字形分为像素字形和矢量字形两种。通常的字体，会在6px 8px等小尺寸提供像素字形，比较大的尺寸则提供矢量字形。矢量字形本身就需要经过渲染才能继续渲染到元素的位图上去。目前最常用的字体库是Freetype，这是一个C++编写的开源的字体库。 在最普遍的情况下，渲染过程生成的位图尺寸跟它在上一步排版时占据的尺寸相同。 但是理想和现实是有差距的，很多属性会影响渲染位图的大小，比如阴影，它可能非常巨大，或者渲染到非常遥远的位置，所以为了优化，浏览器实际的实现中会把阴影作为一个独立的盒来处理。 注意，我们这里讲的渲染过程，是不会把子元素绘制到渲染的位图上的，这样，当父子元素的相对位置发生变化时，可以保证渲染的结果能够最大程度被缓存，减少重新渲染。 合成合成是英文术语compositing的翻译，这个过程实际上是一个性能考量，它并非实现浏览器的必要一环。 我们上一小节中讲到，渲染过程不会把子元素渲染到位图上面，合成的过程，就是为一些元素创建一个“合成后的位图”（我们把它称为合成层），把一部分子元素渲染到合成的位图上面。 看到这句话，我想你一定会问问题，到底是为哪些元素创建合成后的位图，把哪些子元素渲染到合成的位图上面呢？ 这就是我们要讲的合成的策略。我们前面讲了，合成是一个性能考量，那么合成的目标就是提高性能，根据这个目标，我们建立的原则就是最大限度减少绘制次数原则。 我们举一个极端的例子。如果我们把所有元素都进行合成，比如我们为根元素HTML创建一个合成后的位图，把所有子元素都进行合成，那么会发生什么呢？ 那就是，一旦我们用JavaScript或者别的什么方式，改变了任何一个CSS属性，这份合成后的位图就失效了，我们需要重新绘制所有的元素。 那么如果我们所有的元素都不合成，会怎样呢？结果就是，相当于每次我们都必须要重新绘制所有的元素，这也不是对性能友好的选择。 那么好的合成策略是什么呢，好的合成策略是“猜测”可能变化的元素，把它排除到合成之外。 我们来举个例子： &lt;div id=&quot;a&quot;&gt; &lt;div id=&quot;b&quot;&gt;...&lt;/div&gt; &lt;div id=&quot;c&quot; style=&quot;transform:translate(0,0)&quot;&gt;&lt;/div&gt; &lt;/div&gt;假设我们的合成策略能够把a、b两个div合成，而不把c合成，那么，当我执行以下代码时： document.getElementById(&quot;c&quot;).style.transform = &quot;translate(100px, 0)&quot;;我们绘制的时候，就可以只需要绘制a和b合成好的位图和c，从而减少了绘制次数。这里需要注意的是，在实际场景中，我们的b可能有很多复杂的子元素，所以当合成命中时，性能提升收益非常之高。 目前，主流浏览器一般根据position、transform等属性来决定合成策略，来“猜测”这些元素未来可能发生变化。 但是，这样的猜测准确性有限，所以新的CSS标准中，规定了will-change属性，可以由业务代码来提示浏览器的合成策略，灵活运用这样的特性，可以大大提升合成策略的效果。 绘制绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，不过，一般来说，浏览器并不需要用代码来处理这个过程，浏览器只需要把最终要显示的位图交给操作系统即可。 一般最终位图位于显存中，也有一些情况下，浏览器只需要把内存中的一张位图提交给操作系统或者驱动就可以了，这取决于浏览器运行的环境。不过无论如何，我们把任何位图合成到这个“最终位图”的操作称为绘制。 这个过程听上去非常简单，这是因为在前面两个小节中，我们已经得到了每个元素的位图，并且对它们部分进行了合成，那么绘制过程，实际上就是按照z-index把它们依次绘制到屏幕上。 然而如果在实际中这样做，会带来极其糟糕的性能。 有一个一度非常流行于前端群体的说法，讲做CSS性能优化，应该尽量避免“重排”和“重绘”，前者讲的是我们上一课的排版行为，后者模糊地指向了我们本课程三小节讲的三个步骤，而实际上，这个说法大体不能算错，却不够准确。 因为，实际上，“绘制”发生的频率比我们想象中要高得多。我们考虑一个情况：鼠标划过浏览器显示区域。这个过程中，鼠标的每次移动，都造成了重新绘制，如果我们不重新绘制，就会产生大量的鼠标残影。 这个时候，限制绘制的面积就很重要了。如果鼠标某次位置恰巧遮盖了某个较小的元素，我们完全可以重新绘制这个元素来完成我们的目标，当然，简单想想就知道，这种事情不可能总是发生的。 计算机图形学中，我们使用的方案就是“脏矩形”算法，也就是把屏幕均匀地分成若干矩形区域。 当鼠标移动、元素移动或者其它导致需要重绘的场景发生时，我们只重新绘制它所影响到的几个矩形区域就够了。比矩形区域更小的影响最多只会涉及4个矩形，大型元素则覆盖多个矩形。 设置合适的矩形区域大小，可以很好地控制绘制时的消耗。设置过大的矩形会造成绘制面积增大，而设置过小的矩形则会造成计算复杂。 我们重新绘制脏矩形区域时，把所有与矩形区域有交集的合成层（位图）的交集部分绘制即可。 结语在这一节课程中，我们讲解了浏览器中的位图操作部分，这包括了渲染、合成和绘制三个部分。渲染过程把元素变成位图，合成把一部分位图变成合成层，最终的绘制过程把合成层显示到屏幕上。 当绘制完成时，就完成了浏览器的最终任务，把一个URL最后变成了一个可以看的网页图像。当然了，我们对每一个部分的讲解，都省略了大量的细节，比如我们今天讲到的绘制，就有意地无视了滚动区域。 尽管如此，对浏览器工作原理的感性认识，仍然可以帮助我们理解很多前端技术的设计和应用技巧，浏览器的工作原理和性能部分非常强相关，我们在实践部分的性能优化部分，会再次跟你做一些探讨。 实际上，如果你认真阅读浏览器系列的课程，是可以用JavaScript实现一个玩具浏览器的，我非常希望学习课程的同学中能有人这样做，一旦你做到了，收益会非常大。这就是我今天留给你的课外作业，你可以尝试一下。","link":"/2019/08/31/重学前端/浏览器：一个浏览器是如何工作的？（阶段五）/"},{"title":"浏览器：一个浏览器是如何工作的？（阶段四）","text":"你好，我是winter。 我们书接上文。浏览器进行到这一步，我们已经给DOM元素添加了用于展现的CSS属性，接下来，浏览器的工作就是确定每一个元素的位置了。我们的基本原则仍然不变，就是尽可能流式地处理上一步骤的输出。 在构建DOM树和计算CSS属性这两个步骤，我们的产出都是一个一个的元素，但是在排版这个步骤中，有些情况下，我们就没法做到这样了。 尤其是表格相关排版、Flex排版和Grid排版，它们有一个显著的特点，那就是子元素之间具有关联性。 基本概念首先我们先来介绍一些基本概念，使你可以感性地认识一下我们平常说的各种术语。 “排版”这个概念最初来自活字印刷，是指我们把一个一个的铅字根据文章顺序，放入板框当中的步骤，排版的意思是确定每一个字的位置。 在现代浏览器中，仍然借用了这个概念，但是排版的内容更加复杂，包括文字、图片、图形、表格等等，我们把浏览器确定它们位置的过程，叫作排版。 浏览器最基本的排版方案是正常流排版，它包含了顺次排布和折行等规则，这是一个跟我们提到的印刷排版类似的排版方案，也跟我们平时书写文字的方式一致，所以我们把它叫做正常流。 浏览器的文字排版遵循公认的文字排版规范，文字排版是一个复杂的系统，它规定了行模型和文字在行模型中的排布。行模型规定了行顶、行底、文字区域、基线等对齐方式。（你还记得小时候写英语的英语本吗？英语本上的四条线就是一个简单的行模型。） 此外，浏览器支持不同语言，因为不同语言的书写顺序不一致，所以浏览器的文本排版还支持双向文字系统。 浏览器又可以支持元素和文字的混排，元素被定义为占据长方形的区域，还允许边框、边距和留白，这个就是所谓的盒模型。 在正常流的基础上，浏览器还支持两类元素：绝对定位元素和浮动元素。 绝对定位元素把自身从正常流抽出，直接由top和left等属性确定自身的位置，不参加排版计算，也不影响其它元素。绝对定位元素由position属性控制。 浮动元素则是使得自己在正常流的位置向左或者向右移动到边界，并且占据一块排版空间。浮动元素由float属性控制。 除了正常流，浏览器还支持其它排版方式，比如现在非常常用的Flex排版，这些排版方式由外部元素的display属性来控制（注意，display同时还控制元素在正常流中属于inline等级还是block等级）。 正常流文字排版我们会在CSS部分详细介绍正常流排版的行为，我们这里主要介绍浏览器中的正常流。正常流是唯一一个文字和盒混排的排版方式，我们先从文字来讲起。 要想理解正常流，我们首先要回忆一下自己如何在纸上写文章。 首先，纸是有固定宽度的，虽然纸有固定高度，但是我们可以通过下一页纸的方式来接续，因此我们不存在写不下的场景。 我们书写文字的时候，是从左到右依次书写，每一个字跟上一个字都不重叠，文字之间有一定间距，当写满一行时，我们换到下一行去继续写。 书写中文时，文字的上、下、中轴线都对齐，书写英文时，不同字母的高度不同，但是有一条基线对齐。 实际上浏览器环境也很类似。但是因为浏览器支持改变排版方向，不一定是从左到右从上到下，所以我们把文字依次书写的延伸方向称为主轴或者主方向，换行延伸的方向，跟主轴垂直交叉，称为交叉轴或者交叉方向。 我们一般会从某个字体文件中获取某个特定文字的相关信息。我们获取到的信息大概类似下面： 纵向版本： 这两张图片来自著名开源字体解析库freetype，实际上，各个库对字体的理解大同小异，我们注意一下，advance代表每一个文字排布后在主轴上的前进距离，它跟文字的宽/高不相等，是字体中最重要的属性。 除了字体提供的字形本身包含的信息，文字排版还受到一些CSS属性影响，如line-height、letter-spacing、word-spacing等。 在正常流的文字排版中，多数元素被当作长方形盒来排版，而只有display为inline的元素，是被拆成文本来排版的（还有一种run-in元素，它有时作为盒，有时作为文字，不太常用，这里不详细讲了）。 display值为inline的元素中的文字排版时会被直接排入文字流中，inline元素主轴方向的margin属性和border属性（例如主轴为横向时的margin-left和margin-right）也会被计算进排版前进距离当中。 注意，当没有强制指定文字书写方向时，在左到右文字中插入右到左向文字，会形成一个双向文字盒，反之亦然。 这样，即使没有元素包裹，混合书写方向的文字也可以形成一个盒结构，我们在排版时，遇到这样的双向文字盒，会先排完盒内再排盒外。 正常流中的盒在正常流中，display不为inline的元素或者伪元素，会以盒的形式跟文字一起排版。多数display属性都可以分成两部分：内部的排版和是否inline，带有inline-前缀的盒，被称作行内级盒。 根据盒模型，一个盒具有margin、border、padding、width/height等属性，它在主轴方向占据的空间是由对应方向的这几个属性之和决定的，而vertical-align属性决定了盒在交叉轴方向的位置，同时也会影响实际行高。 所以，浏览器对行的排版，一般是先行内布局，再确定行的位置，根据行的位置计算出行内盒和文字的排版位置。 块级盒比较简单，它总是单独占据一整行，计算出交叉轴方向的高度即可。 绝对定位元素position属性为absolute的元素，我们需要根据它的包含块来确定位置，这是完全跟正常流无关的一种独立排版模式，逐层找到其父级的position非static元素即可。 浮动元素排版float元素非常特别，浏览器对float的处理是先排入正常流，再移动到排版宽度的最左/最右（这里实际上是主轴的最前和最后）。 移动之后，float元素占据了一块排版的空间，因此，在数行之内，主轴方向的排版距离发生了变化，直到交叉轴方向的尺寸超过了浮动元素的交叉轴尺寸范围，主轴排版尺寸才会恢复。float元素排布完成后，float元素所在的行需要重新确定位置。 其它的排版CSS的每一种排版都有一个很复杂的规定，实际实现形式也各不相同。比如如Flex排版，支持了flex属性，flex属性将每一行排版后的剩余空间平均分配给主轴方向的width/height属性。浏览器支持的每一种排版方式，都是按照对应的标准来实现的。 结语这一部分，我们以正常流为主，介绍了浏览器的排版基本概念及一些算法。这里，我主要介绍了正常流中的文字排版、正常流中的盒、绝对定位元素、浮动元素排版这几种情况。最后，我还简单介绍了一下Flex排版。这属于进阶版的排版方式了，你可以了解一下。 你平时喜欢使用方式排版呢，欢迎留言告诉我。","link":"/2019/08/31/重学前端/浏览器：一个浏览器是如何工作的？（阶段四）/"},{"title":"用户故事 | 那些你与“重学前端”的不解之缘","text":"写在前面的话不知不觉，专栏已经更新了一半有余了。在两个月的时间里，我收到了很多同学的留言，很开心可以跟大家保持交流，也很惊喜见证了大家的成长。 在整个学习过程中，你有没有一些学习感悟呢，有哪些新的学习收获，又有哪些实践感悟？有没有对前端的知识架构有了更为深刻的认识，是否规划好了自己的前端之路。 如果你有想分享的经验，可以在文章下留言，如果你的留言被选中作为用户故事，我们将会为你送出“极客时间”&amp; winter联名T恤一件。分享你的收获，我们一起成长。 下面我们就一起来看看三位同学的分享。 极客时间用户@阿成 分享在我进入知乎社区的时候，winter 老师就已经不在这个社区了，虽然是退隐了江湖，但是江湖上还流传着他的传说，后来我在 Google Feed 中看到 winter 老师的开篇词，看完就感觉是我要的东西，还正好赶上打折，就毫不犹豫地买了。 我本科学的是光电信息，所以并不算是科班出身的程序员（虽然也有学C啦）。我本身对计算机程序一直很有兴趣，所以从大三开始，我就决定放弃从事本专业，做一名程序员。要说为什么选择前端领域，自然也是烂俗的“门槛低”理由。 不过，我没想到的是，前端的学习曲线到后面是如此陡峭，并且前端发展的速度如此之快，让人目不暇接，也让很多人产生了“技术焦虑”。 在这样的环境中，我也产生了迷茫，作为一名前端开发人员，我到底应该学什么，怎么学。毕业后两年多的时间里，我从使用原生的HTML/CSS/JavaScript，到现在流行的视图库Vue/React，看似我好像学会了很多，但是离开这些库，或者说将来这些库被淘汰了，我又剩下了什么呢？ 我逐渐意识到，我需要的可能是一些更“底层”的东西。 那么,什么是“底层”的东西呢，这里可不是指计算机底层，而是指不会被淘汰的东西，永远有用的东西。我认为对于任何程序员来说，最重要的就是：迅速获取某项知识的能力以及动手解决问题的能力。 前者需要我们建立自己的知识体系，也就是winter老师在第一讲中提到的，我们需要完善的知识架构。 我们不需要也不可能记住整个架构的知识，但我们却可以在需要的时候想起来这块知识的位置，是干什么的，能帮我们解决什么样的问题，可以通过什么关键词检索到，这就够了。 其实你让我回忆winter老师这么多节课的所有内容，我也是好多想不起来的，但多少都留下了印象。我们的大脑容量是有限的，所以“按需加载”也许对人脑也是个不错的策略。 后者其实就归功于winter老师精心设计的课后题，光看这些课文总归是差了点什么，只有你动手去做，才能真正理解这节课所讲的内容。 在做的过程中，你多半会遇到困难（这其实也是winter老师的本意），如果你通过努力解决掉了，这个提升才是最大的。你的方案不一定是最好的，或者你可能实在没什么头绪，这时候也可以利用搜索引擎去看看别人的方案。 因为我早上到公司要坐一个小时左右的公交，路上我基本上会用耳机听完课（不伤眼），然后剩下的时间去思考回顾一下，想想作业怎么完成。 在中午吃完饭休息的时候，动手做一下，有时候时间不一定够，就利用晚上和第二天的时间完成。每个人的情况都不一样，不过，想要有收获，就得付出多一些。 希望大家都能学有所成，有所收获。 极客时间用户@峰峰峰 分享先感谢极客时间给了我这次学习分享的机会，如果文中有不足之处，希望小伙伴们可以多多指导。 我是转行过来学习前端的，目前在前端这个岗位上工作了大概一年半的样子，最初知道重学前端这个专栏，也是因为朋友圈里面的一些大牛分享的，比较好奇，并且老师又是非常有名的winter老师，就报了这门课程。 我本人是对前端的技术非常感兴趣的，尤其是原生基础知识，因为我觉得一个人基础的扎实程度，能决定这个人在这个领域所能发展的高度。 刚开始看到课程目录的时候我很吃惊，因为这个目录和我之前所学的所有的课的目录都不一样，从文法、运行时的角度去解释JavaScript这门语言，这让我非常兴奋，因为我知道，这正是我所需要的。 通过跟随winter老师不断学习，我发现这把我原有的一些知识结构打乱了，但这并不是坏事，因为我以前的学习和知识结构都非常的混乱。 通过这次学习，让我对JavaScript的理解更加深入了一些，同时，重新梳理我的知识点也让我的知识结构更加的清晰了起来。 可能是我工作时间尚短的原因吧，我觉得老师的每一节课对于我来说都是一个新的东西。举个例子，就拿第3讲和第4讲来说吧，标签语义化我一直都知道，但是我在工作中用得很少，并且在理解上也只停留在非常浅的层面上，但是通过老师的讲解，让我理解到了语义化标签真正的含义。 我现在在工作都会开始使用一些我比较熟悉的语义化标签。包括一些浏览器的工作原理，关于JavaScript这门语言是面向对象还是面向类的解释，以及JavaScript的执行等等，这些知识点都让我受益良多，非常感谢winter老师，希望以后还能有机会跟着老师继续学习。 最后，分享一下我的学习方法吧。 先提升知识的广度，再去拓展知识的深度。 养成随时记录的习惯，可以是笔记，可以是代码（一定要写上注释）。 多逛逛技术论坛，有条件的情况下多去实验一下论坛中自己感兴趣的代码。 最后一条也是最重要的一条，坚持每天八小时工作外的学习和锻炼。 以上就是我的学习心得，不足之处还请多多见谅，希望对小伙伴们有帮助。 极客时间用户@木易杨 分享我看了老师在“极客live”的直播，总结了他提到的一些观点。 对于框架的使用没必要花太多时间，应该多研究一下三大框架背后的设计思想。 当一个程序员对算法、语言标准、底层、原生、英文文档这些词汇产生恐惧感的时候，他的技术生命已经走到尽头。 前端架构主要解决的是高复用性，架构能力提升方向主要是组件库开发、前端框架实现等。 对于前端进阶这个问题，其实看书的作用和意义已经不太明显，需要寻找好的平台和合适的项目，在项目中不断克服难题并挑战自己，遇到问题再去查资料总结。如果只是闭门看书那很难成为高手，书只是基础而已，真正的应用还是在项目中。 寒冬中能做的只有提升自己，但是光靠技术是不行的。 推荐 TensorFlow、可视化切图、PWA、WebGL。 TensorFlow 可以了解使用并做点东西出来，原理很难但不影响使用。 PWA 有望进一步发展。 WebGL 在未来会是一个很好的方向，它可以实现任何你想要的界面效果，但重点需要多掌握图形学的基础知识，它和算法，数据结构一样重要。 Weex和 RN 虽然都叫 Hybird 但不太一样，前者适合大厂主要是嵌入 APP 中使用，后者更适合创业公司。 不推荐 SSR、TypeScript、函数式编程。 SSR 不太看好，其主要是用于SEO，不太建议用做服务端渲染，其能够使用的场景不多，而且成本代价太大。 TypeScript 是好东西，是很有前景的语言，但适用于十万行以上代码级别的大型项目，小项目并不适合，反而徒增复杂。 用 JavaScript 做函数式编程并不靠谱，Map/Reduce/Redux/Hooks等并不是函数式编程，只是长得像而已。 PS：笔记内容由自己和群友提供，仅供参考。 我的一些思考和尝试听完 winter 老师直播后对其观点很是赞同，但因为是面对所有人讲解，所以内容有点多范围有些广，但对个人来说还是找适合自己的方向，在自己相对熟悉的领域再去扩展去突破。横向只是拓宽你的眼界，纵向才是你的核心竞争力。 对我来说感触最大的就是 3、4、5 这几点，因为我一直在思考以下的几个问题。 我现在是高级前端，但又感觉自身很弱，那我如何才能夯实我高级的地基然后成为资深前端呢？ 项目迭代节奏快日常加班又多，那我如何做才能平衡工作和学习？ 单单提升技术好像还是有很大瓶颈，那我如何提升我的职场核心竞争力？ 结合 winter老师的专栏和最近看的几篇文章，说说我对这几个问题的思考。 对于第一个问题，在 2 个多月前我还是不会写文章的小白，那个时候受到一些文章的触动，尝试把我的前端之路记录下来。 我的想法很简单，就是把前端进阶 28 期的重难点知识全部讲完，目前已经进行到第 4 期了，通过写作把知识通俗易懂的介绍给别人，在这个过程自己肯定会收获很多很多。 这就是我目前在尝试的学习方式，通过写作建立自己的知识架构，并且在这个架构上不断地进行优化，时间到了自然就进阶了。 对于第二个问题，刚开始写作时精力充沛时间也很多，每天都会更新技术文章，但随着项目迭代压力增大，文章更新速度相应就变慢了一些。 虽然文章质量提升了很多，但更新速度从日更变成了周更再变成了双周更，这个说实话我自身已经很难接受了，因为速度变慢导致我年初的计划要打折扣。 所以说做项目和自我学习要如何权衡，是否说我要减少项目难度和时间并在工作中摸鱼去学习呢？ 我的结论是不，因为一句话，“最好的学习就是在项目中锻炼自己”。既然我有这么好的项目去锻炼，那为什么还要摸鱼去学习呢，这不就是南辕北辙嘛，道理很简单但不是所有人都懂。 我最近在执行的方法是专注 + 锻炼 + 利用周末。 专注即工作时专注于工作，努力做好每次迭代，遇到难题迎难而上，工作时不开微信，勤用笔记安排日常工作并整理文档。 锻炼即一周抽出三天时间每次去健身房锻炼1小时，强壮的体魄才能撑住高强度的工作和学习，因为网易有健身房所以冬天锻炼也没什么问题，没办法去健身房的小伙伴可以尝试跑步或者在瑜伽垫上做 Keep。 利用周末即加大周末和平常晚上熬夜的时间去写文章，减少娱乐的时间，正所谓时间挤一挤总会有的，但这件事情比较反人性，所以重在坚持。公众号写文章更容易坚持，原因在于文章发布后有正反馈，比如粉丝的增长，留言和鼓励，赞赏等等，这些都更能促使你坚持下去，时间长了自然就养成了习惯。 对于第三个问题，winter 老师也说了，寒冬中光靠技术是不行的，那应该靠什么呢？幸好在最近看到的一篇文章中找到了答案，那就是表达能力。 表达能力是形成自己的框架系统，有理有据并且逻辑清晰，而且能让外人听懂，大部分优秀的人都具备这样的能力。反观自己并没有这样的能力，所以我要努力提升这块，其中最重要的方法就是写作训练。 兜兜转转那么多，其实我一直在尝试的进阶方法就是通过写作建立自己的知识架构体系，同时提高自身的表达能力，通过正反馈机制和锻炼保证我长久的坚持下去并最终养成习惯，习惯这一模式之后变成优秀的人也只是时间问题罢了。 希望我的一些思考和尝试能对你有所帮助。 （直播回顾：https://v.qq.com/x/page/x0830fc8xoj.html） 恭喜幸运用户 @阿成、@峰峰峰、@木易杨，你们的经验被选取成为本期的用户故事。极客时间将送出“极客时间”&amp; winter联名T恤一件。1个工作日之内，工作人员会与你取得联系。 读完了三位同学的故事后，你有哪些感受呢，留下你的收获，我们一起成长。","link":"/2019/08/31/重学前端/用户故事 | 那些你与“重学前端”的不解之缘/"},{"title":"（小实验）理解编译原理：一个四则运算的解释器","text":"你好，我是winter。 在前面的课程中，我在JavaScript和CSS的部分，多次提到了编译原理相关的知识。这一部分的知识，如果我们从编译原理“龙书”等正规的资料中学习，就会耗费掉不少的时间，所以我在这里设计了一个小实验，帮助你快速理解编译原理相关的知识。 今天的内容比较特殊，我们来做一段详细的代码实验，详细的代码我放在了文章里，如果你正在收听音频，可以点击文章查看详情。 分析按照编译原理相关的知识，我们来设计一下工作，这里我们分成几个步骤。 定义四则运算：产出四则运算的词法定义和语法定义。 词法分析：把输入的字符串流变成token。 语法分析：把token变成抽象语法树AST。 解释执行：后序遍历AST，执行得出结果。 定义四则运算四则运算就是加减乘除四种运算，例如： 1 + 2 * 3首先我们来定义词法，四则运算里面只有数字和运算符，所以定义很简单，但是我们还要注意空格和换行符，所以词法定义大概是下面这样的。 Token Number: 1``2``3``4``5``6``7``8``9``0 的组合 Operator: + 、-、 *、 / 之一 Whitespace: &lt;sp&gt; LineTerminator：&lt;LF&gt;``&lt;CR&gt; 这里我们对空白和换行符没有任何的处理，所以词法分析阶段会直接丢弃。 接下来我们来定义语法，语法定义多数采用BNF，但是其实大家写起来都是乱写的，比如JavaScript标准里面就是一种跟BNF类似的自创语法。 不过语法定义的核心思想不会变，都是几种结构的组合产生一个新的结构，所以语法定义也叫语法产生式。 因为加减乘除有优先级，所以我们可以认为加法是由若干个乘法再由加号或者减号连接成的： &lt;Expression&gt; ::= &lt;AdditiveExpression&gt;&lt;EOF&gt; &lt;AdditiveExpression&gt; ::= &lt;MultiplicativeExpression&gt; |&lt;AdditiveExpression&gt;&lt;+&gt;&lt;MultiplicativeExpression&gt; |&lt;AdditiveExpression&gt;&lt;-&gt;&lt;MultiplicativeExpression&gt;这种BNF的写法类似递归的原理，你可以理解一下，它表示一个列表。为了方便，我们把普通数字也得当成乘法的一种特例了。 &lt;MultiplicativeExpression&gt; ::= &lt;Number&gt; |&lt;MultiplicativeExpression&gt;&lt;*&gt;&lt;Number&gt; |&lt;MultiplicativeExpression&gt;&lt;/&gt;&lt;Number&gt;好了，这就是四则运算的定义了。 词法分析：状态机词法分析部分，我们把字符流变成token流。词法分析有两种方案，一种是状态机，一种是正则表达式，它们是等效的，选择你喜欢的就好，这里我都会你介绍一下状态机。 根据分析，我们可能产生四种输入元素，其中只有两种token，我们状态机的第一个状态就是根据第一个输入字符来判断进入了哪种状态： var token = []; const start = char =&gt; { if(char === &apos;1&apos; || char === &apos;2&apos; || char === &apos;3&apos; || char === &apos;4&apos; || char === &apos;5&apos; || char === &apos;6&apos; || char === &apos;7&apos; || char === &apos;8&apos; || char === &apos;9&apos; || char === &apos;0&apos; ) { token.push(char); return inNumber; } if(char === &apos;+&apos; || char === &apos;-&apos; || char === &apos;*&apos; || char === &apos;/&apos; ) { emmitToken(char, char); return start } if(char === &apos; &apos;) { return start; } if(char === &apos;\\r&apos; || char === &apos;\\n&apos; ) { return start; } } const inNumber = char =&gt; { if(char === &apos;1&apos; || char === &apos;2&apos; || char === &apos;3&apos; || char === &apos;4&apos; || char === &apos;5&apos; || char === &apos;6&apos; || char === &apos;7&apos; || char === &apos;8&apos; || char === &apos;9&apos; || char === &apos;0&apos; ) { token.push(char); return inNumber; } else { emmitToken(&quot;Number&quot;, token.join(&quot;&quot;)); token = []; return start(char); // put back char } }这个状态机非常简单，它只有两个状态，因为我们只有Number不是单字符的token。 这里我的状态机实现是非常经典的方式：用函数表示状态，用if表示状态的迁移关系，用return值表示下一个状态。 下面我们来运行一下这个状态机试试看： function emmitToken(type, value) { console.log(value); } var input = &quot;1024 + 2 * 256&quot; var state = start; for(var c of input.split(&apos;&apos;)) state = state(c); state(Symbol(&apos;EOF&apos;))运行后我们发现输出如下： 1024 + 2 * 256这是我们想要的答案。 语法分析：LL做完了词法分析，我们开始进行语法分析，LL语法分析根据每一个产生式来写一个函数，首先我们来写好函数名： function AdditiveExpression( ){ } function MultiplicativeExpression(){ }为了便于理解，我们就不做流式处理了，实际上一般编译代码都应该支持流式处理。 所以我们假设token已经都拿到了： var tokens = [{ type:&quot;Number&quot;, value: &quot;1024&quot; }, { type:&quot;+&quot; value: &quot;+&quot; }, { type:&quot;Number&quot;, value: &quot;2&quot; }, { type:&quot;*&quot; value: &quot;*&quot; }, { type:&quot;Number&quot;, value: &quot;256&quot; }, { type:&quot;EOF&quot; }];每个产生式对应着一个函数，例如：根据产生式，我们的AdditiveExpression需要处理三种情况： &lt;AdditiveExpression&gt; ::= &lt;MultiplicativeExpression&gt; |&lt;AdditiveExpression&gt;&lt;+&gt;&lt;MultiplicativeExpression&gt; |&lt;AdditiveExpression&gt;&lt;-&gt;&lt;MultiplicativeExpression&gt;那么AddititveExpression中就要写三个if分支，来处理三种情况。 AdditiveExpression的写法是根传入的节点，利用产生式合成新的节点 function AdditiveExpression(source){ if(source[0].type === &quot;MultiplicativeExpression&quot;) { let node = { type:&quot;AdditiveExpression&quot;, children:[source[0]] } source[0] = node; return node; } if(source[0].type === &quot;AdditiveExpression&quot; &amp;&amp; source[1].type === &quot;+&quot;) { let node = { type:&quot;AdditiveExpression&quot;, operator:&quot;+&quot;, children:[source.shift(), source.shift(), MultiplicativeExpression(source)] } source.unshift(node); } if(source[0].type === &quot;AdditiveExpression&quot; &amp;&amp; source[1].type === &quot;-&quot;) { let node = { type:&quot;AdditiveExpression&quot;, operator:&quot;-&quot;, children:[source.shift(), source.shift(), MultiplicativeExpression(source)] } source.unshift(node); } }那么下一步我们就把解析好的token传给我们的顶层处理函数Expression。 Expression(tokens);接下来，我们看Expression该怎么处理它。 我们Expression收到第一个token，是个Number，这个时候，Expression就傻了，这是因为产生式只告诉我们，收到了 AdditiveExpression 怎么办。 这个时候，我们就需要对产生式的首项层层展开，根据所有可能性调用相应的处理函数，这个过程在编译原理中称为求“closure”。 function Expression(source){ if(source[0].type === &quot;AdditiveExpression&quot; &amp;&amp; source[1] &amp;&amp; source[1].type === &quot;EOF&quot; ) { let node = { type:&quot;Expression&quot;, children:[source.shift(), source.shift()] } source.unshift(node); return node; } AdditiveExpression(source); return Expression(source); } function AdditiveExpression(source){ if(source[0].type === &quot;MultiplicativeExpression&quot;) { let node = { type:&quot;AdditiveExpression&quot;, children:[source[0]] } source[0] = node; return AdditiveExpression(source); } if(source[0].type === &quot;AdditiveExpression&quot; &amp;&amp; source[1] &amp;&amp; source[1].type === &quot;+&quot;) { let node = { type:&quot;AdditiveExpression&quot;, operator:&quot;+&quot;, children:[] } node.children.push(source.shift()); node.children.push(source.shift()); MultiplicativeExpression(source); node.children.push(source.shift()); source.unshift(node); return AdditiveExpression(source); } if(source[0].type === &quot;AdditiveExpression&quot; &amp;&amp; source[1] &amp;&amp; source[1].type === &quot;-&quot;) { let node = { type:&quot;AdditiveExpression&quot;, operator:&quot;-&quot;, children:[] } node.children.push(source.shift()); node.children.push(source.shift()); MultiplicativeExpression(source); node.children.push(source.shift()); source.unshift(node); return AdditiveExpression(source); } if(source[0].type === &quot;AdditiveExpression&quot;) return source[0]; MultiplicativeExpression(source); return AdditiveExpression(source); } function MultiplicativeExpression(source){ if(source[0].type === &quot;Number&quot;) { let node = { type:&quot;MultiplicativeExpression&quot;, children:[source[0]] } source[0] = node; return MultiplicativeExpression(source); } if(source[0].type === &quot;MultiplicativeExpression&quot; &amp;&amp; source[1] &amp;&amp; source[1].type === &quot;*&quot;) { let node = { type:&quot;MultiplicativeExpression&quot;, operator:&quot;*&quot;, children:[] } node.children.push(source.shift()); node.children.push(source.shift()); node.children.push(source.shift()); source.unshift(node); return MultiplicativeExpression(source); } if(source[0].type === &quot;MultiplicativeExpression&quot;&amp;&amp; source[1] &amp;&amp; source[1].type === &quot;/&quot;) { let node = { type:&quot;MultiplicativeExpression&quot;, operator:&quot;/&quot;, children:[] } node.children.push(source.shift()); node.children.push(source.shift()); node.children.push(source.shift()); source.unshift(node); return MultiplicativeExpression(source); } if(source[0].type === &quot;MultiplicativeExpression&quot;) return source[0]; return MultiplicativeExpression(source); }; var source = [{ type:&quot;Number&quot;, value: &quot;3&quot; }, { type:&quot;*&quot;, value: &quot;*&quot; }, { type:&quot;Number&quot;, value: &quot;300&quot; }, { type:&quot;+&quot;, value: &quot;+&quot; }, { type:&quot;Number&quot;, value: &quot;2&quot; }, { type:&quot;*&quot;, value: &quot;*&quot; }, { type:&quot;Number&quot;, value: &quot;256&quot; }, { type:&quot;EOF&quot; }]; var ast = Expression(source); console.log(ast);解释执行得到了AST之后，最困难的一步我们已经解决了。这里我们就不对这颗树做任何的优化和精简了，那么接下来，直接进入执行阶段。我们只需要对这个树做遍历操作执行即可。 我们根据不同的节点类型和其它信息，写if分别处理即可： function evaluate(node) { if(node.type === &quot;Expression&quot;) { return evaluate(node.children[0]) } if(node.type === &quot;AdditiveExpression&quot;) { if(node.operator === &apos;-&apos;) { return evaluate(node.children[0]) - evaluate(node.children[2]); } if(node.operator === &apos;+&apos;) { return evaluate(node.children[0]) + evaluate(node.children[2]); } return evaluate(node.children[0]) } if(node.type === &quot;MultiplicativeExpression&quot;) { if(node.operator === &apos;*&apos;) { return evaluate(node.children[0]) * evaluate(node.children[2]); } if(node.operator === &apos;/&apos;) { return evaluate(node.children[0]) / evaluate(node.children[2]); } return evaluate(node.children[0]) } if(node.type === &quot;Number&quot;) { return Number(node.value); } }总结在这个小实验中，我们通过一个小实验学习了编译原理的基本知识，小实验的目的是帮助你理解JavaScript课程中涉及到的编译原理基本概念，它离真正的编译原理学习还有很大的差距。 通过实验，我们了解了产生式、词法分析、语法分析和解释执行的过程。 最后留给你一些挑战，你可以根据自己的水平选择： 补全emmitToken，使得我们的代码能完整工作起来。 为四则运算加入小数。 引入负数。 添加括号功能。 欢迎写好的同学留言给我。","link":"/2019/08/31/重学前端/（小实验）理解编译原理：一个四则运算的解释器/"}],"tags":[],"categories":[{"name":"许世伟的架构课","slug":"许世伟的架构课","link":"/categories/许世伟的架构课/"},{"name":"重学前端","slug":"重学前端","link":"/categories/重学前端/"}]}