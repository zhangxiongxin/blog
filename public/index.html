<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 3.9.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>Enchanter</title>


    <meta property="og:type" content="website">
<meta property="og:title" content="Enchanter">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Enchanter">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/images/og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Enchanter">
<meta name="twitter:image" content="http://yoursite.com/images/og_image.png">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="Enchanter" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item is-active"
                href="/">Home</a>
                
                <a class="navbar-item"
                href="/categories">Categories</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="Search" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main">
    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:08:23.566Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    23 minutes read (About 3518 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/37 | 键值存储与数据库/">37 | 键值存储与数据库</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>上一讲我们介绍了存储中间件的由来。今天我们就聊一下应用最为广泛的存储中间件：数据库。</p>
<h2 id="数据库的种类"><a href="#数据库的种类" class="headerlink" title="数据库的种类"></a>数据库的种类</h2><p>从使用界面（接口）的角度来说，通常我们接触的数据库有以下这些。</p>
<p>使用最为广泛的，是关系型数据库（Relational Database），以 MySQL、Oracle、SQLSever 为代表。</p>
<p>这类数据库把数据每个条目（row）的数据分成多个项目（column），如果某个项目比较复杂，从数据结构角度来说是一个结构体，那么就搞一个新的表（table）来存储它，在主表只存储一个 ID 来引用。</p>
<p>这类数据库的特点是强 schema，每个项目（column）有明确的数据类型。从业务状态的角度看，可以把一个表（table）理解为一个结构体，当遇到结构体里面套结构体，那么就定义一个子表。</p>
<p>第二类是文档型数据库（Document Database），以 MongoDB 为代表。这类数据库把数据每个条目（row）称为文档（document），每个文档用 JSON或其他文档描述格式表示。</p>
<p>当前文档型数据库大部分是无 schema 的，也就是在插入文档时并不对文档的数据格式的有效性进行检查。</p>
<p>这有好有坏。好处是使用门槛低，升级数据格式方便。不好之处在于，质量保障体系弱化，数据可能被弄脏而不自知。可以预见的是，未来也会诞生强 schema 的文档型数据库。</p>
<p>第三类是键值存储（KV Storage），以 Cassandra 为代表。</p>
<p>键值存储从使用的角度来说，可以认为是数据库的特例。数据库往往是允许设定多个索引字段的，而键值存储明确只有唯一索引。</p>
<p>从实现角度来说，键值存储是数据库的基础。每一组数据库的索引，往往背后就是一组键值存储。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>无论是何种数据库，都面临一个重大选择：是否支持事务。这是一个艰难选择。从需求角度来说，事务功能非常强大，没道理不去支持。从实现角度来说，事务支持带来极大的负担，尤其是在分布式数据库的场景。</p>
<p>什么是事务？简单来说，事务就是把一系列数据库操作变成原子操作的能力。展开来说，事务的特性我们往往简称为 ACID，详细如下。</p>
<ul>
<li>原子性（Atomicity）：在整个事务中的所有操作，要么全部完成，要么全部不做，没有中间状态。对于事务在执行中发生错误，所有的操作都会被回滚，整个事务就像从没被执行过一样。</li>
<li>一致性（Consistency）：事务的执行必须保证系统的一致性。这一点拿转账为例最容易理解。假设 A 有 500 元，B 有 300 元，如果在一个事务里 A 成功转给 B 50元，那么不管并行发生了其他什么事，A 账户一定得是 450 元，B 账户一定得是 350 元。</li>
<li>隔离性（Isolation）：事务与事务之间不会互相影响，一个事务的中间状态不会被其他事务感知。</li>
<li>持久性（Durability）：一旦事务完成了，那么事务对数据所做的变更就完全保存在了数据库中，即使发生停电，系统宕机也是如此。</li>
</ul>
<p>如果我们忽略性能要求，事务是很好实现的，只需要用一把能够 Lock/Unlock 整个数据库的大锁就够了。</p>
<p>但这显然不现实，一把大锁下来，整个数据库就废了。从 IOPS（IO 吞吐能力）角度来说，为什么分布式数据库很讨厌事务是很容易理解的：如果没有事务，一次数据库操作很容易根据数据的分区特征快速将操作落到某个分区实例，剩下来的事情就纯粹是一个单机数据库的操作了。</p>
<p>一种常见的事务实现方式是乐观锁。</p>
<p>什么是乐观锁？</p>
<p>常规的锁是先互斥，再修改数据。不管是不是发生了冲突，我们都会先做互斥。</p>
<p>但乐观锁不同，它是先计算出所有修改的数据，然后最后一步统一提交修改。提交时会进行冲突检查，如果没有冲突，也就是说，在我之前没有人提交过新版本，或者虽然有人提交过新版本，但是修改的数据和我所依赖的数据并不相关，那么提交会成功。否则就是发生了冲突，会放弃本次修改。</p>
<p>这意味着，每个数据有可能有多个值。如下：</p>
<ul>
<li>KEYi -&gt; [(VER0, VAL0), (VER1, VAL1), …]</li>
</ul>
<p>其中，VER0 对应当前已经提交的值 VAL0，VER1 对应事务1 中修改后的值 VAL1，以此类推。</p>
<p>除了修改后的值外，每个事务还需要记录自己读过哪些数据。不幸的是，它并不是记录读过的 KEY 列表那么简单，而是要记录所有的读条件。</p>
<p>例如，对于 SELECT name, age, address WHERE age<code>&gt;</code>17 这样一个查询，我们不是要记录读过哪些 name、age、address，而是认为我们读过所有 age<code>&gt;</code>17 的条目（row）。</p>
<p>在事务提交的时候，锁住整个数据库（前面修改过程事务间不冲突，所以不需要锁数据库），检查所有记录的读条件，如果这些读条件对应的条目（row）的已提交版本都<code>&lt;=</code>基版本（VER0），那么说明不冲突，于是提交该事务所有的修改并释放锁。</p>
<p>如果事务提交的时候发现和其他已提交事务冲突，则放弃该事务，对所有修改进行回滚（其实是删除该事务产生的版本修改记录）。</p>
<p>到这里我们就可以理解为什么要用乐观锁了：至少它让锁数据库的粒度降到最低，判断冲突的逻辑也都是可预期的行为，这就避免了出现死锁的可能。</p>
<p>我们很容易可以推理得知，在所有并行执行的事务中，必然有一个事务的提交会成功。这样就避免了饥饿（永远都没人可以成功）。</p>
<h2 id="主从结构"><a href="#主从结构" class="headerlink" title="主从结构"></a>主从结构</h2><p>一旦我们考虑数据库的业务可用性和数据持久性，我们就需要考虑多副本存储数据。可用性（Availability）关注的是业务是否正常工作，而持久性（Durability）关注的是数据是否会被异常丢失。</p>
<p>当我们数据存在多个副本时，就有数据一致性的问题。因为不同副本的数据可能值不一样，我们到底应该听谁的。</p>
<p>我们的服务同时存在很多并发的请求，这就可能存在客户端 A 希望值是 VALa ，客户端 B 希望值是 VALb 的情况。</p>
<p>解决这个问题的方法之一是采用主从（Master-Slave）结构。主从结构采用的是一主多从模式，所有写操作都发往主（Master），所有从（Slave）都从主这边同步数据修改的操作。</p>
<p>这样，从（Slave）的数据版本只可能因为同步还没有完成，导致版本会比较旧，而不会出现比主（Master）还新的情况。</p>
<p>从（Slave）可以帮主（Master）分担一定的读压力。但是不是所有的读操作都可以被分担。大部分场景的读操作必须要读到最新的数据，否则就可能会出现逻辑错乱。只有那些纯粹用于界面呈现用途，而不是用于逻辑计算的场景，非敏感场景（比如财务场景是敏感场景）下能够接受读的旧版本数据，可以从从节点读。</p>
<p>从（Slave）最重要的是和主（Master）形成了互备关系。在主挂掉的时候，某个从节点可以替代成为新的主节点。这会发生一次选举行为，系统中超过一半的节点需要同意某个节点成为主，那么选举就会通过。</p>
<p>考虑选举的话，意味着集群的节点数为奇数比较好。比如，假设集群有 2 个节点，只有一主一从，那么在主挂掉后，因为只剩下一个节点参与选举，没有超过半数，选举不出新的主节点。</p>
<p>选择谁成为新的主是有讲究的，因为从的数据有可能不是最新的。一旦我们选择没有最新数据的从作为新的主节点，就意味着版本回退，也就意味着发生了数据丢失。</p>
<p>这是不能接受的事情。为了避免版本回退，写操作应该确保至少有一个从节点收到了最新的数据。这样在主挂掉后才可以确保能够选到一个拥有最新数据的节点成为新的主节点。</p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>多副本让数据库的可用性和持久性有了保障，但是仍然有这样一些问题需要解决：</p>
<ul>
<li>数据规模大到一定程度后，单个物理节点存放不了那么大的数据量；</li>
<li>主承受的读写压力太大，单台主节点承受不了这样高的 IOPS（吞吐能力）。</li>
</ul>
<p>从目前存储技术的发展看，单台设备的存储量已经可以非常高，所以上面的第二种情况也会很常见。</p>
<p>怎么解决？</p>
<p>分布式。简单说，就是把数据分片存储到多台设备上的分片服务器一起构成一个单副本的数据库。分片的方式常见的有两种：</p>
<ul>
<li>哈希分片（Hash based sharding）；</li>
<li>范围分配（Range based sharding）。</li>
</ul>
<p>无论哪个分片方式，都会面临因为扩容缩容导致的重新分片过程。重新分片意味着需要做数据的搬迁。</p>
<p>数据迁移阶段对数据访问的持续有不低的挑战，因为这时候对正在迁移的分片来说，有一部分数据在源节点，一部分数据在目标节点。</p>
<p>在分布式存储领域，有一个著名（CAP）理论。其中，C、A、P 分别代表一个我们要追求的目标。</p>
<ul>
<li>数据一致性(Consistency)：如果系统对一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据。</li>
<li>服务可用性(Availability)：所有读写请求在一定时间内得到响应，可终止、不会一直等待。</li>
<li>分区容错性(Partition-tolerance)：在网络分区的情况下，被分隔的节点仍能正常对外服务。</li>
</ul>
<p>那么 CAP 理论说的是什么？简单说，就是 C、A、P 三个目标不能兼得，我们只能取其二。</p>
<p>假设我们不会放弃服务的可用性，那么我们决策一个分布式存储基本上在数据一致性（C）和分区容错性（P）之间权衡。</p>
<p>数据一致性（C）的选择基本上是业务特性决定的，业务要求是强一致，我们就不可能用最终一致性模型，相应的，我们只能在分区容错性（P）上去取舍。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天我们概要讨论了数据库相关的核心话题。我们第一关心的，当然还是使用界面（接口）。从使用界面角度，我们要考虑选择关系型数据库还是文档型数据库，以及是否需要事务特性。</p>
<p>确定了我们要使用什么样的数据库后，接着我们从实现角度，考虑主从结构和分布式方面的特性。</p>
<p>数据库是非常专业并且复杂的领域，限于篇幅我们这里不能展开太多，你如果有兴趣可以参考相关的资料。</p>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将聊聊对象存储。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:08:21.648Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    23 minutes read (About 3455 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/36 | 业务状态与存储中间件/">36 | 业务状态与存储中间件</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>相比桌面程序而言，服务端程序依赖的基础软件不只是操作系统和编程语言，还多了两类：</p>
<ul>
<li>负载均衡（Load Balance）；</li>
<li>数据库或其他形式的存储（DB/Storage）。</li>
</ul>
<p>存储在服务端开发中是什么样的一个地位？今天我们就聊一下有关于存储中间件的那些事情。</p>
<p><img src="https://static001.geekbang.org/resource/image/89/82/895dbf7e39fb562215e0176ca4aad382.png" alt></p>
<h2 id="业务状态"><a href="#业务状态" class="headerlink" title="业务状态"></a>业务状态</h2><p>让我们从头开始。</p>
<p>首先我们思考一个问题：桌面程序和服务端程序的相似之处在哪里，不同之处又在哪里？对于这样一个开放性的问题，我们不同人可能有非常不同的答案。</p>
<p>今天让我们从数据的视角来看这个问题。</p>
<p>我们知道，一个桌面程序基本上是由一系列的 “用户交互事件” 所驱动。你可以把它理解为一个状态机：假设在** i ** 时刻，该桌面程序的状态为<strong>业务状态i</strong> ，它收到<strong>用户交互事件i</strong>后，状态变化为<strong>业务状态i+1</strong> 。这个过程示意如下：</p>
<blockquote>
<p><strong>业务状态i+1 = F( 用户交互事件i ，业务状态i )</strong></p>
</blockquote>
<p>用状态转换图表示如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/b7/cb/b78bf287f43735f81ad7ac30dcf7d1cb.png" alt></p>
<p>那么，服务端呢？</p>
<p>仔细考虑你会发现，其实服务端程序可以用一模一样的模型来看待。只不过它不是由 “用户交互事件” 来驱动，而是由 “网络API请求” 所驱动。</p>
<p>你同样可以把它理解为一个状态机：假设在** i ** 时刻，该服务端程序的状态为<strong>业务状态i</strong> ，它收到<strong>网络API请求i **后，状态变化为</strong>业务状态i+1 **。这个过程示意如下：</p>
<blockquote>
<p><strong>业务状态i+1 = F( 网络API请求i ，业务状态i )</strong></p>
</blockquote>
<p>用状态转换图表示如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/d4/6b/d4adc97bcf06721304ad0d6c30c99c6b.png" alt></p>
<p>那么，桌面程序和服务端程序的差别在哪？</p>
<p>它们最大的差别是业务状态的表示不同。</p>
<p>桌面程序的业务状态是如何表示的？内存中的数据结构。我们在上一章中提到，桌面程序的 Model 层是一棵 DOM 树，根结点通常叫 Document。这棵 DOM 树其实就是桌面程序的业务状态。</p>
<p>服务端程序的业务状态如何表示？用内存中的数据结构可以吗？</p>
<p>答案当然是不能。如果业务状态在内存中，服务端程序一挂，数据就丢了。</p>
<p>前面我们在 “<a href="https://time.geekbang.org/column/article/120049" target="_blank" rel="noopener">34 | 服务端开发的宏观视角</a>” 提到过：</p>
<blockquote>
<p>服务端的领域特征是大规模的用户请求，以及 24 小时不间断的服务。</p>
</blockquote>
<p>这句话是理解服务端体系架构的核心，至关重要。但某种意义上来说更重要的原则是：</p>
<blockquote>
<p>坚决不能丢失用户的数据，即他认为已经完成的业务状态。</p>
</blockquote>
<p>服务端对用户来说是个黑盒，既然用户收到某个 “网络API请求” 成功的反馈，那么他会认为这个成功是确认的。</p>
<p>所以，服务端必须保证其业务状态的可靠性。这与桌面程序不同，桌面程序往往需要明确的用户交互事件，比如 Ctrl+S 命令，来完成数据的存盘操作，这时业务状态才持久化写入到外存。而且对于大部分桌面程序来说，它并不需要支持持久化。</p>
<h2 id="存储中间件与容灾级别"><a href="#存储中间件与容灾级别" class="headerlink" title="存储中间件与容灾级别"></a>存储中间件与容灾级别</h2><p>在没有存储中间件的情况下，服务端需要自己在响应完每一个网络 API 请求之后，对业务状态进行持久化。</p>
<p>听起来这好像不复杂？</p>
<p>其实不然，服务端程序的业务状态持久化难度，比桌面程序要高很多。还是同样的原因，桌面程序是单用户使用的，持久化的时候什么别的事情也不干，看起来用户体验也可以接受。</p>
<p>但是对服务端程序而言，如果我们在某个 API 请求完成并持久化的时候，其他 API 请求如果只能排队等着的话，往轻了说服务的吞吐能力太差了；往严重里说，在持久化执行的那个时段，服务端在用户眼里就停止服务了。所以持久化的时间必须要足够短，短到让人感知不到服务停顿。</p>
<p>服务端程序的业务状态并不简单。这是一个多租户的持久化状态。就算一个用户的业务状态数据只有 100K，有个 100 万用户，那么需要持久化的数据也有 100G。这显然不能用“常规桌面程序每次完全重新生成一个新文件”的持久化思路做到，它需要被设计为一种增量式的存储系统。</p>
<p>如果每一个做服务端程序的开发人员需要自己考虑如何持久化业务状态，这个代价显然过高了。</p>
<p>于是，存储中间件就应运而生了。</p>
<p>从历史上来看，第一个存储中间件是数据库，出现在 1974 年，它就是 IBM System R。</p>
<p>这一年 Internet 刚刚被发明出来。所以数据库的诞生背景，很可能是为工作站服务的，也算网络服务的范畴。</p>
<p>桌面程序很少用数据库。只有一些需要增量持久化业务状态的场景会被采用，比较典型的是微信。微信的本地聊天纪录应该是基于数据库存储的，只不过用的是嵌入式数据库，比如 SQLite。</p>
<p>最早期人们对存储中间件的容灾级别要求并不高。数据库都是单机版本，没有主从。人们对存储中间件的诉求是高性能的、稳定的、经过验证的。数据的可靠性如何保证？晚上选个服务的低峰时期对数据库做个离线备份就完事了。</p>
<p>对服务端开发来说，数据库的出现是革命性的，它大大提升了开发效率。</p>
<p>但在容灾级别这个事情上，随着互联网的普及，我们对它的要求越来越高。</p>
<p>首先，单机数据库是不够的，需要多机相互热备，这就是数据库主从结构的来由。这样我们就不需要担心数据库单机故障会导致服务临时不可访问，甚至出现更严重的数据丢失。</p>
<p>其次，单机数据库是不够的，单机存储量终归有上限，这样我们服务的用户数就有上限。在分布式数据库出现之前，人们的解决方案是手工的分库分表。总之，业务上我们需要做到规模可伸缩，不必担心单机物理存储容量的限制。</p>
<p>最后，单机房的可靠性也是不够的，机房可能会出现网络中断，极端情况下还可能因为自然灾害，比如地震，导致整个机房的数据丢失。于是就出现了“两地三中心”，跨机房容灾的数据灾备方案。</p>
<h2 id="存储即数据结构"><a href="#存储即数据结构" class="headerlink" title="存储即数据结构"></a>存储即数据结构</h2><p>那么问题来了，数据库能够解决所有服务端程序的业务状态持久化需求吗？</p>
<p>答案当然是不能。</p>
<p>对比桌面程序我们能够知道，业务状态其实就是数据结构。虽然数据库这个数据结构的确通用性很强，但是它不是银弹，在很多场合下它并不适用。</p>
<p>存储即数据结构。</p>
<p>存储中间件是什么？存储中间件就是 “元数据结构”。</p>
<p>这个结论的逻辑在于下面几个方面。</p>
<p>首先，和桌面开发不同，桌面端的数据结构基本上都是基于内存的，实现难度较低。但是在服务端不同。我们每一次的业务状态改变都需要考虑持久化，所以服务端的核心数据结构都是基于外存的。</p>
<p>其次，服务端的数据结构对稳定性要求、并发性能（IOPS）要求极高。简单分析就可以知道，服务端程序的伸缩能力完全取决于存储的伸缩能力。</p>
<p>业务服务器往往是无状态的，压力大了新增加一台业务服务器非常容易。但是存储压力大了，并不能简单加一台机器了事，可能涉及数据的重新划分和搬迁工作。</p>
<p>这意味着，在服务端实现一个数据结构是非常困难的。我们举一个很简单的例子，在内存中我们实现一个 KV 存储非常容易，很多语言都有 Dictionary 或者 Map 这样的数据结构来做这事。就算不用库，我们自己花上几十分钟或一个小时来实现，也是非常轻松的一件事情。</p>
<p>但是，一个服务端的 KV 存储非常非常复杂，绝非一个人花上一天两天就可以干出来。就算干出来了，也没人敢立刻投入使用，需要经过非常庞大的测试案例进行方方面面的验证，才敢投入生产环境。并且，即使敢投入生产环境了，为了以策万全，刚开始往往也是采用“双写”的方式：同时使用一个成熟存储系统和我们新上线的存储。</p>
<p>存储系统的品控，至关重要。</p>
<p>正因为服务端的数据结构实现如此之难，所以对于服务端来说，所有业务需要涉及的数据结构都需要抽象出来，成为一个存储中间件。</p>
<p>存储中间件会有多少？</p>
<p>这与服务端开发的模型抽象有关。今天没有比较系统性的理论告诉大家，有了这样一些数据结构就完备了。但是从更长远发展的角度来看，我们很可能需要回答这个问题。</p>
<p>所以，存储中间件是 “元数据结构”。</p>
<p>这里说的 “元数据结构”，是我自己发明的一个词。它表达的含义是，数据结构的种类是非常有限的，并且最好理论可被证明，有了这样一些基本的数据结构，所有的业务需求都可以高效地实现。这些基本的数据结构，就是我说的 “元数据结构”。</p>
<p>今天我们接触的存储中间件有哪些？不完整的列表如下：</p>
<ul>
<li>键值存储（KV-Storage）；</li>
<li>对象存储（Object Storage）；</li>
<li>数据库（Database）；</li>
<li>消息队列（MQ）；</li>
<li>倒排索引（SearchEngine）；</li>
<li>等等。</li>
</ul>
<p>目前看，存储中间件的种类是不可枚举的。但它很可能只是受限于我自己的认知，也许有一天我们能够在这个问题上找到更加完美的答案。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天我们从桌面端程序和服务端程序的业务状态开始，探讨了存储中间件的由来。</p>
<p>前面我们在 “<a href="https://time.geekbang.org/column/article/120049" target="_blank" rel="noopener">34 | 服务端开发的宏观视角</a>” 提到过：</p>
<blockquote>
<p>服务端的领域特征是大规模的用户请求，以及 24 小时不间断的服务。</p>
</blockquote>
<p>这句话是理解服务端体系架构的核心，至关重要。但某种意义上来说更重要的原则是：</p>
<blockquote>
<p>坚决不能丢失用户的数据，即他认为已经完成的业务状态。</p>
</blockquote>
<p>存储即数据结构。存储中间件就是 “元数据结构”。</p>
<p>对于服务端来说，存储中间件至关重要。它不只是极大地解放了生产效率，也是服务端的性能瓶颈所在。几乎所有服务端程序扛不住压力，往往都是因为存储没有扛住压力。</p>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将聊聊数据库。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:08:19.672Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    21 minutes read (About 3159 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/35 | 流量调度与负载均衡/">35 | 流量调度与负载均衡</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>相比桌面程序而言，服务端程序依赖的基础软件不只是操作系统和编程语言，还多了两类：</p>
<ul>
<li>负载均衡（Load Balance）；</li>
<li>数据库或其他形式的存储（DB/Storage）。</li>
</ul>
<p>为什么会需要负载均衡（Load Balance）？今天我们就聊一下有关于流量调度与负载均衡的那些事情。</p>
<p>上一讲我们画了服务端程序的体系架构图，如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/89/82/895dbf7e39fb562215e0176ca4aad382.png" alt></p>
<p>什么是 “流量调度”？我们首先要了解这样几个常见的服务端程序运行实例（进程）相关的概念：</p>
<ul>
<li>连接数；</li>
<li>IOPS；</li>
<li>流量，入向流量和出向流量。</li>
</ul>
<p>我们知道，一个基本的服务端程序的服务请求，通常是由一个请求包（Request）和一个应答包（Response）构成。这样一问一答就是一次完整的服务。</p>
<p>连接数，有时候也会被称为并发数，指的是同时在服务中的请求数。也就是那些已经发送请求（Request），但是还没有收完应答（Response）的请求数量。</p>
<p>IOPS，指的是平均每秒完成的请求（一问一答）的数量。它可以用来判断服务端程序的做事效率。</p>
<p>流量分入向流量和出向流量。入向流量可以这么估算：</p>
<ul>
<li>平均每秒收到的请求包（Request）数量 <code>*</code> 请求包平均大小。</li>
</ul>
<p>同样的，出向流量可以这么估算：</p>
<ul>
<li>平均每秒返回的应答包（Response）数量 <code>*</code> 应答包平均大小。</li>
</ul>
<p>不考虑存在无效的请求包，也就是存在有问无答的情况（但实际生产环境下肯定是有的）的话，那么平均每秒收到的请求包（Request）数量、平均每秒返回的应答包（Response）数量就是 IOPS。故此：</p>
<ul>
<li>入向流量 ≈ IOPS <code>*</code> 请求包平均大小</li>
<li>出向流量 ≈ IOPS <code>*</code> 应答包平均大小</li>
</ul>
<p>所谓流量调度，就是把海量客户并发的请求包按特定策略分派到不同的服务端程序实例的过程。</p>
<p>有很多手段可以做流量调度。</p>
<h2 id="DNS-流量调度"><a href="#DNS-流量调度" class="headerlink" title="DNS 流量调度"></a>DNS 流量调度</h2><p>最基础的方式，是通过 DNS，如下图所示。</p>
<p><img src="https://static001.geekbang.org/resource/image/79/cd/793c5e6b7a884e6816a60ebe2ee803cd.png" alt></p>
<p>一个域名通过 DNS 解析到多个 IP，每个 IP 对应不同的服务端程序实例。这样就完成了流量调度。这里我们没有用到常规意义的负载均衡（Load Balance）软件，但是我们的确完成了流量调度。</p>
<p>那么这种做法有什么不足？</p>
<p><strong>第一个问题，是升级不便。</strong></p>
<p>要想升级 IP1 对应的服务端程序实例，必须先把 IP1 从 DNS 解析中去除，等 IP1 这个实例没有流量了，然后我们升级该实例，最后把 IP1 加回 DNS 解析中。</p>
<p>看起来还好，但是我们不要忘记，DNS 解析是有层层缓冲的。我们把 IP1 从 DNS 解析中去除，就算我们写明 TTL 是 15 分钟，但是过了一天可能都还稀稀拉拉有一些用户请求被发送到 IP1 这个实例。</p>
<p>所以通过调整 DNS 解析来实现升级，有极大的不确定性，完成一个实例的升级周期特别长。</p>
<p>假如一个实例升级需要 1 天，我们总共有 10 个实例，那么就需要 10 天。这太夸张了。</p>
<p><strong>第二个问题，是流量调度不均衡。</strong></p>
<p>DNS 服务器是有能力做一定的流量均衡的。比如第一次域名解析返回 IP1 优先，第二次域名解析让 IP2 优先，以此类推，它可以根据域名解析来均衡地返回 IP 列表。</p>
<p>但是域名解析均衡，并不代表真正的流量均衡。</p>
<p>一方面，不是每次用户请求都会对应一次 DNS 解析，客户端自己有缓存。另一方面，DNS 解析本身也有层层缓存，到 DNS 服务器的比例已经很少了。</p>
<p>所以在这样情况下，按域名解析做流量调度均衡，是非常粗糙的，实际结果并不可控。</p>
<p>那么，怎么让流量调度能够做到真正均衡？</p>
<h2 id="网络层负载均衡"><a href="#网络层负载均衡" class="headerlink" title="网络层负载均衡"></a>网络层负载均衡</h2><p>第一种做法，是在网络层（IP 层）做负载均衡。</p>
<p>章文嵩博士发起的负载均衡软件 LVS（Linux Virtual Server）就工作在这一层。我们以 LVS 为代表介绍一下工作原理。</p>
<p>LVS 支持三种调度模式。</p>
<ul>
<li>VS/NAT：通过网络地址转换（NAT）技术做调度。请求和响应都会经过调度器中转，性能最差。</li>
<li>VS/TUN：把请求报文通过 IP 隧道转发至真实服务器，而真实服务器将响应直接返回给客户，所以调度器只处理请求报文。这种做法性能比 VS/NAT 好很多。</li>
<li>VS/DR：通过改写请求报文的MAC地址，将请求发送到真实服务器，真实服务器将响应直接返回给客户。这种做法相比 VS/TUN 少了 IP 隧道的开销，性能最好。</li>
</ul>
<p>我们重点介绍下 VS/DR 技术。</p>
<p><img src="https://static001.geekbang.org/resource/image/02/32/02d193a74158940f18a8562b771de732.png" alt></p>
<p>如上图所示。设客户端的 IP 和 MAC 为 CIP、CMAC。</p>
<p>第 1 步，客户端发起请求，其 IP 报文中，源 IP 为用户的 CIP ，目标 IP 是 VIP；源 MAC 地址为 CMAC ，目标 MAC 地址为 DMAC。</p>
<p>第 2 步，请求包到达 LVS 调度器（Director Server）。我们保持源 IP 和目标 IP 不变，仅仅修改目标 MAC 地址为 RMAC，将请求转发到真实的业务服务器实例 RS（Real Server）。</p>
<p>第 3 步，RS 收到数据包并经过处理，直接响应发送给客户端。</p>
<p>这里面的关键技巧，是 VIP 绑定在多台机器上，所以我们把它叫做虚拟 IP（Virtual IP）。它既绑定在 LVS 调度器（Director Server）上，也绑定在所有的业务服务器实例 RS（Real Server）上。</p>
<p>当然这里有一个很重要的细节是，ARP 广播查询 VIP 对应的 MAC 地址得到什么？答案当然是 LVS 调度器（Director Server）。在真实的业务服务器实例 RS（Real Server）上，我们把 VIP 绑定在 lo 接口上，并对 ARP 请求作了抑制，这样就避免了 IP 冲突。</p>
<p>LVS 这种在网络层底层来做负载均衡，相比其他负载均衡技术来说，其特点是通用性强、性能优势高。</p>
<p>但它也有一些缺点。假如某个业务服务器实例 RS 挂掉，但 LVS 调度器（Director Server）还没有感知到，在这个短周期内转发到该实例的请求都会失败。这样的失败只能依赖客户端重试来解决。</p>
<h2 id="应用层负载均衡"><a href="#应用层负载均衡" class="headerlink" title="应用层负载均衡"></a>应用层负载均衡</h2><p>有办法避免出现这种请求失败的情况吗？</p>
<p>可以。答案是：服务端重试。</p>
<p>怎么做服务端重试？应用层负载均衡。有时候我们也把它叫做应用网关。</p>
<p>HTTP 协议是应用最为广泛的应用层协议。当前应用网关，绝大多数都是 HTTP 应用网关。</p>
<p>Nginx 和 Apache 都是大家最为耳熟能详的 HTTP 应用网关。因为知道应用层协议的细节，所以 HTTP 应用网关的能力通常非常强大。这一点我们后面还会进一步进行探讨，今天我们先聊负载均衡（Load Balance）相关的内容。</p>
<p>HTTP 网关收到一个 HTTP 请求（Request）后，根据一定调度算法把请求转发给后端真实的业务服务器实例 RS（Real Server），收到 RS 的应答（Response）后，再把它转发给客户端。</p>
<p>整个过程的逻辑非常简单，而且重试也非常好做。</p>
<p>在发现某个 RS 实例挂了后，HTTP 网关可以将同一个 HTTP 请求（Request）重新发给其他 RS 实例。</p>
<p>当然一个重要的细节是为了能够支持重试，HTTP 请求（Request）需要被保存起来。不保存 HTTP 请求做重试是有可能的，但是只能支持业务实例完全挂掉 HTTP 请求一个字节都没发过去的场景。但在断电或异常崩溃等情况，显然会有很多进行中的请求是不符合这个前提的，它们就没法做重试。</p>
<p>大部分 HTTP 请求不大，直接在内存中存储即可，保存代价不高。但是文件上传型的请求，由于请求包中包含文件内容，可能就需要依赖临时文件或其他手段来保存 HTTP 请求。</p>
<h2 id="优雅升级"><a href="#优雅升级" class="headerlink" title="优雅升级"></a>优雅升级</h2><p>有了负载均衡，不只是可以实现了流量的均衡调度，连带业务服务器的升级也会方便多了。</p>
<p>对于前端是 LVS 这种网络层负载均衡的场景，升级的核心步骤为：</p>
<ul>
<li>升级系统通知 LVS 调度器（Director Server）下线要升级的业务服务器（Real Server）实例。</li>
<li>LVS 调度器（Director Server）将该实例从 RS 集合中去除，这样就不再调度新流量到它。</li>
<li>升级系统通知要升级的 RS 实例退出。</li>
<li>要升级的 RS 实例处理完所有处理中的请求，然后主动退出。</li>
<li>升级系统更新 RS 实例到新版本，并重启。</li>
<li>升级系统将 RS 实例重新加回 RS 集合参与调度。</li>
</ul>
<p>对于前端是 HTTP 应用网关这种负载均衡的场景，升级的过程可以更加简单：</p>
<ul>
<li>升级系统通知升级的业务服务器（Real Server）实例退出。</li>
<li>要升级的 RS 实例进入退出状态，这时新请求进来直接拒绝（返回一个特殊的 Status Code）；处理完所有处理中的请求后，RS 实例主动退出。</li>
<li>升级系统更新 RS 实例到新版本，并重启。</li>
</ul>
<p>可以看出，因 HTTP 应用网关支持重试，业务服务器的升级过程就变得简单很多。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天我们从流量调度谈起，聊了几种典型的调度手段和负载均衡的方式。</p>
<p>从流量调度角度来说，负载均衡的最大价值是让多个业务服务器的压力均衡。这里面隐含的一个前提是负载均衡软件的抗压能力往往比业务服务器强很多（为什么？欢迎留言讨论）。</p>
<p>这表现在：其一，负载均衡的实例数/业务服务器的实例数往往大大小于1；其二，DNS 的调度不均衡，所以负载均衡的不同实例的压力不均衡，有的实例可能压力很大。</p>
<p>当然，负载均衡的价值并不只是做流量的均衡调度，它也让我们的业务服务器优雅升级成为可能。</p>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将聊聊存储中间件。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:08:17.750Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    14 minutes read (About 2093 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/34 | 服务端开发的宏观视角/">34 | 服务端开发的宏观视角</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>今天开始，我们进入第三章，谈谈服务端开发。</p>
<h2 id="服务端的发展史"><a href="#服务端的发展史" class="headerlink" title="服务端的发展史"></a>服务端的发展史</h2><p>服务端开发这个分工，出现的历史极短。短得让人难以想象。</p>
<p>1946 年，第一台电子计算机问世。1954 年，第一门高级语言 Fortran 发布。整个信息科技发展到今天，大约也就 60~70 年的历史。</p>
<p>1974 年，Internet 诞生。1989 年，万维网（WWW）诞生，但刚开始只限于政府和学术研究用途，1993 年才开始进入民用市场。</p>
<p>从这个角度来说，服务端开发这个分工，从互联网诞生算起也就 40 多年的历史。真正活跃的时段，其实只有 20 多年。</p>
<p>但其发展速度是非常惊人的。我们简单罗列下这些年来的标志性事件。</p>
<ul>
<li>1971 年，电子邮件诞生。</li>
<li>1974 年，Internet 诞生。</li>
<li>1974 年，第一个数据库系统 IBM System R 诞生。SQL 语言诞生。</li>
<li>1989 年，万维网（WWW）诞生。</li>
<li>1993 年，世界上第一个 Web 服务器 NCSA HTTPd 诞生，它也是大名鼎鼎的 Apache 开源 Web 服务器的前身。</li>
<li>1998 年，Akamai 诞生，提供内容分发网络（CDN）服务。这应该算全球第一个企业云服务，虽然当时还没有云计算这样的概念。</li>
<li>2006 年，Amazon 发布弹性计算云（Elastic Compute Cloud），简称 EC2。这被看作云计算诞生的标志性事件。</li>
<li>2007 年，Amazon 发布简单存储服务（Simple Storage Service），简称 S3。这是全球第一个对象存储服务。</li>
<li>2008 年，Google 发布 GAE（Google App Engine）。</li>
<li>2009 年，Go 语言诞生。Derek Collison 曾预言 Go 语言将制霸云计算领域。</li>
<li>2011 年，七牛云诞生，发布了 “对象存储+CDN+多媒体处理” 融合的 PaaS 型云存储，为企业提供一站式的图片、音视频等多媒体内容的托管服务。</li>
<li>2013 年，Docker 诞生。</li>
<li>2013 年，CoreOS 诞生。这是第一个专门面向服务端的操作系统。</li>
<li>2014 年，Kubernetes 诞生。当前被认为是数据中心操作系统（DCOS）的事实标准。</li>
</ul>
<p>通过回顾服务端的发展历史，我们可以发现，它和桌面开发技术迭代的背后驱动力是完全不同的。</p>
<p>桌面开发技术的迭代，是交互的迭代，是人机交互的革命。而服务端开发技术的迭代，虽然一开始沿用了桌面操作系统的整套体系框架，但它正逐步和桌面操作系统分道而行，转向数据中心操作系统（DCOS）之路。</p>
<h2 id="服务端程序的需求"><a href="#服务端程序的需求" class="headerlink" title="服务端程序的需求"></a>服务端程序的需求</h2><p>这些演进趋势的根源是什么？</p>
<p><strong>其一是规模。</strong></p>
<p>桌面程序是为单个用户服务的，所以它关注点是用户交互体验的不断升级。</p>
<p>服务端程序是被所有用户所共享，为所有用户服务的。一台物理的机器资源总归是有限的，能够服务的用户数必然存在上限，所以一个服务端程序在用户规模到达一定程度后，需要分布式化，跑在多台机器上以服务用户。</p>
<p><strong>其二是连续服务时长。</strong></p>
<p>桌面程序是为单个用户服务的，用户在单个桌面程序的连续使用时长通常不会太长。</p>
<p>但是服务端程序不同，它通常都是 7x24 小时不间断服务的。当用户规模达到一定基数后，每一秒都会有用户在使用它，不存在关闭程序这样的概念。</p>
<p><strong>其三是质量要求。</strong></p>
<p>每个桌面程序的实例都是为单个用户服务的，有一亿的用户就有一亿个桌面程序的实例。</p>
<p>但是服务端程序不同，不可能有一亿个用户就跑一亿个，每个用户单独用一个，而是很多用户共享使用一个程序实例。</p>
<p>这意味着两者对程序运行崩溃的容忍度不同。</p>
<p>一个桌面程序实例运行崩溃，它只影响一个用户。</p>
<p>但一个服务端程序实例崩溃，可能影响几十万甚至几百万的用户。</p>
<p>这是不可接受的。</p>
<p>一个服务端程序的实例可以崩溃，但是它的工作必须立刻转交给其他的实例重新做，否则损失太大了。</p>
<p>所以服务端程序必须能够实现用户的自动转移。一个实例崩溃了，或者因为需要功能升级而重启了，它正在服务的用户需要转给其他实例来服务。</p>
<p>所以，服务端程序必须是多实例的。单个程序实例的临时不可用状态，要做到用户无感知。</p>
<p>从用户视角看，服务端程序 7x24 小时持续服务，任何时刻都不应该崩溃。就如同水电煤一样。</p>
<h2 id="服务端开发的体系架构"><a href="#服务端开发的体系架构" class="headerlink" title="服务端开发的体系架构"></a>服务端开发的体系架构</h2><p>在 “<a href="https://time.geekbang.org/column/article/90170" target="_blank" rel="noopener">01 | 架构设计的宏观视角</a>” 这一讲中，我们将一个服务端程序完整的体系架构归纳如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/55/37/5553453858eb86bf88a5623255f20037.png" alt></p>
<p>这个架构体系，是为了方便你和桌面开发的体系架构建立自然的对应关系而画的。</p>
<p>它当然是对的，但它只是从服务端程序的单个实例看的，不是服务端程序体系架构的全部。</p>
<p>在 “<a href="https://time.geekbang.org/column/article/99184" target="_blank" rel="noopener">15 | 可编程的互联网世界</a>” 这一讲中，我们把 TCP/IP 层比作网络的操作系统，一个网络程序的体系架构如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/27/35/272a1a5319c226fc6472bb4f5f256c35.png" alt></p>
<p>一个服务端程序当然也是一个网络程序，它符合网络程序的体系架构。</p>
<p>但它也不是服务端程序体系架构的全部。</p>
<p>从宏观视角看，一个服务端程序应该首先是一个多实例的分布式程序。其宏观体系架构示意如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/89/82/895dbf7e39fb562215e0176ca4aad382.png" alt></p>
<p>相比桌面程序而言，服务端程序依赖的基础软件不只是操作系统和编程语言，还多了两类：</p>
<ul>
<li>负载均衡（Load Balance）；</li>
<li>数据库或其他形式的存储（DB/Storage）。</li>
</ul>
<p>为什么会需要负载均衡（Load Balance）？为什么会需要数据库或其他形式的存储？你可以留言探讨一下。我们在接下来的几讲将聊聊负载均衡和存储。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天我们从服务端的发展历程、服务端开发的需求谈起，以此方便你理解服务端开发的生态会怎么演化，技术迭代会走向何方。</p>
<p>我们这里探讨的需求和具体业务无关，它属于服务端本身的领域特征。就像桌面的领域特征是强交互，以事件为输入，GDI 为输出一样，服务端的领域特征是大规模的用户请求，以及 24 小时不间断的服务。</p>
<p>这些领域特征直接导致了服务端开发的体系架构和桌面必然是如此的不同。</p>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们将聊聊负载均衡（Load Balance）。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:08:15.818Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    20 minutes read (About 2951 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/33 | 桌面开发篇：回顾与总结/">33 | 桌面开发篇：回顾与总结</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>到今天为止，我们第二章 “桌面开发篇” 就要结束了。今天，让我们对整章的内容做一个回顾与总结。本章我们主要涉及的内容如下。</p>
<p><img src="https://static001.geekbang.org/resource/image/55/50/553d5dd6b9e774585514a05674066550.png" alt></p>
<p>这一章的内容主要分为三类。</p>
<p><strong>一类是基础平台</strong>，也就是上图中的浅绿色背景部分，谈的是 Native 桌面操作系统和浏览器的演变过程。</p>
<p><strong>一类是业务架构</strong>，也就是上图中的浅棕色背景部分，谈得是如何开发一个桌面软件。</p>
<p><strong>最后一类是实战</strong>，也就是上图浅黄色背景部分，我们以画图程序作为例子谈业务架构，并对需求进行了多次的迭代。</p>
<p>通过本章的内容，我们总结一下桌面开发的特点。</p>
<p><strong>首先从基础平台看。它的特点是：种类多、迭代快、知识有效期短。</strong>让桌面开发工程师（大前端）痛苦的是，时不时就有各种新平台、新语言、新框架冒出来，让人应接不暇。</p>
<p><strong>其次从要开发的产品本身看。它的特点是：需求多、迭代快。</strong>桌面开发（大前端）负责的是和活生生的个体打交道，我们的开发人员需要为了功能丰富，体验便捷做各种努力。</p>
<p>为了让产品有竞争力，很多团队的发布周期都是至少一个月迭代一个版本，有的甚至是一周发布一个版本。而Web 前端就更夸张了，一些公司甚至没有统一的发版概念，只要某个功能产品经理验收了，测试验收了，就可以发。</p>
<p><strong>最后我们从对程序员的技能要求看。它的特点是门槛极低，但天花板又极高。</strong></p>
<p>桌面开发（大前端）的代码量大，代码变更又很频繁，所以它对程序员的第一要求，不是质量，而是数量上的需求极大。为什么 GitHub 的语言排行榜总是 JavaScript 排名第一？这不是别的原因，是市场需求所致。</p>
<p>与之相对的，服务端开发则非常不同。服务端开发并不是一上来就有的，是互联网出现后产生的新分工。它并不负责用户交互，所以在需求提炼时可以做到极强的可预测性。因而服务端的第一挑战往往不是快速响应，而是性能和稳定性等质量需求。</p>
<p>桌面开发的客观需求量大，这决定了它的门槛要求必须极低。我在描述桌面开发的未来也提到过，桌面开发技术的演进方向，是 7-8 岁的儿童也可以开发生产级的应用。这是门槛低的极致状态。</p>
<p>但是为什么我又说桌面开发的天花板又极高呢？因为桌面开发的团队人数多、人员质量参差不齐、代码量大、迭代变更频繁，这意味着桌面软件工程项目的管理难度极高。所以桌面开发对架构师能力、软件工程的水平要求之高，要远高于服务端开发。</p>
<p>当然，从国内的现状来说，凡是堆人和加班可以解决的，最终都是用堆人和加班解决。架构师能力培养和软件工程能力提升？对大部分公司来说，他们的想法可能是：这太慢了，等不起。</p>
<h2 id="桌面开发篇的内容回顾"><a href="#桌面开发篇的内容回顾" class="headerlink" title="桌面开发篇的内容回顾"></a>桌面开发篇的内容回顾</h2><p>这一章前面我们讲了些什么？为了让你对第二章内容有个宏观的了解，我画了一幅图，如下。</p>
<p><img src="https://static001.geekbang.org/resource/image/5a/14/5a083512c16a9ff8d661149eae283c14.png" alt></p>
<p>我们首先从单机软件开发讲起。我们开篇第一讲首先回顾了桌面开发关于交互方式的变更。从最早命令行程序，到 2D/3D GUI 图形界面程序，到智能交互程序的萌芽。</p>
<p>为什么我们从交互变更谈起？因为这是桌面系统迭代的根源。每一次桌面系统大的变更周期，都是由一场新的交互革命所驱动。</p>
<p>随后，我们介绍了今天仍然处于主流地位的图形界面操作系统提供的编程框架。尽管使用接口各不相同，但是今天主流桌面操作系统的框架本质大同小异，都是基于事件分派做输入，GDI 做界面呈现。</p>
<p><img src="https://static001.geekbang.org/resource/image/b8/c5/b8063e7ac32e854676b640c86d4628c5.png" alt></p>
<p>互联网的出现，衍生出了浏览器，它支持了一种新的应用形态：Web 应用。这意味着在操作系统之上，产生了一个新操作系统。Web 应用也在演变，从静态页，到以 Gmail 为代表的 AJAX 应用，到 PWA，到小程序。</p>
<p>PC 浏览器之争已经结束，但移动浏览器的竞争才刚开始。</p>
<p>怎么做一个桌面程序？标准的套路是 MVC 架构。无论是单机还是 Web 应用，它都是适用的，只是 Web 程序需要考虑客户端与服务端的分工，需要引入网络协议。</p>
<p>跨平台开发，是桌面程序开发绕不过去的问题。几年前也许不明显，这得益于 Android 和 iOS 的垄断。但是现在又回到了群雄逐鹿的时期。Native 手机操作系统、传统 Web、众多的小程序种类、国际市场的 PWA 等等，需要综合考虑进行取舍。</p>
<p>聊完单机软件和 Web 应用，我们也探讨了桌面开发的未来趋势。桌面开发技术的演进，目标是越来越低的门槛，它和儿童编程教育相向而行，有一天必然汇聚于一点上。</p>
<p>为了让你更好地理解桌面开发的架构逻辑，我们引入了一个长达 5 讲的实战案例。这个案例建议深度消化。</p>
<p>为什么实战是很重要的？</p>
<p><strong>学架构，我个人强调的理念是 “做中学”。</strong></p>
<p>首先还是要勤动手。然后配合本专栏去思考和梳理背后的道理，如此方能快速进步。</p>
<p>我们不能把架构课学成理论课。计算机科学本身是一门实践科学，架构经验更是一线实战经验的积累和总结。</p>
<p>通过这个实战案例，我们也探讨了辅助界面元素，也就是控件的架构。控件架构没有什么特别的地方，唯一需要注意的是支持多实例。用多实例去思考你的应用程序架构的合理性，会有助于你对架构设计中的一些决策提供帮助。</p>
<p>当然更重要的，其实是让你有机会形成更好的架构设计规范。</p>
<p>作为最后收官，我们聊了架构第二步：系统的概要设计，简称系统设计。我们这个阶段关注的是全局性的风险，怎么保证项目可以按时、按质、高度并行化地被执行。</p>
<p><strong>系统架构打的是地基。</strong></p>
<p>这个阶段需要选择操作系统、选择语言、选择主框架，选择项目所依赖的最核心的基础设施。这就是我说的有关于基础架构的工作。</p>
<p>这个阶段也需要分解业务系统。我们一般以子系统为维度来阐述系统各个角色之间的关系。对于关键的子系统，我们还会进一步分解它，甚至详细到把该子系统的所有模块的职责和接口都确定下来。</p>
<p>这个阶段我们的核心意图并不是确定系统完整的模块列表，我们的焦点是整个系统如何被有效地串联起来。如果某个子系统不作进一步的分解也不会在项目上有什么风险，那么我们并不需要在这个阶段对其细化。</p>
<p>为了降低风险，概要设计阶段也应该有代码产出。</p>
<p>这样做的好处是，一上来我们就关注了全局系统性风险的消除，并且给了每个子系统或模块的负责人一个更具象且确定性的认知。</p>
<p>代码即文档。代码是理解一致性更强的文档。</p>
<h2 id="桌面开发篇的参考资料"><a href="#桌面开发篇的参考资料" class="headerlink" title="桌面开发篇的参考资料"></a>桌面开发篇的参考资料</h2><p>桌面开发的知识迭代更新非常快，所以很难去列经典书籍。</p>
<p>这里我列一下我认为值得重点关注的技术：</p>
<ul>
<li>JavaScript。毫无疑问，这是当前桌面开发的第一大语言，务必要精通。这方面我推荐程劭非（winter）的极客时间专栏“<a href="http://gk.link/a/106jG" target="_blank" rel="noopener">重学前端</a>”。</li>
<li>微信小程序。这方面资料比较少，我推荐高磊的极客时间视频课“<a href="http://gk.link/a/106jH" target="_blank" rel="noopener">9小时搞定微信小程序开发</a>”。</li>
<li>React 和 Vue。这应该当前比较知名的两大前端框架，可以学习一下。前者可以看下王沛的“<a href="http://gk.link/a/106jM" target="_blank" rel="noopener">React实战进阶45讲</a>”，后者可以看下唐金州的“<a href="http://gk.link/a/106jN" target="_blank" rel="noopener">Vue开发实战</a>”。</li>
<li>Flutter 和 SwiftUI。这两个技术很新，其中 Flutter 已经有一些资料，比如陈航的“<a href="http://gk.link/a/106jO" target="_blank" rel="noopener">Flutter核心技术与实战</a>”。SwiftUI 与 Swift 语言关联很紧，在张杰的“<a href="https://time.geekbang.org/course/intro/218" target="_blank" rel="noopener">Swift核心技术与实战</a>”中有所涉略。</li>
<li>PWA 和 WebAssembly。这方面图书还比较少，不妨看官方材料结合实战来学习。</li>
</ul>
<p>当然，经典的 Android、iOS 方面的开发资料，也值得看看。这方面资料非常多，我就不再去提名了。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天我们对本章内容做了概要的回顾，并借此对整个桌面开发的骨架进行了一次梳理。</p>
<p>这一章我们开始聊业务架构。学业务架构最好的方式是：“做中学”。做是最重要的，然后要有做后的反思，去思考并完善自己的理论体系。</p>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们开始进入第三章：服务端开发篇。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:08:13.926Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    an hour read (About 6699 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/32 | 架构：系统的概要设计/">32 | 架构：系统的概要设计</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>我们第二章 “桌面开发篇” 就快要结束了。今天我们把话题重新回到架构上。</p>
<h2 id="基础架构与业务架构"><a href="#基础架构与业务架构" class="headerlink" title="基础架构与业务架构"></a>基础架构与业务架构</h2><p>桌面开发篇我们主要涉及的内容如下。</p>
<p><img src="https://static001.geekbang.org/resource/image/55/50/553d5dd6b9e774585514a05674066550.png" alt></p>
<p>对于一位架构师而言，其架构工作的内容可以大体分为两块，一块是基础架构，一块是业务架构。</p>
<p>基础架构，简单来说就是做技术选型。选择要支持的操作系统、选择编程语言、选择技术框架、选择第三方库，这些都可以归结为基础架构方面的工作。</p>
<p>基础架构的能力，考验的是选择能力。背后靠的是技术前瞻性和判断力。这并不简单。大部分架构师往往更容易把关注点放到业务架构上，但实际上基础架构的影响面更广，选错产生的代价更高。</p>
<p>架构师之间的差距，更大的是体现在其对待基础架构的态度和能力构建上。真正牛的架构师，一定会无比重视团队的技术选型，无比重视基础平台的建设。阿里提倡的 “大中台、小前台”，本质上也是在提倡基础平台建设，以此不断降低业务开发的成本，提升企业的创新能力。</p>
<p>业务架构，简单来说就是业务系统的分解能力。基础架构其实也是对业务系统的分解，只不过分解出了与业务属性几乎无关的部分，形成领域无关的基础设施。而业务架构更多的是分解领域问题 。</p>
<p>一旦我们谈业务架构，就避不开领域问题的理解。所谓领域问题，谈的是这个领域的用户群面临的普遍需求。所以我们需要对用户的需求进行分析。</p>
<p>在第一章，我们已经聊了需求分析：</p>
<ul>
<li><a href="https://time.geekbang.org/column/article/100140" target="_blank" rel="noopener">17 | 架构：需求分析（上）</a></li>
<li><a href="https://time.geekbang.org/column/article/100930" target="_blank" rel="noopener">18 | 架构：需求分析（下）- 实战案例</a></li>
</ul>
<p>这是我们开始业务架构的第一步。没有需求分析，就没有业务架构。在业务架构过程中，需求分析至少应该花费三分之一以上的精力。</p>
<p>今天，我们聊一聊架构的第二步：系统的概要设计，简称系统设计。</p>
<p>系统设计，简单来说就是 “对系统进行分解” 的能力。这个阶段核心要干的事情，就是明确子系统的职责边界和接口协议，把整个系统的大框架搭起来。</p>
<p>那么怎么分解系统？</p>
<p>首先我们需要明确的是分解系统优劣的评判标准。也就是说，我们需要知道什么样的系统分解方式是好的，什么样的分解方式是糟糕的。</p>
<p>最朴素的评判依据，是这样两个核心的点：</p>
<ul>
<li>功能的使用界面（或者叫接口），应尽可能符合业务需求对它的自然预期；</li>
<li>功能的实现要高内聚，功能与功能之间的耦合尽可能低。</li>
</ul>
<p>在软件系统中有多个层次的组织单元：子系统、模块、类、方法/函数。子系统如何分解模块？模块如何分解到更具体的类或函数？每一层的分解方式，都遵循相同的套路。也就是分解系统的方法论。</p>
<h2 id="接口要自然体现业务需求"><a href="#接口要自然体现业务需求" class="headerlink" title="接口要自然体现业务需求"></a>接口要自然体现业务需求</h2><p>我们先看功能的使用界面（或者叫接口）。</p>
<p>什么是使用界面？</p>
<p>对于函数，它的使用界面就是函数原型。</p>
<pre><code>package packageName

func FuncName(
  arg1 ArgType1, ..., argN ArgTypeN
  ) (ret1 RetType1, ..., retM RetTypeM)</code></pre><p>它包含三部分信息。</p>
<ul>
<li>函数名。严谨来说是包含该函数所在的名字空间的函数名全称，比如上例是 packageName.FuncName。</li>
<li>输入参数列表。每个参数包含参数名和参数类型。</li>
<li>输出结果列表。每个输出结果包含结果名和结果类型。当然，很多语言的函数是单返回值的，也就是输出结果只有一个。这种情况下输出结果没有名称，只有一个结果类型，也叫返回值类型。</li>
</ul>
<p>对于类，它的使用界面是类的公开属性和方法。</p>
<pre><code>package packageName

type ClassName struct {
  Prop1 PropType1
  ...
  PropK PropTypeK
}

func (receiver *ClassName) MethodName1(
   arg11 ArgType11, ..., arg1N1 ArgType1N1
  ) (ret11 RetType11, ..., ret1M1 RetType1M1)

...

func (receiver *ClassName) MethodNameL(
   argL1 ArgTypeL1, ..., argLNL ArgTypeLNL
  ) (retL1 RetTypeL1, ..., retLML RetTypeLML)</code></pre><p>它包含以下内容。</p>
<ul>
<li>类型名。严谨来说是包含该类型所在的名字空间的类型名全称，比如上例是 packageName.ClassName。</li>
<li>公开属性列表。每个属性包含属性名和属性类型。Go 语言对属性的支持比较有限，直接基于类型的成员变量来表达。而一些语言，比如 JavaScript，对属性的支持比较高级，允许给某个属性设定 get/set 方法。这样就能够做到只读、只写、可读写三种属性。</li>
<li>公开方法列表。</li>
</ul>
<p>方法和函数本质上是一样的，有的只是细节不同。这表现在下面几点。</p>
<ul>
<li><p>名字空间不同。普通函数的函数名全称是 packageName.FuncName，而方法的方法名全称是 packageName.(*ClassName).MethodName 这种形式。</p>
</li>
<li><p>方法相比函数多了一个概念叫 receiver（接受者），也就是方法所作用的对象。在 Go 语言中 receiver 是显式表达的。但大部分语言中 receiver 是隐藏的，通常名字叫 this 或 self。</p>
</li>
</ul>
<p>对于模块，它的使用界面比较多样，需要看模块类型。典型的模块类型有这样一些：</p>
<ul>
<li>包（package）。一些语言中也叫静态库（static library）。</li>
<li>动态库（dynamic library）。在 Go 语言中有个特殊的名称叫插件（plugin）。</li>
<li>可执行程序（application）。</li>
</ul>
<p>对于包（package）和动态库（dynamic library），这两者都是代码的一种发布形态，只是标准的制定方不同。包（package）一般是由编程语言定义的，对开发者比较友好。而动态库（dynamic library）一般是操作系统定义的，可以做到跨语言，但是对开发者往往不太友好。为什么不友好？因为它要定义跨语言的符号定义和类型定义的标准。这意味着它只能取多个编程语言之间的共性部分。</p>
<p>对于可执行程序（application），又要分多种情况。最常见的可执行程序有这么几类：</p>
<ul>
<li>网络服务程序（service）；</li>
<li>命令行程序（command line application）；</li>
<li>桌面程序（GUI application）</li>
</ul>
<p>对于网络服务程序（service），它的使用界面是网络协议。前面我们在 <a href="https://time.geekbang.org/column/article/111289" target="_blank" rel="noopener">“画图” 程序实战（四）</a>这一讲中也有定义过画图服务端的网络协议。如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/1b/c3/1b174cea94808537e21c5328ad2b8bc3.png" alt></p>
<p>对于命令行程序（command line application），它的使用界面包括：</p>
<ul>
<li>命令行，包括：命令名称、开关列表、参数列表。例如：CommandName -Switch1 … -SwitchN Arg1 … ArgM。</li>
<li>标准输入（stdin）。</li>
<li>标准输出（stdout）。</li>
</ul>
<p>对于桌面程序（GUI application），它的使用界面就是用户的操作方式。桌面程序的界面外观当然是重要的，但不是最重要的。最重要的是交互范式，即用户如何完成功能的业务流程的定义。为什么我们需要专门引入产品经理这样的角色来定义产品，正是因为使用界面的重要性。</p>
<p>以上这些组织单元都物理上存在，最后我们还剩一个概念：子系统。在实际开发中，并不存在物理的实体与子系统这个概念对应，它只存在于架构设计的文档中。</p>
<p>那么怎么理解子系统？</p>
<p>子系统是一个逻辑的概念，物理上可能对应一个模块（Module），也可能是多个模块。你可以把子系统理解为一个逻辑上的大模块（Big Module），这个大模块我们同样会去定义它的使用接口。</p>
<p>子系统与模块的对应方式有两种常见的情况。</p>
<p>一种情况，也是最常见的情况，子系统由一个根模块（总控模块）和若干子模块构成。子系统的使用接口，就是根模块的使用接口。</p>
<p>另一种情况，是子系统由多个相似的模块构成。例如对于 Office 程序来说，IO 子系统由很多相似模块构成，例如 Word 文档读写、HTML 文档读写、TXT 文档读写、PDF 文档读写等等，这些模块往往有统一的使用界面。</p>
<p>通过上面对子系统、模块、类、函数的使用界面的解释，你会发现其实它们是有共性的。它们都是在定义完成业务需求的方法，只不过需求满足方式的层次不一样。类和函数是从语言级的函数调用来完成业务，网络服务程序是通过网络 RPC 请求来完成业务，桌面程序是通过用户交互来完成业务。</p>
<p>理解了这一点，你就很容易明白，“功能的使用界面应尽可能符合业务需求对它的自然预期” 这句话背后的含义。</p>
<p>一个程序员的系统分解能力强不强，其实一眼就可以看出来。你都不需要看实现细节，只需要看他定义的模块、类和函数的使用接口。如果存在大量说不清业务意图的函数，或者存在大量职责不清的模块和类，就知道他基本上还处在搬砖阶段。</p>
<p>无论是子系统、模块、类还是函数，都有自己的业务边界。它的职责是否足够单一足够清晰，使用接口是否足够简单明了，是否自然体现业务需求（甚至无需配备额外的说明文档），这些都体现了架构功力。</p>
<h2 id="功能实现准则：高内聚低耦合"><a href="#功能实现准则：高内聚低耦合" class="headerlink" title="功能实现准则：高内聚低耦合"></a>功能实现准则：高内聚低耦合</h2><p>系统分解的套路中，除了功能自身的使用界面之外，我们还关注功能与功能之间是如何被连接起来的。当然这就涉及了功能的实现。</p>
<p>功能实现的基本准则是：功能自身代码要高内聚，功能与功能之间要低耦合。</p>
<p>什么叫高内聚？简单来说，就是一个功能的代码应该尽可能写在一起，而不是散落在各处。我个人在高内聚这个方向上养成的习惯是：</p>
<ul>
<li>一个功能的代码尽可能单独一个文件，不要和其他功能混在一起；</li>
<li>一些小功能的代码可能放在一起放在同一个文件中，但是中间也会用“// —————— ”这样的注释行分割成很多逻辑上的 “小文件”，代表这是一段独立的小功能。</li>
</ul>
<p>代码高内聚的好处是，多大的团队协作都会很顺畅，代码提交基本上不怎么发生冲突。</p>
<p>那么什么叫低耦合？简单来说就是实现某个功能所依赖的外部环境少，易于构建。</p>
<p>功能实现的外部依赖分两种。一种是对业务无关的基础组件依赖，一种是对底层业务模块的依赖。</p>
<p>基础组件可能是开源项目，当然也可能来自公司的基础平台部。关于基础组件的依赖，我们核心的关注点是稳定。稳定体现在如下两个方面。</p>
<p>一方面是组件的成熟度。这个组件已经诞生多久了，使用接口是不是已经不怎么会调整了，功能缺陷（issue）是不是已经比较少了。</p>
<p>另一方面是组件的持久性。组件的维护者是谁，是不是有足够良好的社区信用（credit），这个项目是不是还很活跃，有多少人在参与其中，为其贡献代码。</p>
<p>当然从架构角度，我们关注的重点不是基础组件的依赖，而是对其他业务模块的依赖。它更符合业务系统分解的本来含义。</p>
<p>对底层业务模块的依赖少、耦合低的表现为：</p>
<ul>
<li>对底层业务的依赖是 “通用” 的，尽量不要出现让底层业务模块专门为我定制接口；</li>
<li>依赖的业务接口的个数少，调用频次低。</li>
</ul>
<h2 id="怎么做系统分解？"><a href="#怎么做系统分解？" class="headerlink" title="怎么做系统分解？"></a>怎么做系统分解？</h2><p>有了系统分解的优劣评判标准，那么我们具体怎么去做呢？</p>
<p>总体来说，系统分解是一个领域性的问题，它依赖你对用户需求的理解，并不存在放之四海皆可用的办法。</p>
<p>系统分解首先要从需求归纳出发。用户需求分析清楚很重要。把需求功能点涉及的数据（对象）、操作接口理清楚，并归纳整理，把每个功能都归于某一类。然后把类与类的关系理清楚，做到逻辑上自洽，那么一个基本的系统框架就形成了。</p>
<p>在系统的概要设计阶段，我们一般以子系统为维度来阐述系统各个角色之间的关系。</p>
<p>对于关键的子系统，我们还会进一步分解它，甚至详细到把该子系统的所有模块的职责和接口都确定下来。但这个阶段我们的核心意图并不是确定系统完整的模块列表，我们的焦点是整个系统如何被有效地串联起来。如果某个子系统不作进一步的分解也不会在项目上有什么风险，那么我们并不需要在这个阶段对其细化。</p>
<p>为了降低风险，系统的概要设计阶段也应该有代码产出。</p>
<p>这个阶段的代码用意是什么？</p>
<p>有两个方面的目的。<strong>其一，系统的初始框架代码。也就是说，系统的大体架子已经搭建起来了。其二，原型性的代码来验证。一些核心子系统在这个阶段提供了 mock 的系统。</strong></p>
<p>这样做的好处是，一上来我们就关注了全局系统性风险的消除，并且给了每个子系统或模块的负责人一个更具象且确定性的认知。</p>
<p>代码即文档。代码是理解一致性更强的文档。</p>
<h2 id="再谈-MVC"><a href="#再谈-MVC" class="headerlink" title="再谈 MVC"></a>再谈 MVC</h2><p>本章我们主要探讨的是桌面程序开发。虽然不同桌面应用的业务千差万别，但是桌面本身是一个很确定性的领域，因此会形成自己固有的系统分解的套路。</p>
<p>大家已经知道了，桌面程序系统分解的套路就是 MVC 架构。</p>
<p>虽然不同历史时期的桌面程序的交互方式不太一样，有基于键盘+鼠标的、有基于触摸屏的，但是它们的框架结构是非常一致的，都是基于事件分派做输入，GDI 做界面呈现。</p>
<p><img src="https://static001.geekbang.org/resource/image/b8/c5/b8063e7ac32e854676b640c86d4628c5.png" alt></p>
<p>那么为什么会形成 Model-View-Controller（简称 MVC）架构？</p>
<p>我们第一章探讨需求分析时，我们反复强调一点：要分清需求的稳定点和变化点。稳定点是系统的核心能力，而变化点则需要做好开放性设计。</p>
<p>从这个角度来看，我们可以认为，业务的核心逻辑是稳定的，除非出现了新的技术革命导致产品的内在逻辑发生了质的变化。所以我们最底层一般以类和函数的形态来组织业务的核心逻辑，这就是 Model 层。</p>
<p>但用户交互是一个变化点。大家都是一个 “画图” 程序，无论是在 PC 桌面和手机上，Model 层是一样的，但是用户交互方式并不一样，View、Controllers 就有不小的差别。</p>
<p>当然 Model 层也有自己的变化点。它的变化点在于存储和网络。Model 层要考虑持久化，就会和存储打交道，就有自己的 IO 子系统。Model 层要考虑互联网化，就要考虑 B/S 架构，考虑网络协议。</p>
<p>不过无论是存储还是网络，从架构视角来说变化都是可预期的。存储介质会变，网络技术会变，但是变的只是实现，它们的使用接口并没变化。这意味着 Model 层不只是核心逻辑稳定，IO 和网络子系统也都很稳定。当然这也是把它们归于 Model 层的原因。如果它们是易变的，可能就被从 Model 层独立出去了。</p>
<p>用户交互这个变化点，主要体现在两个方面。一方面是屏幕尺寸导致的变化。更小的屏幕意味着界面上的信息需要被更高效地组织起来。另一方面则是交互的变化，鼠标交互和触摸屏的多点触摸交互是完全不同的。</p>
<p>View 层主要承担了界面呈现的工作。当然这也意味着它也承担了屏幕尺寸这个变化点。</p>
<p>Controller 层主要承担的是交互。具体来说就是响应用户的输入事件，把用户的操作转化为对 Model 层的业务请求。</p>
<p>Controller 层有很多 Controller。这些 Controller 通常各自负责不同的业务功能点。</p>
<p>也就是说，Model 层是一个整体，负责的是业务的核心逻辑。View 层也是一个整体，但在不同的屏幕尺寸和平台可能有不同的实现，但数量不会太多。而且现在流行所谓的响应式布局，也是鼓励尽可能在不同屏幕尺寸不同平台下共享同一个 View 的实现。Controller 层并不是一个整体，它是以插件化的形式存在，不同 Controlller 非常独立。</p>
<p>这样做的好处是可以快速适应交互的变化。比如以创建矩形这样一个功能为例，在 PC 鼠标+键盘的交互方式下有一个 RectCreator Controller，在触摸屏的交互方式可以是一个全新的 RectCreator Controller。在不同平台下，我们可以初始化不同的 Controller 实例来适应该平台的交互方式。</p>
<p>当然前面在 “<a href="https://time.geekbang.org/column/article/105356" target="_blank" rel="noopener">22 | 桌面程序的架构建议</a>” 一讲中，我们也介绍过 MVC 结构的一些变种，比如 MVP（Model-View-Presenter），主要是 Model 的数据更新发出 DataChanged 事件后，由 Controller 负责监听并 Update View，而不是由 View 层响应 DataChanged 事件并 Update View。</p>
<p>这些不同模型的差异其实只是细节的权衡、取舍，并不改变实质。</p>
<h2 id="怎么看待实战？"><a href="#怎么看待实战？" class="headerlink" title="怎么看待实战？"></a>怎么看待实战？</h2><p>第一章 “基础平台篇”，从架构的角度，我们主要是在学习基础架构。我们总体是从学历史的角度在聊，大家也是以听故事的方式为主。</p>
<p>但是第二章开始，我们话题逐步过渡到业务架构，同时也开始引入实战案例：“画图” 程序。</p>
<p>为什么实战是很重要的？</p>
<p><strong>学架构，我个人强调的理念是 “做中学”。</strong></p>
<p><strong>首先还是要勤动手。然后配合本专栏去思考和梳理背后的道理，如此方能快速进步。</strong></p>
<p>我们不能把架构课学成理论课。计算机科学本身是一门实践科学，架构经验更是一线实战经验的积累和总结。</p>
<p>为了方便大家进一步看清楚架构演变过程，我给画图程序实现了一个所有代码都揉在一起的非 MVC 版本（分支 v01）：</p>
<ul>
<li><a href="https://github.com/qiniu/qpaint/blob/v01/paintweb/www/index.htm" target="_blank" rel="noopener">www/index.htm</a></li>
</ul>
<p>它的功能对应我们 “<a href="https://time.geekbang.org/column/article/108887" target="_blank" rel="noopener">26 | 实战(一)：怎么设计一个“画图”程序？</a>” 这一讲中的最小化的画图程序。这是当时给出的源代码（分支 v26）：</p>
<ul>
<li><a href="https://github.com/qiniu/qpaint/tree/v26/paintweb/www" target="_blank" rel="noopener">www/*</a></li>
</ul>
<p>可以看到，v01 版本所有代码，包括 HTML+JavaScript，总共也就 470 行左右。所以这是一个非常小的架构实战案例。如果我们进一步减少案例的代码规模的话，可能就不太需要架构思想了。</p>
<p>我们不妨对比一下两个版本的差异。</p>
<p>一个最基础的对比是代码规模。v26 版本我们分拆了多个文件：</p>
<ul>
<li><p>Model：<a href="https://github.com/qiniu/qpaint/blob/v26/paintweb/www/dom.js" target="_blank" rel="noopener">dom.js</a>（100 行）</p>
</li>
<li><p>View：<a href="https://github.com/qiniu/qpaint/blob/v26/paintweb/www/view.js" target="_blank" rel="noopener">view.js</a>（112 行）</p>
</li>
<li><p>Controllers：</p>
</li>
<li><p><a href="https://github.com/qiniu/qpaint/blob/v26/paintweb/www/accel/menu.js" target="_blank" rel="noopener">accel/menu.js</a>（86 行）</p>
</li>
<li><p><a href="https://github.com/qiniu/qpaint/blob/v26/paintweb/www/creator/path.js" target="_blank" rel="noopener">creator/path.js</a>（90 行）</p>
</li>
<li><p><a href="https://github.com/qiniu/qpaint/blob/v26/paintweb/www/creator/freepath.js" target="_blank" rel="noopener">creator/freepath.js</a>（71 行）</p>
</li>
<li><p><a href="https://github.com/qiniu/qpaint/blob/v26/paintweb/www/creator/rect.js" target="_blank" rel="noopener">creator/rect.js</a>（108 行）</p>
</li>
<li><p>总控：<a href="https://github.com/qiniu/qpaint/blob/v26/paintweb/www/index.htm" target="_blank" rel="noopener">index.htm</a>（18 行）</p>
</li>
</ul>
<p>这些文件加起来的代码量大概在 580 行，比 v01 版本多了 110 行。</p>
<p>这说明 MVC 架构的价值并不是给我们降低总代码行数。实际上，它关注的重点是如何让我们团队协同作战，让工作并行。</p>
<p>怎么让工作并行？这就要求我们实现功能的时候，做到功能自身代码要高内聚，功能间的依赖要低耦合。v26 版本我们把功能分拆为 6 个文件（除了总控 index.htm 不算），可以交给 6 个团队成员来做，平均每个人写 100 行左右的代码。</p>
<p>当然，对于总体代码量 500 行不到的一个程序来说，这多多少少显得有点小题大做。但我们在此之后演进迭代了多个版本，功能越来越复杂，分工的必要性也就越来越大。</p>
<p>除了代码规模外，对比 v01 和 v26 版本，我们不妨从这样一些点来看。</p>
<ul>
<li>功能的高内聚。某个功能代码被分散在多少地方。</li>
<li>功能间的低耦合。当然 v01 版本所有代码都揉在了一起，我们不妨从如何做系统分解的视角来推演 v26 版本用 MVC 架构的意义。</li>
<li>怎么减少全局变量，为控件化做好准备。</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在我们介绍完第二章 “桌面开发” 篇的所有内容后，今天我们介绍了架构的第二步：系统的概要设计。</p>
<p>在概要设计阶段，我们一般以子系统为维度来阐述系统各个角色之间的关系。对于关键的子系统，我们还会进一步分解它，甚至详细到把该子系统的所有模块的职责和接口都确定下来。</p>
<p>这个阶段我们的核心意图并不是确定系统完整的模块列表，我们的焦点是整个系统如何被有效地串联起来。如果某个子系统不作进一步的分解也不会在项目上有什么风险，那么我们并不需要在这个阶段对其细化。</p>
<p>为了降低风险，概要设计阶段也应该有代码产出。</p>
<p>这样做的好处是，一上来我们就关注了全局系统性风险的消除，并且给了每个子系统或模块的负责人一个更具象且确定性的认知。</p>
<p>代码即文档。代码是理解一致性更强的文档。</p>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们会回顾和总结第二章的内容。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:08:12.002Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    38 minutes read (About 5627 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/加餐 |  想当架构师，我需要成为“全才”吗？/">加餐 |  想当架构师，我需要成为“全才”吗？</a>
            
        </h1>
        <div class="content">
            <p>你好，这里是极客时间编辑部。</p>
<p>不知不觉，“许式伟的架构课”专栏已经更新了3个多月，我们的后台收到了同学们数以千计的留言。许式伟老师每天都在实时关注着留言并回答同学们的问题，同时根据同学们的留言不断优化调整课程的设置。</p>
<p>老师和同学在留言区的互动也十分热闹精彩，今天我们就精选出一批留言，一起来看一看。</p>
<h2 id="精选问答"><a href="#精选问答" class="headerlink" title="精选问答"></a>精选问答</h2><p><strong>1.老师好，人精力有限，如果什么都懂，那不是不精了？通才还能做架构师吗？还是“一专多能”，先“专”，精通一样；再“多能”，了解其它技术？</strong></p>
<p>答：挺好的问题。架构师绝对不是要把自己打造为全才。架构师掌控全局的核心思想是打通经络，让自己的内力在全身自然流通，浑然一体。在不影响理解的情况下，你需要放弃很多实现细节的专研，但有一天你需要细节的时候，你能够知道存在这些细节，并且快速钻研进去。</p>
<p><strong>2.许老师，自己现在已经工作快三年了，想往架构师这个方向走，但现在自己有些迷茫，接触到的技术也算挺多了，但不知道该如何入手架构师，之前您也提到过先广度然后深度，但我想问达到什么算广度够了，怎么进行深度学习？</strong></p>
<p>答：架构师核心是把知识串起来，构建一个完整的认知，不留疑惑。大部分知识是不需要深入细节的，只在你需要的时候深入，但深入的时候要很深。</p>
<p><strong>3.如何来确定需求中哪些是稳定的？对架构角度，关注需求到什么层次？</strong></p>
<p>答：挺好的问题。需求分析的重要性怎么形容都不过分。准确的需求分析是做出良好架构设计的基础。很多优秀的架构师之所以换到一个新领域一上来并不一定能够设计出好的架构，往往需要经过几次迭代才趋于稳定，原因在于新领域的需求理解需要一个过程。除了心里对需求的反复推敲的严谨态度外，对客户反馈的尊重之心也至关重要。</p>
<p>4.<strong>老师好，我有三个问题。</strong></p>
<ul>
<li><strong>现在运维开发基本上都用Go，Python慢慢变少了，Java也少用了……现在运维开发是要学Go吗？</strong></li>
<li><strong>架构师要学数据结构和算法吗？很多都说算法是“内功”，中小公司好像学了都基本用不到。</strong></li>
<li><strong>现在不是流行Docker+k8s、微服务、DevOps、AI等，那些主流技术都要了解吗？OpenStack云计算这两年基本不讲了，是否不用学习？</strong></li>
</ul>
<p>答：关于你的三个问题，我的意见是下面这样的。</p>
<ul>
<li>学Go挺好，建议学，生产效率很高的开发工具。</li>
<li>“算法用不到”其实更准确的说法是“想不到”，或者是已经有人实现了你只需要调用，不需要自己实现。但是只有你知道了背后的道理，你才能明白算法对应的限制在哪里，什么情况下应该用什么算法。</li>
<li>高阶的技术可以按需学，按精力学，更根本的还是要打好基础，这也更有助于你判断是否应该深入学习某些技术。</li>
</ul>
<p>5.<strong>“你可以发现，引入了输入输出设备的电脑，不再只能做狭义上的计算（也就是数学意义上的计算），如果我们把交互能力也看做一种计算能力的话，电脑理论上能够解决的计算问题变得无所不包。”</strong></p>
<p><strong>交互能力也看做一种计算能力吗？这句话应该怎么理解呢？这种交互不就是输入和输出？哪有计算？</strong></p>
<p>答：广义的计算包含有副作用的函数（有IO的函数）。因为数据交换本身也是计算的需求，否则计算没有办法与现实世界相互作用。任何工具都需要解决现实问题才有用。计算器还有交互按钮呢，并不是只有纯正的计算。</p>
<p><strong>6.我要做一个最小机器人系统，需要考虑需求的变化点和稳定点。该怎么考虑呢？</strong></p>
<p>答：挺典型的问题。这个问法是一种典型的需求陈述误区。</p>
<p>描述需求需要有几个典型的要素：</p>
<ul>
<li>用户，面向什么人群；</li>
<li>他们有什么要解决的问题；</li>
<li>我解决这个问题的核心系统。</li>
</ul>
<p>只有满足这几个要素的需求才能进一步讨论变化点和稳定点。最小机器人可能符合上面的第三点，但是用户人群和要解决的问题没有描述，也就无法进一步去思考到底哪些因素是稳定的，哪些是易变的。</p>
<p><strong>7. 编程框架和编程范式具体有什么区别呢？感觉它们都具备约束、规范的作用。</strong></p>
<p>答：最主要的差别是：编程框架通常是领域性的，比如面向消息编程是多核背景下的网络服务器编程框架；编程范式则是普适性的，不管解决什么领域的问题都可以适用。</p>
<p><strong>8.老师提到了如果需要重修数据结构这门课程，大学里面学的数据结构是不顶用了。那应该学习什么呢，您可以给个建议吗？</strong></p>
<p>答：这方面的资料不太多。可以给你一个我当年翻过的资料： Purely Functional Data Structures</p>
<ul>
<li><a href="https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf" target="_blank" rel="noopener">https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf</a></li>
</ul>
<p>你可以参考看看。</p>
<p><strong>9.老师您好，我不太理解您说的继承是个过度设计的原因，我目前在架构过程中大量使用了继承，而且我也觉得继承功能将我的代码功能高度抽象化，给我带来了很大的方便。我想咨询下您如果不是用继承的话，用什么方法替代继承的功能呢？</strong></p>
<p>答：建议继承只使用接口继承；正常情况下，优先用组合；当然因为大部分语言的组合功能不够强大，有时候从便捷性的角度继承可以适度使用，但是应当意识到如果过度使用继承对工程来说是有害的。</p>
<p><strong>10.老师授课知识的角度很有深度，更贴切地说是一种思维方式，这种深度思考，从事情的本质重新推演与复盘的思考方式是很值得学习的。因为我们大部分人应该都没有想过自己去重新设计一个计算机的实现。不知道我这么理解的对不对。</strong></p>
<p>答：从无到有到万物，我们这个课的脉络之一就是重新从零构建整个信息世界，这一点在开篇词中提到过，这一点非常非常关键。另一个脉络是架构思维的递进，这一章重点是需求分析。这两个脉络相辅相成，交织在一起。</p>
<p><strong>11.许老师，您好，虽然自己是科班出身，但是对于下面这个问题困扰了我很久。</strong></p>
<ul>
<li><strong>一般来说程序的运行需要OS的支撑，那么在BIOS之前，选择运行哪个操作系统那一段程序是怎么运行的？再问一句，编译器可以独立于操作系统运行吗？</strong></li>
<li><strong>可以用C语言去实现很多其他的语言，比如说Python、Go等，那在C语言之前，这么一直追寻下去，会衍生成鸡生蛋的问题。但是编程语言又具有自举的功能，那自举是怎么实现的？比如目前版本的Go核心实现中，很多是用Go本身实现的，它是怎么做到自己编译自己的？</strong></li>
</ul>
<p>答：先回答你的第一个问题，程序运行不需要操作系统支持，有BIOS支持就可以（把控制权交给它）。编译器可以独立于操作系统存在，而且它应该先于操作系统产生。</p>
<p>接下来是第二个问题，语言诞生的过程是这样的：机器码 =&gt;汇编 =&gt;C =&gt;C写的汇编、C写的C（自举）。当然这个过程不需要每次新架构的CPU或操作系统都重新来一遍，因为人是聪明的，发明了交叉编译这样的东西，C =&gt;新平台的C，这样就一下子完成整个语言的进化了。</p>
<p><strong>12.许老师：选择某种语言无关的接口表示；能举个例吗？</strong></p>
<p>答：先看看是网络协议层的接口，还是跨语言的二进制接口。</p>
<p>前者比如protobuf之类就挺好，后者可以了解一下IDL之类的东西，不过我觉得都有点重。如果要跨语言，我的建议在网络协议层跨，或者用操作系统的动态库机制（有点原始但很轻）；如果语言内的接口，就别太复杂了，用语言自己的机制挺好的。</p>
<p><strong>13.请问每个应用的虚拟内存地址是怎么分配的？起始地址都是0吗？函数F可以跨多个虚拟内存页吗？</strong></p>
<p>答：操作系统会保留一个地址空间，0通常也在保留区间内，因为0开始往往是中断向量表的地址，其他的地址区间怎么分配其实应用自己说了算。函数和数据都可以跨内存页。</p>
<p><strong>14.老师您好，有两个问题希望解答。</strong></p>
<ul>
<li><strong>淘汰的内存页数据保存在哪里；是保存在外置存储设备中吗；</strong></li>
<li><strong>CPU加载对应程序的代码段到内存中，那么CPU是如何知道这个对应程序的代码段在什么位置的呢？</strong></li>
</ul>
<p>答：第一个问题：是的，保存在外置存储中。对于unix系的系统往往是swap分区；windows则是一个隐藏属性的.swp文件。</p>
<p>第二个问题：代码段在哪里，是操作系统约定的，因为负责加载的人是操作系统，它设计程序文件的数据格式。</p>
<p><strong>15.使用Java四年了，看到封装，继承，多态的描述，特别精准，又有了更深刻的理解。不了解Go语言，比如有一个表单的基类，里面有基本的处理，子类继承这个基类，有自己特殊的实现。这种情况，如何用组合实现呢？</strong></p>
<p>答：这是受继承思维的影响了。其实继承实现了代码复用和多态两个东西，揉在一起。在Go里面，组合实现代码复用，接口实现多态，彼此完全独立，非常清晰。</p>
<p><strong>16.请问一下CPU是如何检查是否有中断的。是怎么及时知道发生了中断？每执行完一条指令都去检查一次吗？</strong></p>
<p>答：挺好的问题。硬件中断和软中断不一样。硬件中断你可以理解为总是会定期检查。软中断本身是一条指令，所以不存在检查这样的概念。</p>
<p><strong>17.交叉编译是什么意思，不是很理解，老师能讲讲吗？</strong></p>
<p>答：其实理解清楚一个实质：编译器就是把高级语言翻译成为机器码，更抽象说，它其实就是格式转换器。</p>
<p>目标格式是不是编译器正在运行的环境并不重要，只不过如果目标格式刚好是当前机器的CPU+操作系统，那么目标格式就可以直接执行，否则就编译出一个当前环境下无法执行的目标格式，这种情况就叫交叉编译。</p>
<p><strong>18.关于外存管理，有个问题从之前就困扰我。</strong></p>
<p><strong>磁盘的IO是由CPU完成的吗？但之前见到的说法是“CPU只能操作内存”。既然今天又提到了这个问题，文中提到“大量的磁盘 IO 操作，非常占用 CPU 时间”，那这两种说法是否矛盾？</strong></p>
<p><strong>还想知道磁盘中的数据是怎么被加载到内存上来的呢？另外，更多的文章是说，“CPU的速度远远大于磁盘IO，CPU经常需要‘等待’磁盘IO”，这明显也是一种将CPU和外存割舍开的一种说法，而且按这种说法，CPU不光无需分配很多时间片给IO，而且还有很多“等待”时间。这也和本文中“非常占用CPU时间”相矛盾吧？</strong></p>
<p>答：所有外设CPU都统一基于数据交换（IO）的方式操作。CPU并不知道数据的含义，但是设备的使用方和设备知道。</p>
<p>这种情况下你可以简单理解CPU只是一根网线，但是很重要的一点是它让设备使用方和设备可以交互。CPU并不负责磁盘IO，但是它要等它结束以接收数据。这方面当然也有一些新技术出现改善这一点，可以想一想可能的优化路径，这里不表。</p>
<p><strong>19.有一个疑问：协程属于用户态的线程，它跟线程之间怎么对应呢？协程之间也需要切换，那线程切换的那些成本它一样有啊，没想明白它的优势在哪。</strong></p>
<p>答：从单位时间成本来说，有一定优势但也不会特别大。主要少掉的代价是从用户态到内核态再回到用户态的成本。</p>
<p>这种差异类似于系统调用和普通函数调用的差异。因为高性能服务器上io次数实在太多了，所以单位成本上能够少一点，积累起来也是很惊人的。</p>
<p><strong>20.这种对需求的前瞻性探索挺重要，但同时感觉也是最难的，应该如何培养呢</strong></p>
<p>答：很多时候是思维方式的转变。首先要尝试去做前瞻，预测错了并不可怕，但可以事后复盘到底是缺失了什么重要的信息让你判断出现了什么偏差。</p>
<p><strong>21.隐隐感觉到架构的主要难点在于对需求的前瞻性判断，这要求的不仅仅是技术能力。目前几乎所有的架构课程，都是基于确定的需求来讲技术架构，例如秒杀系统怎么做高可用高并发。不知道我这么理解对不对。</strong></p>
<p>答：架构在于创造，如果你从事的事情总是重复别人，那这个公司又有何价值？即使有所参考，也应该有自己的精气神，这个精气神是需要架构师把它干出来的。</p>
<h2 id="精选学习留言"><a href="#精选学习留言" class="headerlink" title="精选学习留言"></a>精选学习留言</h2><p>恭喜@有铭和@Enthusiasm 两位同学，你们的留言被选为精选留言，极客时间将送出价值99元的专栏阅码一份。1个工作日之内，工作人员会与你取得联系。</p>
<p><strong>@有铭 同学留言</strong></p>
<p>对象范式的原始概念其实根本不包括类和继承，只有1.程序由对象组成，2.对象之间互相发送消息，协作完成任务。</p>
<p>最初世界上第一个面向对象语言是 Simula-67，第二个面向对象语言是 Smalltalk-71。</p>
<p>Smalltalk 受到了 Simula-67 的启发，基本出发点相同,但是最大的不同是Smalltalk是通过发消息来实现对象方法调用，而Simula是直接调用目标对象的方法。</p>
<p>Bjarne Stroustrup 在博士期间深入研究过 Simula，非常欣赏其思想，C++的面向对象思路直接受其影响，因为调用目标对象的方法来“传递消息”需要事先知道这个对象有哪些方法，因此，定义对象本身有哪些方法的“类”和“继承”的概念，一下超越了对象本身，而对象只不过是类这个模子里造出来的东西，反而不重要。</p>
<p>随着C++的大行其道，继承和封装变成了面向对象世界的核心概念，OOP 至此被扭曲为 COP （ Class Oriented Programming，面向类程序设计）。</p>
<p>但是COP这套概念本身是有缺陷的：每个程序员似乎都要先成为领域专家，然后成为领域分类学专家，然后构造一个完整的继承树，然后才能 new 出对象，让程序跑起来。</p>
<p>到了 1990 年代中期，问题已经十分明显。UML 中有一个对象活动图，其描述的就是运行时对象之间相互传递消息的模型。1994 年 Robert C. Martin 在《 Object-Oriented C++ Design Using Booch Method 》中，曾建议面向对象设计从对象活动图入手，而不是从类图入手。</p>
<p>而 1995 年出版的经典作品《 Design Patterns 》中，建议优先考虑组合而不是继承，这也是尽人皆知的事情。</p>
<p>这些迹象表明，在那个时候，面向对象社区里的思想领袖们，已经意识到“面向类的设计”并不好用。只可惜他们的革命精神还不够，Delphi 之父在创建.Net Framework 的时候，曾经不想要继承，在微软内部引起了很大的争议，最后是向市场低头，加上了继承。</p>
<p>2000 年后，工程界明确提出：“组合比继承重要，而且更灵活”，Go和Rust也许是第一批明确的对这种思路进行回应的语言，它们的对象根本不需要类本身来参与，也能完成对象范式的多态组合。</p>
<p>历史让 C++走上了舞台，历史也终将让 COP 重新回到 OOP 的本来面目</p>
<p><strong>@Enthusiasm 同学学习笔记</strong></p>
<p>总结：设计系统架构的前提是用户需求分析，用户需求包括分析出稳定需求点和变化需求点。从功能上看，稳定需求点一般是实现偏核心需求的需求点，变化需求点往往是实现偏扩展性需求的需求点。</p>
<p>从层次结构上看，稳定需求点往往在系统层次的底层，而变化需求点往往在更加抽象层（上层）。从从属关系上看，稳定点需要提供功能给变化点使用，变化点调用稳定点提供的功能。从时间顺序看，稳定需求往往先现是变化点实现的基础，变化点通过调用已经实现的稳定点提供的功能来实现更为抽象的功能。</p>
<p>系统架构类似于一个栈的结构，人机交互（变化点）放在栈顶，底层工作（稳定点）置于栈底。</p>
<p>这节课程让我联想到网络中的OSI 7层模型。大概其也体现了这种软件架构思想。好处就是架构清晰，职责明确，功能规范等等。</p>
<p>以往我认为的架构设计类似上面的描述，描述起来类似按自顶向下顺序，采用分治思想完成。但许老师的方法又有些巧：架构好比搭积木，许老师是先有了很多积木（需求点），然后把再确定这些积木放在哪一层次的格子里。这简化了架构设计的难度，好比用市场经济代替计划经济，很有趣。</p>
<p>架构设计博大精深，灵活多变，初学课程的我们，对架构设计的学习，也只能算是盲人摸象。</p>
<hr>
<p>如果你在课程中有看不懂的地方，有想解答的架构问题，或者想分享的实战经验，都可以在文章下留言，如果你的留言被选中作为精选留言，我们将会为你送出价值99元的阅码一份。欢迎留言，与许式伟老师一起交流讨论，教学相长，共同精进。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:08:09.771Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    21 minutes read (About 3219 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/课外阅读 | 从《孙子兵法》看底层的自然法则/">课外阅读 | 从《孙子兵法》看底层的自然法则</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>近日在读《孙子兵法》，颇有感触。作为我国现存第一部，也是世界最早的军事著作。《孙子兵法》一直为众多政治家、军事家及企业管理者膜拜，被当作军事外交、企业管理的圣典。</p>
<p>时至今日，新经济、科技和社会结构下，很多人认为我们身处一种复杂社会，需要全新的军事、商业和公共策略。然而，不管远古农耕刀兵还是高科技信息社会竞争，时代、人文环境和科学技术的变迁，并不能改变人类社会生存竞争所依赖的基础系统环境和人性思维的规则。</p>
<p>英国空军元帅斯莱瑟曾说过：“孙武的思想有惊人之处——把一些词句稍加变换，他的箴言就像是昨天刚写出来的。”</p>
<p>《孙子兵法》讲的是战争，骨子里包含的却是人类社会生存竞争的底层规则。案例会变迁，背后的道理却很难过时。我们作为架构师，需要做到对世界的认知可宏观、可微观。从对宏观的理解来说，背后所依赖的正是我们对这些底层自然法则的体悟。</p>
<h2 id="明道"><a href="#明道" class="headerlink" title="明道"></a>明道</h2><p>《孙子兵法》讲的是规则。它通过战争，结合环境和人性探讨竞争中生存的规则；然后，在确定目标下，它又将战争行为分解成为一系列细分的规则。</p>
<p>《始计篇》开端，全书先讲总规则，就是“道”。“道者，令民与上同意也，故可以与之死，可以与之生，而不畏危。”如同国家有纲领，企业必须明确愿景，使命或是价值观一样。明心方能正道，明道方知力之所指。事实上，明白道之所求，术方能有指引，追随者才能有方向、有激情。对国家、企业而言“道”不仅是方向，还是战斗力和吸附力的来源，明道和传播非常重要。</p>
<p>“慎战”。“兵者，国之大事，生死之地，存亡之道，不可不察也。”战争和企业竞争涉及系统存亡关系重大，是管理者每日都要考虑的事情。“自古知兵非好战。”这种行为不是个人名利或得失，而是关系到万户千家，或者全体员工和家庭，必须慎之又慎，不可凭个人好恶，更不可好大喜功和拍脑袋。“上兵伐谋”、“不战而屈人之兵”。要牢记初心，保存敬畏和责任感，求胜同时要避免己方生命和资源的巨大消耗。“善战者，无智名，无勇功。”正如“善弈者通盘无妙手”，或是扁鹊治病于未发，“立于不败之地”非常之关键。</p>
<p>“避害第一”，先考虑失败的后果；“先胜后战”，不打无把握的战争。“因利而战”，考虑成本和结果；“一战而终”，准备要充分，动手要迅捷，毕其功于一役。</p>
<p>“兵无常势，水无常形。”环境、资源条件，心态、优劣势这些都可能随时变化，不能教条主义，须将策略灵活应用于变化的实际。满口教义，如赵括那般纸上谈兵，一棒子打死算了。“君将士卒皆有其道”。公司内也应各司其职，人人满口战略、创新和文化，“所有人都举着旗帜，他们用哪只手来战斗？”这样的公司很危险。</p>
<h2 id="庙算"><a href="#庙算" class="headerlink" title="庙算"></a>庙算</h2><p>“先胜后战”，就要“未战先算”。战与棋，一样考的算力，所谓政治经济环境人心都要纳入数据输入。</p>
<p>庙算，非治一战或局部。而是知己知彼综合所获数据，依据规则全面分析，很像是系统竞争成败的“大案牍数”。</p>
<p>庙算策略，不是单一事件的静态考量，而是复杂动态的综合考量。五事，道、天、地、将、法；七计，主、将、天地、法令、兵众、士卒、赏罚都要纳入进来。知己还要知彼。内外部环境，天时地形人才人心钱粮规章，所有影响战争胜负的东西，一切可以数据化，能算计的全都计算进去。</p>
<p>依据庙算可确定“势”，依据“势”决断是否有利并采取相应行动。拥有这样的洞察和决断力，知道了什么时候该打什么时候不该打，真正战争行为才会很简单。战争中要“致人而不致于人”。曾说“朕观诸兵书，无出孙武”的李世民，还有林彪都非常擅长集中优势兵力，通过忍耐和调动对手，“多方以误”，引敌人失误而获取最终胜利。</p>
<p>恰如“木桶理论”，庙算还可以消灭己方短板，寻找或者调动对方出现短板。当然，《孙子兵》并不是每战必胜，也不是以弱胜强，化不可能为可能的魔法书。不宜“知其不可而为之”。一系列庙算都在规则下，寻找到可能性，获得相对优势来战胜对手。如集中优势兵力，实现局部优势。“以迂为直，以患为利。”利用天时地形和行军，训练扎营做饭都有明确的目标。速战还是持久战，都是依据各种条件资源推演分析的结果。“故知战之地，知战之日，则可千里而会战。”唯有算胜，方可一战。</p>
<p>庙算为术，战术不能超脱于战略。“将在外君命有所不受”只是指根据实际情况可以灵活战术，正如当年毛主席要求林彪东北战役要服从大局，大战略不容颠覆。不能因一人之利，一地之利，一时之利而改变，只能随整个系统变化而调整。</p>
<h2 id="感知"><a href="#感知" class="headerlink" title="感知"></a>感知</h2><p>“不可胜在己”，立于不败之地，自己是关键，其他都是辅因；“可胜在敌”，看敌人的软肋和什么时候失误。“内省。知彼，但先要知己。”曾国藩作战，也首先讲明己第一，稳扎稳打立于不败之地，克敌才能实现。胜利也并非都是好事，很多时候当不是自己太强，而是对手太弱或其他因素，造就的胜利只会麻痹自己和埋下根本性失败的伏笔。</p>
<p>“知己知彼”就是自我和对手的感知。“天时地利人和”是对环境的感知。战争错综复杂风云变化，很多时候考较的都是随机应变的感知力和应对能力。“用兵者，合于利而动，不合于利而止。”对是否进行战争的条件的感知。还有对于细节的感知，“汲而先饮者，渴也。”需要通过经验学习感知获取信息，将规则载入情景化和有效利用。感知，可用于内部观察和防患未然，也可以用于判断对手并拟定对策。</p>
<p>“攻其无备，出其不意。”需要重视情报和传播。“兵者，诡道也。”情报和传播，等于数据的输入和输出，很多时候决定战争或组织的成败。依据情报奇兵制胜，如邓艾灭蜀；与对手虚假的情报，像蒋干盗书。更典型的是反间计。李牧、范曾罢黜，赵国、项羽败亡。</p>
<h2 id="法度"><a href="#法度" class="headerlink" title="法度"></a>法度</h2><p>“五事七计”都提到法令和奖惩。楚汉之争刘邦胜，“约法三章”以及陈平的有效奖惩体系都为功不小，胜在乎法令执行和奖惩公平。另一方面，用兵能“破釜沉舟”的项羽，然“印刓敝,忍不能予”是其失败的重要原因。</p>
<p>“五德，智信仁勇乎。”五德相须，缺一不可。但强调“智”，将人才放第一。而法度是规则，人才必须在法度内。</p>
<p>“主孰有道，将孰有能。”</p>
<p>“将之至任，不可不察也。”</p>
<p>“将听吾计，用之必胜，留之。将不听吾计，用之必败，去之。”</p>
<p>“令行素。”平时一样重视，战时才能发挥作用。</p>
<p>对于复杂系统，内部崩溃往往是其失败的主要原因。当然如前所述，这种内因也可由对手或外因推动演化。对于企业来说，领导者素质和人才队伍，中坚力量的支撑很重要，而成为中坚的标准就是一致的价值观和遵循规范。另外，还要建立适应自身、对手和战争形态的管理架构和组织体系，以及有效的规章和奖惩体系。</p>
<h2 id="辨证"><a href="#辨证" class="headerlink" title="辨证"></a>辨证</h2><p>“以正合，以奇胜。”《孙子兵法》可能是辨证思维最早期的著作和运用。</p>
<p>《孙子兵法》里，强弱虚实迂直恩仇甚至胜败都是辩证的，是可以对立转化的。</p>
<p>事实上，无论战争或是组织发展，都不是直线的，而是曲线的，或者周期的，充满了变化。胜负也是辩证和变化的，便是拥有《孙子兵法》，吴国后期数战数胜，开始骄傲自负，百姓疲敝，胜负环境逆转，终致败亡。“水因地而制流，兵因敌而制胜”。所有策略必须依据时机、环境、对手、人心变化而变化。</p>
<p>兵法不可能写尽所有情况，任何行为和结果也不是简单对应，而是因果交错。战争和系统竞争要处理的是复杂数据。《孙子兵法》注定“学者生，像者死”，必须根据特定时空、自己和对手的具体情况灵活化用。</p>
<p>《孙子兵法》重规则轻案例，舍事而言理，因而得以破越时空和领域，成为竞争、管理和生存的基础规则。</p>
<p>《大败局》一书中，吴晓波将中国大多数企业失败归结为缺乏道德感和人文关怀，缺乏对规则和秩序的尊重以及系统的职业精神的缺乏，这些因果在《孙子兵法》中都能够找得到对应；相对的，所有基业长青的公司，又都具备一系列适应变化，可以持续指导成长的一般性规则，这些规则在《孙子兵法》中也都能够找到对应。</p>
<p>作为一种超乎教材而更类似于宗教的力量，《孙子兵法》的价值在于其提供了实用性同时引导了对规则的思考。跨域2500年时空岁月，它的思想精髓仍如星辰闪耀。而且随着数据、时代演进、新元素的输入还会不断推动其演进和发展，即便再过100年，1000年，只要人类、系统和竞争存在，它就永不会过时。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:08:07.848Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    28 minutes read (About 4144 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/31 | 辅助界面元素的架构设计/">31 | 辅助界面元素的架构设计</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>我们第二章 “桌面软件开发” 今天开始进入尾声。前面我们主要围绕一个完整的桌面应用程序，从单机到 B/S 结构，我们的系统架构应该如何考虑。并且，我们通过五讲的 “画图” 程序实战，来验证我们的架构设计思路。</p>
<p>这个实战有点复杂。对于编码量不多的初学者，理解起来还是有点复杂性的。为了减轻理解的难度，我们从原计划的上下两讲，扩大到了五讲。尽管如此，理解上的难度仍然还是有的，后面我们做总结时，会给出一个不基于 MVC 架构的实现代码。</p>
<p>今天我们不谈桌面应用的架构，而是来谈谈辅助界面元素的架构设计。</p>
<p>辅助界面元素非常常见，它其实就是通用控件，或者我们自定义的控件。例如在我们画图程序中使用了线型选择控件（<a href="https://github.com/qiniu/qpaint/blob/v30/paintweb/www/accel/menu.js#L105" target="_blank" rel="noopener">menu.js#L105</a>），如下：</p>
<pre><code>&lt;select id=&quot;lineWidth&quot; onchange=&quot;onIntPropChanged(&apos;lineWidth&apos;)&quot;&gt;
  &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
  &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
  &lt;option value=&quot;5&quot;&gt;5&lt;/option&gt;
  &lt;option value=&quot;7&quot;&gt;7&lt;/option&gt;
  &lt;option value=&quot;9&quot;&gt;9&lt;/option&gt;
  &lt;option value=&quot;11&quot;&gt;11&lt;/option&gt;
&lt;/select&gt;</code></pre><p>还有颜色选择控件（<a href="https://github.com/qiniu/qpaint/blob/v30/paintweb/www/accel/menu.js#L115" target="_blank" rel="noopener">menu.js#L115</a>），如下：</p>
<pre><code>&lt;select id=&quot;lineColor&quot; onchange=&quot;onPropChanged(&apos;lineColor&apos;)&quot;&gt;
  &lt;option value=&quot;black&quot;&gt;black&lt;/option&gt;
  &lt;option value=&quot;red&quot;&gt;red&lt;/option&gt;
  &lt;option value=&quot;blue&quot;&gt;blue&lt;/option&gt;
  &lt;option value=&quot;green&quot;&gt;green&lt;/option&gt;
  &lt;option value=&quot;yellow&quot;&gt;yellow&lt;/option&gt;
  &lt;option value=&quot;gray&quot;&gt;gray&lt;/option&gt;
&lt;/select&gt;

&lt;select id=&quot;fillColor&quot; onchange=&quot;onPropChanged(&apos;fillColor&apos;)&quot;&gt;
  &lt;option value=&quot;white&quot;&gt;white&lt;/option&gt;
  &lt;option value=&quot;null&quot;&gt;transparent&lt;/option&gt;
  &lt;option value=&quot;black&quot;&gt;black&lt;/option&gt;
  &lt;option value=&quot;red&quot;&gt;red&lt;/option&gt;
  &lt;option value=&quot;blue&quot;&gt;blue&lt;/option&gt;
  &lt;option value=&quot;green&quot;&gt;green&lt;/option&gt;
  &lt;option value=&quot;yellow&quot;&gt;yellow&lt;/option&gt;
  &lt;option value=&quot;gray&quot;&gt;gray&lt;/option&gt;
&lt;/select&gt;</code></pre><p>我们统一用通用的 select 控件实现了一个线型选择器、两个颜色选择器的实例。虽然这种方式实现的颜色选择器不够美观，但是它们的确可以正常工作。</p>
<p>不过，产品经理很快就提出反对意见，说我们需要更加用户友好的界面。赶紧换一个更加可视化的颜色选择器吧？比如像下图这样的：</p>
<p><img src="https://static001.geekbang.org/resource/image/65/49/65ca44b08788bd03776bcd86ea3d0749.png" alt></p>
<h2 id="辅助界面元素的框架"><a href="#辅助界面元素的框架" class="headerlink" title="辅助界面元素的框架"></a>辅助界面元素的框架</h2><p>怎么做到？</p>
<p>我们不妨把上面基础版本的线型选择器、颜色选择器叫做 BaseLineWidthPicker、BaseColorPicker，我们总结它们在画图程序中的使用接口如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/4c/2c/4c660159e3d632130c25614f0b0eb02c.png" alt></p>
<p>我们解释一下这个表格中的各项内容。</p>
<p>id 是控件的 id，通过它可以获取到辅助界面元素的顶层结点。</p>
<p>value 是界面元素的值，其实也就是辅助界面元素的 Model 层的数据。从 MVC 架构角度来说，Model 层的数据一般是一棵 DOM 树。但是对很多辅助界面元素来说，它的 DOM 树比较简单，只是一个数值。比如线型选择器是一个 number，颜色选择器是一个 Color 值。</p>
<p>palette 是颜色选择器的调色板，用来指示颜色选择器可以选择哪些颜色。</p>
<p>blur() 方法是主动让一个界面元素失去焦点。</p>
<p>onchange 事件是在该界面元素的值（value）通过用户界面交互进行改变时发送的事件。需要注意的是，这个事件只在用户交互时发送。直接调用 element.value = xxx 这样的方式来修改界面元素的值是不会触发 onchange 事件的。</p>
<p>为了便于修改辅助界面元素，我们计划引入统一的辅助界面元素的框架。</p>
<p>这个框架长什么样？</p>
<p>首先，每个界面元素使用的时候，统一以 <code>&lt;div type=&quot;xxx&quot;&gt;</code>来表示。比如上面的一个线型选择器、两个颜色选择器的实例可以这样来表示：</p>
<pre><code>&lt;div type=&quot;BaseLineWidthPicker&quot; id=&quot;lineWidth&quot; onchange=&quot;onIntPropChanged(&apos;lineWidth&apos;)&quot;&gt;&lt;/div&gt;

&lt;div type=&quot;BaseColorPicker&quot; id=&quot;lineColor&quot; onchange=&quot;onPropChanged(&apos;lineColor&apos;)&quot; palette=&quot;black,red,blue,green,yellow,gray&quot;&gt;&lt;/div&gt;

&lt;div type=&quot;BaseColorPicker&quot; id=&quot;fillColor&quot; onchange=&quot;onPropChanged(&apos;fillColor&apos;)&quot; palette=&quot;white,null(transparent),black,red,blue,green,yellow,gray&quot;&gt;&lt;/div&gt;</code></pre><p>那么它是怎么被替换成前面的界面元素的？</p>
<p>我们引入一个全局的 qcontrols: QControls 实例，所有我们定义的控件都向它注册（register）自己。注册的代码如下：</p>
<pre><code>class QControls {
  constructor() {
    this.data = {}
  }
  register(type, control) {
    this.data[type] = control
  }
}</code></pre><p>可以看出，注册的逻辑基本上没做什么，只是建立了类型（type）和控件的构建函数（control）的关联。有了这个关联表，我们就可以在适当的时候，把所有的 <code>&lt;div type=&quot;xxx&quot;&gt;</code>的div 替换为实际的控件。替换过程如下：</p>
<pre><code>class QControls {
  init() {
    let divs = document.getElementsByTagName(&quot;div&quot;)
    let n = divs.length
    for (let i = n-1; i &gt;= 0; i--) {
      let div = divs[i]
      let type = div.getAttribute(&quot;type&quot;)
      if (type != null) {
        let control = this.data[type]
        if (control) {
          control(div)
        }
      }
    }
  }
}</code></pre><p>这段代码逻辑很简单，遍历文档中所有的 div，如果带 type 属性，就去查这个 type 有没有注册过，注册过就用注册时指定的构建函数去构建控件实例。</p>
<p>完整的辅助界面元素框架代码如下：</p>
<ul>
<li><a href="https://github.com/qiniu/qpaint/blob/v31/paintweb/www/controls/base.js" target="_blank" rel="noopener">controls/base.js</a></li>
</ul>
<p>具体构建控件的代码是怎么样的？源代码请参考这两个文件：</p>
<ul>
<li><a href="https://github.com/qiniu/qpaint/blob/v31/paintweb/www/controls/BaseLineWidthPicker.js" target="_blank" rel="noopener">controls/BaseLineWidthPicker.js</a></li>
<li><a href="https://github.com/qiniu/qpaint/blob/v31/paintweb/www/controls/BaseColorPicker.js" target="_blank" rel="noopener">controls/BaseColorPicker.js</a></li>
</ul>
<p>我们拿 BaseColorPicker 作为例子看下吧：</p>
<pre><code>function BaseColorPicker(div) {
  let id = div.id
  let onchange = div.onchange
  let palette = div.getAttribute(&quot;palette&quot;)
  let colors = palette.split(&quot;,&quot;)
  let options = []
  for (let i in colors) {
    let color = colors[i]
    let n = color.length
    if (color.charAt(n-1) == &quot;)&quot;) {
      let offset = color.indexOf(&quot;(&quot;)
      options.push(`&lt;option value=&quot;` + color.substring(0, offset) + `&quot;&gt;` + color.substring(offset+1, n-1) + `&lt;/option&gt;`)
    } else {
      options.push(`&lt;option value=&quot;` + color + `&quot;&gt;` + color + `&lt;/option&gt;`)
    }
  }
  div.outerHTML = `&lt;select id=&quot;` + id + `&quot;&gt;` + options.join(&quot;&quot;) + `&lt;/select&gt;`
  let elem = document.getElementById(id)
  if (onchange) {
    elem.onchange = onchange
  }
}

qcontrols.register(&quot;BaseColorPicker&quot;, BaseColorPicker)</code></pre><p>可以看到，构建函数的代码大体分为如下三步。</p>
<p>第一步，从占位的 div 元素中读入所有的输入参数。这里是 id, onchange, palette。</p>
<p>第二步，把占位的 div 元素替换为实际的界面。也就是 div.outerHTML = <code>xxx</code> 这段代码。</p>
<p>第三步，如果用户对 onchange 事件感兴趣，把 onchange 响应函数安装到实际界面的 onchange 事件中。</p>
<h2 id="jQuery-颜色选择器"><a href="#jQuery-颜色选择器" class="headerlink" title="jQuery 颜色选择器"></a>jQuery 颜色选择器</h2><p>接下来我们就开始考虑替换颜色选择器的实现了。新版本的颜色选择器，我们不妨命名为 ColorPicker。这个新版本的使用姿势必须和 BaseColorPicker 一样，也就是：</p>
<p><img src="https://static001.geekbang.org/resource/image/fc/f8/fc3856e8ab9aaf35c7af1611e57a47f8.png" alt></p>
<p>从使用的角度来说，我们只需要把之前的 BaseColorPicker 换成 ColorPicker。如下：</p>
<pre><code>&lt;div type=&quot;BaseLineWidthPicker&quot; id=&quot;lineWidth&quot; onchange=&quot;onIntPropChanged(&apos;lineWidth&apos;)&quot;&gt;&lt;/div&gt;

&lt;div type=&quot;ColorPicker&quot; id=&quot;lineColor&quot; onchange=&quot;onPropChanged(&apos;lineColor&apos;)&quot; palette=&quot;black,red,blue,green,yellow,gray&quot;&gt;&lt;/div&gt;

&lt;div type=&quot;ColorPicker&quot; id=&quot;fillColor&quot; onchange=&quot;onPropChanged(&apos;fillColor&apos;)&quot; palette=&quot;white,null(transparent),black,red,blue,green,yellow,gray&quot;&gt;&lt;/div&gt;</code></pre><p>那么实现方面呢？</p>
<p>我们决定基于 jQuery 社区的 <a href="https://github.com/bgrins/spectrum" target="_blank" rel="noopener">spectrum</a> 颜色选择器。</p>
<p>我们的画图程序的主体并没有引用任何现成的框架代码。jQuery 是第一个被引入的。</p>
<p>对待 jQuery，我们可以有两种态度。一种是认为 jQuery 设计非常优良，我们很喜欢，决定将其作为团队的编程用的基础框架。</p>
<p>在这种态度下，我们允许 jQuery 风格的代码蔓延得到处都是，典型表现就是满屏皆是 $ 符号。</p>
<p>当然这种选择的风险是不低的。有一天我们不想再基于 jQuery 开发了，这意味着大量的模块需要进行调整，尤其是那些活跃的项目。</p>
<p>另一种态度是，认为 jQuery 并不是我们的主体框架，只是因为我们有些模块用了社区的成果，比如 <a href="https://github.com/bgrins/spectrum" target="_blank" rel="noopener">spectrum</a> 颜色选择器，它是基于 jQuery 实现的。这意味着我们要用 <a href="https://github.com/bgrins/spectrum" target="_blank" rel="noopener">spectrum</a>，就需要引入 jQuery。</p>
<p>这种团队下，我们会尽可能限制 jQuery 的使用范围，尽量不要让它的代码蔓延，而只是限制在颜色选择器等少量场景中。</p>
<p>我们这一讲假设我们的态度是后者。我们有自己的基础开发框架（虽然我们其实基本上接近裸写 JavaScript 的状态），所以不会大面积使用 jQuery。</p>
<p>这样我们需要包装 jQuery 组件。代码如下（参阅 <a href="https://github.com/qiniu/qpaint/blob/v31/paintweb/www/controls/ColorPicker.js" target="_blank" rel="noopener">controls/ColorPicker.js</a>）：</p>
<pre><code>function ColorPicker(div) {
  let id = div.id
  let onchange = div.onchange
  let palette = div.getAttribute(&quot;palette&quot;)
  let colors = palette.split(&quot;,&quot;)
  let value = colors[0]
  div.outerHTML = `&lt;input type=&quot;button&quot; id=&quot;` + id + `&quot; value=&quot;` + value + `&quot;&gt;`
  let elem = $(&quot;#&quot; + id)
  elem.spectrum({
    showInitial: true,
    showInput: true,
    showButtons: true,
    preferredFormat: &quot;hex6&quot;
  })
  if (onchange) {
    elem.change(onchange)
  }
  Object.defineProperty(document.getElementById(id), &quot;value&quot;, {
    get() {
      return value
    },
    set(x) {
      if (this.busy) {
        return
      }
      value = x
      this.busy = true
      elem.spectrum(&quot;set&quot;, value)
      this.busy = false
    }
  })
}

qcontrols.register(&quot;ColorPicker&quot;, ColorPicker)</code></pre><p>这里大部分代码比较常规，只有 Object.defineProperty 这一段看起来比较古怪一些。这段代码是在改写 document.getElementById(id) 这个界面元素的 value 属性的读写（get/set）函数。</p>
<p>为什么需要改写？</p>
<p>因为我们希望感知到使用者对 value 的改写。正常我们可能认为接管 onchange 就可以了，但是实际上 element.value = xxx 这样的属性改写是不会触发 onchange 事件的。所以我们只能从改写 value 属性的 set 函数来做。</p>
<p>set 函数收到 value 被改写后，会调用 elem.spectrum(“set”, value) 来改变 spectrum 颜色控件的当前值。</p>
<p>但这里又有个细节问题：elem.spectrum(“set”, value) 内部又会调用 element.value = value 来修改 document.getElementById(id) 这个界面元素的 value 属性，这样就出现了死循环。怎么办？我们通过引入一个 busy 标志来解决：如果当前已经处于 value 属性的 set 函数，就直接返回。</p>
<h2 id="辅助界面元素的架构设计"><a href="#辅助界面元素的架构设计" class="headerlink" title="辅助界面元素的架构设计"></a>辅助界面元素的架构设计</h2><p>到目前为止，我们实现了三个符合我们定义的控件规范的辅助界面元素。如下：</p>
<ul>
<li><a href="https://github.com/qiniu/qpaint/blob/v31/paintweb/www/controls/BaseLineWidthPicker.js" target="_blank" rel="noopener">controls/BaseLineWidthPicker.js</a></li>
<li><a href="https://github.com/qiniu/qpaint/blob/v31/paintweb/www/controls/BaseColorPicker.js" target="_blank" rel="noopener">controls/BaseColorPicker.js</a></li>
<li><a href="https://github.com/qiniu/qpaint/blob/v31/paintweb/www/controls/ColorPicker.js" target="_blank" rel="noopener">controls/ColorPicker.js</a></li>
</ul>
<p>观察这些辅助界面元素的代码，你会发现它们都没有基于 MVC 架构。</p>
<p>是因为辅助界面元素不适合用 MVC 架构来编写么？</p>
<p>当然不是。</p>
<p>更本质的原因是因为它们规模太小了。这些界面元素的特点是 DOM 都是一个 value，并不是一棵树，这样 Model 层就没什么代码了。同样的逻辑，View 层、Control 层代码量都过于短小，就没必要有那么清楚的模块划分。View 负责界面呈现，Control 负责事件响应，只是在心里有谱就好了。</p>
<p>但并不是所有辅助界面元素都这么简单。</p>
<p>举一个简单的例子。让我们给自己设定一个新目标：把我们前面实战的 “画图” 程序，改造成一个标准的辅助界面元素，这可行么？</p>
<p>答案当然是肯定的。</p>
<p>但是这意味着我们有一些假设需要修正。这些假设通常都和唯一性有关。</p>
<p>比如，全局有唯一的 View 对象实例 qview: QPaintView。如果我们是辅助界面元素，意味着我们可能在同一个界面出现多个实例。在多实例的情况下，View 对象显然就应该有多个。</p>
<p>再比如，我们画图程序的辅助界面元素（参见 <a href="https://github.com/qiniu/qpaint/blob/v31/paintweb/www/accel/menu.js" target="_blank" rel="noopener">accel/menu.js</a>）都是单例，具体表现为这些界面元素的 id 都是固定的。</p>
<p>当然，辅助界面元素的改造方案有多种可能性。一种方案是将辅助界面元素也改造为多例，使得每个 QPaint 实例都有自己的辅助界面元素。</p>
<p>另一种方案是继续保持单例，这意味着多个 QPaint 实例会有一个当前实例的概念。辅助界面元素根据场景，可以是操作全部实例，也可以是操作当前实例。</p>
<p>我们选择继续保持单例。这意味着 qview: QPaintView 这个全局变量可以继续存在，但是和之前的含义有了很大不同。之前 qview 代表的是单例，现在 qview 代表的是当前实例。</p>
<p>有了当前实例当然就有切换。这样就需要增加焦点相关的事件响应。</p>
<p>在画图程序中，很多 Controller 都是 View 实例相关的。比如：PathCreator、ShapeSelector 等。在 View 存在多例的情况下，这些 Controller 之前的 registerController 动作就需要重新考虑。</p>
<p>为了支持多例，我们引入了 onViewAdded、onCurrentViewChanged 事件。当一个新的 View 实例被创建时，会发送 onViewAdded 事件。Controller 可以响应该事件去完成 registerController 动作。如下：</p>
<pre><code>onViewAdded(function(view) {
  view.registerController(&quot;PathCreator&quot;, function() {
    return new QPathCreator(view, false)
  })
})</code></pre><p>原先，当前图形样式是放在 View 中的，通过 qview.style 可以访问到。这会导致多个 View 实例的当前图形样式不一样，但是我们辅助界面元素又是单例的，这就非常让人混淆。最后我们决定把 qview.style 挪到全局，改名叫 defaultStyle（参阅 <a href="https://github.com/qiniu/qpaint/blob/v31/paintweb/www/accel/menu.js#L42" target="_blank" rel="noopener">accel/menu.js#L42</a>）。</p>
<p>做完这些改造，我们的画图程序就有了成为一个标准控件的基础。具体代码如下（参阅 <a href="https://github.com/qiniu/qpaint/blob/v31/paintweb/www/PaintView.js" target="_blank" rel="noopener">PaintView.js</a>）：</p>
<pre><code>function newPaintView(drawingID) {
  let view = new QPaintView(drawingID)
  fireViewAdded(view)
  return view
}

function initPaintView(drawingID) {
  let view = newPaintView(drawingID)
  setCurrentView(view)
}

function PaintView(div) {
  let id = div.id
  let width = div.getAttribute(&quot;width&quot;)
  let height = div.getAttribute(&quot;height&quot;)
  div.outerHTML = `&lt;canvas id=&quot;` + id + `&quot; width=&quot;` + width + `&quot; height=&quot;` + height + `&quot;&gt;你的浏览器不支持Canvas！&lt;/canvas&gt;`
  initPaintView(id)
}

qcontrols.register(&quot;PaintView&quot;, PaintView)</code></pre><p>有了这个 PaintView 控件，我们就可以到处引用它了。我们做了一个 PaintView 控件的 DEMO 程序，它效果看起来是这样的（代码参阅 <a href="https://github.com/qiniu/qpaint/blob/v31/paintweb/www/PaintDemo.htm" target="_blank" rel="noopener">PaintDemo.htm</a>）：</p>
<p><img src="https://static001.geekbang.org/resource/image/29/52/295e17f40fa63b929a4a5175da39ae52.png" alt></p>
<p>从这个截图看，细心的你可能会留意到，还有一个问题是没有被修改的，那就是 URL 地址。我们的 QPaintView 在 load 文档后会修改 URL，这作为应用程序并没有问题。但是如果是一个控件，整个界面有好多个 PaintView，URL 中应该显示哪个文档的 ID？</p>
<p>显然谁都不合适。如果非要显示，可能要在 PaintView 实例附近放一个辅助界面元素来显示它。</p>
<p>怎么修改？</p>
<p>这个问题暂且留给大家。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天探讨了辅助界面元素，或者叫控件的架构设计。从大的实现逻辑来说，它和应用程序不应该有本质的不同。但控件总是要考虑支持多实例，这会带来一些细节上的差异。</p>
<p>支持多实例听起来是一项简单的工作，但是从我的观察看，对很多工程师来说实际上并不简单。不少初级工程师写代码往往容易全局变量满天飞，模块之间相互传递信息不假思索地基于全局变量来完成。这些不良习惯会导致代码极难控件化。</p>
<p>当然我们不见得什么桌面应用程序都要考虑把它控件化。但是我们花一些精力去思考控件化的话，会有助于你对架构设计中的一些决策提供帮助。</p>
<p>当然更重要的，其实是让你有机会形成更好的架构设计规范。</p>
<p>这一讲我们作出的修改如下：</p>
<ul>
<li><a href="https://github.com/qiniu/qpaint/compare/v30...v31" target="_blank" rel="noopener">https://github.com/qiniu/qpaint/compare/v30…v31</a></li>
</ul>
<p>这是最新版本的源代码：</p>
<ul>
<li><a href="https://github.com/qiniu/qpaint/tree/v31" target="_blank" rel="noopener">https://github.com/qiniu/qpaint/tree/v31</a></li>
</ul>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们会谈谈架构设计的第二步：如何做好系统架构。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-31T10:08:05.859Z">2019-08-31</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    38 minutes read (About 5748 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/31/许世伟的架构课/30  | 实战（五）：怎么设计一个“画图”程序？/">30  | 实战（五）：怎么设计一个“画图”程序？</a>
            
        </h1>
        <div class="content">
            <p>你好，我是七牛云许式伟。</p>
<p>我们继续聊我们的话题。这是画图程序的最后一讲了。当然我们后续还会结合这个实战程序展开讨论有关于架构的方方面面。</p>
<h2 id="宏观的系统架构"><a href="#宏观的系统架构" class="headerlink" title="宏观的系统架构"></a>宏观的系统架构</h2><p>上一讲开始，我们的画图程序有了跨团队协作：因为我们开始有了 paintdom 和 paintweb 两大软件。paintdom 监听的地址是 localhost:9999，而 paintweb 监听的地址是 localhost:8888。</p>
<p>应当注意，在实际业务中它们是不同的软件，事实上我们 paintweb 程序也完全是以进程间协作的方式，通过反向代理机制来调用 paintdom 的功能。但是在我们这个画图 DEMO 程序中，它们同属一个进程，paintdom 作为 paintweb 的一个 goroutine 在跑。这纯粹是因为我们想让这两个程序 “同生共死”，方便调试的时候起停进程。</p>
<p>paintdom 和 paintweb 之间相互协作的基础，是它们之间所采用的网络协议。</p>
<p>当我们说起网络协议，它其实通常包含两个层面的意思：其一是我们网络协议的载体，也就是协议栈（我们这里采纳的是 HTTP 协议，而 HTTP 协议又基于 TCP/IP 协议）；其二是我们网络协议承载的业务逻辑。</p>
<p>当我们谈架构的时候，也会同时聊这两个层面，只是它们在不同的维度。我们会关心网络协议的协议栈选择什么，是基于 HTTP 还是基于自定义的二进制协议，这个是属于基础架构的维度。我们也会关心网络协议的业务逻辑，判断它是否自然体现业务需求，这是属于应用架构的维度。</p>
<p>明确了网络协议后，我们实现了 Mock 版本的服务端程序 paintdom。在实际项目中，Mock 程序往往会大幅提速团队的开发效率。这是因为它能够达到如下两个大的核心目标：</p>
<ul>
<li>让团队的研发迭代并行，彼此可以独立演进。</li>
<li>及早验证网络协议的合理性，在实战中达到用最短时间稳定协议的目的。</li>
</ul>
<p>上一讲我们的 paintdom 和 paintweb 之间虽然定义了网络协议，并且实现了第一版，但是并没有去做两者的对接。</p>
<p>今天我们就来对接它们。</p>
<p>虽然 paintweb 没有对接服务端，但从文档编辑的角度来说，它的功能是非常完整的。我们对接 paintdom 和 paintweb 的目的不是加编辑功能，而是让文档可以存储到服务端，以便于人们在世界任何可以联网的角落都可以打开它。</p>
<p>当然严谨来说，说 paintweb 没有服务端是不正确的，paintweb 本身是一个 B/S 结构，它有它自己的服务端。如下：</p>
<pre><code>var wwwServer = http.FileServer(http.Dir(&quot;www&quot;))

func handleDefault(w http.ResponseWriter, req *http.Request) {
  if req.URL.Path == &quot;/&quot; {
    http.ServeFile(w, req, &quot;www/index.htm&quot;)
    return
  }
  req.URL.RawQuery = &quot;&quot; // skip &quot;?params&quot;
  wwwServer.ServeHTTP(w, req)
}

func main() {
  http.HandleFunc(&quot;/&quot;, handleDefault)
  http.ListenAndServe(&quot;:8888&quot;, nil)
}</code></pre><p>可以看出，paintweb 自己的服务端基本上没干什么事情，就是一个非常普通的静态文件下载服务器，提供给浏览器端下载 HTML + CSS + JavaScript 等内容。</p>
<p>所以 paintweb 的服务端完全是“平庸”的，与业务无关。具体的业务，都是通过 www 目录里面的文件来做到的。这些文件都是前端的浏览器端所依赖的，只不过被 “托管” 到 paintweb 服务端而已。</p>
<p>那么 paintweb 怎么对接 paintdom 呢？</p>
<p>物理上的对接比较简单，只是个反向代理服务器而已，代码如下：</p>
<pre><code>func newReverseProxy(baseURL string) *httputil.ReverseProxy {
  rpURL, _ := url.Parse(baseURL)
  return httputil.NewSingleHostReverseProxy(rpURL)
}

var apiReverseProxy = newReverseProxy(&quot;http://localhost:9999&quot;)

func main() {
  http.Handle(&quot;/api/&quot;, http.StripPrefix(&quot;/api/&quot;, apiReverseProxy))
}</code></pre><p>可以看出，paintweb 的服务端干的事情仍然是 “平庸” 的，只是把发往 <a href="http://localhost:8888/api/xxx" target="_blank" rel="noopener">http://localhost:8888/api/xxx</a> 的请求，原封不动地发往 <a href="http://localhost:9999/xxx" target="_blank" rel="noopener">http://localhost:9999/xxx</a> 而已。</p>
<p>在现实中，paintweb 的服务端干的事情稍微复杂一些。它背后不只是有业务服务器 paintdom，还有必不可少的帐号服务器（Account Service），用来支持用户登录/登出。</p>
<p>帐号服务器是一个基础架构类的服务，与业务无关。公司很可能不只有 QPaint 这样一个业务，还会有别的，但这些业务可以共享相同的帐号服务。更准确地说，是必须共享相同的帐号服务，否则一个公司弄出好多套独立的帐号体系来，用户也会有所诟病。</p>
<p>在需要对接帐号服务器的情况下，实际上 paintweb 的服务端并不是原封不动地转发业务请求，而是会对协议进行转义。</p>
<p>在 “<a href="https://time.geekbang.org/column/article/107128" target="_blank" rel="noopener">24 | 跨平台与 Web 开发的建议</a>”这一讲中我们提到过：</p>
<blockquote>
<p>到了 Web 开发，我们同样需要二次开发接口，只不过这个二次开发接口不再是在 Client 端完成的，而是在 Server 端完成。Server 端支持直接的 API 调用，以支持自动化（Automation）方面的需求。</p>
<p>所以，对 Server 端来说，最底层的是一个多租户的 Model 层（Multi-User Model），它实现了自动化（Automation）所需的 API。</p>
<p>在 Multi-User Model 层之上，有一个 Web 层。Web 层和 Model 层的假设不同，Web 层是基于会话的（Session-based），因为它负责用户的接入，每个用户登录后，会形成一个个会话（Session）。</p>
<p>如果我们对Web 层细究的话，又分为 Model 层和 ViewModel 层。为了区分，Web 这边的 Model 层我们叫它 Session-based Model。相应地，ViewModel 层我们叫它 Session-based ViewModel。</p>
<p> 在服务端，Session-based Model 和 Session-based ViewModel 并不发生直接关联，它们通过自己网络遥控浏览器这一侧的 Model 和 ViewModel，从而响应用户的交互。</p>
<p>Session-based Model 是什么样的呢？它其实是 Multi-User Model 层的转译。把多租户的 API 转译成单租户的场景。所以这一层并不需要太多的代码，甚至理论上自动实现也是有可能的。</p>
<p>Session-based ViewModel 是一些 HTML+JavaScript+CSS 文件。它是真正的 Web 业务入口。它通过互联网把自己的数据返回给浏览器，浏览器基于 ViewModel 渲染出View，这样整个系统就运转起来了。</p>
</blockquote>
<p>这段话说的比较抽象，但结合 QPaint 这个实际的例子，就非常明朗了：</p>
<ul>
<li>paintdom 就是这里说的 Multi-User Model 层，负责多租户的业务服务器。</li>
<li>paintweb 服务端实现 Session-based Model 层，负责 Session-based 到 Multi-User 的转译。由于我们当前这个例子还不支持多租户，转译就变成了简单的转发。后面我们在 “服务端开发” 一节中会给大家看实际的转译层是怎么做的。</li>
</ul>
<p>所以你可以看到，其实 paintweb 自身的服务端是业务无关的。它做这样一些事情：</p>
<ul>
<li>Web 前端文件的托管（作为静态文件下载服务器）；</li>
<li>支持帐号服务，实现 Web 的用户登录；</li>
<li>做业务协议的转译，将 Session-based 的 API 请求转为 Multi-User 的 API 请求。</li>
</ul>
<p>当然，我们这里假设 Web 自身的业务逻辑都是通过 JavaScript 来实现的。这意味着我们是基于 “胖前端” 模式的。</p>
<p>但这并不一定符合事实，有些公司会基于 “胖后端” 模式。这意味着大部分的前端用户行为，都是由后端支持的，比如我们用 PHP 来实现 Web 后端的业务代码。</p>
<p>胖后端模式的好处是 Web 代码比较安全。这里的 “安全” 是指 IT 资产保全方面的安全，不是指业务存在安全问题，因为别人看不到完整的 Web 业务逻辑代码。</p>
<p>但是胖后端模式的缺点是没办法支持离线。大部分的用户交互都需要 Web 后端来响应，一旦断了网就什么都干不了了。</p>
<p>在 “胖后端” 模式下，我个人会倾向于基于类似 PHP 这种胶水语言来实现 Web 后端的业务代码。而一旦我们这么做，paintweb 的业务逻辑就被剥离了，paintweb 自身的后端仍然是业务无关的，只是多了一个职责：支持 PHP 脚本语言。</p>
<p>真正 Web 后端业务逻辑，还是放在了 www 目录中，以 PHP 文件存在，这些文件就不是简单的静态资源，而是 “胖后端” 的业务代码。</p>
<p>既然 paintweb 后端是 “平庸” 的，与业务无关，那么整个业务逻辑的串联，靠的就是 www 里面的 js 文件，和 paintdom 提供的 API 接口。</p>
<p>上面我们说过，在连接 paintdom 之前，paintweb 程序独立看是完整的，它支持离线创建、编辑以及存储文档到浏览器本地的 localStorage 上。</p>
<p>对接 paintdom 与 paintweb 后我们并不会放弃离线编辑的能力，而是要能够做到：</p>
<ul>
<li>在断网情况下，表现为上一讲我们达到的效果，可以继续离线编辑和保存；</li>
<li>一旦联网，所有离线编辑的内容可以自动保存到 paintdom 服务器。</li>
</ul>
<h2 id="计算变更"><a href="#计算变更" class="headerlink" title="计算变更"></a>计算变更</h2><p>听起来挺简单一件事情？</p>
<p>其实很复杂。第一件要做的事情是：怎么知道断网后离线编辑过的内容有哪些？</p>
<p>思路一是不管三七二十一，每次都完整保存整篇文档。这很浪费，因为不单单刚恢复联网的时候我们需要保存文档，平常每一次编辑操作我们也都会自动保存修改的内容。</p>
<p>思路二是记录完整的编辑操作历史，每做一个编辑操作都将其记录到 localStorage。这个思路看似会更节约，但是实际上在很多情况下会更浪费。原因在于：</p>
<ul>
<li>一个对象编辑多次，会有很多条编辑操作的指令要保存；</li>
<li>断网久了，编辑操作累计下来，其存储空间甚至可能超过文档大小。</li>
</ul>
<p>所以这种方案缺乏很好的鲁棒性，在 badcase 情况下让人难以接受。</p>
<p>思路三是给对象增加版本号。通过对比整个文档的基版本（baseVer，即上一次同步完成时的版本），与某个对象的版本 ver。如果 ver &gt; baseVer，说明上一次同步完成后，该对象发生了变更。完整的变更信息的计算逻辑如下：</p>
<pre><code>prepareSync(baseVer) {
  let shapeIDs = []
  let changes = []
  let shapes = this._shapes
  for (let i in shapes) {
    let shape = shapes[i]
    if (shape.ver &gt; baseVer) {
      changes.push(shape)
    }
    shapeIDs.push(shape.id)
  }
  let result = {
    shapes: shapeIDs,
    changes: changes,
    ver: this.ver
  }
  this.ver++
  return result
}</code></pre><h2 id="同步变更"><a href="#同步变更" class="headerlink" title="同步变更"></a>同步变更</h2><p>有了变更的信息，怎么同步给服务端？</p>
<p>一个可能的思路是把变更还原为一条条编辑操作发给服务端。但是，这样做问题会很复杂，因为这些编辑操作一部分发送成功，一部分发送失败怎么办？</p>
<p>这种部分成功的中间态是最挑战我们程序员的编程水平的，很烧脑。</p>
<p>我个人一贯坚持的架构准则是不要烧脑。尤其对大部分非性能敏感的业务代码，简单易于实施为第一原则。</p>
<p>所以我们选择了修改网络协议。增加了同步接口：</p>
<p><img src="https://static001.geekbang.org/resource/image/15/13/15b65c55fae904ca16ec6192ed81b613.png" alt></p>
<p>这很有趣。在我们讨论相互配合的接口时，我们非常尊重业务逻辑，按照我们对业务的理解，定义了一系列的编辑操作。但是，到最后我们却发现，它们统统不管用，我们要的是一个同步协议。</p>
<p>是最初我们错了吗？</p>
<p>也不能这么说。最初我们定义协议的逻辑并没有错，只是没有考虑到支持离线编辑这样的需求而已。</p>
<p>复盘这件事情，我们可以这么说：</p>
<ul>
<li>需求的预见性非常重要。如果我们没有充分预见到需求，大部分情况下就会因为我们缺乏市场洞察而买单；</li>
<li>进一步说明，及早推出 Mock，让前端可以快速迭代，进而及早去发现原先定义网络协议的不足是很有必要的。越晚做出协议调整，事情就越难，也越低效。</li>
</ul>
<p>有了同步协议，我们就可以把变更信息同步给服务端了。这个事情我们交给了 QSynchronizer 类来完成（详细请看 <a href="https://github.com/qiniu/qpaint/blob/v30/paintweb/www/dom.js#L204" target="_blank" rel="noopener">dom.js#L204</a>）。</p>
<h2 id="加载文档"><a href="#加载文档" class="headerlink" title="加载文档"></a>加载文档</h2><p>把变更详细推送给服务端后，理论上我们就可以在世界各地看到这篇文档。</p>
<p>怎么做到？</p>
<p>我们接下来就谈谈怎么来加载文档。这个过程的难点在于怎么根据服务端返回的 json 数据重建整个文档。</p>
<p>上一讲我们已经说过，我们图形（Shape）的网络协议中的数据格式，和 localStorage 中是不同的。这意味着我们需要做两套图形数据的加载工作。</p>
<p>这挺没有必要。</p>
<p>而且，从预测变更的角度，我们很容易预期的一个变化，就是画图程序支持的图形（Shape）的种类会越来越多。</p>
<p>这两个事情我们一起看。为此我们做了一次重构。重构目标是：</p>
<ul>
<li>统一 localStorage 和网络协议中的图形表示；</li>
<li>增加新的图形种类要很容易，代码非常内聚，不必到处修改代码。</li>
</ul>
<p>为此我们增加 qshapes: QSerializer 全局变量，允许各种图形类型注册自己的创建方法（creator）进去。示意代码如下：</p>
<pre><code>qshapes.register(&quot;rect&quot;, function(json) {
  return new QRect(json)
})</code></pre><p>为了支持 QSerializer 类（代码参见 <a href="https://github.com/qiniu/qpaint/blob/v30/paintweb/www/dom.js#L89" target="_blank" rel="noopener">dom.js#L89</a>），每个图形需要增加两个方法：</p>
<pre><code>interface Shape {
  constructor(json: Object)
  toJSON(): Object
}</code></pre><p>这样我们就可以调用 qshapes.create(json) 来创建一个图形实例。</p>
<p>有了这个能力，我们加载文档就水到渠成了，具体代码请参考 QPaintDoc 类的 _loadRemote(displayID) 方法（参见 <a href="https://github.com/qiniu/qpaint/blob/v30/paintweb/www/dom.js#L690" target="_blank" rel="noopener">dom.js#L690</a>）。</p>
<p>完整来说，加载文档的场景分为这样三类：</p>
<ul>
<li>_loadBlank，即加载新文档。在联网情况下，会在服务端创建一个新 drawing。在非联网情况下，会本地创建一个临时文档（displayID 以 t 开头）。</li>
<li>_loadTempDoc，即加载一个临时文档。即该文档从创建之初到目前，一直都处于离线编辑的状态。同样它也分两个情况，如果当前处于联网状态下，会在服务端创建一个新 drawing，并把当前的离线编辑的数据同步过去。如果在非联网的情况下，会加载离线编辑的数据，并可继续离线编辑。</li>
<li>_loadRemote，即加载一个远程文档。该文档在本地有可能编辑过，那么会先加载本地缓存的离线编辑的数据。如果当前处于联网状态，会异步加载远程文档，成功后本地离线编辑的内容会被放弃。</li>
</ul>
<p>另外，加载文档结束后，QPaintDoc 会发出 onload 消息。这个消息当前会被 QPaintView 响应，用来刷新界面，代码如下：</p>
<pre><code>class QPaintView {
  constructor() {
    ...
    let view = this
    this.doc.onload = function() {
      view.invalidateRect(null)
    }
    ...
  }
}</code></pre><p>之所以会有 onload 消息，是因为向服务器的 ajax 请求，什么时候完成是比较难预期的，我们加载文档是在异步 ajax 完成之后。这样来看，完成文档加载后发出 onload 事件，就可以避免 Model 层需要去理解 View 层的业务逻辑。</p>
<h2 id="Model-层的厚度"><a href="#Model-层的厚度" class="headerlink" title="Model 层的厚度"></a>Model 层的厚度</h2><p>介绍到这里，我们基本上把本次迭代的主体内容介绍清楚了。其他有些小细节的变动，我们不再赘述。详细的代码变更请参阅：</p>
<ul>
<li><a href="https://github.com/qiniu/qpaint/compare/v29...v30" target="_blank" rel="noopener">https://github.com/qiniu/qpaint/compare/v29…v30</a></li>
</ul>
<p>下面我想聊的话题是关于 Model 层的厚度问题。我们在 “<a href="https://time.geekbang.org/column/article/105356" target="_blank" rel="noopener">22 | 桌面程序的架构建议</a>” 中提到：</p>
<blockquote>
<p>从界面编程角度看，Model 层越厚越好。为什么这么说？因为这是和操作系统的界面程序框架最为无关的部分，是最容易测试的部分，也同时是跨平台最容易的部分。我们把逻辑更多向 Model 层倾斜，那么 Controller 层就简洁很多，这对跨平台开发将极其有利。</p>
</blockquote>
<p>我们秉承的理念是 Model 层越厚越好。事实上在这次 “画图” 程序实战中，我们在一直坚持这一点。让我们来观测两组数据。</p>
<p>其一，不同版本（v26…v30）的 Model 层（dom.js）对比：</p>
<ul>
<li>MVP 版本（v26 版）的 <a href="https://github.com/qiniu/qpaint/blob/v26/paintweb/www/dom.js" target="_blank" rel="noopener">dom.js</a> ，约 120 行。</li>
<li>最新版本（v30 版）的 <a href="https://github.com/qiniu/qpaint/blob/v30/paintweb/www/dom.js" target="_blank" rel="noopener">dom.js</a> ，约 860 行。</li>
</ul>
<p>Model 层的代码行翻了多少倍？7.x 倍。</p>
<p>其二，不同版本（v26…v30）的变更历史：</p>
<p>v27：<a href="https://github.com/qiniu/qpaint/compare/v26...v27" target="_blank" rel="noopener">https://github.com/qiniu/qpaint/compare/v26…v27</a></p>
<p><img src="https://static001.geekbang.org/resource/image/23/6f/23a102e16f26d278ef10a4938066fd6f.png" alt></p>
<p>v28：<a href="https://github.com/qiniu/qpaint/compare/v27...v28" target="_blank" rel="noopener">https://github.com/qiniu/qpaint/compare/v27…v28</a></p>
<p><img src="https://static001.geekbang.org/resource/image/1a/4d/1ab61e11c153a2b3b38bc90bf1006c4d.png" alt></p>
<p>v29：<a href="https://github.com/qiniu/qpaint/compare/v28...v29" target="_blank" rel="noopener">https://github.com/qiniu/qpaint/compare/v28…v29</a></p>
<p><img src="https://static001.geekbang.org/resource/image/74/ab/74032dc7ab390189f3be591c13dad2ab.png" alt></p>
<p>v30：<a href="https://github.com/qiniu/qpaint/compare/v29...v30" target="_blank" rel="noopener">https://github.com/qiniu/qpaint/compare/v29…v30</a></p>
<p><img src="https://static001.geekbang.org/resource/image/f4/b7/f4715e1055c75bbdf1b9d21bb89496b7.png" alt></p>
<p>不知道你看出什么来了吗？</p>
<p>一个有趣的事实是，多个版本的迭代，基本上都是以变更 Model 层为多。v29 版本的变更看似比较例外，没有修改 dom.js。但是实际上 v29 整个变更都是 Model 层的变更，因为是增加了服务端的 Model（我们前面把它叫做 Multi-User Model）。</p>
<p>我们深刻思考这个问题的话，我们会有这样一个推论：</p>
<ul>
<li>如果我们不是让 Model 层代码以内聚的方式放在一起，而是让它自由的散落于各处，那么我们的代码变更质量会非常不受控。</li>
</ul>
<p>为什么？Model 层总体来说是最容易测试的，因为它的环境依赖最小。如果这些代码被分散到 View、Controller 层中，代码的阅读难度、维护难度、测试的难度都会大幅增加。</p>
<p>通过几轮的功能迭代，我们对 Model 层的认知在不断的加深。我们总结一下它的职责，如下：</p>
<ul>
<li>业务逻辑，对外暴露业务接口。它也是 Model 的最本职的工作。</li>
<li>实现 View 层委托的 onpaint 事件，完成绘制功能。</li>
<li>实现 Controller 层的 hitTest 接口，用来实现 selection 支持。</li>
<li>实现与服务端 Multi-User Model 层的通讯，View、Controllers 组件都不需要感知服务端。</li>
<li>实现离线编辑 localStorage 的存取。</li>
</ul>
<p>除了少量 View（onpaint）、Controllers（hitTest）的需求，大部分都是 Model 层的正常业务范畴。</p>
<p>这些职责已经很多，所以 Model 层自然会胖。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天我们完成了画图程序前后端 paintdom、paintweb 的对接。由于考虑支持离线编辑，对接工作有较大的复杂性，你如果不能理解，建议仔细对代码进行研读。当然后面我们还会掰开来细谈这个案例。</p>
<p>这是最新版本的源代码：</p>
<ul>
<li><a href="https://github.com/qiniu/qpaint/tree/v30" target="_blank" rel="noopener">https://github.com/qiniu/qpaint/tree/v30</a></li>
</ul>
<p>到这里我们的实战过程就先告一段落了。</p>
<p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。到现在为止，我们探讨的都是一个完整的桌面应用程序（可能是单机的，也可能是 B/S 结构的）的业务架构。</p>
<p>下一讲我们会谈谈辅助界面元素（自定义控件）的架构设计，它和应用程序的业务架构考虑的问题颇有不同。</p>
<p>话外：按照大纲，当前进度还只有 1/3 的内容。看起来我们最终会比原计划的 58 讲超出不少，可能要往 90 讲去了。关于这一点，我总体还是以说清楚事情为目标，在聊的过程会根据反馈作出适当的调整。</p>
<p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt></p>

        </div>
        
        
        
    </div>
</div>









    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous is-invisible is-hidden-mobile">
            <a class="is-flex-grow has-text-black-ter" href="/page/0/">Anterior</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/page/2/">Siguiente</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link is-current" href="/">1</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/2/">2</a></li>
            
            <li><span class="pagination-ellipsis has-text-black-ter">&hellip;</span></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/10/">10</a></li>
            
        </ul>
    </nav>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                        <figure class="image is-128x128 has-mb-6">
                            <img class="is-rounded" src="https://ws2.sinaimg.cn/large/0067tbKZgy1g6j281yfbqj30ox0oxq41.jpg" alt="xcool">
                        </figure>
                    
                    
                    <p class="is-size-4 is-block">
                        xcool
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        enchanter
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>http://www.enchanter.tech</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Entradas
                    </p>
                    <p class="title has-text-weight-normal">
                        99
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Categorias
                    </p>
                    <p class="title has-text-weight-normal">
                        2
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Etiquetas
                    </p>
                    <p class="title has-text-weight-normal">
                        0
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/zhangxiongxin/blog" target="_blank">
                SEGUIR</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Github" href="https://github.com/zhangxiongxin">
                
                <i class="fab fa-github"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
        


    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Categorias
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/许世伟的架构课/">
            <span class="level-start">
                <span class="level-item">许世伟的架构课</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">42</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/重学前端/">
            <span class="level-start">
                <span class="level-item">重学前端</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">57</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Nube de etiquetas
        </h3>
        
    </div>
</div>

    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Recientes
        </h3>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/37 | 键值存储与数据库/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="37 | 键值存储与数据库">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:23.566Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/37 | 键值存储与数据库/" class="title has-link-black-ter is-size-6 has-text-weight-normal">37 | 键值存储与数据库</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/36 | 业务状态与存储中间件/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="36 | 业务状态与存储中间件">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:21.648Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/36 | 业务状态与存储中间件/" class="title has-link-black-ter is-size-6 has-text-weight-normal">36 | 业务状态与存储中间件</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/35 | 流量调度与负载均衡/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="35 | 流量调度与负载均衡">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:19.672Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/35 | 流量调度与负载均衡/" class="title has-link-black-ter is-size-6 has-text-weight-normal">35 | 流量调度与负载均衡</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/34 | 服务端开发的宏观视角/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="34 | 服务端开发的宏观视角">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:17.750Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/34 | 服务端开发的宏观视角/" class="title has-link-black-ter is-size-6 has-text-weight-normal">34 | 服务端开发的宏观视角</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/33 | 桌面开发篇：回顾与总结/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="33 | 桌面开发篇：回顾与总结">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:15.818Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/33 | 桌面开发篇：回顾与总结/" class="title has-link-black-ter is-size-6 has-text-weight-normal">33 | 桌面开发篇：回顾与总结</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archivos
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">August 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">99</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Etiquetas
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
            </div>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Recientes
        </h3>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/37 | 键值存储与数据库/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="37 | 键值存储与数据库">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:23.566Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/37 | 键值存储与数据库/" class="title has-link-black-ter is-size-6 has-text-weight-normal">37 | 键值存储与数据库</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/36 | 业务状态与存储中间件/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="36 | 业务状态与存储中间件">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:21.648Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/36 | 业务状态与存储中间件/" class="title has-link-black-ter is-size-6 has-text-weight-normal">36 | 业务状态与存储中间件</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/35 | 流量调度与负载均衡/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="35 | 流量调度与负载均衡">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:19.672Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/35 | 流量调度与负载均衡/" class="title has-link-black-ter is-size-6 has-text-weight-normal">35 | 流量调度与负载均衡</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/34 | 服务端开发的宏观视角/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="34 | 服务端开发的宏观视角">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:17.750Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/34 | 服务端开发的宏观视角/" class="title has-link-black-ter is-size-6 has-text-weight-normal">34 | 服务端开发的宏观视角</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/31/许世伟的架构课/33 | 桌面开发篇：回顾与总结/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="33 | 桌面开发篇：回顾与总结">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-31T10:08:15.818Z">2019-08-31</time></div>
                    <a href="/2019/08/31/许世伟的架构课/33 | 桌面开发篇：回顾与总结/" class="title has-link-black-ter is-size-6 has-text-weight-normal">33 | 桌面开发篇：回顾与总结</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/许世伟的架构课/">许世伟的架构课</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archivos
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">August 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">99</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Etiquetas
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="Enchanter" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2019 xcool&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("en");</script>

<script>
var IcarusThemeSettings = {
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>



    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Entradas',
                PAGES: 'Pages',
                CATEGORIES: 'Categorias',
                TAGS: 'Etiquetas',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>